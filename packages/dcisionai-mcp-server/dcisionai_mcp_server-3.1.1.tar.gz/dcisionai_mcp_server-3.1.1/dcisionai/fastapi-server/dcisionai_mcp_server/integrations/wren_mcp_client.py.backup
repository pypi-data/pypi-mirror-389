"""
Wren MCP Client for DcisionAI
Enables server-to-server MCP communication with Wren Engine

This allows DcisionAI to query customer databases (PostgreSQL, MySQL, Snowflake, etc.)
through Wren Engine's MCP server, providing:
- Direct database connectivity
- Semantic layer with business logic
- Access control and governance
- Zero data movement (query in-place)
"""

import asyncio
import json
import logging
import os
import httpx
from typing import Dict, Any, Optional, List
from dataclasses import dataclass

logger = logging.getLogger(__name__)


@dataclass
class WrenMCPConfig:
    """Configuration for Wren MCP server"""
    wren_url: str = "http://localhost:8001"  # Wren Ibis server (mapped from 8000)
    timeout: int = 30
    enabled: bool = False


class WrenMCPClient:
    """
    MCP Client for communicating with Wren Engine MCP server
    
    This enables DcisionAI to query customer databases through Wren's semantic layer.
    Wren MCP server handles:
    - Database connectivity (11+ data sources)
    - SQL query translation
    - Semantic model (MDL) interpretation
    - Access control
    """
    
    def __init__(self, config: WrenMCPConfig):
        self.config = config
        self.http_client = httpx.AsyncClient(timeout=config.timeout)
        self.mdl_deployed = False
    
    async def call_tool(self, tool_name: str, arguments: Dict[str, Any] = None) -> Dict[str, Any]:
        """
        Call a Wren MCP tool via HTTP
        
        Args:
            tool_name: Name of Wren MCP tool (e.g., 'query', 'get_available_tables')
            arguments: Tool arguments
            
        Returns:
            Tool execution result
        """
        try:
            # Wren MCP tools exposed via HTTP endpoint
            # This assumes Wren Ibis server has MCP HTTP bridge (we may need to add this)
            
            # For now, use direct Wren Ibis API
            # TODO: Use proper MCP-to-MCP protocol when Wren exposes HTTP MCP endpoint
            
            if tool_name == "query":
                return await self._query_wren_api(arguments.get("sql"))
            elif tool_name == "health_check":
                return await self._health_check_api()
            elif tool_name == "get_available_tables":
                return await self._get_tables_api()
            else:
                logger.warning(f"Tool {tool_name} not implemented yet")
                return {"error": f"Tool {tool_name} not implemented"}
        
        except Exception as e:
            logger.error(f"Failed to call Wren MCP tool {tool_name}: {e}")
            raise
    
    async def _query_wren_api(self, sql: str) -> Dict[str, Any]:
        """
        Query Wren Ibis server directly using DuckDB data source
        
        Note: This uses Wren's v3 API with MDL and connection info
        """
        try:
            logger.info(f"ðŸ” Querying Wren: {sql[:100]}...")
            
            # Load MDL and connection info
            mdl_path = "/Users/ameydhavle/Documents/DcisionAI/dcisionai-mcp-platform/poc_wren_engine/wren_config/dcisionai_mdl.json"
            conn_path = "/Users/ameydhavle/Documents/DcisionAI/dcisionai-mcp-platform/poc_wren_engine/wren_config/postgres_connection.json"
            
            import json
            with open(mdl_path) as f:
                mdl = json.load(f)
            
            with open(conn_path) as f:
                connection_info = json.load(f)
            
            # Wren Ibis API v3 endpoint
            # Use postgres for Supabase connection
            data_source = "postgres"
            url = f"{self.config.wren_url}/v3/connector/{data_source}/query"
            
            # Prepare request payload
            import base64
            mdl_json = json.dumps(mdl)
            mdl_base64 = base64.b64encode(mdl_json.encode()).decode()
            
            payload = {
                "sql": sql,
                "manifestStr": mdl_base64,  # MDL as base64-encoded string
                "connectionInfo": connection_info
            }
            
            # Make request to Wren Ibis
            response = await self.http_client.post(
                url,
                json=payload,
                headers={
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            )
            
            if response.status_code == 200:
                result = response.json()
                rows = result.get("data", [])
                columns = result.get("columns", [])
                
                logger.info(f"âœ… Wren query successful: {len(rows)} rows")
                
                # Convert array format to dict format
                # Wren returns: data: [[val1, val2, ...]], columns: ["col1", "col2", ...]
                dict_rows = []
                for row in rows:
                    if isinstance(row, list) and columns:
                        dict_row = {columns[i]: row[i] for i in range(min(len(columns), len(row)))}
                        dict_rows.append(dict_row)
                    elif isinstance(row, dict):
                        dict_rows.append(row)
                
                return {
                    "status": "success",
                    "data": dict_rows,
                    "columns": columns
                }
            else:
                logger.error(f"Wren query failed: HTTP {response.status_code} - {response.text}")
                return {
                    "status": "error",
                    "error": f"HTTP {response.status_code}: {response.text}",
                    "data": []
                }
        
        except Exception as e:
            logger.error(f"Wren query failed: {e}")
            return {
                "status": "error",
                "error": str(e),
                "data": []
            }
    
    async def _health_check_api(self) -> Dict[str, Any]:
        """Check if Wren Ibis server is accessible"""
        try:
            response = await self.http_client.get(f"{self.config.wren_url}/health")
            
            if response.status_code == 200:
                logger.info("âœ… Wren Engine is healthy")
                return {"status": "healthy", "message": "Wren Engine is accessible"}
            else:
                logger.warning(f"âš ï¸ Wren health check returned {response.status_code}")
                return {"status": "unhealthy", "message": f"Status code: {response.status_code}"}
        
        except Exception as e:
            logger.error(f"âŒ Wren health check failed: {e}")
            return {"status": "unhealthy", "error": str(e)}
    
    async def _get_tables_api(self) -> List[str]:
        """Get available tables from Wren MDL"""
        # TODO: Implement actual Wren API call
        logger.warning("âš ï¸ Using mock tables - implement actual API call")
        return ["portfolio_holdings", "product_inventory", "resource_projects"]
    
    async def query_portfolio_data(self, user_id: str) -> Dict[str, Any]:
        """
        Query portfolio holdings for a specific user
        
        Args:
            user_id: User identifier
            
        Returns:
            Portfolio data with holdings and metrics
        """
        logger.info(f"ðŸ“Š Fetching portfolio data for {user_id} via Wren MCP")
        
        sql = f"""
        SELECT 
            ticker,
            company_name,
            sector,
            current_allocation,
            current_value,
            expected_return,
            volatility,
            expense_ratio
        FROM portfolio_holdings
        WHERE user_id = '{user_id}'
        """
        
        try:
            result = await self.call_tool("query", {"sql": sql})
            
            # Transform result to DcisionAI format
            return {
                "holdings": result.get("data", []),
                "data_provenance": {
                    "source": "wren_mcp",
                    "database": "customer_database",
                    "quality_score": 0.98,
                    "completeness": 1.0
                }
            }
        
        except Exception as e:
            logger.error(f"Failed to fetch portfolio data: {e}")
            raise
    
    async def query_retail_data(self, store_id: str) -> Dict[str, Any]:
        """
        Query retail inventory for a specific store
        
        Args:
            store_id: Store identifier
            
        Returns:
            Retail inventory data
        """
        logger.info(f"ðŸª Fetching retail data for {store_id} via Wren MCP")
        
        sql = f"""
        SELECT 
            product_id,
            product_name,
            category,
            margin,
            monthly_sales,
            customer_traffic_zone,
            requires_refrigeration
        FROM product_inventory
        WHERE store_id = '{store_id}'
        """
        
        try:
            result = await self.call_tool("query", {"sql": sql})
            
            return {
                "inventory": result.get("data", []),
                "data_provenance": {
                    "source": "wren_mcp",
                    "database": "customer_database",
                    "quality_score": 0.98,
                    "completeness": 1.0
                }
            }
        
        except Exception as e:
            logger.error(f"Failed to fetch retail data: {e}")
            raise
    
    async def query_resource_data(self, organization_id: str) -> Dict[str, Any]:
        """
        Query resource projects for an organization
        
        Args:
            organization_id: Organization identifier
            
        Returns:
            Resource allocation data
        """
        logger.info(f"ðŸ’¼ Fetching resource data for {organization_id} via Wren MCP")
        
        sql = f"""
        SELECT 
            project_id,
            project_name,
            priority,
            expected_value,
            required_budget,
            required_headcount,
            required_compute_hours,
            deadline
        FROM resource_projects
        WHERE organization_id = '{organization_id}'
        """
        
        try:
            result = await self.call_tool("query", {"sql": sql})
            
            return {
                "projects": result.get("data", []),
                "data_provenance": {
                    "source": "wren_mcp",
                    "database": "customer_database",
                    "quality_score": 0.98,
                    "completeness": 1.0
                }
            }
        
        except Exception as e:
            logger.error(f"Failed to fetch resource data: {e}")
            raise
    
    async def health_check(self) -> bool:
        """
        Check if Wren Engine is accessible
        
        Returns:
            True if healthy, False otherwise
        """
        try:
            result = await self.call_tool("health_check")
            return result.get("status") == "healthy"
        except Exception as e:
            logger.error(f"Health check failed: {e}")
            return False
    
    async def close(self):
        """Close HTTP client"""
        await self.http_client.aclose()


# Singleton instance
_wren_mcp_client: Optional[WrenMCPClient] = None


def get_wren_mcp_client(config: Optional[WrenMCPConfig] = None) -> Optional[WrenMCPClient]:
    """
    Get or create Wren MCP client singleton
    
    Args:
        config: Optional Wren MCP configuration
        
    Returns:
        WrenMCPClient instance if enabled, None otherwise
    """
    global _wren_mcp_client
    
    # Check if Wren is enabled
    wren_enabled = os.getenv("WREN_ENABLED", "false").lower() == "true"
    
    if not wren_enabled:
        return None
    
    if _wren_mcp_client is None:
        if config is None:
            config = WrenMCPConfig(
                wren_url=os.getenv("WREN_URL", "http://localhost:8001"),
                timeout=int(os.getenv("WREN_TIMEOUT", "30")),
                enabled=wren_enabled
            )
        
        _wren_mcp_client = WrenMCPClient(config)
        logger.info(f"âœ… Wren MCP client initialized: {config.wren_url}")
    
    return _wren_mcp_client

