# 口腔种植手术导航定位系统大语言模型支持软件 V1.0 设计说明书

**版本：1.0**

## 1. 引言

### 1.1. 编写目的

本设计说明书旨在详细阐述“口腔种植手术导航定位系统大语言模型支持软件”（以下简称“本软件”）的设计方案。其主要目的是明确软件的架构、功能模块、接口设计、实现逻辑及错误处理机制，作为后续开发、测试和维护的依据，并满足软件著作权登记的要求。本文档面向开发人员、测试人员以及项目管理人员。

### 1.2. 项目背景

随着人工智能技术的发展，大型语言模型（LLM）在人机交互领域展现出巨大潜力。口腔种植手术导航定位系统是现代精准医疗的重要工具，但其操作通常需要专业培训。为了提升系统的易用性和交互效率，本项目旨在开发一款支持软件，利用支持模型上下文协议（MCP, Model Context Protocol）的大型语言模型（如 Claude Desktop, Cline 等）作为自然语言交互入口，通过本软件控制口腔种植手术导航定位系统（以下简称“导航系统”，预期基于 3D Slicer 或类似平台实现）的各项功能。

### 1.3. 软件概述

本软件 V1.0 是一款基于 Python 开发的应用软件，运行于 Windows 10 及以上操作系统。它充当支持 MCP 协议的 LLM 客户端与导航系统之间的桥梁。通过建立一个 MCP 服务器，本软件接收来自 LLM 的指令，解析并调用导航系统提供的 Web Server API，从而实现对导航系统的远程控制。其核心目标是让医护人员能够通过自然语言指令，便捷地完成场景管理、视图控制、植体规划和设备操作等任务。

### 1.4. 定义与缩写

| 缩写/术语  | 全称/解释                                                  |
| :--------- | :--------------------------------------------------------- |
| LLM        | Large Language Model (大型语言模型)                        |
| MCP        | Model Context Protocol (模型上下文协议)                    |
| 本软件     | 口腔种植手术导航定位系统大语言模型支持软件 V1.0            |
| 导航系统   | 口腔种植手术导航定位系统 (预期基于 3D Slicer)              |
| API        | Application Programming Interface (应用程序接口)           |
| MCP Server | 本软件运行的，遵循 MCP 协议的服务器                        |
| MCP Client | 支持 MCP 协议的 LLM 客户端软件 (如 Claude)                 |
| Web Server | 导航系统内部运行的，提供 HTTP API 的服务器                 |
| MRML       | Medical Reality Modeling Language (3D Slicer 场景描述语言) |
| Node       | 导航系统场景中的对象（如模型、标记点等）                   |

## 2. 软件总体设计

### 2.1. 软件需求概述

本软件旨在满足以下核心需求：

1.  **MCP 协议支持**：实现一个 MCP Server，能够被支持 MCP 的 LLM Client 发现和调用。
2.  **导航系统控制**：能够通过调用导航系统（如 3D Slicer）的 Web Server API，实现对其功能的控制。
3.  **核心功能实现**：
    - 列出和过滤导航系统场景中的节点（Node），并查看其属性。
    - 控制导航系统的相机视角（如平移、旋转、缩放）。
    - 控制导航系统的视图布局（如切换四视图、三维视图等）。
    - 辅助进行植体规划操作（如放置虚拟植体、调整参数等）。
    - 控制与导航系统连接的机械臂进行模式切换或其他操作。
4.  **自然语言交互**：使用户能够通过 LLM Client，使用自然语言指令间接操作导航系统。
5.  **环境兼容性**：能在常见的 PC 硬件（X86 CPU, >=4GB RAM, >=500GB HDD）和 Windows 10 及以上操作系统上稳定运行。

### 2.2. 总体架构设计

本软件采用三层架构设计，连接 LLM Client 和导航系统：

1.  **LLM Client 层**：用户通过支持 MCP 协议的 LLM Client（如 Claude Desktop）输入自然语言指令。LLM Client 解析指令，识别用户意图，并选择调用本软件提供的 MCP 工具。
2.  **MCP Server 层（本软件核心）**：本软件作为 MCP Server 运行。它接收来自 LLM Client 的工具调用请求（基于 MCP 协议），解析请求参数，并将这些请求转化为对导航系统 Web Server API 的调用。
3.  **导航系统层**：导航系统（如 3D Slicer）内部运行一个 Web Server，提供一系列 HTTP API 用于外部控制。本软件通过这些 API 与导航系统交互，执行具体操作。

**系统架构图:**

````mermaid
graph TD
    A[用户] --> B(LLM Client 例如 Claude Desktop);
    B -- MCP 协议: 工具调用 --> C{MCP Server (本软件)};
    C -- HTTP API 调用: GET/POST --> D[导航系统 Web Server (例如 Slicer Web Server)];
    D -- 内部接口调用 --> E(导航系统核心功能 例如 3D Slicer);

    style A fill:#f9f,stroke:#333,stroke-width:2px
    style B fill:#ccf,stroke:#333,stroke-width:2px
    style C fill:#cfc,stroke:#333,stroke-width:2px
    style D fill:#ffc,stroke:#333,stroke-width:2px
    style E fill:#fcc,stroke:#333,stroke-width:2px

- **图描述**：该图展示了用户、LLM Client、MCP Server（本软件）和导航系统（含 Web Server）之间的交互流程。用户与 LLM Client 交互，LLM Client 通过 MCP 协议调用 MCP Server 提供的工具，MCP Server 再通过 HTTP 请求调用导航系统的 Web Server API，最终实现对导航系统的控制。

### 2.3. 技术选型

- **编程语言**：Python 3.13+
- **核心库**：
  - `mcp.server.fastmcp`: 用于快速构建 MCP Server。
  - `requests`: 用于向导航系统的 Web Server 发送 HTTP 请求。
- **开发工具**：Visual Studio Code
- **目标平台**：Windows 10 及以上

### 2.4. 模块设计

本软件主要包含以下模块：

1.  **MCP 服务模块 (`mcp_server.py`)**：
    - 初始化并运行 FastMCP 服务器。
    - 定义并注册 MCP 工具（Tool）。
    - 处理来自 LLM Client 的 MCP 请求。
2.  **工具实现模块 (`mcp_server.py` 中的工具函数)**：
    - `list_nodes` 工具：实现列出、过滤节点及获取属性的功能。
    - `execute_python_code` 工具：实现执行任意 Python 代码的功能，用于实现相机控制、视图布局、植体规划、机械臂控制等复杂操作。
3.  **HTTP 客户端模块 (集成在工具实现中)**：
    - 负责构建和发送 HTTP GET/POST 请求到导航系统的 Web Server API。
    - 处理 HTTP 响应，包括成功结果和错误信息。
4.  **主程序模块 (`main.py`)**：
    - 程序的入口点，负责启动 MCP 服务模块。

## 3. 功能详细设计

### 3.1. 列出和过滤场景节点 (`list_nodes` 工具)

- **功能描述**：允许用户通过 LLM 查询导航系统场景（MRML Scene）中的节点信息。可以按节点类型（Class Name）、名称（Name）或 ID 进行过滤，并获取节点的名称列表、ID 列表或详细属性。
- **输入参数**：
  - `filter_type` (str): 查询类型，可选 "names", "ids", "properties"。默认为 "names"。
  - `class_name` (str, optional): 按节点类名过滤。
  - `name` (str, optional): 按节点名称过滤。
  - `id` (str, optional): 按节点 ID 过滤。
- **处理流程**：
  1.  接收 LLM Client 调用 `list_nodes` 工具的请求及参数。
  2.  根据 `filter_type` 确定目标导航系统 Web Server API 端点（`/mrml/names`, `/mrml/ids`, `/mrml/properties`）。
  3.  构建 HTTP GET 请求，将 `class_name`, `name`, `id` 作为查询参数。
  4.  向 `http://localhost:2016/slicer/...` (导航系统 Web Server 地址) 发送请求。
  5.  接收响应，解析 JSON 数据。
  6.  将结果封装成 MCP 工具要求的字典格式返回给 LLM Client。
- **输出**：包含节点信息的字典，格式如 `{"nodes": [...]}` 或 `{"nodes": {"node1": {...}, ...}}`，或包含错误信息的字典 `{"error": "..."}`。
- **[此处应有 `list_nodes` 功能流程图]**

### 3.2. 执行 Python 代码 (`execute_python_code` 工具)

- **功能描述**：允许用户通过 LLM 发送 Python 代码片段，由本软件转发给导航系统（如 3D Slicer）在其内置的 Python 环境中执行。这是实现复杂控制功能（相机、视图、规划、机械臂等）的核心机制。
- **输入参数**：
  - `code` (str): 需要在导航系统环境中执行的 Python 代码字符串。代码可以通过将结果赋值给 `__execResult` 变量来返回值。
- **处理流程**：
  1.  接收 LLM Client 调用 `execute_python_code` 工具的请求及 `code` 参数。
  2.  构建 HTTP POST 请求，将 `code` 字符串作为请求体（`text/plain` 类型）。
  3.  向 `http://localhost:2016/slicer/exec` (导航系统 Web Server 执行代码端点) 发送请求。
  4.  接收响应，解析 JSON 数据。
  5.  检查响应中是否包含执行成功或失败的信息。
  6.  将执行结果（成功时可能包含 `__execResult` 的值）或错误信息封装成 MCP 工具要求的字典格式返回给 LLM Client。
- **输出**：包含执行结果的字典，格式如 `{"success": True, "message": ...}` 或 `{"success": False, "message": "..."}`。
- **[此处应有 `execute_python_code` 功能流程图]**

### 3.3. 控制相机视角

- **实现方式**：通过 `execute_python_code` 工具实现。
- **流程**：
  1.  用户通过 LLM 发出控制相机指令（如“放大视图”、“旋转到左视图”）。
  2.  LLM Client 解析指令，生成控制相机的 Python 代码片段（例如，调用 Slicer 的 `slicer.app.layoutManager().threeDWidget(0).threeDView().camera().Zoom(1.5)`）。
  3.  LLM Client 调用本软件的 `execute_python_code` 工具，传入生成的代码。
  4.  本软件将代码转发给导航系统执行。
  5.  导航系统执行代码，更新相机视角。
  6.  执行结果返回给 LLM Client。

### 3.4. 控制视图排布

- **实现方式**：通过 `execute_python_code` 工具实现。
- **流程**：
  1.  用户通过 LLM 发出控制视图布局指令（如“切换到四视图”、“只显示三维视图”）。
  2.  LLM Client 解析指令，生成控制布局的 Python 代码片段（例如，调用 Slicer 的 `slicer.app.layoutManager().setLayout(slicer.vtkMRMLLayoutNode.SlicerLayoutFourUpView)`）。
  3.  LLM Client 调用 `execute_python_code` 工具。
  4.  本软件转发代码给导航系统执行。
  5.  导航系统更新视图布局。
  6.  结果返回。

### 3.5. 控制植体规划

- **实现方式**：通过 `execute_python_code` 工具实现。
- **流程**：
  1.  用户通过 LLM 发出植体规划指令（如“在坐标 (10, 20, 30) 放置一个直径 4mm、长度 10mm 的植体”）。
  2.  LLM Client 解析指令，生成执行植体规划操作的 Python 代码（可能涉及创建 Markups Fiducial 节点、设置模型参数、调用特定规划模块的函数等）。
  3.  LLM Client 调用 `execute_python_code` 工具。
  4.  本软件转发代码给导航系统执行。
  5.  导航系统执行规划操作。
  6.  结果返回。

### 3.6. 控制机械臂模式切换

- **实现方式**：通过 `execute_python_code` 工具实现。
- **流程**：
  1.  用户通过 LLM 发出机械臂控制指令（如“切换到自由拖动模式”、“进入导航模式”）。
  2.  LLM Client 解析指令，生成与导航系统内机械臂控制模块交互的 Python 代码（具体代码依赖于导航系统实际集成的机械臂接口）。
  3.  LLM Client 调用 `execute_python_code` 工具。
  4.  本软件转发代码给导航系统执行。
  5.  导航系统通过其接口控制机械臂模式。
  6.  结果返回。

## 4. 接口设计

### 4.1. 用户接口

本软件不直接提供图形用户界面（GUI）。用户通过支持 MCP 协议的 LLM Client（如 Claude Desktop 或 Cline）的文本界面进行交互，使用自然语言发出指令。

### 4.2. 内部接口 (MCP 工具接口)

本软件作为 MCP Server，向 LLM Client 提供以下工具接口：

1.  **`list_nodes` 工具**
    - **描述**：查询导航系统场景节点信息。
    - **参数**：`filter_type` (str), `class_name` (str, optional), `name` (str, optional), `id` (str, optional)
    - **返回**：包含节点信息或错误的 JSON 字典。
2.  **`execute_python_code` 工具**
    - **描述**：在导航系统环境中执行 Python 代码。
    - **参数**：`code` (str)
    - **返回**：包含执行结果或错误的 JSON 字典。

### 4.3. 外部接口 (导航系统 Web Server API)

本软件调用导航系统（预期为 3D Slicer）提供的 Web Server API。

- **基础 URL**：`http://localhost:2016/slicer` (可配置)
- **主要使用的端点**：
  - `GET /mrml/names`: 获取节点名称列表。
    - 可选参数: `class`, `name`, `id`
  - `GET /mrml/ids`: 获取节点 ID 列表。
    - 可选参数: `class`, `name`, `id`
  - `GET /mrml/properties`: 获取节点属性。
    - 可选参数: `class`, `name`, `id`
  - `POST /exec`: 执行 Python 代码。
    - 请求体: `text/plain` 格式的 Python 代码字符串。
- **数据格式**：主要使用 JSON 进行数据交换。

## 5. 出错处理设计

本软件设计了多层错误处理机制：

1.  **MCP Server 内部错误**：
    - 如接收到无效的 MCP 请求或参数，MCP Server 框架 (FastMCP) 会处理并返回标准错误响应给 LLM Client。
2.  **导航系统 Web Server 连接错误**：
    - 在调用导航系统 API 时，如果发生网络连接错误（如目标服务器未启动、网络中断），`requests` 库会抛出异常。
    - 本软件捕获 `requests.exceptions.RequestException` 异常，并将其封装成包含错误信息的 JSON 字典（如 `{"error": "Connection error: ..."}` 或 `{"success": False, "message": "Connection error: ..."}`）返回给 LLM Client。
3.  **导航系统 Web Server HTTP 错误**：
    - 如果导航系统 API 返回 HTTP 错误状态码（如 404 Not Found, 500 Internal Server Error），`requests` 库会抛出 `requests.exceptions.HTTPError` 异常。
    - 本软件捕获此异常，并将错误码和错误信息封装返回（如 `{"error": "HTTP Error 404: ..."}` 或 `{"success": False, "message": "HTTP Error 404: ..."}`）。
4.  **导航系统 API 返回错误**：
    - 即使 HTTP 请求成功，导航系统 API 的业务逻辑也可能出错（如 `execute_python_code` 执行的代码有语法错误）。
    - 本软件检查 API 返回的 JSON 内容。对于 `/exec` 接口，会检查返回的字典中是否明确包含错误指示（如 Slicer 返回的 `{"success": False, "message": "..."}`）。
    - 将导航系统返回的错误信息封装返回给 LLM Client。
5.  **数据处理错误**：
    - 如果导航系统 API 返回的响应不是有效的 JSON 格式，本软件会捕获 `json.JSONDecodeError`，并返回相应的错误信息（如 `{"error": "Invalid JSON response: ..."}` 或 `{"success": False, "message": "Invalid JSON response: ..."}`）。

所有返回给 LLM Client 的错误信息都应清晰、简洁，以便 LLM 能够理解并向用户反馈。

## 6. 安全性考虑

- **`execute_python_code` 工具的风险**：该工具允许执行任意 Python 代码，这是一个强大的功能，但也带来了严重的安全风险。恶意或错误的指令可能导致导航系统崩溃、数据损坏或执行非预期操作。
- **风险缓解**：
  - **明确告知用户风险**：在文档和使用说明中强调此工具的潜在危险。
  - **限制使用环境**：强烈建议仅在受信任的本地网络环境中使用本软件，避免暴露在公共网络。
  - **访问控制**：依赖导航系统 Web Server 本身的访问控制机制（如果存在）。本软件 V1.0 未实现额外的认证或授权层。
  - **未来考虑**：未来版本可考虑增加代码审查、限制可执行函数范围或引入更安全的沙箱执行环境等机制，但这会增加复杂性并可能限制功能。
- **当前状态**：V1.0 版本主要面向研究和原型验证，**不建议直接用于生产或临床环境**。

## 7. 部署与运行

1.  **环境准备**：
    - 安装 Python 3.13+。
    - 安装 `uv` 包管理器。
    - 确保目标机器上已安装并运行口腔种植手术导航定位系统（如 3D Slicer 5.8+），并已启动其内部的 Web Server，开放所需接口（`/mrml/*`, `/exec`）。
2.  **安装本软件**：(假设已发布到 PyPI)
    ```bash
    uv pip install mcp-slicer # 包名可能需要根据实际发布情况调整
    ```
3.  **配置 LLM Client**：
    - 在 LLM Client（如 Claude Desktop）的 MCP Server 配置中添加本软件的启动命令。例如：
      ```json
      {
        "mcpServers": {
          "slicer": {
            "command": "uvx", // 或直接 python -m mcp_slicer.main
            "args": ["mcp-slicer"] // 或空列表，取决于入口点设置
          }
        }
      }
      ```
4.  **运行**：
    - 启动 LLM Client。它将根据配置自动启动本软件作为 MCP Server 进程。
    - 通过 LLM Client 的界面与本软件提供的工具进行交互。

---

**文档结束**
````
