"""
Data models for context capsules.

This module defines the Pydantic models used for serializing and validating
context capsules, which store developer context information.
"""

from datetime import datetime
from typing import List, Optional, Dict, Any
from pathlib import Path
from uuid import UUID, uuid4
from pydantic import BaseModel, Field, field_validator, ConfigDict

class ModifiedFile(BaseModel):
    """Represents a modified file in the git workspace."""
    path: str = Field(..., description="Relative path to the file")
    status: str = Field(..., description="Git status: modified|added|deleted")
    last_modified: datetime = Field(default_factory=datetime.utcnow)

class Commit(BaseModel):
    """Represents a git commit."""
    hash: str = Field(..., description="Commit hash")
    message: str = Field(..., description="Commit message")
    timestamp: datetime = Field(..., description="Commit timestamp")

class Todo(BaseModel):
    """Represents a TODO comment found in code."""
    file: str = Field(..., description="File containing the TODO")
    line: int = Field(..., description="Line number of the TODO")
    text: str = Field(..., description="TODO message")
    context: str = Field(..., description="Surrounding code context")
    function_context: Optional[str] = Field(None, description="Function/class containing the TODO")
    detailed_context: Optional[str] = Field(None, description="Detailed line context with line numbers")

class FileDiff(BaseModel):
    """Represents a file diff with detailed change information."""
    file_path: str = Field(..., description="Path to the file")
    change_type: str = Field(..., description="Type of change: new_code|refactoring|debugging")
    diff: str = Field(..., description="Git diff content")
    modified_functions: List[dict] = Field(default_factory=list, description="Functions/classes modified")
    additions: int = Field(default=0, description="Lines added")
    deletions: int = Field(default=0, description="Lines deleted")

class CodeSnippet(BaseModel):
    """Represents a code snippet with context."""
    file_path: str = Field(..., description="File containing the code")
    function_name: Optional[str] = Field(None, description="Function/method name")
    class_name: Optional[str] = Field(None, description="Class name if applicable")
    line_start: int = Field(..., description="Starting line number")
    line_end: int = Field(..., description="Ending line number")
    content: str = Field(..., description="Code content")
    is_incomplete: bool = Field(default=False, description="Whether this code is incomplete")

class WorkSession(BaseModel):
    """Represents a work session with detailed metrics."""
    work_type: str = Field(default="unknown", description="Type: debugging|refactoring|new_feature|bug_fixing")
    start_time: datetime = Field(default_factory=datetime.utcnow)
    end_time: Optional[datetime] = Field(None)
    focus_files: List[str] = Field(default_factory=list, description="Files with most edits")
    activity_score: int = Field(default=0, description="Activity level 0-100")
    context_switches: int = Field(default=0, description="Number of context switches")
    focus_duration: int = Field(default=0, description="Total focus time in seconds")
    incomplete_functions: List[CodeSnippet] = Field(default_factory=list, description="Unfinished functions")

class Insight(BaseModel):
    """Represents a workflow insight generated by analysis."""
    type: str = Field(..., description="Insight type: focus|pattern|suggestion|alert")
    title: str = Field(..., description="Short title for the insight")
    description: str = Field(..., description="Detailed description")
    timestamp: datetime = Field(default_factory=datetime.utcnow)
    priority: int = Field(default=3, description="Priority level 1-5, higher is more important")
    related_files: List[str] = Field(default_factory=list, description="Files related to this insight")

class Command(BaseModel):
    """Represents a terminal command that was executed."""
    command: str = Field(..., description="The command that was executed")
    timestamp: Optional[datetime] = Field(None, description="When the command was executed")
    shell: str = Field(default="unknown", description="Shell type: zsh|bash|etc")
    exit_code: Optional[int] = Field(None, description="Command exit code")
    output: Optional[str] = Field(None, description="Command output (truncated)")
    duration: Optional[float] = Field(None, description="Execution duration in seconds")

class CapsuleMetadata(BaseModel):
    """Metadata about the context capsule."""
    timestamp: datetime = Field(default_factory=datetime.utcnow)
    version: str = Field(default="0.1.0")
    session_id: UUID = Field(default_factory=uuid4)
    tags: List[str] = Field(default_factory=list, description="User-defined tags for categorization")
    custom_message: Optional[str] = Field(None, description="User's custom note about this session")
    session_duration: Optional[float] = Field(None, description="Session duration in seconds")

class ProjectInfo(BaseModel):
    """Information about the project context."""
    name: str = Field(..., description="Project name")
    root_path: Path = Field(..., description="Absolute path to project root")
    git_branch: Optional[str] = Field(None, description="Current git branch")
    git_repo: Optional[str] = Field(None, description="Git repository name")

    model_config = ConfigDict(arbitrary_types_allowed=True)

    @field_validator('root_path')
    def validate_root_path(cls, v):
        """Ensure root_path is absolute and exists."""
        if not v.is_absolute():
            raise ValueError("root_path must be absolute")
        if not v.exists():
            raise ValueError("root_path must exist")
        return v

class ContextData(BaseModel):
    """The actual context data captured."""
    modified_files: List[ModifiedFile] = Field(default_factory=list)
    recent_commits: List[Commit] = Field(default_factory=list)
    todos: List[Todo] = Field(default_factory=list)
    active_file: Optional[str] = Field(None)
    insights: List[Insight] = Field(default_factory=list, description="Workflow insights from analysis")
    recent_commands: List[Command] = Field(default_factory=list, description="Recent terminal commands")
    file_diffs: List[FileDiff] = Field(default_factory=list, description="Detailed file diffs")
    work_session: Optional[WorkSession] = Field(None, description="Current work session details")
    incomplete_work: List[CodeSnippet] = Field(default_factory=list, description="Unfinished code snippets")
    ai_summary: Optional[str] = Field(None, description="AI-generated session summary")
    next_steps: Optional[str] = Field(None, description="AI-suggested next steps")
    
    # 5-Source Architecture Fields (v0.2.0+)
    full_file_contents: Optional[Dict[str, Any]] = Field(default_factory=dict, description="Complete file contents from File Scanner")
    ast_analysis: Optional[Dict[str, Any]] = Field(default_factory=dict, description="AST structure analysis")
    semantic_results: Optional[List[Dict[str, Any]]] = Field(default_factory=list, description="Semantic search results")
    project_metadata: Optional[Dict[str, Any]] = Field(default=None, description="Project context metadata")

class Capsule(BaseModel):
    """The complete context capsule."""
    metadata: CapsuleMetadata = Field(default_factory=CapsuleMetadata)
    project: ProjectInfo
    context: ContextData = Field(default_factory=ContextData)

    def save(self, path: Path) -> Path:
        """
        Save the capsule to a JSON file.
        
        Args:
            path: Directory to save the capsule in
            
        Returns:
            Path: Path to the saved capsule file
        """
        if not path.exists():
            path.mkdir(parents=True)
        
        # Generate filename with timestamp (keep simple for compatibility)
        timestamp_str = self.metadata.timestamp.strftime('%Y%m%d_%H%M%S')
        filename = f"capsule_{timestamp_str}.json"
        file_path = path / filename
        
        with open(file_path, 'w', encoding='utf-8') as f:
            f.write(self.model_dump_json(indent=2))
        
        return file_path

    @classmethod
    def load(cls, path: Path) -> 'Capsule':
        """
        Load a capsule from a JSON file.
        
        Args:
            path: Path to the capsule file
            
        Returns:
            Capsule: The loaded capsule
        """
        with open(path, 'r', encoding='utf-8') as f:
            return cls.model_validate_json(f.read())