from dataclasses import dataclass
from datetime import datetime, UTC
from typing import Type, TypeVar
import json
from brenthy_tools_beta.utils import string_to_time, time_to_string
from decorate_all import decorate_all_functions
from multi_crypt import Crypt
from strict_typing import strictly_typed

_Service = TypeVar("_Service", bound="Service")


@dataclass
class Service:
    """Represents a DID service.

    DID services are applications/operations registered in a DID document that
    use specific cryptographic keys also published in the DID document.
    """

    service_id: str
    family: str
    # example: 'messenger://user_id/chatroom'
    service_endpoint: str | list | dict

    @classmethod
    def from_service_spec(cls: Type[_Service], service_spec: dict) -> _Service:
        """Initialise a Service from a DID service spec from a DID document."""
        return cls(
            service_id=service_spec["id"].strip("#"),
            family=service_spec["family"],
            service_endpoint=["serviceEndpoint"],
        )

    def generate_service_spec(self) -> dict:
        """Generate a service spec for a DID document."""
        return {
            "id": f"#{self.service_id}",
            "family": self.family,
            "serviceEndpoint": self.service_endpoint,
        }


_Key = TypeVar("_Key", bound="Key")


@dataclass
class Key(Crypt):
    """Represents a set of cryptographic keys, compatible with DID specs."""

    family: str
    public_key: bytes
    private_key: bytes | None
    creation_time: datetime

    def __init__(
        self,
        family: str,
        public_key: bytes | str,
        private_key: bytes | str | None,
        creation_time: datetime,
    ):
        """Create a Key object."""
        if isinstance(public_key, str):
            public_key = bytes.fromhex(public_key)

        if isinstance(private_key, str):
            private_key = bytes.fromhex(private_key)
        self.family = family
        self.public_key = public_key
        self.private_key = private_key
        self.creation_time = creation_time
        super().__init__(
            family=self.family,
            private_key=self.private_key,
            public_key=self.public_key,
        )

    @classmethod
    def create(cls: Type[_Key], family: str) -> _Key:
        """Initialise a Key from a DID key spec from a DID document."""
        crypt = Crypt.new(family)

        return cls(
            family=crypt.family,
            public_key=crypt.public_key,
            private_key=crypt.private_key,
            creation_time=datetime.now(UTC),
        )

    @classmethod
    def from_crypt(
        cls: Type[_Key], crypt: Crypt, creation_time: datetime
    ) -> _Key:
        """Create a Key object from a Crypt object."""
        return cls(
            family=crypt.family,
            public_key=crypt.public_key,
            private_key=crypt.private_key,
            creation_time=creation_time,
        )

    @classmethod
    def from_key_spec(cls: Type[_Key], key_spec: dict) -> _Key:
        """Initialise a Key from a DID key spec from a DID document."""
        key = cls(
            family=key_spec["type"],
            public_key=key_spec["publicKeyMultibase"],
            private_key=None,
            creation_time=string_to_time(key_spec["creation_time"]),
        )
        if key_spec["id"].strip("#") != key.get_key_id():
            raise ValueError(
                "The key-spec's key ID doesn't match our convention"
            )
        return key

    @classmethod
    def from_key_id(cls: Type[_Key], key_id: str) -> _Key:
        """Initialise a Key from a key ID generated by this class."""
        data = key_id.split(":")
        public_key = data[-1]
        timestamp = data[-2]
        family = ":".join(data[0:-2])
        key = cls(
            family=family,
            public_key=public_key,
            private_key=None,
            creation_time=string_to_time(timestamp),
        )
        return key

    def generate_key_spec(self, controller: str) -> dict:
        """Generate a key spec for a DID document."""
        return {
            "id": f"#{self.get_key_id()}",
            "type": self.family,
            "publicKeyMultibase": self.public_key.hex(),
            "creation_time": time_to_string(self.creation_time),
            "controller": controller,
        }

    def serialise_private(
        self,
    ) -> dict:
        """Serialise this key's data, including the private key encrypted."""

        if not (
            self.private_key,
            self.family and self.public_key and self.creation_time,
        ):
            error_message = "Not all of this objects' fields are set!\n".join(
                [
                    f"family: {type(self.family)}",
                    f"public_key: {type(self.public_key)}",
                    f"private_key: {type(self.private_key)}",
                    f"creation_time: {type(self.creation_time)}",
                ]
            )
            raise ValueError(error_message)

        return {
            "family": self.family,
            "public_key": self.public_key.hex(),
            "private_key": self.private_key.hex(),
            "creation_time": time_to_string(self.creation_time),
        }

    def serialise_private_encrypted(
        self, crypt: Crypt, allow_missing_private_key: bool = False
    ) -> dict:
        """Serialise this key's data, including the private key encrypted."""
        if not allow_missing_private_key and not self.private_key:
            raise ValueError(
                "Private Key is not set!\n"
                "You can use the `allow_missing_private_key` parameter to "
                "ignore this."
            )

        if not (self.family and self.public_key and self.creation_time):
            error_message = "Not all of this objects' fields are set!\n".join(
                [
                    f"family: {type(self.family)}",
                    f"public_key: {type(self.public_key)}",
                    f"creation_time: {type(self.creation_time)}",
                ]
            )
            raise ValueError(error_message)

        private_key = (
            crypt.encrypt(self.private_key).hex() if self.private_key else None
        )
        return {
            "family": self.family,
            "public_key": self.public_key.hex(),
            "private_key": private_key,
            "creation_time": time_to_string(self.creation_time),
        }

    def is_unlocked(self) -> bool:
        if self.private_key:
            return True
        return False

    @classmethod
    def deserialise_private(
        cls: Type[_Key],
        data: dict,
    ) -> _Key:
        """Deserialise data with encrypted private key."""
        if isinstance(data, str):
            data = json.loads(data)
        return cls(
            family=data["family"],
            public_key=bytes.fromhex(data["public_key"]),
            private_key=bytes.fromhex(data["private_key"]),
            creation_time=string_to_time(data["creation_time"]),
        )

    @classmethod
    def deserialise_private_encrypted(
        cls: Type[_Key], data: dict, crypt: Crypt
    ) -> _Key:
        """Deserialise data with encrypted private key."""
        if isinstance(data, str):
            data = json.loads(data)
        private_key = (
            crypt.decrypt(bytes.fromhex(data["private_key"]))
            if data["private_key"]
            else None
        )
        return cls(
            family=data["family"],
            public_key=data["public_key"],
            private_key=private_key,
            creation_time=string_to_time(data["creation_time"]),
        )

    def get_public_key(self) -> str:
        return self.public_key.hex()

    def get_private_key(self) -> str:
        if not self.private_key:
            raise ValueError("This key's private key hasn't been defined")
        return self.private_key.hex()

    def get_key_id(self) -> str:
        return generate_key_id(
            family=self.family,
            creation_time=self.creation_time,
            public_key=self.public_key,
        )

    def clone_public(self) -> "Key":
        return Key(
            public_key=self.public_key,
            private_key=None,
            family=self.family,
            creation_time=self.creation_time,
        )

    def __str__(self):
        return self.get_key_id()


def generate_key_id(
    family: str,
    public_key: bytes | str,
    creation_time: datetime,
):
    if isinstance(public_key, bytes) or isinstance(public_key, bytearray):
        public_key = public_key.hex()
    if not (family and public_key and creation_time):
        raise ValueError("Not all key fields provided.")
    return f"{family}:{time_to_string(creation_time)}:{public_key}"


decorate_all_functions(strictly_typed, __name__)
