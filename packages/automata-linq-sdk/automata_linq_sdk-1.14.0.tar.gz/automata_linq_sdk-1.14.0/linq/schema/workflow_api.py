# generated by datamodel-codegen:
#   filename:  http://localhost:8000/openapi.json
#   timestamp: 2025-10-17T15:54:28+00:00
# pyright: reportInvalidTypeForm=false

from __future__ import annotations

from typing import Annotated, Any, Literal
from uuid import UUID

from pydantic import AwareDatetime, BaseModel, ConfigDict, Discriminator, Field, RootModel, conint
from typing_extensions import TypeAliasType


class AdvancedOptions(BaseModel):
    """
    Advanced options for failure handling.
    """

    model_config = ConfigDict(frozen=True)
    additional_labwares_to_abort: list[str] = Field(
        ..., description="List of labware IDs to abort on failure", title="Additional Labwares To Abort"
    )


class AdvancedOptionsInput(BaseModel):
    """
    Advanced options for failure handling.
    """

    model_config = ConfigDict(frozen=True)
    additional_labwares_to_abort: list[str] | None = Field(
        default=None, description="List of labware IDs to abort on failure", title="Additional Labwares To Abort"
    )


class AvailableActions(BaseModel):
    model_config = ConfigDict(frozen=True)
    complete_manually: bool = Field(
        ..., description="Whether the task can be completed manually", title="Complete Manually"
    )
    retry: bool = Field(..., description="Whether the task can be retried", title="Retry")
    ignore: bool = Field(..., title="Ignore", deprecated=True)
    advanced_options: AdvancedOptions = Field(..., description="Advanced options for failure handling")


class AvailableActionsInput(BaseModel):
    model_config = ConfigDict(frozen=True)
    complete_manually: bool = Field(
        default=True, description="Whether the task can be completed manually", title="Complete Manually"
    )
    retry: bool = Field(default=True, description="Whether the task can be retried", title="Retry")
    ignore: bool = Field(default=False, title="Ignore", deprecated=True)
    advanced_options: AdvancedOptionsInput | None = Field(
        default=None, description="Advanced options for failure handling"
    )


class BooleanParameterDefinition(BaseModel):
    model_config = ConfigDict(frozen=True)
    id: str = Field(
        ...,
        description="Unique identifier for the parameter. This is used to reference the parameter in the workflow definition.",
        title="Id",
    )
    name: str = Field(..., description="Human-readable name for the parameter.", title="Name")
    always_required: bool = Field(
        ...,
        description="If true, the parameter is always required. If false, parameter is only required when publishing or validating for execution.",
        title="Always Required",
    )
    type: Literal["boolean"] = Field(default="boolean", title="Type")
    default: bool | None = Field(
        ..., description="Default value for the parameter. If not provided, the parameter is required.", title="Default"
    )


class BooleanParameterDefinitionInput(BaseModel):
    model_config = ConfigDict(frozen=True)
    id: str = Field(
        ...,
        description="Unique identifier for the parameter. This is used to reference the parameter in the workflow definition.",
        title="Id",
    )
    name: str = Field(..., description="Human-readable name for the parameter.", title="Name")
    always_required: bool = Field(
        default=False,
        description="If true, the parameter is always required. If false, parameter is only required when publishing or validating for execution.",
        title="Always Required",
    )
    type: Literal["boolean"] = Field(default="boolean", title="Type")
    default: bool | None = Field(
        default=None,
        description="Default value for the parameter. If not provided, the parameter is required.",
        title="Default",
    )


class BooleanParameterValueInput(BaseModel):
    model_config = ConfigDict(frozen=True)
    id: str = Field(
        ...,
        description="Unique identifier for the parameter. This is used to reference the parameter definition",
        title="Id",
    )
    type: Literal["boolean"] = Field(default="boolean", title="Type")
    value: bool = Field(..., description="Value for the boolean parameter.", title="Value")


class CommandStatusResult(BaseModel):
    model_config = ConfigDict(frozen=True)
    status: str | None = Field(..., title="Status")
    instance_name: str | None = Field(..., title="Instance Name")
    status_details: str | None = Field(..., title="Status Details")


class ConditionalSourceTask(BaseModel):
    model_config = ConfigDict(frozen=True)
    task_ids: list[str] = Field(
        ...,
        description="The list of potential source tasks that the labware can be retrieved from.The tasks must be conditionally independent.In reality, only one of these tasks will be the source task, once some conditional is evaluated.",
        title="Task Ids",
    )


class ConditionalSourceTaskInput(ConditionalSourceTask):
    pass


class Coordinate(BaseModel):
    """
    Coordinates on a grid
    """

    model_config = ConfigDict(frozen=True)
    row: int | None = Field(..., description="Position in y", title="Row")
    column: int | None = Field(..., description="Position in x", title="Column")
    reachable: bool | None = Field(
        ..., description="Is the coordinate reachable by Automata transport.", title="Reachable"
    )


DataConnectorAction = Literal["import", "export"]
DataConnectorType = Literal["sftp"]


class DataOutputSuffixInfo(BaseModel):
    model_config = ConfigDict(frozen=True)
    field_name: str = Field(..., title="Field Name")
    repeated_field: bool = Field(..., title="Repeated Field")


DefaultArgument = TypeAliasType(
    "DefaultArgument",
    int | str | float | bool | bytes | list[int | str | float | bool | bytes] | dict[str, "DefaultArgument"],
)


class DriverProtocol(BaseModel):
    model_config = ConfigDict(frozen=True)
    actions: dict[str, dict[str, str]] = Field(..., description="Actions defined for the protocol", title="Actions")


class DuplicateWorkflowInput(BaseModel):
    model_config = ConfigDict(frozen=True)
    name: str | None = Field(default=None, description="New name for duplicated workflow", title="Name")


FailureResponse = Literal["abort", "pause"]


class FeasibilityStage(BaseModel):
    model_config = ConfigDict(frozen=True)
    enable_advanced_solving: bool = Field(
        ...,
        description="Whether to enable advanced solving techniques to find a feasible solution.",
        title="Enable Advanced Solving",
    )
    incremental_solve: bool = Field(
        ...,
        description="Force the solver to use iterative solving advanced method. Performance varies - can be slower to solve but can also be more reliable than other methods.",
        title="Incremental Solve",
    )
    max_computation_time: float | None = Field(
        ..., description="Maximum time (in seconds) to spend in the feasibility stage.", title="Max Computation Time"
    )


class FeasibilityStageInput(BaseModel):
    model_config = ConfigDict(frozen=True)
    enable_advanced_solving: bool = Field(
        default=False,
        description="Whether to enable advanced solving techniques to find a feasible solution.",
        title="Enable Advanced Solving",
    )
    incremental_solve: bool = Field(
        default=False,
        description="Force the solver to use iterative solving advanced method. Performance varies - can be slower to solve but can also be more reliable than other methods.",
        title="Incremental Solve",
    )
    max_computation_time: float | None = Field(
        default=None,
        description="Maximum time (in seconds) to spend in the feasibility stage.",
        title="Max Computation Time",
    )


class FileRefParameterDefinition(BaseModel):
    model_config = ConfigDict(frozen=True)
    id: str = Field(
        ...,
        description="Unique identifier for the parameter. This is used to reference the parameter in the workflow definition.",
        title="Id",
    )
    name: str = Field(..., description="Human-readable name for the parameter.", title="Name")
    always_required: bool = Field(
        ...,
        description="If true, the parameter is always required. If false, parameter is only required when publishing or validating for execution.",
        title="Always Required",
    )
    type: Literal["file_ref"] = Field(default="file_ref", title="Type")
    default: str | None = Field(
        ..., description="Default value for the parameter. If not provided, the parameter is required.", title="Default"
    )


class FileRefParameterDefinitionInput(BaseModel):
    model_config = ConfigDict(frozen=True)
    id: str = Field(
        ...,
        description="Unique identifier for the parameter. This is used to reference the parameter in the workflow definition.",
        title="Id",
    )
    name: str = Field(..., description="Human-readable name for the parameter.", title="Name")
    always_required: bool = Field(
        default=False,
        description="If true, the parameter is always required. If false, parameter is only required when publishing or validating for execution.",
        title="Always Required",
    )
    type: Literal["file_ref"] = Field(default="file_ref", title="Type")
    default: str | None = Field(
        default=None,
        description="Default value for the parameter. If not provided, the parameter is required.",
        title="Default",
    )


class FileRefParameterValueInput(BaseModel):
    model_config = ConfigDict(frozen=True)
    id: str = Field(
        ...,
        description="Unique identifier for the parameter. This is used to reference the parameter definition",
        title="Id",
    )
    type: Literal["file_ref"] = Field(default="file_ref", title="Type")
    value: str = Field(..., description="Value for the file reference parameter.", title="Value")
    name: str = Field(..., description="Name of the file reference.", title="Name")


class FloatParameterDefinition(BaseModel):
    model_config = ConfigDict(frozen=True)
    id: str = Field(
        ...,
        description="Unique identifier for the parameter. This is used to reference the parameter in the workflow definition.",
        title="Id",
    )
    name: str = Field(..., description="Human-readable name for the parameter.", title="Name")
    always_required: bool = Field(
        ...,
        description="If true, the parameter is always required. If false, parameter is only required when publishing or validating for execution.",
        title="Always Required",
    )
    type: Literal["float"] = Field(default="float", title="Type")
    default: float | None = Field(
        ..., description="Default value for the parameter. If not provided, the parameter is required.", title="Default"
    )
    minimum: float | None = Field(
        ...,
        description="Minimum value for the parameter, greater than or equal to. If not provided, no minimum is enforced.",
        title="Minimum",
    )
    maximum: float | None = Field(
        ...,
        description="Maximum value for the parameter, less than or equal to. If not provided, no maximum is enforced.",
        title="Maximum",
    )


class FloatParameterDefinitionInput(BaseModel):
    model_config = ConfigDict(frozen=True)
    id: str = Field(
        ...,
        description="Unique identifier for the parameter. This is used to reference the parameter in the workflow definition.",
        title="Id",
    )
    name: str = Field(..., description="Human-readable name for the parameter.", title="Name")
    always_required: bool = Field(
        default=False,
        description="If true, the parameter is always required. If false, parameter is only required when publishing or validating for execution.",
        title="Always Required",
    )
    type: Literal["float"] = Field(default="float", title="Type")
    default: float | None = Field(
        default=None,
        description="Default value for the parameter. If not provided, the parameter is required.",
        title="Default",
    )
    minimum: float | None = Field(
        default=None,
        description="Minimum value for the parameter, greater than or equal to. If not provided, no minimum is enforced.",
        title="Minimum",
    )
    maximum: float | None = Field(
        default=None,
        description="Maximum value for the parameter, less than or equal to. If not provided, no maximum is enforced.",
        title="Maximum",
    )


class FloatParameterValueInput(BaseModel):
    model_config = ConfigDict(frozen=True)
    id: str = Field(
        ...,
        description="Unique identifier for the parameter. This is used to reference the parameter definition",
        title="Id",
    )
    type: Literal["float"] = Field(default="float", title="Type")
    value: float = Field(..., description="Value for the float parameter.", title="Value")


class GrippingOffset(BaseModel):
    model_config = ConfigDict(frozen=True)
    portrait: float | None = Field(default=None, title="Portrait")
    landscape: float | None = Field(default=None, title="Landscape")


class GrippingOffsetInput(GrippingOffset):
    pass


class GrippingWidth(BaseModel):
    model_config = ConfigDict(frozen=True)
    gripped: float | None = Field(default=None, title="Gripped")
    released: float | None = Field(default=None, title="Released")


class GrippingWidthInput(GrippingWidth):
    pass


class GrippingWidths(BaseModel):
    model_config = ConfigDict(frozen=True)
    portrait: GrippingWidth | None = None
    landscape: GrippingWidth | None = None


class GrippingWidthsInput(BaseModel):
    model_config = ConfigDict(frozen=True)
    portrait: GrippingWidthInput | None = None
    landscape: GrippingWidthInput | None = None


class HookParameters(BaseModel):
    model_config = ConfigDict(frozen=True)
    url: str = Field(..., title="Url")
    headers: dict[str, str] | None = Field(
        default=None, description="HTTP headers to include in the request", title="Headers"
    )


class HookParametersInput(HookParameters):
    pass


class InstrumentBlock(BaseModel):
    """
    Instructions to block off an instrument from being used between two tasks. Useful if the first task modifies the instrument state temporarily, such as holding caps or lids.
    """

    model_config = ConfigDict(frozen=True)
    start_task_id: str = Field(..., description="ID of the task to block the instrument after", title="Start Task Id")
    end_task_id: str = Field(..., description="ID of the task to block the instrument until", title="End Task Id")


class InstrumentBlockInput(BaseModel):
    """
    Instructions to block off an instrument from being used between two tasks. Useful if the first task modifies the instrument state temporarily, such as holding caps or lids.
    """

    model_config = ConfigDict(frozen=True)
    start_task_id: str = Field(..., description="ID of the task to block the instrument from", title="Start Task Id")
    end_task_id: str = Field(..., description="ID of the task to block the instrument until", title="End Task Id")


class InstrumentDeck(BaseModel):
    """
    Deck of an instrument
    """

    model_config = ConfigDict(frozen=True)
    coordinate: list[Coordinate] | None = Field(
        ..., description="List of coordinates of an instrument deck", title="Coordinate"
    )


class IntegerParameterDefinition(BaseModel):
    model_config = ConfigDict(frozen=True)
    id: str = Field(
        ...,
        description="Unique identifier for the parameter. This is used to reference the parameter in the workflow definition.",
        title="Id",
    )
    name: str = Field(..., description="Human-readable name for the parameter.", title="Name")
    always_required: bool = Field(
        ...,
        description="If true, the parameter is always required. If false, parameter is only required when publishing or validating for execution.",
        title="Always Required",
    )
    type: Literal["integer"] = Field(default="integer", title="Type")
    default: int | None = Field(
        ..., description="Default value for the parameter. If not provided, the parameter is required.", title="Default"
    )
    minimum: int | None = Field(
        ...,
        description="Minimum value for the parameter, greater than or equal to. If not provided, no minimum is enforced.",
        title="Minimum",
    )
    maximum: int | None = Field(
        ...,
        description="Maximum value for the parameter, less than or equal to. If not provided, no maximum is enforced.",
        title="Maximum",
    )
    multiple_of: int | None = Field(
        ...,
        description="Value must be a multiple of this number. If not provided, no restriction is enforced.",
        title="Multiple Of",
    )


class IntegerParameterDefinitionInput(BaseModel):
    model_config = ConfigDict(frozen=True)
    id: str = Field(
        ...,
        description="Unique identifier for the parameter. This is used to reference the parameter in the workflow definition.",
        title="Id",
    )
    name: str = Field(..., description="Human-readable name for the parameter.", title="Name")
    always_required: bool = Field(
        default=False,
        description="If true, the parameter is always required. If false, parameter is only required when publishing or validating for execution.",
        title="Always Required",
    )
    type: Literal["integer"] = Field(default="integer", title="Type")
    default: int | None = Field(
        default=None,
        description="Default value for the parameter. If not provided, the parameter is required.",
        title="Default",
    )
    minimum: int | None = Field(
        default=None,
        description="Minimum value for the parameter, greater than or equal to. If not provided, no minimum is enforced.",
        title="Minimum",
    )
    maximum: int | None = Field(
        default=None,
        description="Maximum value for the parameter, less than or equal to. If not provided, no maximum is enforced.",
        title="Maximum",
    )
    multiple_of: int | None = Field(
        default=None,
        description="Value must be a multiple of this number. If not provided, no restriction is enforced.",
        title="Multiple Of",
    )


class IntegerParameterValueInput(BaseModel):
    model_config = ConfigDict(frozen=True)
    id: str = Field(
        ...,
        description="Unique identifier for the parameter. This is used to reference the parameter definition",
        title="Id",
    )
    type: Literal["integer"] = Field(default="integer", title="Type")
    value: int = Field(..., description="Value for the integer parameter.", title="Value")


IssueLevel = Literal["error", "warning"]
JsonSerializable = TypeAliasType(
    "JsonSerializable", list["JsonSerializable"] | dict[str, "JsonSerializable"] | str | bool | int | float | None
)


class LabwareDimensions(BaseModel):
    model_config = ConfigDict(frozen=True)
    length: float = Field(..., title="Length")
    width: float = Field(..., title="Width")
    height: float = Field(..., title="Height")


class LabwareDimensionsInput(BaseModel):
    model_config = ConfigDict(frozen=True)
    length: float = Field(default=127.76, title="Length")
    width: float = Field(default=85.48, title="Width")
    height: float = Field(default=10.0, title="Height")


class LabwareMovementHook(BaseModel):
    """
    Hook to be triggered when labware is transported.
    """

    model_config = ConfigDict(frozen=True)
    parameters: HookParameters
    filter: Literal["on_labware_movement"] = Field(default="on_labware_movement", title="Filter")
    labware_ids: list[str] = Field(
        ...,
        description="List of labware IDs that the hook should be triggered for. If empty, the hook will be triggered for all labware.",
        title="Labware Ids",
    )
    trigger_on: Literal["start", "end", "both"] = Field(
        default="both",
        description="When to trigger the hook. 'start' triggers the hook when the labware is picked up, 'end' triggers the hook when the labware is placed down, 'both' does both.",
        title="Trigger On",
    )


class LabwareMovementHookInput(BaseModel):
    """
    Hook to be triggered when labware is transported.
    """

    model_config = ConfigDict(frozen=True)
    filter: Literal["on_labware_movement"] = Field(default="on_labware_movement", title="Filter")
    parameters: HookParametersInput
    labware_ids: list[str] = Field(
        ...,
        description="List of labware IDs that the hook should be triggered for. If empty, the hook will be triggered for all labware.",
        title="Labware Ids",
    )
    trigger_on: Literal["start", "end", "both"] = Field(
        default="both",
        description="When to trigger the hook. 'start' triggers the hook when the labware is picked up, 'end' triggers the hook when the labware is placed down, 'both' does both.",
        title="Trigger On",
    )


class LabwareOffsets(BaseModel):
    model_config = ConfigDict(frozen=True)
    height: float | None = Field(..., title="Height")


class LabwareOffsetsInput(BaseModel):
    model_config = ConfigDict(frozen=True)
    height: float | None = Field(default=None, title="Height")


class LabwareType(BaseModel):
    model_config = ConfigDict(frozen=True)
    id: str = Field(..., title="Id")
    dimensions: LabwareDimensions | None = Field(..., description="Dimensions of the labware type")
    labware_dimension_offset: LabwareOffsets = Field(..., description="Offset dimensions of the labware type")
    max_idle_time: int | None = Field(
        ...,
        description="Maximum time gap allowed between consecutive operations on a labware of this type, in seconds",
        title="Max Idle Time",
    )
    gripping_widths: GrippingWidths | None = Field(
        default=None,
        description="Gripping widths along the X-axis for portrait and landscape orientations, including both gripped and released states",
    )
    gripping_depth_offset: GrippingOffset | None = Field(
        default=None,
        description="Offsets along the Y-axis for the tool, applicable to both portrait and landscape orientations",
    )
    gripping_height_offset: float | GrippingOffset | None = Field(
        default=None,
        description="Z-axis offsets for gripping, either as a single value or specified per orientation",
        title="Gripping Height Offset",
    )
    scara_motion_profile: str | None = Field(
        default=None,
        description="SCARA motion profile for the labware type, if applicable",
        title="Scara Motion Profile",
    )
    scara_speed_multiplier: float | None = Field(
        default=None, description="Speed multiplier for SCARA motion, if applicable", title="Scara Speed Multiplier"
    )


class LabwareTypeInput(BaseModel):
    model_config = ConfigDict(frozen=True)
    id: str = Field(..., title="Id")
    dimensions: LabwareDimensionsInput | None = Field(
        default=None,
        description="Dimensions of the labware type - Deprecated, use 'labware_dimensions_offset' instead",
        deprecated=True,
    )
    labware_dimension_offset: LabwareOffsetsInput | None = Field(
        default=None, description="Offset dimensions of the labware type"
    )
    max_idle_time: int | None = Field(
        default=None,
        description="Maximum time gap allowed between consecutive operations on a labware of this type, in seconds",
        title="Max Idle Time",
    )
    gripping_widths: GrippingWidthsInput | None = Field(
        default=None,
        description="Gripping widths along the X-axis for portrait and landscape orientations, including both gripped and released states",
    )
    gripping_depth_offset: GrippingOffsetInput | None = Field(
        default=None,
        description="Offsets along the Y-axis for the tool, applicable to both portrait and landscape orientations",
    )
    gripping_height_offset: float | GrippingOffsetInput | None = Field(
        default=None,
        description="Z-axis offsets for gripping, either as a single value or specified per orientation",
        title="Gripping Height Offset",
    )
    scara_motion_profile: str | None = Field(
        default=None,
        description="SCARA motion profile for the labware type, if applicable",
        title="Scara Motion Profile",
    )
    scara_speed_multiplier: float | None = Field(
        default=None, description="Speed multiplier for SCARA motion, if applicable", title="Scara Speed Multiplier"
    )


class Layout(BaseModel):
    """
    GUI layout and extra data.
    """

    model_config = ConfigDict(frozen=True)
    version: str = Field(..., title="Version")
    data: JsonSerializable


class LayoutInput(BaseModel):
    """
    GUI layout and extra data.
    """

    model_config = ConfigDict(frozen=True)
    version: str = Field(default="", title="Version")
    data: JsonSerializable | None = None


class Location(BaseModel):
    model_config = ConfigDict(frozen=True)
    instrument: str = Field(..., title="Instrument")
    slot: int = Field(..., title="Slot")


class LocationInput(Location):
    pass


class LocationRange(BaseModel):
    model_config = ConfigDict(frozen=True)
    instrument: str = Field(..., title="Instrument")
    start_slot: int = Field(..., title="Start Slot")
    end_slot: int = Field(..., title="End Slot")


class LocationRangeInput(BaseModel):
    model_config = ConfigDict(frozen=True)
    start_slot: int = Field(..., title="Start Slot")
    end_slot: int = Field(..., title="End Slot")
    instrument: str = Field(..., title="Instrument")


class LuaFunction(BaseModel):
    """
    A Lua function written inline as a string.
    """

    model_config = ConfigDict(frozen=True)
    type: Literal["lua"] = Field(default="lua", title="Type")
    value: str = Field(..., title="Value")


class LuaFunctionInput(LuaFunction):
    """
    A Lua function written inline as a string.
    """


class Metrics(BaseModel):
    model_config = ConfigDict(frozen=True)
    plan_solve_duration: float = Field(
        ...,
        description="Total time taken to create and solve the optimisation model to get a plan",
        title="Plan Solve Duration",
    )
    total_plan_duration: float = Field(
        ...,
        description="The total duration from the start of a workflow till the end of the last task",
        title="Total Plan Duration",
    )
    batches_requested: int | None = Field(
        ..., description="Number of batches the workflow was generated for.", title="Batches Requested"
    )
    instrument_utilization: dict[str, float] | None = Field(
        default=None, description="Utilization percentage for each instrument", title="Instrument Utilization"
    )
    total_deadtime: int = Field(..., description="Total dead time in the workflow", title="Total Dead Time")
    create_model_duration: float = Field(
        ..., description="Total time taken to create the optimisation model", title="Create Model Duration"
    )
    search_duration: float = Field(
        ..., description="Total time taken to search for a solution", title="Search Duration"
    )
    times: list[float] | None = Field(default=None, description="Times for final solve", title="Times")
    solutions: list[float] | None = Field(default=None, description="Solutions for final solve", title="Solutions")
    time_to_feasible: float = Field(..., description="Time to find first feasible solution", title="Time to Feasible")


class MockBehaviour(BaseModel):
    model_config = ConfigDict(frozen=True)
    execution_time: float | None = Field(
        ...,
        description="Execution time in seconds. Overrides the default execution time of the task. If set to 0, task will not start",
        title="Execution Time",
    )
    success: bool = Field(..., description="Whether the task should succeed or fail", title="Success")
    data_outputs: dict[str, JsonSerializable] = Field(
        ...,
        description="key,value pairs of data to be stored in the data store after the task is completed",
        title="Data Outputs",
    )


class MockBehaviourInput(BaseModel):
    model_config = ConfigDict(frozen=True)
    execution_time: float | None = Field(
        default=None,
        description="Execution time in seconds. Overrides the default execution time of the task. If set to 0, task will not start",
        title="Execution Time",
    )
    success: bool = Field(default=True, description="Whether the task should succeed or fail", title="Success")
    data_outputs: dict[str, JsonSerializable] | None = Field(
        default=None,
        description="key,value pairs of data to be stored in the data store after the task is completed",
        title="Data Outputs",
    )


class NewPlanHook(BaseModel):
    """
    Hook to be triggered when a new plan is generated.
    """

    model_config = ConfigDict(frozen=True)
    parameters: HookParameters
    filter: Literal["on_new_plan"] = Field(default="on_new_plan", title="Filter")


class NewPlanHookInput(BaseModel):
    """
    Hook to be triggered when a new plan is generated.
    """

    model_config = ConfigDict(frozen=True)
    filter: Literal["on_new_plan"] = Field(default="on_new_plan", title="Filter")
    parameters: HookParametersInput


OutputSlotFillingBehavior = Literal["match_input", "use_range"]


class OutputSlotFillingRule(BaseModel):
    model_config = ConfigDict(frozen=True)
    behavior: OutputSlotFillingBehavior = Field(..., description="The slot filling behavior")


class ParameterReference(BaseModel):
    """
    A reference to a parameter that will get replaced with the parameter value.
    """

    model_config = ConfigDict(frozen=True)
    parameter_id: str = Field(..., description="The id of the parameter to reference.", title="Parameter Id")


class ParameterReferenceInput(ParameterReference):
    """
    A reference to a parameter that will get replaced with the parameter value.
    """


class PlanInstrument(BaseModel):
    model_config = ConfigDict(frozen=True)
    id: str = Field(..., title="Id")
    name: str = Field(..., title="Name")


class PlanLabware(BaseModel):
    model_config = ConfigDict(frozen=True)
    id: str = Field(..., title="Id")
    description: str = Field(..., title="Description")
    batch: int | None = Field(
        default=None,
        description="The batch the labware is used in. For reusable labware, this will be the _first_ batch in which it is used.",
        title="Batch",
    )


PlanStage = Literal["QUEUEING", "SOLVING", "OPTIMIZING"]
PlanStatus = Literal["PENDING", "COMPLETED", "FAILED", "CANCELLED"]


class PlanTaskDetail(BaseModel):
    model_config = ConfigDict(frozen=True)
    start: int = Field(..., title="Start")
    end: int = Field(..., title="End")
    action: str = Field(..., title="Action")
    description: str = Field(..., title="Description")
    instrument: PlanInstrument
    labware_in: list[PlanLabware] = Field(..., title="Labware In")
    labware_out: list[PlanLabware] = Field(..., title="Labware Out")
    is_manual_interaction: bool = Field(..., title="Is Manual Interaction")
    batch: int | None = Field(
        ...,
        description="The best guess at the batch that this task belongs to. Calculated in Maestro by looking at the highest batch number of any input labware",
        title="Batch",
    )


class PlannedLabwareLocation(Location):
    pass


PlannerFailureResponse = Literal["abort", "pause", "continue"]


class PlannerOptions(BaseModel):
    model_config = ConfigDict(frozen=True)
    preset: Literal["DRAFT", "TEST", "PROD_STANDARD", "PROD_LARGE"] | None = Field(
        ..., description="Preset to use for the planner options", title="Preset"
    )
    target_objective: float | None = Field(..., description="Target objective value", title="Target Objective")
    max_computation_time: int | None = Field(
        ...,
        description="Max computation time allowed for the planner to improve the solution, in seconds.",
        title="Max Computation Time",
    )
    max_dead_time: int | None = Field(
        ..., description="Max dead time allowed between tasks with a transport between them", title="Max Dead Time"
    )
    round_robin_load_balancing: bool = Field(
        ...,
        description="Maestro uses a round robin approach to load balancing. This is useful when the instruments are equivalent, eg. two instruments that take the same time to transport to.",
        title="Round Robin Load Balancing",
    )
    feasibility_stage: FeasibilityStage | None = Field(
        ..., description="Configuration for the feasibility stage of the planner."
    )
    optimisation_target: Literal[
        "minimize_total_plan_duration",
        "minimize_labware_idle_time",
        "balance_total_plan_duration_and_labware_idle_time",
    ] = Field(
        ...,
        description="What the scheduler seeks to minimise: total plan duration, gaps in the schedule (labware idle time), or a balance of both.",
        title="Optimisation Target",
    )


class PlannerOptionsInput(BaseModel):
    model_config = ConfigDict(frozen=True)
    preset: Literal["DRAFT", "TEST", "PROD_STANDARD", "PROD_LARGE"] | None = Field(
        default=None, description="Preset to use for the planner options", title="Preset"
    )
    target_objective: float | None = Field(default=None, description="Target objective value", title="Target Objective")
    max_computation_time: int | None = Field(
        default=None,
        description="Max computation time allowed for the planner to improve the solution, in seconds.",
        title="Max Computation Time",
    )
    max_dead_time: int | None = Field(
        default=None,
        description="Max dead time allowed between tasks with a transport between them",
        title="Max Dead Time",
    )
    round_robin_load_balancing: bool = Field(
        default=False,
        description="Maestro uses a round robin approach to load balancing. This is useful when the instruments are equivalent, eg. two instruments that take the same time to transport to.",
        title="Round Robin Load Balancing",
    )
    feasibility_stage: FeasibilityStageInput | None = Field(
        default=None, description="Configuration for the feasibility stage of the planner."
    )
    optimisation_target: Literal[
        "minimize_total_plan_duration",
        "minimize_labware_idle_time",
        "balance_total_plan_duration_and_labware_idle_time",
    ] = Field(
        default="minimize_total_plan_duration",
        description="What the scheduler seeks to minimise: total plan duration, gaps in the schedule (labware idle time), or a balance of both.",
        title="Optimisation Target",
    )


class PublishedWorkflow(BaseModel):
    model_config = ConfigDict(frozen=True)
    workflow_id: UUID = Field(..., title="Workflow Id")
    linq_backend_workflow_id: UUID = Field(..., title="Linq Backend Workflow Id")


class PythonReferenceFunction(BaseModel):
    """
    A reference to a python function from the user organisation's scripts (evals repo).
    """

    model_config = ConfigDict(frozen=True)
    type: Literal["python_reference"] = Field(default="python_reference", title="Type")
    value: str = Field(..., title="Value")


class PythonReferenceFunctionInput(PythonReferenceFunction):
    """
    A reference to a python function from the user organisation's scripts (evals repo).
    """


class ReferenceData(BaseModel):
    """
    A reference to some data added by the user as Reference Data. This is not produced by a task in the workflow.
    """

    model_config = ConfigDict(frozen=True)
    key: str = Field(..., description="The key that the data is stored under", title="Key")


class ReferenceDataInput(ReferenceData):
    """
    A reference to some data added by the user as Reference Data. This is not produced by a task in the workflow.
    """


class RenameWorkflowInput(BaseModel):
    """
    Input for renaming a workflow.
    """

    model_config = ConfigDict(frozen=True)
    name: str = Field(..., description="New name for the workflow. Must be unique and not empty.", title="Name")


class RestartHubOutput(BaseModel):
    model_config = ConfigDict(frozen=True)
    command_id: str | None = Field(..., title="Command Id")


class RunInstruction(BaseModel):
    model_config = ConfigDict(frozen=True)
    description: str = Field(..., title="Description")
    phase: Literal["pre", "mid", "post"] = Field(..., title="Phase")


class RunInstructionInput(BaseModel):
    model_config = ConfigDict(frozen=True)
    description: str = Field(..., description="Description of the instruction", title="Description")
    phase: Literal["pre", "mid", "post"] = Field(
        ..., description="phase when instructions is displayed ('pre', 'mid' and 'post')", title="Phase"
    )


class RunStateChangeHook(BaseModel):
    """
    Hook to be triggered when a run state changes.
    """

    model_config = ConfigDict(frozen=True)
    parameters: HookParameters
    filter: Literal["on_run_state_change"] = Field(default="on_run_state_change", title="Filter")


class RunStateChangeHookInput(BaseModel):
    """
    Hook to be triggered when a run state changes.
    """

    model_config = ConfigDict(frozen=True)
    filter: Literal["on_run_state_change"] = Field(default="on_run_state_change", title="Filter")
    parameters: HookParametersInput


class SafetyStateChangeHook(BaseModel):
    """
    Hook to be triggered on changes to the state of the safety adapter.
    """

    model_config = ConfigDict(frozen=True)
    parameters: HookParameters
    filter: Literal["on_safety_state_change"] = Field(default="on_safety_state_change", title="Filter")


class SafetyStateChangeHookInput(BaseModel):
    """
    Hook to be triggered on changes to the state of the safety adapter.
    """

    model_config = ConfigDict(frozen=True)
    filter: Literal["on_safety_state_change"] = Field(default="on_safety_state_change", title="Filter")
    parameters: HookParametersInput


Scheduler = Literal["maestro"]


class SchedulerConfig(BaseModel):
    """
    Configuration for the scheduler used to validate/plan/execute the workflow.
    """

    model_config = ConfigDict(frozen=True)
    scheduler: Scheduler = Field(..., description="Scheduler used for this workflow.")
    version: str = Field(..., description="Version of the scheduler", title="Version")
    python_scripts_version: str | None = Field(
        default=None,
        description="Version of the user organisation's custom python scripts to be used. If not provided, the most recent python scripts will be used. (see CodeTasks)",
        title="Python Scripts Version",
    )


class SchedulerConfigInput(BaseModel):
    """
    Configuration for the scheduler used to validate/plan/execute the workflow.
    """

    model_config = ConfigDict(frozen=True)
    scheduler: Scheduler | None = Field(default=None, description="Scheduler used for this workflow.")
    version: str = Field(..., description="Version of the scheduler.", title="Version")
    python_scripts_version: str | None = Field(
        default=None,
        description="Version of the user organisation's custom python scripts to be used. If not provided, the most recent python scripts will be used. (see CodeTasks)",
        title="Python Scripts Version",
    )


class ScriptArgumentInfo(BaseModel):
    model_config = ConfigDict(frozen=True)
    name: str = Field(..., title="Name")
    type: str = Field(..., title="Type")
    default: Any = Field(..., title="Default")


class ScriptReturnInfo(BaseModel):
    model_config = ConfigDict(frozen=True)
    name: str = Field(..., title="Name")
    type: str = Field(..., title="Type")


SlotFillingDistribution = Literal["unique", "non_unique"]


class SlotRange(BaseModel):
    model_config = ConfigDict(frozen=True)
    start_slot: int = Field(..., title="Start Slot")
    end_slot: int = Field(..., title="End Slot")


class SlotRangeInput(SlotRange):
    pass


class StaticData(BaseModel):
    """
    Static data to be passed to a code task.
    """

    model_config = ConfigDict(frozen=True)
    value: JsonSerializable = Field(..., description="The static value to be passed to the task.")


class StaticDataInput(StaticData):
    """
    Static data to be passed to a code task.
    """


class StoredLabware(BaseModel):
    model_config = ConfigDict(frozen=True)
    type: Literal["stored_labware"] = Field(default="stored_labware", title="Type")
    labware_id: str = Field(..., title="Labware Id")
    slot: int = Field(..., description="The slot the labware is stored in.", title="Slot")


class StoredLabwareInput(StoredLabware):
    pass


class StringParameterDefinition(BaseModel):
    model_config = ConfigDict(frozen=True)
    id: str = Field(
        ...,
        description="Unique identifier for the parameter. This is used to reference the parameter in the workflow definition.",
        title="Id",
    )
    name: str = Field(..., description="Human-readable name for the parameter.", title="Name")
    always_required: bool = Field(
        ...,
        description="If true, the parameter is always required. If false, parameter is only required when publishing or validating for execution.",
        title="Always Required",
    )
    type: Literal["string"] = Field(default="string", title="Type")
    default: str | None = Field(
        ..., description="Default value for the parameter. If not provided, the parameter is required.", title="Default"
    )
    is_file_path: bool | None = Field(
        ...,
        description="If true, the parameter is expected to be a file path. This allows for additional validation.",
        title="Is File Path",
    )
    is_directory_path: bool = Field(
        ...,
        description="If true, the parameter is expected to be a directory path. This allows for additional validation.",
        title="Is Directory Path",
    )


class StringParameterDefinitionInput(BaseModel):
    model_config = ConfigDict(frozen=True)
    id: str = Field(
        ...,
        description="Unique identifier for the parameter. This is used to reference the parameter in the workflow definition.",
        title="Id",
    )
    name: str = Field(..., description="Human-readable name for the parameter.", title="Name")
    always_required: bool = Field(
        default=False,
        description="If true, the parameter is always required. If false, parameter is only required when publishing or validating for execution.",
        title="Always Required",
    )
    type: Literal["string"] = Field(default="string", title="Type")
    default: str | None = Field(
        default=None,
        description="Default value for the parameter. If not provided, the parameter is required.",
        title="Default",
    )
    is_file_path: bool | None = Field(
        default=False,
        description="If true, the parameter is expected to be a file path. This allows for additional validation.",
        title="Is File Path",
    )
    is_directory_path: bool = Field(
        default=False,
        description="If true, the parameter is expected to be a directory path. This allows for additional validation.",
        title="Is Directory Path",
    )


class StringParameterValueInput(BaseModel):
    model_config = ConfigDict(frozen=True)
    id: str = Field(
        ...,
        description="Unique identifier for the parameter. This is used to reference the parameter definition",
        title="Id",
    )
    type: Literal["string"] = Field(default="string", title="Type")
    value: str = Field(..., description="Value for the string parameter.", title="Value")


class TaskArguments(BaseModel):
    model_config = ConfigDict(frozen=True)
    static: dict[str, JsonSerializable] = Field(
        ..., description="Static arguments that are passed to the instrument driver", title="Static"
    )
    shared: dict[str, str] = Field(
        ..., description="Shared arguments that are passed to the instrument driver", title="Shared"
    )


class TaskArgumentsInput(BaseModel):
    model_config = ConfigDict(frozen=True)
    static: dict[str, JsonSerializable] | None = Field(
        default=None, description="Static arguments that are passed to the instrument driver", title="Static"
    )
    shared: dict[str, str] | None = Field(
        default=None, description="Shared arguments that are passed to the instrument driver", title="Shared"
    )


class TaskInstrument(BaseModel):
    model_config = ConfigDict(frozen=True)
    type: str = Field(..., title="Type")
    mappings: list[str] = Field(
        ..., description="List of mapping IDs that the planner should choose from (OR)", title="Mappings"
    )


class TaskInstrumentInput(BaseModel):
    model_config = ConfigDict(frozen=True)
    type: str = Field(..., title="Type")
    mappings: list[str] | None = Field(
        default=None, description="List of mapping IDs that the planner should choose from (OR)", title="Mappings"
    )


class TaskOutputReference(BaseModel):
    """
    A reference to some data produced by another task in the workflow.
    """

    model_config = ConfigDict(frozen=True)
    task_id: str = Field(..., description="The task id of the task that produces the data.", title="Task Id")
    output_name: str | None = Field(
        ...,
        description="The name of the output from the task. Can leave as None if the task only has one output.",
        title="Output Name",
    )


class TaskOutputReferenceInput(BaseModel):
    """
    A reference to some data produced by another task in the workflow.
    """

    model_config = ConfigDict(frozen=True)
    task_id: str = Field(..., description="The task id of the task that produces the data.", title="Task Id")
    output_name: str | None = Field(
        default=None,
        description="The name of the output from the task. Can leave as None if the task only has one output.",
        title="Output Name",
    )


class TaskStateChangeHook(BaseModel):
    """
    Hook to be triggered when a task state changes.
    """

    model_config = ConfigDict(frozen=True)
    parameters: HookParameters
    filter: Literal["on_task_state_change"] = Field(default="on_task_state_change", title="Filter")
    task_ids: list[str] = Field(
        ...,
        description="List of task IDs that the hook should be triggered for. If empty, the hook will be triggered for all tasks.",
        title="Task Ids",
    )


class TaskStateChangeHookInput(BaseModel):
    """
    Hook to be triggered when a task state changes.
    """

    model_config = ConfigDict(frozen=True)
    filter: Literal["on_task_state_change"] = Field(default="on_task_state_change", title="Filter")
    parameters: HookParametersInput
    task_ids: list[str] = Field(
        ...,
        description="List of task IDs that the hook should be triggered for. If empty, the hook will be triggered for all tasks.",
        title="Task Ids",
    )


TimeConstraintType = Literal["start_to_end", "start_to_start", "end_to_end", "end_to_start", "consistency"]


class TransportPath(BaseModel):
    model_config = ConfigDict(frozen=True)
    source: str = Field(..., description="Source bench", title="Source")
    destination: str = Field(..., description="Destination bench", title="Destination")
    time: int = Field(..., description="Estimated transport time", title="Time")


class TransportPathInput(TransportPath):
    pass


UniqueInstrumentType = Literal["UNIQUE_INSTRUMENT_UNSPECIFIED", "UNIQUE_INSTRUMENT_HAMILTON"]
Units = Literal["rpm", "celsius", "seconds"]


class ValidBatchData(BaseModel):
    """
    Information displaying the valid batch numbers and the reason why these are the only valid batch numbers.
    """

    model_config = ConfigDict(frozen=True)
    valid_batch_numbers: list[int] = Field(
        ...,
        description="List of all valid batch numbers derived from restrictions imposed by labware location ranges and slot filling rules.",
        title="Valid Batch Numbers",
    )
    reason: str = Field(..., description="Reason why these are the only valid batch numbers.", title="Reason")


class ValidationError(BaseModel):
    model_config = ConfigDict(frozen=True)
    loc: list[str | int] = Field(..., title="Location")
    msg: str = Field(..., title="Message")
    type: str = Field(..., title="Error Type")


class WorkcellInstrument(BaseModel):
    model_config = ConfigDict(frozen=True)
    type: str = Field(..., description="Type of instrument", title="Type")
    id: str = Field(..., description="ID of the instrument", title="Id")
    name: str = Field(..., description="Non-functional friendly name of the instrument", title="Name")
    capacity: int = Field(..., description="Number of labwares that can be held by the instrument", title="Capacity")
    is_slotless_container: bool = Field(
        ...,
        description="Flag indicating the instrument is a bin or similar, in that 'slots' inside it need not be unique",
        title="Is Slotless Container",
    )
    bench: str = Field(..., description="The bench that the instrument is located on", title="Bench")
    driver: str = Field(..., description="Name of the driver that is used to control the instrument", title="Driver")
    mappings: list[str] = Field(
        ..., description="List of all mappings that the instrument belongs to (AND)", title="Mappings"
    )
    config: dict[str, JsonSerializable] = Field(..., description="Configuration for the driver", title="Config")
    simulate: bool = Field(..., description="Flag to simulate the instrument", title="Simulate")


class WorkcellInstrumentInput(BaseModel):
    model_config = ConfigDict(frozen=True)
    id: str = Field(..., description="ID of the instrument", title="Id")
    type: str = Field(..., description="Type of instrument", title="Type")
    name: str = Field(..., description="Non-functional friendly name of the instrument", title="Name")
    capacity: int = Field(
        default=1, description="Number of labwares that can be held by the instrument", title="Capacity"
    )
    is_slotless_container: bool = Field(
        default=False,
        description="Flag indicating the instrument is a bin or similar, in that 'slots' inside it need not be unique",
        title="Is Slotless Container",
    )
    bench: str = Field(..., description="The bench that the instrument is located on", title="Bench")
    driver: str = Field(..., description="Name of the driver that is used to control the instrument", title="Driver")
    mappings: list[str] | None = Field(
        default=None, description="List of all mappings that the instrument belongs to (AND)", title="Mappings"
    )
    config: dict[str, JsonSerializable] | None = Field(
        default=None, description="Configuration for the driver, passed to the grpc server on connect", title="Config"
    )
    simulate: bool = Field(
        default=False,
        description="Flag to simulate the instrument, used mostly for testing workflows",
        title="Simulate",
    )


ParameterValues = TypeAliasType(
    "ParameterValues",
    Annotated[
        StringParameterValueInput
        | IntegerParameterValueInput
        | FloatParameterValueInput
        | BooleanParameterValueInput
        | FileRefParameterValueInput,
        Discriminator("type"),
    ],
)


class WorkflowDeployInput(BaseModel):
    """
    The model for the deploy workflow endpoint input.
    """

    model_config = ConfigDict(frozen=True)
    device_id: str = Field(
        ..., description="The ID of the hub related to the workcell to deploy the workflow to", title="Device Id"
    )
    reason: str = Field(..., description="The reason to deploy workflow", title="Reason")


Hooks = TypeAliasType(
    "Hooks",
    Annotated[
        TaskStateChangeHookInput
        | RunStateChangeHookInput
        | LabwareMovementHookInput
        | SafetyStateChangeHookInput
        | NewPlanHookInput,
        Discriminator("filter"),
    ],
)


class WorkflowPlanResult(BaseModel):
    model_config = ConfigDict(frozen=True)
    plan: dict[str, PlanTaskDetail] = Field(..., title="Plan")
    metrics: Metrics
    locations: dict[str, list[PlannedLabwareLocation]] = Field(..., title="Locations")


class WorkflowPlanStatus(BaseModel):
    model_config = ConfigDict(frozen=True)
    id: UUID = Field(..., description="The ID of the workflow plan", title="Id")
    status: PlanStatus = Field(..., description="The status of the workflow plan task")
    error: str = Field(..., description="The error message if the plan failed", title="Error")
    stage: PlanStage | None = Field(..., description="The stage of the plan while it is pending")


WorkflowType = Literal["sdk", "canvas"]


class WorkflowValidationIssue(BaseModel):
    """
    Details about a workflow validation issue.
    """

    model_config = ConfigDict(frozen=True)
    level: IssueLevel = Field(..., description="The level of the issue.")
    type: str = Field(
        ...,
        description="Type of the issue. Currently an arbitrary string but may become an enum as error handling is improved.",
        title="Type",
    )
    loc: list[int | str] = Field(
        ...,
        description='Location of the issue in the input ([body, field1, field2,...]). A location of "body" indicates a global issue.',
        title="Loc",
    )
    msg: str = Field(..., description="Human-readable message", title="Msg")


class WorkflowValidationResult(BaseModel):
    """
    The result of a workflow validation.
    """

    model_config = ConfigDict(frozen=True)
    is_valid: bool = Field(..., title="Is Valid")
    errors: list[WorkflowValidationIssue] = Field(..., title="Errors")
    warnings: list[WorkflowValidationIssue] = Field(..., title="Warnings")


class CodeTask(BaseModel):
    model_config = ConfigDict(frozen=True)
    id: str = Field(..., description="Unique identifier for the task. Arbitrary string.", title="Id")
    type: Literal["code"] = Field(default="code", title="Type")
    description: str = Field(..., description="Description of the task", title="Description")
    dependencies: list[str] = Field(
        ...,
        description="A list of task ids that must be completed before this task can be started.",
        title="Dependencies",
    )
    mock_behaviour: MockBehaviour = Field(..., description="Overrides for the behaviour of the task on mock drivers")
    function: LuaFunction | PythonReferenceFunction = Field(
        ..., description="The function to be executed by the task", title="Function"
    )
    inputs: dict[str, StaticData | TaskOutputReference | ReferenceData | ParameterReference] = Field(
        ..., description="The inputs to the function", title="Inputs"
    )
    available_failure_actions: AvailableActions = Field(
        ..., description="Available actions for the operator if the task fails."
    )


class CodeTaskInput(BaseModel):
    model_config = ConfigDict(frozen=True)
    id: str = Field(..., description="Unique identifier for the task. Arbitrary string.", title="Id")
    parent_id: str | None = Field(
        default=None,
        description="This field is used internally when batching. The task id of the parent task. If not set, the task is assumed to be a top level task, before its been batched.",
        title="Parent Id",
    )
    description: str = Field(..., description="Description of the task", title="Description")
    dependencies: list[str] | None = Field(
        default=None,
        description="A list of task ids that must be completed before this task can be started.",
        title="Dependencies",
    )
    batch: int | None = Field(default=None, description="The batch ID that the task belongs to.", title="Batch")
    type: Literal["code"] = Field(default="code", title="Type")
    function: LuaFunctionInput | PythonReferenceFunctionInput = Field(
        ..., description="The function to be executed by the task", title="Function"
    )
    inputs: dict[
        str, StaticDataInput | TaskOutputReferenceInput | ReferenceDataInput | ParameterReferenceInput
    ] | None = Field(default=None, description="The inputs to the function", title="Inputs")
    mock_behaviour: MockBehaviourInput | None = Field(
        default=None, description="Overrides for the behaviour of the task on mock drivers"
    )
    available_failure_actions: AvailableActionsInput | None = Field(
        default=None,
        description="Available actions for the operator if the task fails. Leave blank for defaults: [complete_manually=True, retry=True]",
    )


class CommandStatusOutput(BaseModel):
    model_config = ConfigDict(frozen=True)
    result: CommandStatusResult | None = None


class Comparison(BaseModel):
    model_config = ConfigDict(frozen=True)
    lhs: TaskOutputReference | ReferenceData = Field(
        ...,
        description="Left-hand side of the comparison. Note that this side of the comparison always has to reference the output of a task, or a piece of reference data. Static data can only be used on the right-hand side.",
        title="Lhs",
    )
    rhs: StaticData | TaskOutputReference | ReferenceData | ParameterReference = Field(
        ...,
        description="Right-hand side of the comparison. Unlike the left-hand side, this can include static data.",
        title="Rhs",
    )
    operator: Literal["==", "!=", "<", "<=", ">", ">=", "in", "not in"] = Field(
        ..., description="Operator for the comparison.", title="Operator"
    )


class ComparisonInput(BaseModel):
    model_config = ConfigDict(frozen=True)
    lhs: TaskOutputReferenceInput | ReferenceDataInput = Field(
        ...,
        description="Left-hand side of the comparison. Note that this side of the comparison always has to reference the output of a task, or a piece of reference data. Static data can only be used on the right-hand side.",
        title="Lhs",
    )
    rhs: StaticDataInput | TaskOutputReferenceInput | ReferenceDataInput | ParameterReferenceInput = Field(
        ...,
        description="Right-hand side of the comparison. Unlike the left-hand side, this can include static data.",
        title="Rhs",
    )
    operator: Literal["==", "!=", "<", "<=", ">", ">=", "in", "not in"] = Field(
        ..., description="Operator for the comparison.", title="Operator"
    )


class DataConnector(BaseModel):
    model_config = ConfigDict(frozen=True)
    id: str = Field(..., description="Unique identifier for the task. Arbitrary string.", title="Id")
    description: str = Field(..., description="Description of the task", title="Description")
    dependencies: list[str] = Field(
        ...,
        description="A list of task ids that must be completed before this task can be started.",
        title="Dependencies",
    )
    data_connector_type: DataConnectorType = Field(..., description="The type of data connector.")
    action: DataConnectorAction = Field(..., description="The action to perform on the SFTP server.")
    inputs: dict[str, StaticData | TaskOutputReference | ReferenceData | ParameterReference] = Field(
        ..., description="Input arguments that are passed to the instrument driver", title="Inputs"
    )
    batch: int | None = Field(..., description="The batch ID that the task belongs to.", title="Batch")
    mock_behaviour: MockBehaviour = Field(..., description="Overrides for the behaviour of the task on mock drivers")


class DataConnectorInput(BaseModel):
    """
    Data connector input.

     Notes:
     Different drivers require different input arguments e.g. SFTP export:
     - file_path: StaticDataInput|TaskOutputReferenceInput
    - input_task: TaskOutputReferenceInput (TBC)
    """

    model_config = ConfigDict(frozen=True)
    id: str = Field(..., description="Unique identifier for the task. Arbitrary string.", title="Id")
    parent_id: str | None = Field(
        default=None,
        description="This field is used internally when batching. The task id of the parent task. If not set, the task is assumed to be a top level task, before its been batched.",
        title="Parent Id",
    )
    description: str = Field(..., description="Description of the task", title="Description")
    dependencies: list[str] | None = Field(
        default=None,
        description="A list of task ids that must be completed before this task can be started.",
        title="Dependencies",
    )
    batch: int | None = Field(default=None, description="The batch ID that the task belongs to.", title="Batch")
    data_connector_type: DataConnectorType = Field(..., description="The type of data connector.")
    action: DataConnectorAction = Field(..., description="The action to perform on the SFTP server.")
    inputs: dict[
        str, StaticDataInput | TaskOutputReferenceInput | ReferenceDataInput | ParameterReferenceInput
    ] | None = Field(
        default=None, description="Input arguments that are passed to the instrument driver", title="Inputs"
    )
    mock_behaviour: MockBehaviourInput | None = Field(
        default=None, description="Overrides for the behaviour of the task on mock drivers"
    )


class DataOutputInfo(BaseModel):
    model_config = ConfigDict(frozen=True)
    name: str = Field(..., title="Name")
    type: str | None = Field(..., description="The type of the data output, if known", title="Type")
    suffix_with_field: DataOutputSuffixInfo | None = Field(
        ..., description="If set, describes how the value of another field will be used to suffix the data name"
    )


class DriverInstrument(BaseModel):
    """
    Metadata for a driver instrument.
    """

    model_config = ConfigDict(frozen=True)
    has_door: bool | None = Field(..., description="Does the instrument have a door", title="Has Door")
    has_io_bay: bool | None = Field(..., description="Does the instrument have an IO bay", title="Has Io Bay")
    max_capacity: int | None = Field(..., description="Maximum capacity of the instrument", title="Max Capacity")
    is_loadable: bool | None = Field(
        ..., description="Is the instrument loadable, does it have load and unload", title="Is Loadable"
    )
    is_carousel_loadable: bool | None = Field(
        ...,
        description="Is the instrument carousel loadable, does it have load and unload with a carousel",
        title="Is Carousel Loadable",
    )
    is_concurrent: bool | None = Field(
        ..., description="Can the instrument handle multiple tasks at once", title="Is Concurrent", deprecated=True
    )
    deck: InstrumentDeck | None = None
    is_unique: UniqueInstrumentType | None = Field(
        ..., description="Unique instrument type which requires special handling"
    )


class DriverMetadata(BaseModel):
    """
    Metadata for managing/organising driver data.
    """

    model_config = ConfigDict(frozen=True)
    manufacturer: str | None = Field(..., description="Manufacturer of the driver/instrument", title="Manufacturer")
    model: str | None = Field(..., description="Model of the driver/instrument", title="Model")
    instrument: DriverInstrument | None = Field(..., description="Metadata for a driver instrument, if it is one")


class ExecutorOptions(BaseModel):
    model_config = ConfigDict(frozen=True)
    behaviour_on_failure: FailureResponse = Field(
        ..., description="Behaviour of the system when a task fails. Defaults to tearing down"
    )
    behaviour_on_planner_failure: FailureResponse | PlannerFailureResponse = Field(
        ...,
        description="Behaviour of the system when a replan fails. Defaults to continue (ignore the failure and continue with the current plan)",
        title="Behaviour On Planner Failure",
    )
    include_task_description_in_logs: bool = Field(
        ...,
        description="Only available in scheduler engine version 4.266.0 and up. Controls the verbosity of task information in logs. When enabled, logs will include both task ID and description. When disabled, only task ID will be shown.",
        title="Include Task Description In Logs",
    )


class ExecutorOptionsInput(BaseModel):
    model_config = ConfigDict(frozen=True)
    behaviour_on_failure: FailureResponse | None = Field(
        default=None, description="Behaviour of the system when a task fails. Defaults to tearing down"
    )
    behaviour_on_planner_failure: FailureResponse | PlannerFailureResponse | None = Field(
        default=None,
        description="Behaviour of the system when a replan fails. Defaults to continue (ignore the failure and continue with the current plan)",
        title="Behaviour On Planner Failure",
    )
    include_task_description_in_logs: bool = Field(
        default=False,
        description="Only available in scheduler engine version 4.266.0 and up. Controls the verbosity of task information in logs. When enabled, logs will include both task ID and description. When disabled, only task ID will be shown.",
        title="Include Task Description In Logs",
    )


class HTTPValidationError(BaseModel):
    model_config = ConfigDict(frozen=True)
    detail: list[ValidationError] | None = Field(default=None, title="Detail")


class LabwareItem(BaseModel):
    model_config = ConfigDict(frozen=True)
    id: str = Field(..., title="Id")
    type: str = Field(..., description="id of this labware's LabwareType", title="Type")
    description: str | None = Field(..., title="Description")
    location: Location | LocationRange | list[LocationRange | Location] = Field(
        ...,
        description="Initial location of labware item before workflow execution. Use a list of LocationRangeInput or LocationInput to specify multiple locations, for a group of labwares being batched",
        title="Location",
    )
    batch: int | None = Field(
        ..., description="The batch that this labware belongs to. Leave as None for auto-assignment", title="Batch"
    )
    barcode: str | None = Field(default=None, description="Deprecated, do not use", title="Barcode", deprecated=True)
    total_units: conint(ge=1) = Field(
        ...,
        description="The number of consumable 'units' in a single piece of labware. Does not affect the workflow if 'units_consumed' is not defined on any tasks.",
        title="Total Units",
    )
    max_idle_time: int | None = Field(
        default=None,
        description="Maximum time gap allowed between consecutive operations on this specific labware item, in seconds. Overrides the labware type's max_idle_time if set.",
        title="Max Idle Time",
    )


class LabwareItemInput(BaseModel):
    model_config = ConfigDict(frozen=True)
    id: str = Field(..., title="Id")
    parent_id: str | None = Field(
        default=None, description="The id of the parent labware item for batched labware", title="Parent Id"
    )
    type: str = Field(..., description="id of this labware's LabwareType", title="Type")
    description: str | None = Field(default=None, title="Description")
    location: LocationInput | LocationRangeInput | list[LocationRangeInput | LocationInput] = Field(
        ...,
        description="Initial location of labware item before workflow execution. Use a list of LocationRangeInput or LocationInput to specify multiple locations, for a group of labwares being batched",
        title="Location",
    )
    batch: int | None = Field(
        default=None,
        description="The batch that this labware belongs to. Leave as None for auto-assignment",
        title="Batch",
    )
    barcode: str | None = Field(default=None, description="Deprecated, do not use", title="Barcode", deprecated=True)
    total_units: conint(ge=1) = Field(
        default=1,
        description="The number of consumable 'units' in a single piece of labware. Does not affect the workflow if 'units_consumed' is not defined on any tasks.",
        title="Total Units",
    )
    max_idle_time: int | None = Field(
        default=None,
        description="Maximum time gap allowed between consecutive operations on this specific labware item, in seconds. Overrides the labware type's max_idle_time if set.",
        title="Max Idle Time",
    )


class LabwareOutput(BaseModel):
    model_config = ConfigDict(frozen=True)
    type: Literal["labware_output"] = Field(default="labware_output", title="Type")
    labware_id: str = Field(..., title="Labware Id")
    slot: int | OutputSlotFillingRule = Field(
        ...,
        description="The slot that the labware will be in after the task is completed, or the range of slots the labware can be placed in, as defined by the OutputSlotFillingRuleInput.",
        title="Slot",
    )


class Options(BaseModel):
    model_config = ConfigDict(frozen=True)
    planner: PlannerOptions
    executor: ExecutorOptions


class OptionsInput(BaseModel):
    model_config = ConfigDict(frozen=True)
    planner: PlannerOptionsInput | None = None
    executor: ExecutorOptionsInput | None = None
    is_explicit: bool = Field(
        default=False,
        description="Set to true to prevent the API from filling in any implicit logic in the workflow. This disables automatically adding transport instruments and logistics tasks like opening doors.",
        title="Is Explicit",
    )


class OutputSlotFillingRuleInput(BaseModel):
    model_config = ConfigDict(frozen=True)
    behavior: OutputSlotFillingBehavior | None = Field(default=None, description="The slot filling behavior")
    slot_range: SlotRangeInput | None = Field(
        default=None, description="The slot range to use when behavior is USE_RANGE"
    )


ParameterDefinition = TypeAliasType(
    "ParameterDefinition",
    Annotated[
        StringParameterDefinition
        | IntegerParameterDefinition
        | FloatParameterDefinition
        | BooleanParameterDefinition
        | FileRefParameterDefinition,
        Discriminator("type"),
    ],
)
ParameterDefinitionInput = TypeAliasType(
    "ParameterDefinitionInput",
    Annotated[
        StringParameterDefinitionInput
        | IntegerParameterDefinitionInput
        | FloatParameterDefinitionInput
        | BooleanParameterDefinitionInput
        | FileRefParameterDefinitionInput,
        Discriminator("type"),
    ],
)


class PublishBodyParameters(BaseModel):
    model_config = ConfigDict(frozen=True)
    parameter_values: list[ParameterValues] | None = Field(
        default=None, description="User provided parameter inputs", title="Parameter Values"
    )


class ScriptFunctionInfo(BaseModel):
    model_config = ConfigDict(frozen=True)
    function_name: str = Field(..., title="Function Name")
    description: str = Field(..., title="Description")
    arguments: list[ScriptArgumentInfo] = Field(..., title="Arguments")
    returns: list[ScriptReturnInfo] = Field(..., title="Returns")


class SlotFillingRule(BaseModel):
    model_config = ConfigDict(frozen=True)
    range: SlotRange | list[SlotRange] = Field(
        ..., description="The range of slots that the labware can be placed in.", title="Range"
    )
    min_count: int | None = Field(
        ..., description="The minimum number of labware items that must be placed in the slots.", title="Min Count"
    )
    max_count: int | None = Field(
        ..., description="The maximum number of labware items that can be placed in the slots.", title="Max Count"
    )
    distribution: SlotFillingDistribution = Field(..., description="How labware will be distributed in the slots")


class SlotFillingRuleInput(BaseModel):
    model_config = ConfigDict(frozen=True)
    range: SlotRangeInput | list[SlotRangeInput] = Field(
        ..., description="The range of slots that the labware can be placed in.", title="Range"
    )
    min_count: int | None = Field(
        default=None,
        description="The minimum number of labware items that must be placed in the slots.",
        title="Min Count",
    )
    max_count: int | None = Field(
        default=None,
        description="The maximum number of labware items that can be placed in the slots.",
        title="Max Count",
    )
    distribution: SlotFillingDistribution | None = Field(
        default=None, description="How labware will be distributed in the slots"
    )


class TimeConstraint(BaseModel):
    model_config = ConfigDict(frozen=True)
    id: str = Field(..., title="Id")
    type: TimeConstraintType = Field(..., description="Type of time constraint")
    start_task_id: str = Field(
        ..., description="ID of the first task in the sequence that the constraint applies to", title="Start Task Id"
    )
    end_task_id: str = Field(
        ..., description="ID of the last task in the sequence that the constraint applies to", title="End Task Id"
    )
    min_duration: int | None = Field(..., description="Minimum duration allowed for the sequence", title="Min Duration")
    max_duration: int | None = Field(..., description="Maximum duration allowed for the sequence", title="Max Duration")
    enable_detailed_coverage_calculation: bool = Field(
        ...,
        description="Whether to enable detailed coverage calculation, i.e. checking tasks covered by constraint when pausing the workflow",
        title="Enable Detailed Coverage Calculation",
    )


class TimeConstraintInput(BaseModel):
    model_config = ConfigDict(frozen=True)
    id: str = Field(..., title="Id")
    type: TimeConstraintType = Field(..., description="Type of time constraint")
    start_task_id: str = Field(
        ..., description="ID of the first task in the sequence that the constraint applies to", title="Start Task Id"
    )
    end_task_id: str = Field(
        ..., description="ID of the last task in the sequence that the constraint applies to", title="End Task Id"
    )
    min_duration: int | None = Field(
        default=None, description="Minimum duration allowed for the sequence", title="Min Duration"
    )
    max_duration: int | None = Field(
        default=None, description="Maximum duration allowed for the sequence", title="Max Duration"
    )
    enable_detailed_coverage_calculation: bool = Field(
        default=True,
        description="Whether to enable detailed coverage calculation, i.e. checking tasks covered by constraint when pausing the workflow",
        title="Enable Detailed Coverage Calculation",
    )


class TransportMatrix(BaseModel):
    model_config = ConfigDict(frozen=True)
    default: int = Field(..., description="Default time for transport, if no path is specified", title="Default")
    paths: list[TransportPath] = Field(..., description="List of path lengths between BENCHES", title="Paths")


class TransportMatrixInput(BaseModel):
    model_config = ConfigDict(frozen=True)
    default: int = Field(..., description="Default time for transport, if no path is specified", title="Default")
    paths: list[TransportPathInput] | None = Field(
        default=None, description="List of path lengths between BENCHES", title="Paths"
    )


class Workcell(BaseModel):
    model_config = ConfigDict(frozen=True)
    workcell_id: UUID | None = Field(
        ...,
        description="Optional ID of the workcell, used to get an existing stored Transport Config from the cloud.",
        title="Workcell Id",
    )
    instruments: list[WorkcellInstrument] = Field(
        ..., description="List of instruments in the workcell", title="Instruments"
    )
    transport_matrix: TransportMatrix = Field(..., description="Matrix of transport times")


class WorkcellInput(BaseModel):
    model_config = ConfigDict(frozen=True)
    workcell_id: UUID | None = Field(
        default=None,
        description="Optional ID of the workcell, used to get an existing stored Transport Config from the cloud.",
        title="Workcell Id",
    )
    instruments: list[WorkcellInstrumentInput] = Field(
        ..., description="List of instruments in the workcell", title="Instruments"
    )
    transport_matrix: TransportMatrixInput = Field(..., description="Matrix of transport times")


class WorkflowInfo(BaseModel):
    model_config = ConfigDict(frozen=True)
    id: UUID = Field(..., title="Id")
    name: str = Field(..., title="Name")
    author: str = Field(..., title="Author", deprecated=True)
    creator_username: str = Field(..., title="Creator Username")
    version: str = Field(..., title="Version")
    workflow_type: WorkflowType | None = None
    published: bool = Field(..., title="Published", deprecated=True)
    created_at: AwareDatetime = Field(..., title="Created At")
    updated_at: AwareDatetime = Field(..., title="Updated At")
    published_at: AwareDatetime | None = Field(..., title="Published At")
    parameter_definitions: list[ParameterDefinition] = Field(..., title="Parameter Definitions")
    valid_batch_data: ValidBatchData
    synced_plan_id: UUID | None = Field(..., title="Synced Plan Id")


class WorkflowMetadata(BaseModel):
    """
    Metadata for managing/organising workflow data.
    """

    model_config = ConfigDict(frozen=True)
    description: str = Field(..., title="Description")
    author: str = Field(..., title="Author", deprecated=True)
    creator_username: str = Field(..., title="Creator Username")
    workflow_type: WorkflowType | None = None
    version: str | int = Field(
        ...,
        description="Version of the workflow. String versions are deprecated, will become an int in a future release.",
        title="Version",
    )
    created_at: AwareDatetime = Field(..., title="Created At")
    updated_at: AwareDatetime = Field(..., title="Updated At")
    published_at: AwareDatetime | None = Field(..., title="Published At")
    valid_batch_data: ValidBatchData


class WorkflowMetadataInput(BaseModel):
    """
    Metadata for managing/organising workflow data.
    """

    model_config = ConfigDict(frozen=True)
    author: str | None = Field(..., title="Author", deprecated=True)
    description: str = Field(..., title="Description")
    workflow_type: WorkflowType | None = Field(default=None, description="Specifies the source of workflow creation.")
    version: str = Field(
        ...,
        description="Version of the workflow. Deprecated - this will become a read-only field in the future.",
        title="Version",
        deprecated=True,
    )


class LabwareOutputItemInput(BaseModel):
    model_config = ConfigDict(frozen=True)
    type: Literal["labware_output"] = Field(default="labware_output", title="Type")
    labware_id: str = Field(..., title="Labware Id")
    slot: int | OutputSlotFillingRuleInput = Field(
        ...,
        description="The slot that the labware will be in after the task is completed, or the range of slots the labware can be placed in, as defined by the OutputSlotFillingRuleInput.",
        title="Slot",
    )


class LabwareSource(BaseModel):
    model_config = ConfigDict(frozen=True)
    type: Literal["labware_source"] = Field(default="labware_source", title="Type")
    labware_id: str = Field(..., title="Labware Id")
    source_task: str | ConditionalSourceTask | None = Field(
        ...,
        description="ID of the task the labware is being transported from. None for tasks retrieving labware from their initial instrument.",
        title="Source Task",
    )
    destination_slot: int | SlotFillingRule = Field(
        ...,
        description="The slot to transport the labware to, or the rule for filling slots with labware.",
        title="Destination Slot",
    )
    dependencies: list[str] = Field(
        ...,
        description="Additional tasks that have to be completed before the labware for the task is retrieved.",
        title="Dependencies",
    )
    units_consumed: conint(ge=1) | None = Field(
        ...,
        description="The number of units of the labware that are consumed in the task. Tied to the total_units of the labware. Leave blank for no units to be consumed.",
        title="Units Consumed",
    )


class LabwareSourceInput(BaseModel):
    model_config = ConfigDict(frozen=True)
    type: Literal["labware_source"] = Field(default="labware_source", title="Type")
    labware_id: str = Field(..., title="Labware Id")
    destination_slot: int | SlotFillingRuleInput = Field(
        ...,
        description="The slot to transport the labware to, or the rule for filling slots with labware.",
        title="Destination Slot",
    )
    source_task: str | ConditionalSourceTaskInput | None = Field(
        default=None,
        description="ID of the task the labware is being transported from. None for tasks retrieving labware from their initial instrument.",
        title="Source Task",
    )
    dependencies: list[str] | None = Field(
        default=None,
        description="Additional tasks that have to be completed before the labware for the task is retrieved.",
        title="Dependencies",
    )
    units_consumed: conint(ge=1) | None = Field(
        default=None,
        description="The number of units of the labware that are consumed in the task. Tied to the total_units of the labware. Leave blank for no units to be consumed.",
        title="Units Consumed",
    )


class OrgScriptsInfo(BaseModel):
    model_config = ConfigDict(frozen=True)
    org_slug: str = Field(..., title="Org Slug")
    version: str = Field(..., title="Version")
    functions: list[ScriptFunctionInfo] = Field(..., title="Functions")


class ActionTask(BaseModel):
    model_config = ConfigDict(frozen=True)
    id: str = Field(..., description="Unique identifier for the task. Arbitrary string.", title="Id")
    type: Literal["action"] = Field(default="action", title="Type")
    description: str = Field(..., description="Description of the task", title="Description")
    dependencies: list[str] = Field(
        ...,
        description="A list of task ids that must be completed before this task can be started.",
        title="Dependencies",
    )
    skip: bool = Field(
        ...,
        description="Flag to skip this task during planning and execution, used mostly for testing workflows",
        title="Skip",
    )
    mock_behaviour: MockBehaviour = Field(..., description="Overrides for the behaviour of the task on mock drivers")
    available_failure_actions: AvailableActions = Field(
        ..., description="Available actions for the operator if the task fails."
    )
    instrument: TaskInstrument = Field(..., description="The instrument type/mapping to be used for the task.")
    action: str = Field(
        ..., description="The action to be performed by the instrument. Must match the driver API.", title="Action"
    )
    time_estimate: int | ParameterReference = Field(
        ..., description="The estimated time to complete the task in seconds.", title="Time Estimate"
    )
    arguments: TaskArguments | None = Field(
        ..., description="Arguments that are passed to the instrument driver", deprecated=True
    )
    inputs: dict[str, StaticData | TaskOutputReference | ReferenceData | ParameterReference] = Field(
        ..., description="Input arguments that are passed to the instrument driver", title="Inputs"
    )
    labware_sources: dict[str, LabwareSource | StoredLabware] = Field(
        ..., description="The labware sources for the task.", title="Labware Sources"
    )
    labware_outputs: dict[str, LabwareOutput | StoredLabware] = Field(
        ..., description="Labware available for future tasks", title="Labware Outputs"
    )
    batch: int | None = Field(..., description="The batch ID that the task belongs to.", title="Batch")


class ActionTaskInput(BaseModel):
    model_config = ConfigDict(frozen=True)
    id: str = Field(..., description="Unique identifier for the task. Arbitrary string.", title="Id")
    parent_id: str | None = Field(
        default=None,
        description="This field is used internally when batching. The task id of the parent task. If not set, the task is assumed to be a top level task, before its been batched.",
        title="Parent Id",
    )
    description: str = Field(..., description="Description of the task", title="Description")
    dependencies: list[str] | None = Field(
        default=None,
        description="A list of task ids that must be completed before this task can be started.",
        title="Dependencies",
    )
    batch: int | None = Field(default=None, description="The batch ID that the task belongs to.", title="Batch")
    type: Literal["action"] = Field(default="action", title="Type")
    skip: bool = Field(
        default=False,
        description="Flag to skip this task during planning and execution, used mostly for testing workflows",
        title="Skip",
    )
    mock_behaviour: MockBehaviourInput | None = Field(
        default=None, description="Overrides for the behaviour of the task on mock drivers"
    )
    available_failure_actions: AvailableActionsInput | None = Field(
        default=None,
        description="Available actions for the operator if the task fails. Leave blank for defaults: [complete_manually=True, retry=True]",
    )
    instrument: TaskInstrumentInput = Field(..., description="The instrument type/mapping to be used for the task.")
    action: str = Field(
        ..., description="The action to be performed by the instrument. Must match the driver API.", title="Action"
    )
    labware_sources: dict[str, StoredLabwareInput | LabwareSourceInput] = Field(
        ..., description="The labware sources for the task.", title="Labware Sources"
    )
    labware_outputs: dict[str, StoredLabwareInput | LabwareOutputItemInput] = Field(
        ..., description="Labware available for future tasks", title="Labware Outputs"
    )
    time_estimate: int | ParameterReferenceInput = Field(
        ..., description="The estimated time to complete the task in seconds.", title="Time Estimate"
    )
    arguments: TaskArgumentsInput | None = Field(
        default=None, description="Arguments that are passed to the instrument driver", deprecated=True
    )
    inputs: dict[
        str, StaticDataInput | TaskOutputReferenceInput | ReferenceDataInput | ParameterReferenceInput
    ] | None = Field(
        default=None, description="Input arguments that are passed to the instrument driver", title="Inputs"
    )


class Action(BaseModel):
    model_config = ConfigDict(frozen=True)
    is_atomic: bool = Field(
        ...,
        description="Some actions are not directly supported by drivers, but instead are split into multiple actions. Any such combined actions are marked with is_atomic=False. Non-atomic actions can be used the same way as any other action, but planning results will show separate actions, and they cannot be used in workflows using the `is_explicit` option.",
        title="Is Atomic",
    )
    arguments: dict[str, Argument] = Field(..., title="Arguments")
    is_sub_action: bool = Field(..., title="Is Sub Action")
    time_estimate: int | None = Field(
        ..., description="Estimated time to complete the action in seconds", title="Time Estimate"
    )
    data_outputs: dict[str, DataOutputInfo] = Field(
        ..., description="Expected data outputs from the action", title="Data Outputs"
    )


class Argument(BaseModel):
    model_config = ConfigDict(frozen=True)
    type: ArgumentType
    is_required: bool = Field(..., title="Is Required")
    is_deprecated: bool = Field(..., title="Is Deprecated")
    min_value: int | float | None = Field(..., title="Min Value")
    max_value: int | float | None = Field(..., title="Max Value")
    units: Units | None = None
    default: DefaultArgument | Literal["NO_DEFAULT"] = Field(..., title="Default")


ArgumentType = TypeAliasType(
    "ArgumentType",
    Literal["int", "str", "float", "bool", "bytes"]
    | list[Literal["int", "str", "float", "bool", "bytes"]]
    | dict[str, Argument],
)


class Conditional(BaseModel):
    model_config = ConfigDict(frozen=True)
    id: str = Field(..., title="Id")
    type: Literal["conditional"] = Field(default="conditional", title="Type")
    comparison: Comparison | Literal["Else"] = Field(..., title="Comparison")
    is_expected: bool = Field(
        ...,
        description="Exactly one of the conditions in an If/ElseIf/Else block has to be the expected outcome. The planner will pre-plan the workflow only for this outcome.",
        title="Is Expected",
    )
    next: Conditional | None = Field(
        ...,
        description="The next conditional in the block, i.e. ElseIf or Else. For the 'Else', this is always None, for any If or ElseIf statement, it links to the condition coming after it.",
    )
    tasks: dict[str, ActionTask | CodeTask | DataConnector | Conditional | Repeated] = Field(
        ..., description="Tasks (and nested conditionals) that depend on this conditional.", title="Tasks"
    )


class ConditionalInput(BaseModel):
    model_config = ConfigDict(frozen=True)
    tasks: dict[str, ActionTaskInput | CodeTaskInput | DataConnectorInput | ConditionalInput | RepeatedInput] = Field(
        ..., description="Tasks (and nested conditionals) that are contained by this conditional.", title="Tasks"
    )
    id: str = Field(..., title="Id")
    type: Literal["conditional"] = Field(default="conditional", title="Type")
    comparison: ComparisonInput | Literal["Else"] = Field(..., title="Comparison")
    is_expected: bool = Field(
        ...,
        description="Exactly one of the conditions in an If/ElseIf/Else block has to be the expected outcome. The planner will pre-plan the workflow only for this outcome.",
        title="Is Expected",
    )
    next: ConditionalInput | None = Field(
        default=None,
        description="The next conditional in the block, i.e. ElseIf or Else. For the 'Else', this is always None, for any If or ElseIf statement, it links to the condition coming after it.",
    )


class Driver(BaseModel):
    model_config = ConfigDict(frozen=True)
    name: str = Field(..., title="Name")
    version: str = Field(..., title="Version")
    configuration: dict[str, Argument] = Field(..., title="Configuration")
    actions: dict[str, Action] = Field(..., title="Actions")
    protocols: dict[str, DriverProtocol] = Field(..., description="Protocols defined for the driver", title="Protocols")
    metadata: DriverMetadata = Field(..., description="Metadata for the driver/instrument")


class Repeated(BaseModel):
    model_config = ConfigDict(frozen=True)
    id: str = Field(..., title="Id")
    iterations: int = Field(
        ..., description="Number of times to repeat the tasks in the container.", title="Iterations"
    )
    description: str = Field(..., description="Description of the repeated container.", title="Description")
    tasks: dict[str, ActionTask | CodeTask | DataConnector | Conditional | Repeated] = Field(
        ..., description="Tasks that are held in the container and repeated an number of time.", title="Tasks"
    )


class RepeatedInput(BaseModel):
    model_config = ConfigDict(frozen=True)
    tasks: dict[str, ActionTaskInput | CodeTaskInput | DataConnectorInput | ConditionalInput | RepeatedInput] = Field(
        ..., description="Tasks that are held in the container and repeated an number of time.", title="Tasks"
    )
    id: str = Field(..., title="Id")
    iterations: int = Field(
        ..., description="Number of times to repeat the tasks in the container.", title="Iterations"
    )
    description: str = Field(default="", description="Description of the repeated container.", title="Description")


class Workflow(BaseModel):
    model_config = ConfigDict(frozen=True)
    labware_types: list[LabwareType] = Field(..., title="Labware Types")
    labware: list[LabwareItem] = Field(..., title="Labware")
    tasks: dict[str, ActionTask | CodeTask | DataConnector | Conditional | Repeated] = Field(..., title="Tasks")
    time_constraints: list[TimeConstraint] = Field(..., title="Time Constraints")
    layout: Layout
    instrument_blocks: list[InstrumentBlock] = Field(..., title="Instrument Blocks")
    hooks: list[
        TaskStateChangeHook | RunStateChangeHook | LabwareMovementHook | SafetyStateChangeHook | NewPlanHook
    ] = Field(..., title="Hooks")
    batches: int | ParameterReference = Field(..., title="Batches")
    planning_targets: dict[str, list[dict[str, Any]]] | None = Field(..., title="Planning Targets")


class WorkflowConfig(BaseModel):
    model_config = ConfigDict(frozen=True)
    name: str = Field(..., description="Name of the workflow. Arbitrary string.", title="Name")
    metadata: WorkflowMetadata = Field(..., description="Metadata about the workflow configuration")
    workflow: Workflow = Field(..., description="The workflow to execute")
    workcell: Workcell = Field(..., description="Workcell configuration")
    options: Options = Field(..., description="Options for the system")
    run_instructions: list[RunInstruction] = Field(
        ..., description="list of Instructions for running the workflow", title="Run Instructions"
    )
    parameter_definitions: list[ParameterDefinition] = Field(
        ..., description="Definitions of parameters that can be used in the workflow", title="Parameter Definitions"
    )
    scheduler_config: SchedulerConfig
    published: bool = Field(..., description="Whether this workflow is published. ", title="Published")
    drivers_version: str | None = Field(
        default=None, description="Version of the drivers used to create the workflow", title="Drivers Version"
    )
    evals_version: str | None = Field(
        default=None, description="Version of the evals used to create the workflow", title="Evals Version"
    )
    planning_targets: dict[str, list[dict[str, Any]]] | None = Field(
        default=None,
        description="Planning targets for optimization objectives (e.g., consistency groups)",
        title="Planning Targets",
    )


class WorkflowConfigInput(BaseModel):
    model_config = ConfigDict(frozen=True)
    name: str = Field(..., description="Name of the workflow. Arbitrary string.", title="Name")
    metadata: WorkflowMetadataInput = Field(..., description="Metadata about the workflow configuration")
    workflow: WorkflowInput = Field(..., description="The workflow to execute")
    workcell: WorkcellInput = Field(..., description="Workcell configuration")
    options: OptionsInput = Field(..., description="Options for the system")
    run_instructions: list[RunInstructionInput] | None = Field(
        default=None, description="list of Instructions for running the workflow", title="Run Instructions"
    )
    scheduler_config: SchedulerConfigInput
    parameter_definitions: list[ParameterDefinitionInput] | None = Field(
        default=None, description="Definitions for parameters", title="Parameter Definitions"
    )
    drivers_version: str | None = Field(
        default=None, description="Version of the drivers used to create the workflow", title="Drivers Version"
    )
    evals_version: str | None = Field(
        default=None, description="Version of the evals used to create the workflow", title="Evals Version"
    )
    planning_targets: dict[str, list[dict[str, Any]]] | None = Field(
        default=None,
        description="Planning targets for optimization objectives (e.g., consistency groups)",
        title="Planning Targets",
    )


class WorkflowConfigInputWithParameters(BaseModel):
    model_config = ConfigDict(frozen=True)
    name: str = Field(..., description="Name of the workflow. Arbitrary string.", title="Name")
    metadata: WorkflowMetadataInput = Field(..., description="Metadata about the workflow configuration")
    workflow: WorkflowInput = Field(..., description="The workflow to execute")
    workcell: WorkcellInput = Field(..., description="Workcell configuration")
    options: OptionsInput = Field(..., description="Options for the system")
    run_instructions: list[RunInstructionInput] | None = Field(
        default=None, description="list of Instructions for running the workflow", title="Run Instructions"
    )
    scheduler_config: SchedulerConfigInput
    parameter_definitions: list[ParameterDefinitionInput] | None = Field(
        default=None, description="Definitions for parameters", title="Parameter Definitions"
    )
    drivers_version: str | None = Field(
        default=None, description="Version of the drivers used to create the workflow", title="Drivers Version"
    )
    evals_version: str | None = Field(
        default=None, description="Version of the evals used to create the workflow", title="Evals Version"
    )
    planning_targets: dict[str, list[dict[str, Any]]] | None = Field(
        default=None,
        description="Planning targets for optimization objectives (e.g., consistency groups)",
        title="Planning Targets",
    )
    parameter_values: list[ParameterValues] | None = Field(
        default=None, description="User provided parameter inputs", title="Parameter Values"
    )


class WorkflowInput(BaseModel):
    model_config = ConfigDict(frozen=True)
    tasks: dict[str, ActionTaskInput | CodeTaskInput | DataConnectorInput | ConditionalInput | RepeatedInput] = Field(
        ..., title="Tasks"
    )
    labware_types: list[LabwareTypeInput] = Field(..., title="Labware Types")
    labware: list[LabwareItemInput] = Field(..., title="Labware")
    time_constraints: list[TimeConstraintInput] = Field(..., title="Time Constraints")
    instrument_blocks: list[InstrumentBlockInput] | None = Field(default=None, title="Instrument Blocks")
    layout: LayoutInput | None = None
    hooks: list[Hooks] | None = Field(default=None, title="Hooks")
    batches: int | ParameterReferenceInput = Field(
        default=1, description="Number of batches of this workflow to run", title="Batches"
    )
    planning_targets: dict[str, list[dict[str, Any]]] | None = Field(
        default=None,
        description="Planning targets for optimization objectives (e.g., consistency groups)",
        title="Planning Targets",
    )


pass
pass
Action.model_rebuild()
Argument.model_rebuild()
Conditional.model_rebuild()
ConditionalInput.model_rebuild()
WorkflowConfigInput.model_rebuild()
WorkflowConfigInputWithParameters.model_rebuild()
