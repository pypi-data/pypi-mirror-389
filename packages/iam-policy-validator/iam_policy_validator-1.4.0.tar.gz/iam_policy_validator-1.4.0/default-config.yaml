# IAM Policy Validator Configuration
# This file defines which checks to run and their configuration

# ============================================================================
# SEVERITY LEVELS
# ============================================================================
# The validator uses two types of severity levels:
#
# 1. IAM VALIDITY SEVERITIES (for AWS IAM policy correctness):
#    - error:   Policy violates AWS IAM rules (invalid actions, ARNs, etc.)
#    - warning: Policy may have IAM-related issues but is technically valid
#    - info:    Informational messages about the policy structure
#
# 2. SECURITY SEVERITIES (for security best practices):
#    - critical: Critical security risk (e.g., wildcard action + resource)
#    - high:     High security risk (e.g., missing required conditions)
#    - medium:   Medium security risk (e.g., overly permissive wildcards)
#    - low:      Low security risk (e.g., minor best practice violations)
#
# Use 'error' for policy validity issues, and 'critical/high/medium/low' for
# security best practices. This distinction helps separate "broken policies"
# from "insecure but valid policies".
# ============================================================================

# ============================================================================
# GLOBAL SETTINGS
# ============================================================================

settings:
  # Stop validation on first error
  fail_fast: false

  # Maximum number of concurrent policy validations
  max_concurrent: 10

  # Enable/disable ALL built-in checks (default: true)
  # Set to false when using AWS Access Analyzer to avoid redundant validation
  # Individual checks can still be disabled with enabled: false below
  enable_builtin_checks: true

  # Enable parallel execution of checks (default: true)
  parallel_execution: true

  # AWS Service Definitions Source
  # Use pre-downloaded AWS service JSON files instead of calling the AWS API
  # This enables offline validation and avoids API throttling
  #
  # When set to a directory path:
  #   - The validator will load service definitions from JSON files in this directory
  #   - No API calls will be made to AWS Service Reference API
  #   - Useful for offline environments or when you have a local backup
  #
  # Directory should contain:
  #   - _services.json: List of all services (underscore prefix for easy discovery)
  #   - {service}.json: Individual service definition files (e.g., s3.json, ec2.json)
  #
  # You can download these files using: make download-aws-services
  # This will create an aws_services/ directory with all service definitions
  #
  # Examples:
  #   aws_services_dir: ./aws_services      # Use local backup
  #   aws_services_dir: null                # Use AWS API (default)
  aws_services_dir: null

  # Cache AWS service definitions locally (persists between runs)
  # Only used when aws_services_dir is not set (i.e., using AWS API)
  # Cache location: Platform-specific user cache directory by default
  #   - macOS: ~/Library/Caches/iam-validator/aws_services
  #   - Linux: ~/.cache/iam-validator/aws_services
  #   - Windows: %LOCALAPPDATA%/iam-validator/cache/aws_services
  cache_enabled: true
  # Optional: Override default cache directory (use null for platform default)
  # cache_directory: null
  # Cache TTL in hours (default: 168 hours = 7 days)
  # Longer TTL reduces AWS API calls and avoids rate limiting
  cache_ttl_hours: 168

  # Severity levels that cause validation to fail
  # IAM Validity: error, warning, info
  # Security: critical, high, medium, low
  fail_on_severity:
    - error # IAM policy validity errors
    - critical # Critical security issues
    - high # Uncomment to fail on high security issues
    # - warning  # Uncomment to fail on IAM validity warnings

# ============================================================================
# BUILT-IN CHECKS - AWS Validation
# These validate that policies conform to AWS requirements
# Disable all with: settings.enable_builtin_checks: false (useful with Access Analyzer)
# Or disable individually with: enabled: false
# ============================================================================

# Validate Statement ID (Sid) uniqueness as per AWS IAM requirements
sid_uniqueness_check:
  enabled: true
  severity: error
  description: "Validates that Statement IDs (Sids) are unique and follow AWS naming requirements"
  # AWS SID requirements:
  # - Must be unique within the policy (duplicate_sid)
  # - Must contain only alphanumeric characters, hyphens, and underscores (invalid_sid_format)
  # - No spaces or special characters allowed

# Validate policy size against AWS limits
policy_size_check:
  enabled: true
  severity: error
  description: "Validates that IAM policies don't exceed AWS size limits"
  # Policy type determines which AWS limit to enforce
  # Options: managed, inline_user, inline_group, inline_role
  policy_type: "managed"
  # Optional: Override default AWS size limits (in characters, excluding whitespace)
  # Default limits:
  #   managed: 6144
  #   inline_user: 2048
  #   inline_group: 5120
  #   inline_role: 10240
  # size_limits:
  #   managed: 6144
  #   inline_user: 2048
  #   inline_group: 5120
  #   inline_role: 10240

# Validate IAM actions against AWS service definitions
action_validation_check:
  enabled: true
  severity: error
  description: "Validates that actions exist in AWS services"

# Validate condition keys for actions against AWS service definitions
condition_key_validation_check:
  enabled: true
  severity: error # Invalid condition keys are IAM policy errors
  description: "Validates condition keys against AWS service definitions for specified actions"
  # Validate aws:* global condition keys against known list
  validate_aws_global_keys: true

# Validate resource ARN formats
resource_validation_check:
  enabled: true
  severity: error
  description: "Validates ARN format for resources"
  # Regex pattern for ARN validation
  # Pattern allows wildcards (*) in region and account fields
  arn_pattern: "^arn:(aws|aws-cn|aws-us-gov|aws-eusc|aws-iso|aws-iso-b|aws-iso-e|aws-iso-f):[a-z0-9\\-]+:[a-z0-9\\-*]*:[0-9*]*:.+$"

# Validate principals in resource policies
# This check validates Principal elements in resource-based policies (S3 buckets, SNS topics, etc.)
# Only runs when --policy-type RESOURCE_POLICY is specified
principal_validation_check:
  enabled: true
  severity: high # Security issue, not IAM validity error
  description: "Validates Principal elements in resource policies for security best practices"

  # Block dangerous/public principals
  # These principals should never be allowed in your resource policies
  blocked_principals:
    - "*" # Public access to everyone
    # - "arn:aws:iam::*:root"  # All AWS accounts (uncomment to block)

  # Allow only specific principals (optional - leave empty to allow all except blocked)
  # When specified, ONLY these principals are allowed (whitelist mode)
  # Supports patterns with wildcards
  allowed_principals:
    []
    # Examples:
    # - "arn:aws:iam::123456789012:root"  # Specific account
    # - "arn:aws:iam::123456789012:role/*"  # All roles in account
    # - "arn:aws:iam::*:role/OrganizationAccountAccessRole"  # Specific role in any account

  # Require conditions for specific principals
  # These principals must have conditions to limit their access
  require_conditions_for:
    # Principal pattern -> Required condition keys
    "*":
      - "aws:SourceArn" # Public access must be limited by source ARN
      - "aws:SourceAccount" # Public access must be limited by source account
    # "arn:aws:iam::*:root":
    #   - "aws:PrincipalOrgID"  # Cross-account access must be from same org

  # Organization validation (optional)
  # Ensure principals belong to your AWS Organization
  # require_organization_principals: true
  # allowed_organization_ids:
  #   - "o-123456789"

  # Service principals that are always allowed (built-in whitelist)
  # These AWS service principals are commonly used and considered safe
  allowed_service_principals:
    - "cloudfront.amazonaws.com"
    - "s3.amazonaws.com"
    - "sns.amazonaws.com"
    - "lambda.amazonaws.com"
    - "logs.amazonaws.com"
    - "events.amazonaws.com"

# Validate resource constraints for actions
# This check ensures that actions without required resource types (account-level operations)
# use Resource: "*" as they cannot target specific resources
action_resource_constraint_check:
  enabled: true
  severity: error
  description: "Validates that actions without required resource types use Resource: '*'"

# Security best practices checks
# Scans at BOTH statement-level AND policy-level for security anti-patterns
security_best_practices_check:
  enabled: true
  description: "Checks for common security anti-patterns"

  # Allowed wildcard patterns for actions that can be used with Resource: "*"
  #
  # HOW IT WORKS:
  # 1. Patterns in this list (e.g., "ec2:Describe*") are expanded using the AWS API
  #    to get all matching real AWS actions
  # 2. When validating a policy, if ALL actions in a statement are in the expanded list,
  #    Resource: "*" is allowed (no warning is raised)
  # 3. This ensures only validated AWS actions are allowed with wildcard resources
  #
  # EXAMPLE:
  #   Config:  allowed_wildcards: ["ec2:Describe*"]
  #   Expands: "ec2:Describe*" â†’ ["ec2:DescribeInstances", "ec2:DescribeImages", ...]
  #   Policy:  "Action": ["ec2:DescribeInstances", "ec2:DescribeImages"], "Resource": "*"
  #   Result:  âœ… No warning (both actions are in the expanded list)
  #
  # WHY USE EXPANSION:
  # - Validates patterns against actual AWS services (catches typos/invalid patterns)
  # - More precise than regex pattern matching
  # - Ensures you're only allowing real AWS actions
  #
  # DEFAULT LIST:
  # These are common read-only actions considered "safe" for wildcard resources.
  # Customize this list to match your organization's security policies.
  # Note: s3:Get* is intentionally excluded as it can access sensitive data
  allowed_wildcards:
    - autoscaling:Describe*
    - cloudwatch:Describe*
    - cloudwatch:Get*
    - cloudwatch:List*
    - dynamodb:Describe*
    - ec2:Describe*
    - elasticloadbalancing:Describe*
    - iam:Get* # Non-sensitive IAM read actions
    - iam:List* # Non-sensitive IAM read actions
    - kms:Describe*
    - lambda:Get*
    - lambda:List*
    - logs:Describe*
    - logs:Filter*
    - logs:Get*
    - rds:Describe*
    - route53:Get*
    - route53:List*
    - s3:Describe*
    - s3:GetBucket* # Safe read action
    - s3:GetM*
    - s3:List*
    - sqs:Get*
    - sqs:List*
    - apigateway:GET

  # Check for wildcard actions
  wildcard_action_check:
    enabled: true
    severity: medium # Security issue: medium severity
    # Customize validation messages (optional)
    message: "Statement allows all actions (*)"
    suggestion: "Replace wildcard with specific actions needed for your use case"
    example: |
      Replace:
        "Action": ["*"]

      With specific actions:
        "Action": [
          "s3:GetObject",
          "s3:PutObject",
          "s3:ListBucket"
        ]

  # Check for wildcard resources
  wildcard_resource_check:
    enabled: true
    severity: medium # Security issue: medium severity

    # Allow Resource: "*" when statement contains ONLY actions from allowed_wildcards
    # ==================================================================================
    # When configured, Resource: "*" is acceptable if ALL actions in the statement
    # match patterns in the parent allowed_wildcards list (defined above). This is
    # useful for read-only wildcard actions that legitimately require access to all resources.
    #
    # Behavior:
    #   - By default: Inherits from parent security_best_practices_check.allowed_wildcards
    #   - If configured below: Uses this list instead
    #   - Set to [] to disable this feature and always flag Resource: "*"
    #
    # Common use cases where Resource: "*" is required by AWS:
    #   - s3:ListAllMyBuckets (requires * to list all buckets in account)
    #   - iam:ListRoles, iam:ListUsers (account-level operations)
    #   - ec2:Describe* (many describe operations work across all regions)
    #
    # Example: A statement with actions ["s3:List*", "s3:Describe*"] and Resource: "*"
    # will NOT be flagged if those patterns are in the parent allowed_wildcards.
    #
    # To override the parent allowed_wildcards for this check only, uncomment:
    # allowed_wildcards:
    #   - s3:List*
    #   - iam:List*
    #   - ec2:Describe*

    # Customize validation messages (optional)
    message: "Statement applies to all resources (*)"
    suggestion: "Replace wildcard with specific resource ARNs"
    example: |
      Replace:
        "Resource": "*"

      With specific ARNs:
        "Resource": [
          "arn:aws:service:region:account-id:resource-type/resource-id",
          "arn:aws:service:region:account-id:resource-type/*"
        ]

  # Critical check for both wildcards together
  full_wildcard_check:
    enabled: true
    severity: critical # Security issue: critical severity (was error)
    # Customize validation messages (optional)
    message: "Statement allows all actions on all resources - CRITICAL SECURITY RISK"
    suggestion: "This grants full administrative access. Replace both wildcards with specific actions and resources to follow least-privilege principle"
    example: |
      Replace:
        "Action": "*",
        "Resource": "*"

      With specific values:
        "Action": [
          "s3:GetObject",
          "s3:PutObject"
        ],
        "Resource": [
          "arn:aws:s3:::my-bucket/*"
        ]

  # Check for service-level wildcards (e.g., "iam:*", "s3:*", "ec2:*")
  # These grant ALL permissions for a service and are often too permissive
  service_wildcard_check:
    enabled: true
    severity: high # Security issue: high severity

    # Optional: Allow specific services to use wildcards
    # Useful for logging or monitoring services where wildcards are acceptable
    allowed_services:
      - "logs" # Allow "logs:*" for CloudWatch Logs
      - "cloudwatch" # Allow "cloudwatch:*" for CloudWatch metrics
      - "xray" # Uncomment to allow "xray:*" for AWS X-Ray

    # Customize validation messages (optional)
    # Supports template placeholders: {action}, {service}
    # message: "Service-level wildcard '{action}' grants all permissions for {service} service"
    # suggestion: "Replace service-level wildcard with specific actions. Use Get*/List*/Describe* wildcards if needed for read operations"
    # example: |
    #   Replace:
    #     "Action": "{service}:*"
    #
    #   With specific actions:
    #     "Action": [
    #       "{service}:GetObject",
    #       "{service}:ListBucket",
    #       "{service}:DescribeInstances"
    #     ]

  # Check for sensitive actions without conditions
  # NOTE: For specific condition requirements (like iam:PassRole needing iam:PassedToService),
  #       use the action_condition_enforcement built-in check instead (configured below)
  sensitive_action_check:
    enabled: true
    severity: medium # Security issue: medium severity

    # Customize validation messages (optional)
    # Supports template placeholders: {action} (single), {actions} (multiple)
    message_single: "Sensitive action '{action}' should have conditions to limit when it can be used"
    message_multiple: "Sensitive actions '{actions}' should have conditions to limit when they can be used"
    suggestion: "Add IAM conditions to limit when this action can be used. Consider: ABAC (ResourceTag OR RequestTag must match PrincipalTag), IP restrictions (aws:SourceIp), MFA requirements (aws:MultiFactorAuthPresent), or time-based restrictions (aws:CurrentTime)"
    example: |
      "Condition": {
        "StringEquals": {
          "aws:ResourceTag/owner": "${aws:PrincipalTag/owner}"
        }
      }

    # ========================================================================
    # SENSITIVE ACTIONS - Exact action matches with automatic wildcard expansion
    # ========================================================================
    #
    # âš¡ WILDCARD EXPANSION: Actions with wildcards are automatically expanded
    # using the AWS API before checking against this list. This means:
    #
    # - "ec2:*" will be expanded to ALL ec2 actions (including ec2:DeleteVolume, ec2:TerminateInstances)
    # - "iam:Delete*" will expand to all IAM delete actions (iam:DeleteUser, iam:DeleteRole, etc.)
    # - "s3:*Bucket*" will expand to actions like s3:DeleteBucket, s3:PutBucketPolicy, etc.
    #
    # âœ… This ensures sensitive actions are ALWAYS detected, regardless of how they're written:
    #    - Exact: "ec2:DeleteVolume" âœ“
    #    - Service wildcard: "ec2:*" âœ“ (expands to include ec2:DeleteVolume)
    #    - Prefix wildcard: "ec2:Delete*" âœ“ (expands to include ec2:DeleteVolume)
    #    - Complex wildcard: "ec2:*Vol*" âœ“ (expands to include ec2:DeleteVolume)
    #
    # ðŸ“ NO NEED for sensitive_action_patterns in most cases - just list the exact
    #    actions you want to protect, and wildcards will be detected automatically.
    #
    # Supports three formats:
    #
    # 1. Simple list (backward compatible - uses any_of logic):
    #    sensitive_actions:
    #      - "iam:CreateUser"
    #      - "s3:DeleteBucket"
    #
    # 2. any_of: Flag if ANY of these actions appear:
    #    sensitive_actions:
    #      any_of:
    #        - "iam:CreateUser"
    #        - "s3:DeleteBucket"
    #
    # 3. all_of: Flag only if ALL of these actions appear in the same statement:
    #    sensitive_actions:
    #      all_of:
    #        - "iam:CreateUser"
    #        - "iam:AttachUserPolicy"
    #    (Useful for detecting privilege escalation patterns)
    # ========================================================================

    # List of specific actions considered sensitive
    # These will be detected even when granted through wildcards like "iam:*" or "ec2:Delete*"
    sensitive_actions:
      # iam:PassRole commented out - use action_condition_enforcement for specific requirements
      # - "iam:PassRole"

      # IAM & Identity
      - "iam:AddClientIDToOpenIDConnectProvider"
      - "iam:AttachRolePolicy"
      - "iam:AttachUserPolicy"
      - "iam:CreateAccessKey"
      - "iam:CreateOpenIDConnectProvider"
      - "iam:CreatePolicyVersion"
      - "iam:CreateRole"
      - "iam:CreateSAMLProvider"
      - "iam:CreateUser"
      - "iam:DeleteAccessKey"
      - "iam:DeleteLoginProfile"
      - "iam:DeleteOpenIDConnectProvider"
      - "iam:DeleteRole"
      - "iam:DeleteRolePolicy"
      - "iam:DeleteSAMLProvider"
      - "iam:DeleteUser"
      - "iam:DeleteUserPolicy"
      - "iam:DetachRolePolicy"
      - "iam:DetachUserPolicy"
      - "iam:PutRolePolicy"
      - "iam:PutUserPolicy"
      - "iam:SetDefaultPolicyVersion"
      - "iam:UpdateAccessKey"
      - "iam:UpdateAssumeRolePolicy"

      # Secrets & Credentials
      - "kms:DisableKey"
      - "kms:PutKeyPolicy"
      - "kms:ScheduleKeyDeletion"
      - "secretsmanager:DeleteSecret"
      - "secretsmanager:GetSecretValue"
      - "secretsmanager:PutSecretValue"
      - "ssm:DeleteParameter"
      - "ssm:PutParameter"

      # Compute & Containers
      - "ec2:DeleteSnapshot"
      - "ec2:DeleteVolume"
      - "ec2:DeleteVpc"
      - "ec2:ModifyInstanceAttribute"
      - "ec2:TerminateInstances"
      - "ecr:DeleteRepository"
      - "ecs:DeleteCluster"
      - "ecs:DeleteService"
      - "eks:DeleteCluster"
      - "lambda:DeleteFunction"
      - "lambda:DeleteFunctionConcurrency"
      - "lambda:PutFunctionConcurrency"

      # Database & Storage
      - "dynamodb:DeleteTable"
      - "efs:DeleteFileSystem"
      - "elasticache:DeleteCacheCluster"
      - "fsx:DeleteFileSystem"
      - "rds:DeleteDBCluster"
      - "rds:DeleteDBInstance"
      - "redshift:DeleteCluster"

      # S3
      - "backup:DeleteBackupVault"
      - "glacier:DeleteArchive"
      - "s3:DeleteBucket"
      - "s3:DeleteBucketPolicy"
      - "s3:DeleteObject"
      - "s3:PutBucketPolicy"
      - "s3:PutLifecycleConfiguration"

      # Network & Security
      - "ec2:AuthorizeSecurityGroupIngress"
      - "ec2:DeleteSecurityGroup"
      - "ec2:DisassociateRouteTable"
      - "ec2:RevokeSecurityGroupEgress"

      # Access & Logging
      - "cloudtrail:DeleteTrail"
      - "cloudtrail:StopLogging"
      - "cloudwatch:DeleteLogGroup"
      - "config:DeleteConfigurationRecorder"
      - "guardduty:DeleteDetector"

      # Account & Organization
      - "account:CloseAccount"
      - "account:CreateAccount"
      - "organizations:LeaveOrganization"
      - "organizations:RemoveAccountFromOrganization"

    # ========================================================================
    # SENSITIVE ACTION PATTERNS - Regex pattern matches (OPTIONAL)
    # ========================================================================
    #
    # â„¹ï¸  NOTE: With automatic wildcard expansion (see above), sensitive_action_patterns
    #     is OPTIONAL for most use cases. You typically only need sensitive_actions.
    #
    # Use sensitive_action_patterns when you want to:
    # 1. Flag entire categories of actions (e.g., ALL delete actions across services)
    # 2. Match actions based on naming patterns without listing each one
    # 3. Create flexible rules that adapt to new AWS actions automatically
    #
    # Example use cases:
    # - "^.*:Delete.*" - Flag ANY delete action from ANY service
    # - "^.*:.*Admin.*" - Flag actions with "Admin" in the name
    # - "^iam:.*User$" - Flag all IAM actions ending with "User"
    #
    # Supports three formats (same as sensitive_actions):
    #
    # 1. Simple list (backward compatible - uses any_of logic):
    #    sensitive_action_patterns:
    #      - "^iam:Delete.*"
    #      - "^s3:Delete.*"
    #
    # 2. any_of: Flag if actions match ANY pattern:
    #    sensitive_action_patterns:
    #      any_of:
    #        - "^iam:Delete.*"
    #        - "^s3:Delete.*"
    #
    # 3. all_of: Flag if actions match ALL patterns:
    #    sensitive_action_patterns:
    #      all_of:
    #        - "^iam:.*"       # Must be IAM service
    #        - ".*User$"       # Must end with "User"
    #    (Useful for finding specific action types like iam:CreateUser, iam:DeleteUser)
    # ========================================================================

    # Regex patterns for sensitive actions (optional - use only if needed)
    # sensitive_action_patterns:
    # - "^iam:Delete.*" # All IAM delete actions
    # - "^iam:Put.*Policy$" # All IAM policy put actions
    # - ".*:Delete.*"           # Uncomment to flag all delete actions
    # - "^s3:PutBucket.*" # All S3 bucket modification actions
    # - "^kms:(Delete|Disable).*" # KMS delete and disable actions
    # - "^rds:Delete.*" # All RDS delete actions

    # ========================================================================
    # EXAMPLES: Using any_of and all_of
    # ========================================================================
    # Example 1: Detect privilege escalation pattern (all_of)
    # IMPORTANT: all_of checks work at POLICY-LEVEL, detecting actions
    # scattered across MULTIPLE statements in the same policy!
    #
    # sensitive_actions:
    #   all_of:
    #     - "iam:CreateUser"
    #     - "iam:AttachUserPolicy"
    #
    # This will flag a policy if it has BOTH actions anywhere across
    # all its statements, even if they're in separate statements:
    #   Statement 1: "iam:CreateUser"
    #   Statement 2: "iam:AttachUserPolicy"
    #   â†’ DETECTED: Privilege escalation risk!
    #
    # Example 2: Detect any destructive S3 action (any_of with patterns)
    # This checks per-statement (traditional behavior):
    # sensitive_action_patterns:
    #   any_of:
    #     - "^s3:Delete.*"
    #     - "^s3:PutBucket.*"
    #
    # Example 3: Detect IAM actions on user resources (all_of patterns)
    # Flag only IAM actions that specifically target users:
    # sensitive_action_patterns:
    #   all_of:
    #     - "^iam:.*"      # Must be IAM service
    #     - ".*User.*"     # Must involve users
    #
    # ========================================================================
    # ADVANCED: Multiple Groups (Detect different privilege escalation patterns)
    # ========================================================================
    # You can specify MULTIPLE all_of groups to detect DIFFERENT privilege
    # escalation patterns across the ENTIRE POLICY:
    #
    # sensitive_actions:
    #   - all_of:  # Pattern 1: User privilege escalation
    #       - "iam:CreateUser"
    #       - "iam:AttachUserPolicy"
    #   - all_of:  # Pattern 2: Role privilege escalation
    #       - "iam:CreateRole"
    #       - "iam:AttachRolePolicy"
    #   - all_of:  # Pattern 3: Lambda backdoor
    #       - "lambda:CreateFunction"
    #       - "iam:PassRole"
    #
    # Each all_of group is checked independently against ALL statements.
    # If a policy grants all actions in ANY all_of group (even across
    # different statements), it will be flagged.
    #
    # Mixed groups (combine simple actions, any_of, and all_of):
    # sensitive_actions:
    #   - "s3:DeleteBucket"  # Simple action (per-statement, any_of logic)
    #   - all_of:            # Privilege escalation (policy-level detection)
    #       - "iam:CreateUser"
    #       - "iam:AttachUserPolicy"
    #   - any_of:            # Any Lambda code changes (per-statement)
    #       - "lambda:CreateFunction"
    #       - "lambda:UpdateFunctionCode"
    #
    # Pattern groups work the same way:
    # sensitive_action_patterns:
    #   - "^kms:Delete.*"                      # Simple pattern
    #   - all_of: ["^iam:.*", ".*User$"]      # IAM user actions
    #   - all_of: ["^s3:.*", ".*Bucket.*"]    # S3 bucket operations
    # ========================================================================

# ============================================================================
# Action Condition Enforcement
# Enforce ALL types of condition requirements for actions:
# - MFA requirements
# - IP/VPC restrictions
# - Tag requirements (replaces action_tag_enforcement)
# - Time-based access
# - Encryption requirements
# - Any AWS condition key
#
# Supports all_of/any_of/none_of logic for both actions and conditions
# - all_of: ALL specified items must be present
# - any_of: At least ONE specified item must be present
# - none_of: NONE of the specified items should be present (forbidden)
# ============================================================================
action_condition_enforcement_check:
  enabled: true
  severity: high # Default severity: high (can be overridden per-requirement)
  description: "Enforce specific IAM condition requirements (unified: MFA, IP, tags, etc.)"

  # ========================================================================
  # PER-REQUIREMENT SEVERITY OVERRIDES
  # ========================================================================
  # You can set different severity levels for different requirements:
  #
  # Global severity (applies to all requirements unless overridden):
  #   severity: high
  #
  # Per-requirement severity (overrides global):
  #   - actions:
  #       - "iam:PassRole"
  #     severity: critical  # This requirement is critical
  #     required_conditions: [...]
  #
  # Per-condition severity (overrides both global and requirement):
  #   - actions:
  #       - "ec2:RunInstances"
  #     required_conditions:
  #       - condition_key: "aws:RequestTag/Owner"
  #         severity: high  # This specific condition is high
  #
  # Severity precedence: condition > requirement > global
  # ========================================================================

  action_condition_requirements:
    # iam:PassRole MUST specify which services can use the role
    # This is CRITICAL because missing iam:PassedToService enables privilege escalation
    - actions:
        - "iam:PassRole"
      # action_patterns:
      #   - "^iam:Pas?.*$"
      severity: high # Override: this specific requirement is critical
      required_conditions:
        - condition_key: "iam:PassedToService"
          description: "Specify which AWS services are allowed to use the passed role to prevent privilege escalation"
          # enforce specific service list
          # expected_value: ["lambda.amazonaws.com", "ecs-tasks.amazonaws.com"]
          example: |
            "Condition": {
              "StringEquals": {
                "iam:PassedToService": [
                  "lambda.amazonaws.com",
                  "ecs-tasks.amazonaws.com",
                  "ec2.amazonaws.com",
                  "glue.amazonaws.com",
                  "lambda.amazonaws.com"
                ]
              }
            }

    # Sensitive IAM actions require permissions boundary
    # Note: This check uses AWS action fetcher to match wildcards intelligently
    # For example, "iam:P*" will be detected because it grants PutUserPolicy, PutRolePolicy, etc.
    - actions:
        - "iam:CreateRole"
        - "iam:PutRolePolicy*" # Wildcard: any put role policy action
        - "iam:PutUserPolicy"
        - "iam:PutRolePolicy"
        - "iam:Attach*Policy*" # Wildcard: any attach policy action
        - "iam:AttachUserPolicy"
        - "iam:AttachRolePolicy"
      # action_patterns:
      #   - "^iam:Create" # Pattern: matches iam:Create*, iam:Creat*, iam:C*, iam:CreateUser, etc.
      #   - "^iam:Put.*Policy" # Pattern: matches iam:PutUserPolicy, iam:PutRolePolicy, etc.
      #   - "^iam:Attach.*Policy" # Pattern: matches iam:AttachUserPolicy, iam:AttachRolePolicy, etc.
      severity: high # High severity for IAM operations without permissions boundary
      required_conditions:
        - condition_key: "iam:PermissionsBoundary"
          description: "Require permissions boundary for sensitive IAM operations to prevent privilege escalation"
          expected_value: "arn:aws:iam::*:policy/DeveloperBoundary"
          example: |
            # See: https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_boundaries.html
            "Condition": {
              "StringEquals": {
                "iam:PermissionsBoundary": "arn:aws:iam::123456789012:policy/XCompanyBoundaries"
              }
            }

    # S3 write actions should force aws:ResourceOrgId condition
    # Prevents cross-organization writes for data exfiltration (when used with AWS Organizations)
    - actions:
        - "s3:PutObject"
      # - action_patterns:
      #     - "^s3:Put.*$"
      #     - "^s3:Delete.*$"
      #     - "^s3:Create.*$"
      severity: medium # Medium severity for S3 write actions without ResourceOrgId
      required_conditions:
        - condition_key: "aws:ResourceOrgId"
          description: "Require aws:ResourceOrgId condition for S3 write actions to enforce organization-level access control"
          example: |
            "Condition": {
              "StringEquals": {
                "aws:ResourceOrgId": "${aws:PrincipalOrgID}"
              }
            }

    # S3 destructive operations require MFA
    # - actions:
    #     - "s3:DeleteBucket"
    #     - "s3:DeleteBucketPolicy"
    #     - "s3:PutBucketPolicy"
    #   severity: high # High severity for S3 destructive operations without MFA
    #   required_conditions:
    #     - condition_key: aws:MultiFactorAuthPresent
    #       description: "Require MFA for S3 destructive operations"
    #       expected_value: "true"

    # All S3 operations must use HTTPS (optional - uncomment if needed)
    # - action_patterns:
    #     - "^s3:.*"
    #   required_conditions:
    #     - condition_key: "aws:SecureTransport"
    #       description: "Require HTTPS for all S3 operations"
    #       expected_value: true

    # EC2 instances must be in specific VPCs (optional - uncomment and customize)
    # - actions:
    #     - "ec2:RunInstances"
    #   required_conditions:
    #     - condition_key: "ec2:Vpc"
    #       description: "EC2 instances must be launched in approved VPCs"
    #       example: |
    #         "Condition": {
    #           "StringEquals": {
    #             "ec2:Vpc": "arn:aws:ec2:us-east-1:123456789012:vpc/vpc-12345678"
    #           }
    #         }

    # Require source IP restrictions
    - action_patterns:
        - "^ssm:StartSession$"
        - "^ssm:Run.*$"
        - "^s3:GetObject$"
        - "^rds-db:Connect$"
      severity: low # Low severity for missing IP restrictions
      required_conditions:
        - condition_key: "aws:SourceIp"
          description: "Restrict access to corporate IP ranges"
          example: |
            "Condition": {
              "IpAddress": {
                "aws:SourceIp": [
                  "10.0.0.0/8",
                  "172.16.0.0/12"
                ]
              }
            }

    # ============================================================================
    # TAG ENFORCEMENT EXAMPLES
    # Use action_condition_enforcement for tag requirements too!
    # ============================================================================

    # EC2 instances must have owner tag matching principal's owner tag
    # - actions:
    #     - "ec2:RunInstances"
    #   required_conditions:
    #     all_of:
    #       - condition_key: "aws:RequestTag/env"
    #         operator: "StringEquals"
    #         expected_value: ["prod", "pre", "dev", "sandbox"]
    #         description: "Must specify a valid Environment tag"
    #     any_of:
    #       - condition_key: "aws:ResourceTag/owner"
    #         operator: "StringEquals"
    #         expected_value: "${aws:PrincipalTag/owner}" # normal policy variable
    #         description: "Resource owner must match the principal's owner tag"
    #       - condition_key: "aws:RequestTag/owner"
    #         description: "Must specify resource owner"
    #         expected_value: "$$${aws:PrincipalTag/owner}" # terragrunt template
    #       - condition_key: "aws:RequestTag/owner"
    #         description: "Must specify resource owner"
    #         expected_value: "$${aws:PrincipalTag/owner}" # terraform template

    # RDS databases need required tags
    # - action_patterns:
    #     - "^rds:Create.*"
    #     - "^rds:Modify.*"
    #   required_conditions:
    #     all_of:
    #       - condition_key: "aws:RequestTag/DataClassification"
    #         description: "Must specify data classification"
    #       - condition_key: "aws:RequestTag/BackupPolicy"
    #         description: "Must specify backup policy"
    #       - condition_key: "aws:RequestTag/Owner"
    #         description: "Must specify resource owner"

    # S3 bucket operations with data classification matching
    # - actions:
    #     - "s3:CreateBucket"
    #     - "s3:PutObject"
    #   required_conditions:
    #     all_of:
    #       - condition_key: "aws:ResourceTag/DataClassification"
    #         operator: "StringEquals"
    #         expected_value: "${aws:PrincipalTag/DataClassification}"
    #         description: "Data classification must match principal's tag"
    #       - condition_key: "aws:RequestTag/Owner"
    #         description: "Must specify owner"
    #       - condition_key: "aws:RequestTag/CostCenter"
    #         description: "Must specify cost center"

    # ============================================================================
    # NONE_OF EXAMPLES - Forbidden Actions and Conditions
    # ============================================================================

    # Example 1: Forbidden actions - flag if these dangerous actions appear
    # - actions:
    #     none_of:
    #       - "iam:*"
    #       - "s3:DeleteBucket"
    #       - "s3:DeleteBucketPolicy"
    #   description: "These highly sensitive actions are forbidden in this policy"

    # Example 2: Ensure insecure transport is never explicitly allowed
    - actions:
        - "s3:GetObject"
        - "s3:PutObject"
      required_conditions:
        none_of:
          - condition_key: "aws:SecureTransport"
            expected_value: false
            description: "Never allow insecure transport to be explicitly permitted"
            example: |
              # Set this condition to true to enforce secure transport or remove it entirely
              "Condition": {
                "Bool": {
                  "aws:SecureTransport": "true"
                }
              }

    # Example 3: Prevent overly permissive IP ranges
    # - action_patterns:
    #     - "^s3:.*"
    #   required_conditions:
    #     none_of:
    #       - condition_key: "aws:SourceIp"
    #         expected_value: "0.0.0.0/0"
    #         description: "Do not allow access from any IP address"

# ============================================================================
# CUSTOM CHECKS - Business Rules
# These enforce your organization's specific requirements
# Configured via custom_checks_dir and the checks section below
# ============================================================================

# Custom checks directory - auto-discover PolicyCheck subclasses
# custom_checks_dir: "./custom_checks"

# Configure custom checks loaded from custom_checks_dir
# The check_id corresponds to the check's check_id property
# Note: action_condition_enforcement and action_tag_enforcement are now built-in checks
# For examples of custom business-specific checks, see: examples/custom-business-rules.yaml

# ============================================================================
# USAGE SCENARIOS
# ============================================================================

# Scenario 1: Default - Full built-in validation
#   iam-validator validate --path ./policies

# Scenario 2: With AWS Access Analyzer (disable built-in AWS validation)
#   Set: enable_builtin_checks: true
#   Then run:
#     iam-validator analyze --path ./policies --post-findings
#     iam-validator validate --path ./policies  # Only custom checks run

# Scenario 3: Disable specific built-in check
#   sid_uniqueness_check:
#     enabled: false  # Disable just this one check

# Scenario 4: Enable custom business rules
#   See: examples/custom-business-rules.yaml
