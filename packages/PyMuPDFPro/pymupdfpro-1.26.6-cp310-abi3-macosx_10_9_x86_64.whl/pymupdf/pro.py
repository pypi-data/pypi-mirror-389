# This file was automatically generated by SWIG (https://www.swig.org).
# Version 4.3.1
#
# Do not make changes to this file unless you know what you are doing - modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _pro
else:
    import _pro

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "this":
            set(self, name, value)
        elif name == "thisown":
            self.this.own(value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


class SwigPyIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pro.delete_SwigPyIterator

    def value(self):
        return _pro.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _pro.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _pro.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _pro.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _pro.SwigPyIterator_equal(self, x)

    def copy(self):
        return _pro.SwigPyIterator_copy(self)

    def next(self):
        return _pro.SwigPyIterator_next(self)

    def __next__(self):
        return _pro.SwigPyIterator___next__(self)

    def previous(self):
        return _pro.SwigPyIterator_previous(self)

    def advance(self, n):
        return _pro.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _pro.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _pro.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _pro.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _pro.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _pro.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _pro.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self

# Register SwigPyIterator in _pro:
_pro.SwigPyIterator_swigregister(SwigPyIterator)
class vectors(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _pro.vectors_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _pro.vectors___nonzero__(self)

    def __bool__(self):
        return _pro.vectors___bool__(self)

    def __len__(self):
        return _pro.vectors___len__(self)

    def __getslice__(self, i, j):
        return _pro.vectors___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _pro.vectors___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _pro.vectors___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _pro.vectors___delitem__(self, *args)

    def __getitem__(self, *args):
        return _pro.vectors___getitem__(self, *args)

    def __setitem__(self, *args):
        return _pro.vectors___setitem__(self, *args)

    def pop(self):
        return _pro.vectors_pop(self)

    def append(self, x):
        return _pro.vectors_append(self, x)

    def empty(self):
        return _pro.vectors_empty(self)

    def size(self):
        return _pro.vectors_size(self)

    def swap(self, v):
        return _pro.vectors_swap(self, v)

    def begin(self):
        return _pro.vectors_begin(self)

    def end(self):
        return _pro.vectors_end(self)

    def rbegin(self):
        return _pro.vectors_rbegin(self)

    def rend(self):
        return _pro.vectors_rend(self)

    def clear(self):
        return _pro.vectors_clear(self)

    def get_allocator(self):
        return _pro.vectors_get_allocator(self)

    def pop_back(self):
        return _pro.vectors_pop_back(self)

    def erase(self, *args):
        return _pro.vectors_erase(self, *args)

    def __init__(self, *args):
        _pro.vectors_swiginit(self, _pro.new_vectors(*args))

    def push_back(self, x):
        return _pro.vectors_push_back(self, x)

    def front(self):
        return _pro.vectors_front(self)

    def back(self):
        return _pro.vectors_back(self)

    def assign(self, n, x):
        return _pro.vectors_assign(self, n, x)

    def resize(self, *args):
        return _pro.vectors_resize(self, *args)

    def insert(self, *args):
        return _pro.vectors_insert(self, *args)

    def reserve(self, n):
        return _pro.vectors_reserve(self, n)

    def capacity(self):
        return _pro.vectors_capacity(self)
    __swig_destroy__ = _pro.delete_vectors

# Register vectors in _pro:
_pro.vectors_swigregister(vectors)

import inspect
import json
import os
import platform
import pymupdf
import queue
import requests
import subprocess
import sys
import threading
import time

from . import _pro_build
assert pymupdf.mupdf_version_tuple == _pro_build.mupdf_version_tuple, f'PyMuPDFPro cannot run because built with mupdf-{_pro_build.mupdf_version}, but pymupdf has mupdf-{pymupdf.mupdf_version}.'

KEYFLAG_VOLUME_LICENSE = 1
KEYFLAG_DISABLE_SO = 2

def unlock(keystring=None, *, fontpath=None, fontpath_auto=None):
    '''
    keystring:
        The key to use or None.
    '''
    if fontpath is None:
        fontpath = os.environ.get('PYMUPDFPRO_FONT_PATH')
    if fontpath is None:
        pass
    elif not isinstance(fontpath, str):
# Convert sequence to string, as expected by internal_unlock().
        fontpath = os.pathsep.join(fontpath)
    if fontpath_auto is None:
        fontpath_auto = os.environ.get('PYMUPDFPRO_FONT_PATH_AUTO', '1') == '1'
    flags = internal_unlock(keystring, fontpath, fontpath_auto)

    activity_verbose = os.environ.get('PYMUPDFPRO_ACTIVITY_VERBOSE') == '1'
    if flags & KEYFLAG_VOLUME_LICENSE:
        if pymupdf.mupdf_version_tuple < (1, 26):
            assert 0, f'Key specifies KEYFLAG_VOLUME_LICENSE but MuPDF is too old, {pymupdf.mupdf_version=}.'
        else:
            if activity_verbose:
                print(f'PyMuPDFPro: Starting activity monitoring.', flush=1)
            _activity_setup(keystring)
    else:
        if activity_verbose:
            print(f'PyMuPDFPro: Not starting activity monitoring.', flush=1)

# Activity monitor using separate process.
#

_activity_child = None
_activity_write = None

def _activity_setup(keystring):
# We create a pipe and a new process that reads from the pipe.
    global _activity_child
    global _activity_write

    if not _activity_child:
        r, _activity_write = os.pipe()

# os.fork not safe from multi-threaded parent, so we run a new
# Python process using `subprocess.Popen()`. We need it to inherit
# file descriptor <r>, and the simplest way to do this seems to be
# to set stdin=r, because only fds 0, 1 and 2 can be inherited on
# Windows.
#
        creationflags = 0
        command = f'import pymupdf.pro;'

# Ensure that Ctrl-C doesn't kill new process.
        if platform.system() == 'Windows':
            creationflags=subprocess.CREATE_NEW_PROCESS_GROUP
        else:
            command += f' import os; os.setpgrp();'
        command += f' pymupdf.pro._activity_monitor(0, "{keystring}")'

        _activity_child = subprocess.Popen(
                [sys.executable, '-c', command],
                stdin=r,
                creationflags=creationflags,
                )

# We don't need <r> in parent process.
        os.close(r)

# Set MuPDF activity callback to an internal C++ function that
# writes to the pipe.
    e = internal_setup_activity(_activity_write)
    assert not e, f'Failed to set up activity monitoring.'

def _activity_monitor(r, keystring):
# We repeatedly read items from pipe <r> until EOF, pushing each item
# onto a queue as we go. We read from this queue in a separate thread
# which sends information to remote server as required. The queue
# functions as a buffer that ensures that we don't let the pipe fill
# up, which would block the main PyMuPDFPro process. It also avoids the
# need to use select/poll on <r>, which is not supported by Windows.
#
    q = queue.Queue()
    queue_thread = threading.Thread(
            target=_activity_queuefn,
            args=(q, keystring),
            daemon=0,
            )
    queue_thread.start()
    while 1:
        end = False
        try:
            item_bytes = os.read(r, 4)
        except Exception as e:
            end = True
        else:
            if item_bytes:
                assert len(item_bytes) == 4
                item = int.from_bytes(item_bytes, sys.byteorder)
            else:
                end = True
        if end:
            break
        else:
            q.put(item)
    q.put(None)
    queue_thread.join()

def _activity_queuefn(q, keystring):
# Output extra diagnostics for scripts/test.py.
    verbose = os.environ.get('PYMUPDFPRO_ACTIVITY_VERBOSE') == '1'
    items = list()
    t0 = time.time()    # Last time we sent to server.
    while 1:
        end = 0
        endtime = t0 + 10
# Read items until <endtime>.
        while 1:
            timeout = max(0, endtime - time.time())
            try:
               i = q.get(timeout)
            except queue.Empty: # Timeout.
                break
            else:
                if i is None:
                    end = 'EOF'
                    break
                else:
                    items.append(i)
        if items:
            if verbose:
                print(f'Activity flush to server: {end=}.')
                for item in items:
                    print(f'Activity to server: {item=}.', flush=1)
            t0 = time.time()
            _activity_send(keystring, items, end)
        if end:
# EOF
            break


def _activity_send(keystring, items, end, verbose=None):
# Send data to remote server via https.
#
# Args:
#   keystring:
#       24-character string representation of the key.
#   items:
#       List of integer fz_activity_reason codes, typically always
#       FZ_ACTIVITY_NEW_DOC = 0.
#   end:
#       If true we are being called on termination of the PyMuPDFPro
#       process. In this case we repeatedly contact the server until we
#       succeed.
#
# Does `del items[:]` on success.
#
    if verbose is None:
        verbose = os.environ.get('PYMUPDFPRO_ACTIVITY_VERBOSE') == '1'
    url = "https://lp2piszqpd.execute-api.us-east-1.amazonaws.com/usage"

    data = {
        "key_code": keystring,
        "document_count": len(items),
    }
    data_str = json.dumps(data)

    headers = {
        "Content-Type": "application/json"
    }
    if verbose:
        print(f'Sending: {headers=} {data_str=}.', flush=1)

# If end is true we repeatedly try to contact server until we succeed.
# Otherwise we try only once and return with <items> unchanged if there
# was an error.
    while 1:
        try:
            response = requests.post(url, headers=headers, data=data_str)
            response.raise_for_status()
        except Exception as e:
            if verbose:
                print(f'Failed to send to {url=}: {e}', flush=1)
            _log(f'Failed to send to {url=}: {e}')
            if end:
                if verbose:
                    print(f'{end=}: retrying...')
                time.sleep(1)
                continue
        else:
            if verbose:
                print(f'Sent to {url=}: {data_str=}', flush=1)
            del(items[:])
        break

def _log(text, caller=1):
# We deliberately write to stderr so that we don't interfere with tests
# that check stdout is as expected.
    if 0:
# Don't write detailed detailed diagnostics to stderr.
        return
    fr = inspect.stack(context=0)[caller]
    try:
        filename = os.path.relpath(fr.filename)
    except Exception:   # Can fail on Windows.
        filename = fr.filename
    tid = threading.get_native_id()
    for line in text.split('\n'):
        print(f'[{tid}] {filename}:{fr.lineno}:{fr.function}(): {line}', file=sys.stderr, flush=1)


def internal_unlock(keystring, fontpath, fontpath_auto):
    return _pro.internal_unlock(keystring, fontpath, fontpath_auto)

def get_fontpath():
    return _pro.get_fontpath()

def internal_setup_activity(parent_fd):
    return _pro.internal_setup_activity(parent_fd)

