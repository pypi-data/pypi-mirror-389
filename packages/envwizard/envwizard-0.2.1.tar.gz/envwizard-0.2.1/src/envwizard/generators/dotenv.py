"""Generate .env files with smart defaults."""

import os
from pathlib import Path
from typing import List, Optional, Tuple
from envwizard.detectors.framework import FrameworkDetector


class DotEnvGenerator:
    """Generate .env and .env.example files."""

    def __init__(self, project_path: Optional[Path] = None) -> None:
        """Initialize dotenv generator."""
        self.project_path = project_path or Path.cwd()

    def _validate_output_filename(self, filename: str) -> bool:
        """
        Validate output filename to prevent path traversal.

        Args:
            filename: The filename to validate

        Returns:
            True if filename is safe, False otherwise
        """
        # Reject if filename contains path separators
        if os.sep in filename or (os.altsep and os.altsep in filename):
            return False

        # Reject if filename contains parent directory references
        if ".." in filename:
            return False

        # Reject absolute paths
        if os.path.isabs(filename):
            return False

        # Reject if filename contains null bytes
        if "\x00" in filename:
            return False

        return True

    def generate_dotenv(
        self,
        frameworks: List[str],
        output_file: str = ".env",
        create_example: bool = True,
    ) -> Tuple[bool, str]:
        """
        Generate .env file based on detected frameworks.

        Args:
            frameworks: List of detected frameworks
            output_file: Output filename (default: .env)
            create_example: Also create .env.example file

        Returns:
            Tuple of (success, message)
        """
        # Validate output_file to prevent path traversal (SEC-005)
        if not self._validate_output_filename(output_file):
            return False, f"Invalid output filename: {output_file}. Must be a simple filename without path separators."

        env_path = self.project_path / output_file
        example_path = self.project_path / ".env.example"

        # Verify the resolved path is within project directory
        try:
            env_path.resolve().relative_to(self.project_path.resolve())
        except ValueError:
            return False, f"Output file path escapes project directory: {output_file}"

        # Check if .env already exists
        if env_path.exists():
            return False, f"{output_file} already exists. Not overwriting."

        # Get environment variables for detected frameworks
        env_vars = FrameworkDetector.get_all_env_vars(frameworks)

        # Check for database
        db_type = FrameworkDetector.detect_database(self.project_path)
        if db_type:
            env_vars.extend(FrameworkDetector.get_database_env_vars(db_type))

        # Generate .env content
        env_content = self._generate_env_content(env_vars, frameworks, db_type)

        try:
            # Write .env file with secure permissions (SEC-011)
            env_path.write_text(env_content)
            # Set permissions to 0600 (owner read/write only) on Unix-like systems
            try:
                env_path.chmod(0o600)
            except (OSError, NotImplementedError):
                # Windows or systems that don't support chmod
                pass

            message = f"Created {output_file}"

            # Write .env.example file (can have normal permissions since it has no secrets)
            if create_example:
                example_content = self._generate_example_content(env_vars, frameworks, db_type)
                example_path.write_text(example_content)
                message += " and .env.example"

            return True, message

        except Exception as e:
            return False, f"Failed to create .env file: {str(e)}"

    def _generate_env_content(
        self,
        env_vars: List[Tuple[str, str]],
        frameworks: List[str],
        db_type: Optional[str],
    ) -> str:
        """Generate content for .env file."""
        lines = []

        # Header
        lines.append("# Environment Configuration")
        lines.append("# Auto-generated by envwizard")
        lines.append("#")
        lines.append("# IMPORTANT: This file contains sensitive information.")
        lines.append("# Do not commit this file to version control!")
        lines.append("")

        # Detected frameworks section
        if frameworks:
            lines.append("# Detected frameworks:")
            for framework in frameworks:
                config = FrameworkDetector.get_framework_config(framework)
                if config:
                    lines.append(f"#   - {framework}: {config['description']}")
            lines.append("")

        # Database section
        if db_type:
            lines.append(f"# Database: {db_type}")
            lines.append("")

        # Add environment variables
        current_section = None
        for var, value in env_vars:
            # Add section headers based on variable prefixes
            section = self._get_section_name(var)
            if section != current_section:
                if current_section is not None:
                    lines.append("")
                lines.append(f"# {section}")
                current_section = section

            lines.append(f"{var}={value}")

        # Footer
        lines.append("")
        lines.append("# Add your custom environment variables below")
        lines.append("")

        return "\n".join(lines)

    def _generate_example_content(
        self,
        env_vars: List[Tuple[str, str]],
        frameworks: List[str],
        db_type: Optional[str],
    ) -> str:
        """Generate content for .env.example file."""
        lines = []

        # Header
        lines.append("# Environment Configuration Template")
        lines.append("# Copy this file to .env and fill in your values")
        lines.append("")

        # Detected frameworks section
        if frameworks:
            lines.append("# Detected frameworks:")
            for framework in frameworks:
                config = FrameworkDetector.get_framework_config(framework)
                if config:
                    lines.append(f"#   - {framework}: {config['description']}")
            lines.append("")

        # Database section
        if db_type:
            lines.append(f"# Database: {db_type}")
            lines.append("")

        # Add environment variables with placeholder values
        current_section = None
        for var, value in env_vars:
            # Add section headers
            section = self._get_section_name(var)
            if section != current_section:
                if current_section is not None:
                    lines.append("")
                lines.append(f"# {section}")
                current_section = section

            # Use placeholder for sensitive values
            if self._is_sensitive(var):
                lines.append(f"{var}=<your-{var.lower().replace('_', '-')}>")
            else:
                lines.append(f"{var}={value}")

        # Footer
        lines.append("")
        lines.append("# Add your custom environment variables below")
        lines.append("")

        return "\n".join(lines)

    def _get_section_name(self, var: str) -> str:
        """Determine section name for a variable."""
        var_lower = var.lower()

        if any(
            db in var_lower
            for db in ["postgres", "mysql", "mongo", "redis", "database", "db"]
        ):
            return "Database Configuration"
        elif any(word in var_lower for word in ["secret", "key", "token", "password"]):
            return "Security & Authentication"
        elif any(word in var_lower for word in ["celery", "redis", "broker", "queue"]):
            return "Task Queue Configuration"
        elif any(word in var_lower for word in ["debug", "env", "log"]):
            return "Application Settings"
        elif any(word in var_lower for word in ["api", "host", "port", "url"]):
            return "API & Network Configuration"
        else:
            return "General Configuration"

    def _is_sensitive(self, var: str) -> bool:
        """Check if a variable contains sensitive information."""
        sensitive_keywords = [
            "secret",
            "key",
            "password",
            "token",
            "auth",
            "credential",
            "private",
        ]
        var_lower = var.lower()
        return any(keyword in var_lower for keyword in sensitive_keywords)

    def add_to_gitignore(self) -> Tuple[bool, str]:
        """Add .env to .gitignore if not already present."""
        gitignore_path = self.project_path / ".gitignore"

        try:
            if gitignore_path.exists():
                content = gitignore_path.read_text()
                if ".env" in content:
                    return True, ".env already in .gitignore"

                # Add .env to gitignore
                with open(gitignore_path, "a") as f:
                    f.write("\n# Environment variables\n")
                    f.write(".env\n")
                    f.write(".env.local\n")
                return True, "Added .env to .gitignore"
            else:
                # Create new .gitignore
                content = "# Environment variables\n.env\n.env.local\n"
                gitignore_path.write_text(content)
                return True, "Created .gitignore with .env entry"

        except Exception as e:
            return False, f"Failed to update .gitignore: {str(e)}"

    def validate_env_file(self, env_file: str = ".env") -> Tuple[bool, List[str]]:
        """Validate .env file and return any issues found."""
        env_path = self.project_path / env_file
        issues = []

        if not env_path.exists():
            return False, [f"{env_file} does not exist"]

        try:
            content = env_path.read_text()
            lines = content.splitlines()

            for i, line in enumerate(lines, 1):
                line = line.strip()
                if not line or line.startswith("#"):
                    continue

                if "=" not in line:
                    issues.append(f"Line {i}: Missing '=' in variable assignment")
                    continue

                var, value = line.split("=", 1)
                var = var.strip()
                value = value.strip()

                # Check for empty values in required fields
                if not value:
                    issues.append(f"Line {i}: Variable '{var}' has no value")

                # Check for placeholder values
                if value.startswith("<") and value.endswith(">"):
                    issues.append(f"Line {i}: Variable '{var}' still has placeholder value")

                # Check for common mistakes
                if " " in var:
                    issues.append(f"Line {i}: Variable name '{var}' contains spaces")

            return len(issues) == 0, issues

        except Exception as e:
            return False, [f"Failed to read {env_file}: {str(e)}"]
