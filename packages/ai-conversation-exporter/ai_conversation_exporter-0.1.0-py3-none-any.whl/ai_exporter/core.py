import os
import re
from datetime import datetime
from typing import List, Dict, Any

# ä¿®å¤å¯¼å…¥ - ä½¿ç”¨ç›¸å¯¹å¯¼å…¥
from .parsers import (
    ChatGPTParser, DeepSeekParser, ClaudeParser, UniversalParser
)

class AIExporter:
    """å¤šå¹³å°AIå¯¹è¯å¯¼å‡ºå™¨"""
    
    def __init__(self):
        self.parsers = [
            ChatGPTParser(),
            DeepSeekParser(), 
            ClaudeParser(),
            UniversalParser()  # é€šç”¨è§£æå™¨æ”¾åœ¨æœ€å
        ]
    
    def detect_platform(self, file_path: str):
        """æ£€æµ‹æ–‡ä»¶æ ¼å¼å¹¶è¿”å›åˆé€‚çš„è§£æå™¨"""
        if not os.path.exists(file_path):
            raise FileNotFoundError(f"æ–‡ä»¶ä¸å­˜åœ¨: {file_path}")
        
        for parser in self.parsers:
            if parser.can_parse(file_path):
                print(f"âœ… æ£€æµ‹åˆ° {parser.get_platform_name()} æ ¼å¼")
                return parser
        
        print("âš ï¸  æ— æ³•è¯†åˆ«æ ¼å¼ï¼Œä½¿ç”¨é€šç”¨è§£æå™¨")
        return self.parsers[-1]
    
    def convert(self, input_path: str, output_dir: str = "./ai_output"):
        """è½¬æ¢å…¥å£å‡½æ•°"""
        os.makedirs(output_dir, exist_ok=True)
        
        # æ£€æµ‹æ–‡ä»¶æ ¼å¼
        parser = self.detect_platform(input_path)
        
        # è§£æå¯¹è¯
        print("ğŸ“– æ­£åœ¨è§£æå¯¹è¯...")
        conversations = parser.parse(input_path)
        
        if not conversations:
            print("âŒ æœªæ‰¾åˆ°å¯è½¬æ¢çš„å¯¹è¯æ•°æ®")
            return
        
        print(f"ğŸ“ æ‰¾åˆ° {len(conversations)} ä¸ªå¯¹è¯")
        
        # è½¬æ¢æ¯ä¸ªå¯¹è¯
        successful = 0
        for i, conversation in enumerate(conversations, 1):
            try:
                print(f"ğŸ”„ æ­£åœ¨è½¬æ¢ç¬¬ {i}/{len(conversations)} ä¸ªå¯¹è¯...")
                self._convert_single(conversation, output_dir, parser.get_platform_name())
                successful += 1
            except Exception as e:
                print(f"âŒ è½¬æ¢å¯¹è¯æ—¶å‡ºé”™: {e}")
                continue
        
        print(f"âœ… æˆåŠŸè½¬æ¢ {successful}/{len(conversations)} ä¸ªå¯¹è¯")
    
    def _convert_single(self, conversation: Dict[str, Any], output_dir: str, platform: str):
        """è½¬æ¢å•ä¸ªå¯¹è¯ä¸ºMarkdown"""
        title = conversation.get('title', 'æœªå‘½åå¯¹è¯')
        messages = conversation.get('messages', [])
        
        if not messages:
            raise ValueError("å¯¹è¯ä¸­æ²¡æœ‰æ¶ˆæ¯å†…å®¹")
        
        # ç”Ÿæˆå®‰å…¨æ–‡ä»¶å
        safe_title = self._safe_filename(title)
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        filename = f"{timestamp}_{safe_title}.md"
        filepath = os.path.join(output_dir, filename)
        
        # æ„å»ºMarkdownå†…å®¹
        md_content = self._build_markdown(title, messages, platform)
        
        # å†™å…¥æ–‡ä»¶
        with open(filepath, 'w', encoding='utf-8') as f:
            f.write(md_content)
        
        print(f"ğŸ“„ å·²åˆ›å»º: {filename}")
    
    def _safe_filename(self, filename: str) -> str:
        """ç”Ÿæˆå®‰å…¨çš„æ–‡ä»¶å"""
        # ç§»é™¤æˆ–æ›¿æ¢éæ³•å­—ç¬¦
        safe_name = re.sub(r'[<>:"/\\|?*]', '_', filename)
        # é™åˆ¶é•¿åº¦
        if len(safe_name) > 100:
            safe_name = safe_name[:100]
        return safe_name
    
    def _build_markdown(self, title: str, messages: List[Dict[str, Any]], platform: str) -> str:
        """æ„å»ºMarkdownå†…å®¹"""
        lines = []
        
        # YAML front matter
        lines.append("---")
        lines.append(f"title: {title}")
        lines.append(f"platform: {platform}")
        lines.append(f"export_date: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        lines.append(f"message_count: {len(messages)}")
        lines.append("---")
        lines.append("")
        
        # æ ‡é¢˜å’Œå…ƒä¿¡æ¯
        lines.append(f"# {title}")
        lines.append("")
        lines.append(f"**å¹³å°**: {platform}  |  **æ¶ˆæ¯æ•°é‡**: {len(messages)}  |  **å¯¼å‡ºæ—¶é—´**: {datetime.now().strftime('%Y-%m-%d %H:%M')}")
        lines.append("")
        lines.append("---")
        lines.append("")
        
        # æ·»åŠ æ¶ˆæ¯
        for i, msg in enumerate(messages, 1):
            role = msg['role']
            content = msg['content']
            
            # è§’è‰²æ˜¾ç¤ºåç§°æ˜ å°„
            role_display = {
                'user': 'ğŸ‘¤ ç”¨æˆ·',
                'human': 'ğŸ‘¤ ç”¨æˆ·',
                'assistant': 'ğŸ¤– åŠ©æ‰‹', 
                'system': 'âš™ï¸ ç³»ç»Ÿ',
                'tool': 'ğŸ› ï¸ å·¥å…·'
            }.get(role, f'â“ {role}')
            
            lines.append(f"## {role_display}")
            lines.append("")
            
            # å¤„ç†æ¶ˆæ¯å†…å®¹
            if content.strip():
                lines.append(content.strip())
            else:
                lines.append("*(ç©ºæ¶ˆæ¯)*")
            
            lines.append("")
            
            # æ·»åŠ åˆ†éš”çº¿ï¼ˆé™¤äº†æœ€åä¸€æ¡æ¶ˆæ¯ï¼‰
            if i < len(messages):
                lines.append("---")
                lines.append("")
        
        return '\n'.join(lines)

def convert(input_path: str, output_dir: str = "./ai_output"):
    """ä¾¿æ·è½¬æ¢å‡½æ•°"""
    exporter = AIExporter()
    exporter.convert(input_path, output_dir)

def main():
    """å‘½ä»¤è¡Œå…¥å£ç‚¹"""
    import argparse
    
    parser = argparse.ArgumentParser(
        description='å°†å¤šå¹³å°AIå¯¹è¯å¯¼å‡ºä¸ºMarkdownæ ¼å¼',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
æ”¯æŒå¹³å°:
  â€¢ ChatGPT (.zip å¯¼å‡ºæ–‡ä»¶)
  â€¢ DeepSeek (.jsonl æ–‡ä»¶)
  â€¢ Claude (.json æ–‡ä»¶)
  â€¢ å…¶ä»–AIå¹³å° (é€šç”¨JSON/JSONLæ ¼å¼)

ç¤ºä¾‹:
  ai-export chatgpt_export.zip
  ai-export deepseek_conversation.jsonl -o ./output
  ai-export claude_chat.json
        """
    )
    
    parser.add_argument('input_file', help='è¾“å…¥æ–‡ä»¶è·¯å¾„')
    parser.add_argument('-o', '--output', default='./ai_output', 
                       help='è¾“å‡ºç›®å½• (é»˜è®¤: ./ai_output)')
    
    args = parser.parse_args()
    
    if not os.path.exists(args.input_file):
        print(f"âŒ é”™è¯¯: æ–‡ä»¶ '{args.input_file}' ä¸å­˜åœ¨")
        return
    
    print("ğŸš€ AIå¯¹è¯å¯¼å‡ºå·¥å…·")
    print("=" * 50)
    
    exporter = AIExporter()
    exporter.convert(args.input_file, args.output)
    
    print("=" * 50)
    print("ğŸ‰ è½¬æ¢å®Œæˆï¼")

if __name__ == "__main__":
    main()