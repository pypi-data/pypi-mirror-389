"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from intuned_client.types import (
    BaseModel,
    Nullable,
    OptionalNullable,
    UNSET,
    UNSET_SENTINEL,
)
from intuned_client.utils import FieldMetadata, PathParamMetadata, RequestMetadata
import pydantic
from pydantic import model_serializer
from typing import Any, Dict, List, Literal, Optional, Union
from typing_extensions import Annotated, NotRequired, TypeAliasType, TypedDict


class CreateJobGlobalsTypedDict(TypedDict):
    workspace_id: NotRequired[str]
    r"""Your workspace ID. [How to find it](/docs/guides/general/how-to-get-a-workspace-id)?"""


class CreateJobGlobals(BaseModel):
    workspace_id: Annotated[
        Optional[str],
        pydantic.Field(alias="workspaceId"),
        FieldMetadata(path=PathParamMetadata(style="simple", explode=False)),
    ] = None
    r"""Your workspace ID. [How to find it](/docs/guides/general/how-to-get-a-workspace-id)?"""


class CreateJobPayloadRetryTypedDict(TypedDict):
    r"""Retry policy configurations in case of failure."""

    maximum_attempts: NotRequired[int]
    r"""Maximum number of attempts to retry the run in case of failure"""


class CreateJobPayloadRetry(BaseModel):
    r"""Retry policy configurations in case of failure."""

    maximum_attempts: Annotated[
        Optional[int], pydantic.Field(alias="maximumAttempts")
    ] = 3
    r"""Maximum number of attempts to retry the run in case of failure"""


class CreateJobPayloadTypedDict(TypedDict):
    parameters: Dict[str, Any]
    r"""The parameters to be passed to the API."""
    api_name: str
    r"""The name of the API to be executed. This is the file path relative to the `api` folder inside your project."""
    request_timeout: NotRequired[int]
    r"""Timeout for the API request in seconds. Default is 10 minutes (600 seconds)."""
    retry: NotRequired[CreateJobPayloadRetryTypedDict]
    r"""Retry policy configurations in case of failure."""


class CreateJobPayload(BaseModel):
    parameters: Dict[str, Any]
    r"""The parameters to be passed to the API."""

    api_name: Annotated[str, pydantic.Field(alias="apiName")]
    r"""The name of the API to be executed. This is the file path relative to the `api` folder inside your project."""

    request_timeout: Annotated[
        Optional[int], pydantic.Field(alias="requestTimeout")
    ] = 600
    r"""Timeout for the API request in seconds. Default is 10 minutes (600 seconds)."""

    retry: Optional[CreateJobPayloadRetry] = None
    r"""Retry policy configurations in case of failure."""


class CreateJobConfigurationRetryTypedDict(TypedDict):
    r"""The retry policy of the job. Configure how many retries and the delay between them for each payload."""

    maximum_attempts: NotRequired[int]
    r"""Maximum number of attempts to retry the run in case of failure"""


class CreateJobConfigurationRetry(BaseModel):
    r"""The retry policy of the job. Configure how many retries and the delay between them for each payload."""

    maximum_attempts: Annotated[
        Optional[int], pydantic.Field(alias="maximumAttempts")
    ] = 3
    r"""Maximum number of attempts to retry the run in case of failure"""


class CreateJobConfigurationTypedDict(TypedDict):
    r"""Job configuration settings"""

    retry: NotRequired[CreateJobConfigurationRetryTypedDict]
    r"""The retry policy of the job. Configure how many retries and the delay between them for each payload."""
    max_concurrent_requests: NotRequired[float]
    r"""The batch size of payloads to execute. This does not guarantee that the payloads will be executed at the same time."""
    request_timeout: NotRequired[int]
    r"""Timeout for the API request in seconds. Default is 10 minutes (600 seconds)."""


class CreateJobConfiguration(BaseModel):
    r"""Job configuration settings"""

    retry: Optional[CreateJobConfigurationRetry] = None
    r"""The retry policy of the job. Configure how many retries and the delay between them for each payload."""

    max_concurrent_requests: Annotated[
        Optional[float], pydantic.Field(alias="maxConcurrentRequests")
    ] = None
    r"""The batch size of payloads to execute. This does not guarantee that the payloads will be executed at the same time."""

    request_timeout: Annotated[
        Optional[int], pydantic.Field(alias="requestTimeout")
    ] = 600
    r"""Timeout for the API request in seconds. Default is 10 minutes (600 seconds)."""


CreateJobJitterTypedDict = TypeAliasType("CreateJobJitterTypedDict", Union[int, str])


CreateJobJitter = TypeAliasType("CreateJobJitter", Union[int, str])


CreateJobEveryTypedDict = TypeAliasType("CreateJobEveryTypedDict", Union[int, str])


CreateJobEvery = TypeAliasType("CreateJobEvery", Union[int, str])


class CreateJobIntervalTypedDict(TypedDict):
    r"""An interval object, which represents a period to trigger the job. The interval is relative to the [Unix epoch](https://en.wikipedia.org/wiki/Unix_time)."""

    every: CreateJobEveryTypedDict


class CreateJobInterval(BaseModel):
    r"""An interval object, which represents a period to trigger the job. The interval is relative to the [Unix epoch](https://en.wikipedia.org/wiki/Unix_time)."""

    every: CreateJobEvery


CreateJobSecondEnum = Literal["*",]


class CreateJobSecond4TypedDict(TypedDict):
    start: int
    end: NotRequired[int]


class CreateJobSecond4(BaseModel):
    start: int

    end: Optional[int] = None


class CreateJobSecond3TypedDict(TypedDict):
    start: int
    step: int
    end: int


class CreateJobSecond3(BaseModel):
    start: int

    step: int

    end: int


CreateJobSecondUnion2TypedDict = TypeAliasType(
    "CreateJobSecondUnion2TypedDict",
    Union[CreateJobSecond4TypedDict, CreateJobSecond3TypedDict, int],
)


CreateJobSecondUnion2 = TypeAliasType(
    "CreateJobSecondUnion2", Union[CreateJobSecond4, CreateJobSecond3, int]
)


class CreateJobSecond2TypedDict(TypedDict):
    start: int
    end: NotRequired[int]


class CreateJobSecond2(BaseModel):
    start: int

    end: Optional[int] = None


class CreateJobSecond1TypedDict(TypedDict):
    start: int
    step: int
    end: int


class CreateJobSecond1(BaseModel):
    start: int

    step: int

    end: int


CreateJobSecondUnion1TypedDict = TypeAliasType(
    "CreateJobSecondUnion1TypedDict",
    Union[
        CreateJobSecond2TypedDict,
        CreateJobSecond1TypedDict,
        int,
        List[CreateJobSecondUnion2TypedDict],
        CreateJobSecondEnum,
    ],
)
r"""Seconds of the calendar, a number in the range 0 - 59"""


CreateJobSecondUnion1 = TypeAliasType(
    "CreateJobSecondUnion1",
    Union[
        CreateJobSecond2,
        CreateJobSecond1,
        int,
        List[CreateJobSecondUnion2],
        CreateJobSecondEnum,
    ],
)
r"""Seconds of the calendar, a number in the range 0 - 59"""


CreateJobMinuteEnum = Literal["*",]


class CreateJobMinute4TypedDict(TypedDict):
    start: int
    end: NotRequired[int]


class CreateJobMinute4(BaseModel):
    start: int

    end: Optional[int] = None


class CreateJobMinute3TypedDict(TypedDict):
    start: int
    step: int
    end: int


class CreateJobMinute3(BaseModel):
    start: int

    step: int

    end: int


CreateJobMinuteUnion2TypedDict = TypeAliasType(
    "CreateJobMinuteUnion2TypedDict",
    Union[CreateJobMinute4TypedDict, CreateJobMinute3TypedDict, int],
)


CreateJobMinuteUnion2 = TypeAliasType(
    "CreateJobMinuteUnion2", Union[CreateJobMinute4, CreateJobMinute3, int]
)


class CreateJobMinute2TypedDict(TypedDict):
    start: int
    end: NotRequired[int]


class CreateJobMinute2(BaseModel):
    start: int

    end: Optional[int] = None


class CreateJobMinute1TypedDict(TypedDict):
    start: int
    step: int
    end: int


class CreateJobMinute1(BaseModel):
    start: int

    step: int

    end: int


CreateJobMinuteUnion1TypedDict = TypeAliasType(
    "CreateJobMinuteUnion1TypedDict",
    Union[
        CreateJobMinute2TypedDict,
        CreateJobMinute1TypedDict,
        int,
        List[CreateJobMinuteUnion2TypedDict],
        CreateJobMinuteEnum,
    ],
)
r"""Minutes of the calendar, a number in the range 0 - 59"""


CreateJobMinuteUnion1 = TypeAliasType(
    "CreateJobMinuteUnion1",
    Union[
        CreateJobMinute2,
        CreateJobMinute1,
        int,
        List[CreateJobMinuteUnion2],
        CreateJobMinuteEnum,
    ],
)
r"""Minutes of the calendar, a number in the range 0 - 59"""


CreateJobHourEnum = Literal["*",]


class CreateJobHour4TypedDict(TypedDict):
    start: int
    end: NotRequired[int]


class CreateJobHour4(BaseModel):
    start: int

    end: Optional[int] = None


class CreateJobHour3TypedDict(TypedDict):
    start: int
    step: int
    end: int


class CreateJobHour3(BaseModel):
    start: int

    step: int

    end: int


CreateJobHourUnion2TypedDict = TypeAliasType(
    "CreateJobHourUnion2TypedDict",
    Union[CreateJobHour4TypedDict, CreateJobHour3TypedDict, int],
)


CreateJobHourUnion2 = TypeAliasType(
    "CreateJobHourUnion2", Union[CreateJobHour4, CreateJobHour3, int]
)


class CreateJobHour2TypedDict(TypedDict):
    start: int
    end: NotRequired[int]


class CreateJobHour2(BaseModel):
    start: int

    end: Optional[int] = None


class CreateJobHour1TypedDict(TypedDict):
    start: int
    step: int
    end: int


class CreateJobHour1(BaseModel):
    start: int

    step: int

    end: int


CreateJobHourUnion1TypedDict = TypeAliasType(
    "CreateJobHourUnion1TypedDict",
    Union[
        CreateJobHour2TypedDict,
        CreateJobHour1TypedDict,
        int,
        List[CreateJobHourUnion2TypedDict],
        CreateJobHourEnum,
    ],
)
r"""Hours of the calendar, a number in the range 0 - 23"""


CreateJobHourUnion1 = TypeAliasType(
    "CreateJobHourUnion1",
    Union[
        CreateJobHour2,
        CreateJobHour1,
        int,
        List[CreateJobHourUnion2],
        CreateJobHourEnum,
    ],
)
r"""Hours of the calendar, a number in the range 0 - 23"""


CreateJobDayOfWeekWildcard = Literal["*",]


CreateJobDayOfWeekStart4 = Literal[
    "SUNDAY",
    "MONDAY",
    "TUESDAY",
    "WEDNESDAY",
    "THURSDAY",
    "FRIDAY",
    "SATURDAY",
]


CreateJobDayOfWeekEnd4 = Literal[
    "SUNDAY",
    "MONDAY",
    "TUESDAY",
    "WEDNESDAY",
    "THURSDAY",
    "FRIDAY",
    "SATURDAY",
]


class CreateJobDayOfWeek4TypedDict(TypedDict):
    start: CreateJobDayOfWeekStart4
    end: NotRequired[CreateJobDayOfWeekEnd4]


class CreateJobDayOfWeek4(BaseModel):
    start: CreateJobDayOfWeekStart4

    end: Optional[CreateJobDayOfWeekEnd4] = None


CreateJobDayOfWeekStart3 = Literal[
    "SUNDAY",
    "MONDAY",
    "TUESDAY",
    "WEDNESDAY",
    "THURSDAY",
    "FRIDAY",
    "SATURDAY",
]


CreateJobDayOfWeekEnd3 = Literal[
    "SUNDAY",
    "MONDAY",
    "TUESDAY",
    "WEDNESDAY",
    "THURSDAY",
    "FRIDAY",
    "SATURDAY",
]


class CreateJobDayOfWeek3TypedDict(TypedDict):
    start: CreateJobDayOfWeekStart3
    step: int
    end: CreateJobDayOfWeekEnd3


class CreateJobDayOfWeek3(BaseModel):
    start: CreateJobDayOfWeekStart3

    step: int

    end: CreateJobDayOfWeekEnd3


CreateJobDayOfWeekEnum2 = Literal[
    "SUNDAY",
    "MONDAY",
    "TUESDAY",
    "WEDNESDAY",
    "THURSDAY",
    "FRIDAY",
    "SATURDAY",
]


CreateJobDayOfWeekUnion2TypedDict = TypeAliasType(
    "CreateJobDayOfWeekUnion2TypedDict",
    Union[
        CreateJobDayOfWeek4TypedDict,
        CreateJobDayOfWeek3TypedDict,
        CreateJobDayOfWeekEnum2,
    ],
)


CreateJobDayOfWeekUnion2 = TypeAliasType(
    "CreateJobDayOfWeekUnion2",
    Union[CreateJobDayOfWeek4, CreateJobDayOfWeek3, CreateJobDayOfWeekEnum2],
)


CreateJobDayOfWeekStart2 = Literal[
    "SUNDAY",
    "MONDAY",
    "TUESDAY",
    "WEDNESDAY",
    "THURSDAY",
    "FRIDAY",
    "SATURDAY",
]


CreateJobDayOfWeekEnd2 = Literal[
    "SUNDAY",
    "MONDAY",
    "TUESDAY",
    "WEDNESDAY",
    "THURSDAY",
    "FRIDAY",
    "SATURDAY",
]


class CreateJobDayOfWeek2TypedDict(TypedDict):
    start: CreateJobDayOfWeekStart2
    end: NotRequired[CreateJobDayOfWeekEnd2]


class CreateJobDayOfWeek2(BaseModel):
    start: CreateJobDayOfWeekStart2

    end: Optional[CreateJobDayOfWeekEnd2] = None


CreateJobDayOfWeekStart1 = Literal[
    "SUNDAY",
    "MONDAY",
    "TUESDAY",
    "WEDNESDAY",
    "THURSDAY",
    "FRIDAY",
    "SATURDAY",
]


CreateJobDayOfWeekEnd1 = Literal[
    "SUNDAY",
    "MONDAY",
    "TUESDAY",
    "WEDNESDAY",
    "THURSDAY",
    "FRIDAY",
    "SATURDAY",
]


class CreateJobDayOfWeek1TypedDict(TypedDict):
    start: CreateJobDayOfWeekStart1
    step: int
    end: CreateJobDayOfWeekEnd1


class CreateJobDayOfWeek1(BaseModel):
    start: CreateJobDayOfWeekStart1

    step: int

    end: CreateJobDayOfWeekEnd1


CreateJobDayOfWeekEnum1 = Literal[
    "SUNDAY",
    "MONDAY",
    "TUESDAY",
    "WEDNESDAY",
    "THURSDAY",
    "FRIDAY",
    "SATURDAY",
]


CreateJobDayOfWeekUnion1TypedDict = TypeAliasType(
    "CreateJobDayOfWeekUnion1TypedDict",
    Union[
        CreateJobDayOfWeek2TypedDict,
        CreateJobDayOfWeek1TypedDict,
        CreateJobDayOfWeekEnum1,
        List[CreateJobDayOfWeekUnion2TypedDict],
        CreateJobDayOfWeekWildcard,
    ],
)
r"""Days of week, one of SUNDAY, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY"""


CreateJobDayOfWeekUnion1 = TypeAliasType(
    "CreateJobDayOfWeekUnion1",
    Union[
        CreateJobDayOfWeek2,
        CreateJobDayOfWeek1,
        CreateJobDayOfWeekEnum1,
        List[CreateJobDayOfWeekUnion2],
        CreateJobDayOfWeekWildcard,
    ],
)
r"""Days of week, one of SUNDAY, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY"""


CreateJobDayOfMonthEnum = Literal["*",]


class CreateJobDayOfMonth4TypedDict(TypedDict):
    start: int
    end: NotRequired[int]


class CreateJobDayOfMonth4(BaseModel):
    start: int

    end: Optional[int] = None


class CreateJobDayOfMonth3TypedDict(TypedDict):
    start: int
    step: int
    end: int


class CreateJobDayOfMonth3(BaseModel):
    start: int

    step: int

    end: int


CreateJobDayOfMonthUnion2TypedDict = TypeAliasType(
    "CreateJobDayOfMonthUnion2TypedDict",
    Union[CreateJobDayOfMonth4TypedDict, CreateJobDayOfMonth3TypedDict, int],
)


CreateJobDayOfMonthUnion2 = TypeAliasType(
    "CreateJobDayOfMonthUnion2", Union[CreateJobDayOfMonth4, CreateJobDayOfMonth3, int]
)


class CreateJobDayOfMonth2TypedDict(TypedDict):
    start: int
    end: NotRequired[int]


class CreateJobDayOfMonth2(BaseModel):
    start: int

    end: Optional[int] = None


class CreateJobDayOfMonth1TypedDict(TypedDict):
    start: int
    step: int
    end: int


class CreateJobDayOfMonth1(BaseModel):
    start: int

    step: int

    end: int


CreateJobDayOfMonthUnion1TypedDict = TypeAliasType(
    "CreateJobDayOfMonthUnion1TypedDict",
    Union[
        CreateJobDayOfMonth2TypedDict,
        CreateJobDayOfMonth1TypedDict,
        int,
        List[CreateJobDayOfMonthUnion2TypedDict],
        CreateJobDayOfMonthEnum,
    ],
)
r"""Days of the month, a number in the range 1 - 31"""


CreateJobDayOfMonthUnion1 = TypeAliasType(
    "CreateJobDayOfMonthUnion1",
    Union[
        CreateJobDayOfMonth2,
        CreateJobDayOfMonth1,
        int,
        List[CreateJobDayOfMonthUnion2],
        CreateJobDayOfMonthEnum,
    ],
)
r"""Days of the month, a number in the range 1 - 31"""


CreateJobMonthWildcard = Literal["*",]


CreateJobMonthStart4 = Literal[
    "JANUARY",
    "FEBRUARY",
    "MARCH",
    "APRIL",
    "MAY",
    "JUNE",
    "JULY",
    "AUGUST",
    "SEPTEMBER",
    "OCTOBER",
    "NOVEMBER",
    "DECEMBER",
]


CreateJobMonthEnd4 = Literal[
    "JANUARY",
    "FEBRUARY",
    "MARCH",
    "APRIL",
    "MAY",
    "JUNE",
    "JULY",
    "AUGUST",
    "SEPTEMBER",
    "OCTOBER",
    "NOVEMBER",
    "DECEMBER",
]


class CreateJobMonth4TypedDict(TypedDict):
    start: CreateJobMonthStart4
    end: NotRequired[CreateJobMonthEnd4]


class CreateJobMonth4(BaseModel):
    start: CreateJobMonthStart4

    end: Optional[CreateJobMonthEnd4] = None


CreateJobMonthStart3 = Literal[
    "JANUARY",
    "FEBRUARY",
    "MARCH",
    "APRIL",
    "MAY",
    "JUNE",
    "JULY",
    "AUGUST",
    "SEPTEMBER",
    "OCTOBER",
    "NOVEMBER",
    "DECEMBER",
]


CreateJobMonthEnd3 = Literal[
    "JANUARY",
    "FEBRUARY",
    "MARCH",
    "APRIL",
    "MAY",
    "JUNE",
    "JULY",
    "AUGUST",
    "SEPTEMBER",
    "OCTOBER",
    "NOVEMBER",
    "DECEMBER",
]


class CreateJobMonth3TypedDict(TypedDict):
    start: CreateJobMonthStart3
    step: int
    end: CreateJobMonthEnd3


class CreateJobMonth3(BaseModel):
    start: CreateJobMonthStart3

    step: int

    end: CreateJobMonthEnd3


CreateJobMonthEnum2 = Literal[
    "JANUARY",
    "FEBRUARY",
    "MARCH",
    "APRIL",
    "MAY",
    "JUNE",
    "JULY",
    "AUGUST",
    "SEPTEMBER",
    "OCTOBER",
    "NOVEMBER",
    "DECEMBER",
]


CreateJobMonthUnion2TypedDict = TypeAliasType(
    "CreateJobMonthUnion2TypedDict",
    Union[CreateJobMonth4TypedDict, CreateJobMonth3TypedDict, CreateJobMonthEnum2],
)


CreateJobMonthUnion2 = TypeAliasType(
    "CreateJobMonthUnion2", Union[CreateJobMonth4, CreateJobMonth3, CreateJobMonthEnum2]
)


CreateJobMonthStart2 = Literal[
    "JANUARY",
    "FEBRUARY",
    "MARCH",
    "APRIL",
    "MAY",
    "JUNE",
    "JULY",
    "AUGUST",
    "SEPTEMBER",
    "OCTOBER",
    "NOVEMBER",
    "DECEMBER",
]


CreateJobMonthEnd2 = Literal[
    "JANUARY",
    "FEBRUARY",
    "MARCH",
    "APRIL",
    "MAY",
    "JUNE",
    "JULY",
    "AUGUST",
    "SEPTEMBER",
    "OCTOBER",
    "NOVEMBER",
    "DECEMBER",
]


class CreateJobMonth2TypedDict(TypedDict):
    start: CreateJobMonthStart2
    end: NotRequired[CreateJobMonthEnd2]


class CreateJobMonth2(BaseModel):
    start: CreateJobMonthStart2

    end: Optional[CreateJobMonthEnd2] = None


CreateJobMonthStart1 = Literal[
    "JANUARY",
    "FEBRUARY",
    "MARCH",
    "APRIL",
    "MAY",
    "JUNE",
    "JULY",
    "AUGUST",
    "SEPTEMBER",
    "OCTOBER",
    "NOVEMBER",
    "DECEMBER",
]


CreateJobMonthEnd1 = Literal[
    "JANUARY",
    "FEBRUARY",
    "MARCH",
    "APRIL",
    "MAY",
    "JUNE",
    "JULY",
    "AUGUST",
    "SEPTEMBER",
    "OCTOBER",
    "NOVEMBER",
    "DECEMBER",
]


class CreateJobMonth1TypedDict(TypedDict):
    start: CreateJobMonthStart1
    step: int
    end: CreateJobMonthEnd1


class CreateJobMonth1(BaseModel):
    start: CreateJobMonthStart1

    step: int

    end: CreateJobMonthEnd1


CreateJobMonthEnum1 = Literal[
    "JANUARY",
    "FEBRUARY",
    "MARCH",
    "APRIL",
    "MAY",
    "JUNE",
    "JULY",
    "AUGUST",
    "SEPTEMBER",
    "OCTOBER",
    "NOVEMBER",
    "DECEMBER",
]


CreateJobMonthUnion1TypedDict = TypeAliasType(
    "CreateJobMonthUnion1TypedDict",
    Union[
        CreateJobMonth2TypedDict,
        CreateJobMonth1TypedDict,
        CreateJobMonthEnum1,
        List[CreateJobMonthUnion2TypedDict],
        CreateJobMonthWildcard,
    ],
)
r"""Months, one of JANUARY, FEBRUARY, MARCH, APRIL, MAY, JUNE, JULY, AUGUST, SEPTEMBER, OCTOBER, NOVEMBER, DECEMBER"""


CreateJobMonthUnion1 = TypeAliasType(
    "CreateJobMonthUnion1",
    Union[
        CreateJobMonth2,
        CreateJobMonth1,
        CreateJobMonthEnum1,
        List[CreateJobMonthUnion2],
        CreateJobMonthWildcard,
    ],
)
r"""Months, one of JANUARY, FEBRUARY, MARCH, APRIL, MAY, JUNE, JULY, AUGUST, SEPTEMBER, OCTOBER, NOVEMBER, DECEMBER"""


CreateJobYearEnum = Literal["*",]


class CreateJobYear4TypedDict(TypedDict):
    start: int
    end: NotRequired[int]


class CreateJobYear4(BaseModel):
    start: int

    end: Optional[int] = None


class CreateJobYear3TypedDict(TypedDict):
    start: int
    step: int
    end: int


class CreateJobYear3(BaseModel):
    start: int

    step: int

    end: int


CreateJobYearUnion2TypedDict = TypeAliasType(
    "CreateJobYearUnion2TypedDict",
    Union[CreateJobYear4TypedDict, CreateJobYear3TypedDict, int],
)


CreateJobYearUnion2 = TypeAliasType(
    "CreateJobYearUnion2", Union[CreateJobYear4, CreateJobYear3, int]
)


class CreateJobYear2TypedDict(TypedDict):
    start: int
    end: NotRequired[int]


class CreateJobYear2(BaseModel):
    start: int

    end: Optional[int] = None


class CreateJobYear1TypedDict(TypedDict):
    start: int
    step: int
    end: int


class CreateJobYear1(BaseModel):
    start: int

    step: int

    end: int


CreateJobYearUnion1TypedDict = TypeAliasType(
    "CreateJobYearUnion1TypedDict",
    Union[
        CreateJobYear2TypedDict,
        CreateJobYear1TypedDict,
        int,
        List[CreateJobYearUnion2TypedDict],
        CreateJobYearEnum,
    ],
)
r"""Full year. For example: 2024"""


CreateJobYearUnion1 = TypeAliasType(
    "CreateJobYearUnion1",
    Union[
        CreateJobYear2,
        CreateJobYear1,
        int,
        List[CreateJobYearUnion2],
        CreateJobYearEnum,
    ],
)
r"""Full year. For example: 2024"""


class CreateJobCalendarTypedDict(TypedDict):
    r"""A calendar object. It is similar to a cron string, but more verbose."""

    second: NotRequired[CreateJobSecondUnion1TypedDict]
    r"""Seconds of the calendar, a number in the range 0 - 59"""
    minute: NotRequired[CreateJobMinuteUnion1TypedDict]
    r"""Minutes of the calendar, a number in the range 0 - 59"""
    hour: NotRequired[CreateJobHourUnion1TypedDict]
    r"""Hours of the calendar, a number in the range 0 - 23"""
    day_of_week: NotRequired[CreateJobDayOfWeekUnion1TypedDict]
    r"""Days of week, one of SUNDAY, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY"""
    day_of_month: NotRequired[CreateJobDayOfMonthUnion1TypedDict]
    r"""Days of the month, a number in the range 1 - 31"""
    month: NotRequired[CreateJobMonthUnion1TypedDict]
    r"""Months, one of JANUARY, FEBRUARY, MARCH, APRIL, MAY, JUNE, JULY, AUGUST, SEPTEMBER, OCTOBER, NOVEMBER, DECEMBER"""
    year: NotRequired[CreateJobYearUnion1TypedDict]
    r"""Full year. For example: 2024"""
    comment: NotRequired[str]
    r"""A comment to describe what the calendar is supposed to represent"""


class CreateJobCalendar(BaseModel):
    r"""A calendar object. It is similar to a cron string, but more verbose."""

    second: Optional[CreateJobSecondUnion1] = None
    r"""Seconds of the calendar, a number in the range 0 - 59"""

    minute: Optional[CreateJobMinuteUnion1] = None
    r"""Minutes of the calendar, a number in the range 0 - 59"""

    hour: Optional[CreateJobHourUnion1] = None
    r"""Hours of the calendar, a number in the range 0 - 23"""

    day_of_week: Annotated[
        Optional[CreateJobDayOfWeekUnion1], pydantic.Field(alias="dayOfWeek")
    ] = None
    r"""Days of week, one of SUNDAY, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY"""

    day_of_month: Annotated[
        Optional[CreateJobDayOfMonthUnion1], pydantic.Field(alias="dayOfMonth")
    ] = None
    r"""Days of the month, a number in the range 1 - 31"""

    month: Optional[CreateJobMonthUnion1] = None
    r"""Months, one of JANUARY, FEBRUARY, MARCH, APRIL, MAY, JUNE, JULY, AUGUST, SEPTEMBER, OCTOBER, NOVEMBER, DECEMBER"""

    year: Optional[CreateJobYearUnion1] = None
    r"""Full year. For example: 2024"""

    comment: Optional[str] = None
    r"""A comment to describe what the calendar is supposed to represent"""


class CreateJobScheduleTypedDict(TypedDict):
    r"""Schedule configurations for the job. If set, the job will periodically run according to this configuration. The configurations are used to calculate the closest next run time."""

    jitter: NotRequired[CreateJobJitterTypedDict]
    intervals: NotRequired[List[CreateJobIntervalTypedDict]]
    r"""An array of interval objects"""
    calendars: NotRequired[List[CreateJobCalendarTypedDict]]
    r"""An array of calendar objects"""


class CreateJobSchedule(BaseModel):
    r"""Schedule configurations for the job. If set, the job will periodically run according to this configuration. The configurations are used to calculate the closest next run time."""

    jitter: Optional[CreateJobJitter] = None

    intervals: Optional[List[CreateJobInterval]] = None
    r"""An array of interval objects"""

    calendars: Optional[List[CreateJobCalendar]] = None
    r"""An array of calendar objects"""


CreateJobTypeS3 = Literal["s3",]


class CreateJobS3SinkConfigurationTypedDict(TypedDict):
    r"""Configuration for the S3 sink."""

    type: CreateJobTypeS3
    bucket: str
    r"""The name of the S3 bucket where the data will be stored."""
    access_key_id: str
    r"""The access key ID for the S3 bucket."""
    secret_access_key: str
    r"""The secret access key for the S3 bucket."""
    region: str
    r"""The region where the S3 bucket is located."""
    prefix: NotRequired[str]
    r"""Optional prefix for the S3 objects. This can be used to organize objects within the bucket."""
    skip_on_fail: NotRequired[bool]
    r"""If enabled, failed payload runs will ***not*** be written to the bucket."""
    apis_to_send: NotRequired[List[str]]
    r"""List of API names to be sent to the S3 bucket. If not provided, all APIs will be sent."""
    endpoint: NotRequired[str]
    r"""Optional custom endpoint for the S3 bucket. This can be used for S3-compatible services."""
    force_path_style: NotRequired[bool]
    r"""If true, the S3 client will use path-style URLs instead of virtual-hosted-style URLs. This is useful for S3-compatible services that require path-style access."""


class CreateJobS3SinkConfiguration(BaseModel):
    r"""Configuration for the S3 sink."""

    type: CreateJobTypeS3

    bucket: str
    r"""The name of the S3 bucket where the data will be stored."""

    access_key_id: Annotated[str, pydantic.Field(alias="accessKeyId")]
    r"""The access key ID for the S3 bucket."""

    secret_access_key: Annotated[str, pydantic.Field(alias="secretAccessKey")]
    r"""The secret access key for the S3 bucket."""

    region: str
    r"""The region where the S3 bucket is located."""

    prefix: Optional[str] = None
    r"""Optional prefix for the S3 objects. This can be used to organize objects within the bucket."""

    skip_on_fail: Annotated[Optional[bool], pydantic.Field(alias="skipOnFail")] = False
    r"""If enabled, failed payload runs will ***not*** be written to the bucket."""

    apis_to_send: Annotated[Optional[List[str]], pydantic.Field(alias="apisToSend")] = (
        None
    )
    r"""List of API names to be sent to the S3 bucket. If not provided, all APIs will be sent."""

    endpoint: Optional[str] = None
    r"""Optional custom endpoint for the S3 bucket. This can be used for S3-compatible services."""

    force_path_style: Annotated[
        Optional[bool], pydantic.Field(alias="forcePathStyle")
    ] = None
    r"""If true, the S3 client will use path-style URLs instead of virtual-hosted-style URLs. This is useful for S3-compatible services that require path-style access."""


CreateJobTypeWebhook = Literal["webhook",]


class CreateJobWebhookSinkConfigurationTypedDict(TypedDict):
    r"""Configuration for the webhook sink."""

    type: CreateJobTypeWebhook
    url: str
    r"""The URL to which the webhook will send the data."""
    headers: NotRequired[Dict[str, str]]
    r"""Optional headers to be sent with the webhook request."""
    skip_on_fail: NotRequired[bool]
    r"""If true, the webhook will not be sent if the API execution fails."""
    apis_to_send: NotRequired[List[str]]
    r"""List of API names to be sent to the webhook. If not provided, all APIs will be sent."""


class CreateJobWebhookSinkConfiguration(BaseModel):
    r"""Configuration for the webhook sink."""

    type: CreateJobTypeWebhook

    url: str
    r"""The URL to which the webhook will send the data."""

    headers: Optional[Dict[str, str]] = None
    r"""Optional headers to be sent with the webhook request."""

    skip_on_fail: Annotated[Optional[bool], pydantic.Field(alias="skipOnFail")] = False
    r"""If true, the webhook will not be sent if the API execution fails."""

    apis_to_send: Annotated[Optional[List[str]], pydantic.Field(alias="apisToSend")] = (
        None
    )
    r"""List of API names to be sent to the webhook. If not provided, all APIs will be sent."""


CreateJobSinkTypedDict = TypeAliasType(
    "CreateJobSinkTypedDict",
    Union[
        CreateJobWebhookSinkConfigurationTypedDict,
        CreateJobS3SinkConfigurationTypedDict,
    ],
)
r"""Optional sink configuration for the job. Can be a webhook or S3 Compatible sink."""


CreateJobSink = TypeAliasType(
    "CreateJobSink",
    Union[CreateJobWebhookSinkConfiguration, CreateJobS3SinkConfiguration],
)
r"""Optional sink configuration for the job. Can be a webhook or S3 Compatible sink."""


class CreateJobAuthSessionTypedDict(TypedDict):
    id: str
    check_attempts: NotRequired[int]
    r"""Number of attempts to check the validity of the auth session before recreating it."""
    create_attempts: NotRequired[int]
    r"""Number of attempts to create a new auth session if the current one is invalid or expired."""


class CreateJobAuthSession(BaseModel):
    id: str

    check_attempts: Annotated[Optional[int], pydantic.Field(alias="checkAttempts")] = 3
    r"""Number of attempts to check the validity of the auth session before recreating it."""

    create_attempts: Annotated[
        Optional[int], pydantic.Field(alias="createAttempts")
    ] = 3
    r"""Number of attempts to create a new auth session if the current one is invalid or expired."""


class CreateJobRequestBodyTypedDict(TypedDict):
    r"""Job creation input schema"""

    id: str
    r"""The ID of the job. Has to be a valid URL slug."""
    payload: List[CreateJobPayloadTypedDict]
    r"""Array of API calls to be executed"""
    configuration: CreateJobConfigurationTypedDict
    r"""Job configuration settings"""
    schedule: NotRequired[Nullable[CreateJobScheduleTypedDict]]
    r"""Schedule configurations for the job. If set, the job will periodically run according to this configuration. The configurations are used to calculate the closest next run time."""
    sink: NotRequired[Nullable[CreateJobSinkTypedDict]]
    r"""Optional sink configuration for the job. Can be a webhook or S3 Compatible sink."""
    proxy: NotRequired[Nullable[str]]
    r"""Proxy configuration for the job"""
    auth_session: NotRequired[Nullable[CreateJobAuthSessionTypedDict]]


class CreateJobRequestBody(BaseModel):
    r"""Job creation input schema"""

    id: str
    r"""The ID of the job. Has to be a valid URL slug."""

    payload: List[CreateJobPayload]
    r"""Array of API calls to be executed"""

    configuration: CreateJobConfiguration
    r"""Job configuration settings"""

    schedule: OptionalNullable[CreateJobSchedule] = UNSET
    r"""Schedule configurations for the job. If set, the job will periodically run according to this configuration. The configurations are used to calculate the closest next run time."""

    sink: OptionalNullable[CreateJobSink] = UNSET
    r"""Optional sink configuration for the job. Can be a webhook or S3 Compatible sink."""

    proxy: OptionalNullable[str] = UNSET
    r"""Proxy configuration for the job"""

    auth_session: OptionalNullable[CreateJobAuthSession] = UNSET

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["schedule", "sink", "proxy", "auth_session"]
        nullable_fields = ["schedule", "sink", "proxy", "auth_session"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class CreateJobRequestTypedDict(TypedDict):
    project_name: str
    r"""Your project name. It is the name you provide when creating a project."""
    request_body: CreateJobRequestBodyTypedDict
    r"""Job creation input schema"""


class CreateJobRequest(BaseModel):
    project_name: Annotated[
        str,
        pydantic.Field(alias="projectName"),
        FieldMetadata(path=PathParamMetadata(style="simple", explode=False)),
    ]
    r"""Your project name. It is the name you provide when creating a project."""

    request_body: Annotated[
        CreateJobRequestBody,
        FieldMetadata(request=RequestMetadata(media_type="application/json")),
    ]
    r"""Job creation input schema"""


CreateJobNotFoundCode = Literal["not-found",]
r"""The requested resource was not found
https://docs.intunedhq.com/docs/support/errors#not-found - Find more info here
"""


CreateJobNotFoundCategory = Literal["user",]
r"""Errors caused by user actions or input
https://docs.intunedhq.com/docs/support/errors#user - Find more info here
"""


CreateJobUnauthorizedCode = Literal["unauthorized",]
r"""The request requires user authentication
https://docs.intunedhq.com/docs/support/errors#unauthorized - Find more info here
"""


CreateJobUnauthorizedCategory = Literal["user",]
r"""Errors caused by user actions or input
https://docs.intunedhq.com/docs/support/errors#user - Find more info here
"""


CreateJobBadRequestCode = Literal["bad-request",]
r"""The request is invalid or malformed
https://docs.intunedhq.com/docs/support/errors#bad-request - Find more info here
"""


CreateJobBadRequestCategory = Literal["user",]
r"""Errors caused by user actions or input
https://docs.intunedhq.com/docs/support/errors#user - Find more info here
"""


CreateJobMessage = Literal["created",]


class CreateJobResponseTypedDict(TypedDict):
    r"""Job created successfully."""

    id: str
    r"""The ID of the created job."""
    message: CreateJobMessage


class CreateJobResponse(BaseModel):
    r"""Job created successfully."""

    id: str
    r"""The ID of the created job."""

    message: CreateJobMessage
