"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from datetime import datetime
from intuned_client.types import (
    BaseModel,
    Nullable,
    OptionalNullable,
    UNSET,
    UNSET_SENTINEL,
)
from intuned_client.utils import FieldMetadata, PathParamMetadata
import pydantic
from pydantic import model_serializer
from typing import Any, Dict, List, Literal, Optional, Union
from typing_extensions import Annotated, NotRequired, TypeAliasType, TypedDict


class GetJobsGlobalsTypedDict(TypedDict):
    workspace_id: NotRequired[str]
    r"""Your workspace ID. [How to find it](/docs/guides/general/how-to-get-a-workspace-id)?"""


class GetJobsGlobals(BaseModel):
    workspace_id: Annotated[
        Optional[str],
        pydantic.Field(alias="workspaceId"),
        FieldMetadata(path=PathParamMetadata(style="simple", explode=False)),
    ] = None
    r"""Your workspace ID. [How to find it](/docs/guides/general/how-to-get-a-workspace-id)?"""


class GetJobsRequestTypedDict(TypedDict):
    project_name: str
    r"""Your project name. It is the name you provide when creating a project."""


class GetJobsRequest(BaseModel):
    project_name: Annotated[
        str,
        pydantic.Field(alias="projectName"),
        FieldMetadata(path=PathParamMetadata(style="simple", explode=False)),
    ]
    r"""Your project name. It is the name you provide when creating a project."""


GetJobsNotFoundCode = Literal["not-found",]
r"""The requested resource was not found
https://docs.intunedhq.com/docs/support/errors#not-found - Find more info here
"""


GetJobsNotFoundCategory = Literal["user",]
r"""Errors caused by user actions or input
https://docs.intunedhq.com/docs/support/errors#user - Find more info here
"""


GetJobsUnauthorizedCode = Literal["unauthorized",]
r"""The request requires user authentication
https://docs.intunedhq.com/docs/support/errors#unauthorized - Find more info here
"""


GetJobsUnauthorizedCategory = Literal["user",]
r"""Errors caused by user actions or input
https://docs.intunedhq.com/docs/support/errors#user - Find more info here
"""


GetJobsBadRequestCode = Literal["bad-request",]
r"""The request is invalid or malformed
https://docs.intunedhq.com/docs/support/errors#bad-request - Find more info here
"""


GetJobsBadRequestCategory = Literal["user",]
r"""Errors caused by user actions or input
https://docs.intunedhq.com/docs/support/errors#user - Find more info here
"""


class GetJobsConfigurationRetryTypedDict(TypedDict):
    r"""The retry policy of the job. Configure how many retries and the delay between them for each payload."""

    maximum_attempts: NotRequired[int]
    r"""Maximum number of attempts to retry the run in case of failure"""


class GetJobsConfigurationRetry(BaseModel):
    r"""The retry policy of the job. Configure how many retries and the delay between them for each payload."""

    maximum_attempts: Annotated[
        Optional[int], pydantic.Field(alias="maximumAttempts")
    ] = 3
    r"""Maximum number of attempts to retry the run in case of failure"""


class GetJobsConfigurationTypedDict(TypedDict):
    r"""Job configuration settings"""

    retry: NotRequired[GetJobsConfigurationRetryTypedDict]
    r"""The retry policy of the job. Configure how many retries and the delay between them for each payload."""
    max_concurrent_requests: NotRequired[float]
    r"""The batch size of payloads to execute. This does not guarantee that the payloads will be executed at the same time."""
    request_timeout: NotRequired[int]
    r"""Timeout for the API request in seconds. Default is 10 minutes (600 seconds)."""


class GetJobsConfiguration(BaseModel):
    r"""Job configuration settings"""

    retry: Optional[GetJobsConfigurationRetry] = None
    r"""The retry policy of the job. Configure how many retries and the delay between them for each payload."""

    max_concurrent_requests: Annotated[
        Optional[float], pydantic.Field(alias="maxConcurrentRequests")
    ] = None
    r"""The batch size of payloads to execute. This does not guarantee that the payloads will be executed at the same time."""

    request_timeout: Annotated[
        Optional[int], pydantic.Field(alias="requestTimeout")
    ] = 600
    r"""Timeout for the API request in seconds. Default is 10 minutes (600 seconds)."""


class GetJobsPayloadRetryTypedDict(TypedDict):
    r"""Retry policy configurations in case of failure."""

    maximum_attempts: NotRequired[int]
    r"""Maximum number of attempts to retry the run in case of failure"""


class GetJobsPayloadRetry(BaseModel):
    r"""Retry policy configurations in case of failure."""

    maximum_attempts: Annotated[
        Optional[int], pydantic.Field(alias="maximumAttempts")
    ] = 3
    r"""Maximum number of attempts to retry the run in case of failure"""


class GetJobsPayloadTypedDict(TypedDict):
    parameters: Dict[str, Any]
    r"""The parameters to be passed to the API."""
    api_name: str
    r"""The name of the API to be executed. This is the file path relative to the `api` folder inside your project."""
    request_timeout: NotRequired[int]
    r"""Timeout for the API request in seconds. Default is 10 minutes (600 seconds)."""
    retry: NotRequired[GetJobsPayloadRetryTypedDict]
    r"""Retry policy configurations in case of failure."""


class GetJobsPayload(BaseModel):
    parameters: Dict[str, Any]
    r"""The parameters to be passed to the API."""

    api_name: Annotated[str, pydantic.Field(alias="apiName")]
    r"""The name of the API to be executed. This is the file path relative to the `api` folder inside your project."""

    request_timeout: Annotated[
        Optional[int], pydantic.Field(alias="requestTimeout")
    ] = 600
    r"""Timeout for the API request in seconds. Default is 10 minutes (600 seconds)."""

    retry: Optional[GetJobsPayloadRetry] = None
    r"""Retry policy configurations in case of failure."""


GetJobsTypeS3 = Literal["s3",]


class GetJobsS3SinkConfigurationTypedDict(TypedDict):
    r"""Configuration for the S3 sink."""

    type: GetJobsTypeS3
    bucket: str
    r"""The name of the S3 bucket where the data will be stored."""
    access_key_id: str
    r"""The access key ID for the S3 bucket."""
    secret_access_key: str
    r"""The secret access key for the S3 bucket."""
    region: str
    r"""The region where the S3 bucket is located."""
    prefix: NotRequired[str]
    r"""Optional prefix for the S3 objects. This can be used to organize objects within the bucket."""
    skip_on_fail: NotRequired[bool]
    r"""If enabled, failed payload runs will ***not*** be written to the bucket."""
    apis_to_send: NotRequired[List[str]]
    r"""List of API names to be sent to the S3 bucket. If not provided, all APIs will be sent."""
    endpoint: NotRequired[str]
    r"""Optional custom endpoint for the S3 bucket. This can be used for S3-compatible services."""
    force_path_style: NotRequired[bool]
    r"""If true, the S3 client will use path-style URLs instead of virtual-hosted-style URLs. This is useful for S3-compatible services that require path-style access."""


class GetJobsS3SinkConfiguration(BaseModel):
    r"""Configuration for the S3 sink."""

    type: GetJobsTypeS3

    bucket: str
    r"""The name of the S3 bucket where the data will be stored."""

    access_key_id: Annotated[str, pydantic.Field(alias="accessKeyId")]
    r"""The access key ID for the S3 bucket."""

    secret_access_key: Annotated[str, pydantic.Field(alias="secretAccessKey")]
    r"""The secret access key for the S3 bucket."""

    region: str
    r"""The region where the S3 bucket is located."""

    prefix: Optional[str] = None
    r"""Optional prefix for the S3 objects. This can be used to organize objects within the bucket."""

    skip_on_fail: Annotated[Optional[bool], pydantic.Field(alias="skipOnFail")] = False
    r"""If enabled, failed payload runs will ***not*** be written to the bucket."""

    apis_to_send: Annotated[Optional[List[str]], pydantic.Field(alias="apisToSend")] = (
        None
    )
    r"""List of API names to be sent to the S3 bucket. If not provided, all APIs will be sent."""

    endpoint: Optional[str] = None
    r"""Optional custom endpoint for the S3 bucket. This can be used for S3-compatible services."""

    force_path_style: Annotated[
        Optional[bool], pydantic.Field(alias="forcePathStyle")
    ] = None
    r"""If true, the S3 client will use path-style URLs instead of virtual-hosted-style URLs. This is useful for S3-compatible services that require path-style access."""


GetJobsTypeWebhook = Literal["webhook",]


class GetJobsWebhookSinkConfigurationTypedDict(TypedDict):
    r"""Configuration for the webhook sink."""

    type: GetJobsTypeWebhook
    url: str
    r"""The URL to which the webhook will send the data."""
    headers: NotRequired[Dict[str, str]]
    r"""Optional headers to be sent with the webhook request."""
    skip_on_fail: NotRequired[bool]
    r"""If true, the webhook will not be sent if the API execution fails."""
    apis_to_send: NotRequired[List[str]]
    r"""List of API names to be sent to the webhook. If not provided, all APIs will be sent."""


class GetJobsWebhookSinkConfiguration(BaseModel):
    r"""Configuration for the webhook sink."""

    type: GetJobsTypeWebhook

    url: str
    r"""The URL to which the webhook will send the data."""

    headers: Optional[Dict[str, str]] = None
    r"""Optional headers to be sent with the webhook request."""

    skip_on_fail: Annotated[Optional[bool], pydantic.Field(alias="skipOnFail")] = False
    r"""If true, the webhook will not be sent if the API execution fails."""

    apis_to_send: Annotated[Optional[List[str]], pydantic.Field(alias="apisToSend")] = (
        None
    )
    r"""List of API names to be sent to the webhook. If not provided, all APIs will be sent."""


GetJobsSinkTypedDict = TypeAliasType(
    "GetJobsSinkTypedDict",
    Union[
        GetJobsWebhookSinkConfigurationTypedDict, GetJobsS3SinkConfigurationTypedDict
    ],
)
r"""Optional sink configuration for the job. Can be a webhook or S3 Compatible sink."""


GetJobsSink = TypeAliasType(
    "GetJobsSink", Union[GetJobsWebhookSinkConfiguration, GetJobsS3SinkConfiguration]
)
r"""Optional sink configuration for the job. Can be a webhook or S3 Compatible sink."""


GetJobsJitterTypedDict = TypeAliasType("GetJobsJitterTypedDict", Union[int, str])


GetJobsJitter = TypeAliasType("GetJobsJitter", Union[int, str])


GetJobsEveryTypedDict = TypeAliasType("GetJobsEveryTypedDict", Union[int, str])


GetJobsEvery = TypeAliasType("GetJobsEvery", Union[int, str])


class GetJobsIntervalTypedDict(TypedDict):
    r"""An interval object, which represents a period to trigger the job. The interval is relative to the [Unix epoch](https://en.wikipedia.org/wiki/Unix_time)."""

    every: GetJobsEveryTypedDict


class GetJobsInterval(BaseModel):
    r"""An interval object, which represents a period to trigger the job. The interval is relative to the [Unix epoch](https://en.wikipedia.org/wiki/Unix_time)."""

    every: GetJobsEvery


GetJobsSecondEnum = Literal["*",]


class GetJobsSecond4TypedDict(TypedDict):
    start: int
    end: NotRequired[int]


class GetJobsSecond4(BaseModel):
    start: int

    end: Optional[int] = None


class GetJobsSecond3TypedDict(TypedDict):
    start: int
    step: int
    end: int


class GetJobsSecond3(BaseModel):
    start: int

    step: int

    end: int


GetJobsSecondUnion1TypedDict = TypeAliasType(
    "GetJobsSecondUnion1TypedDict",
    Union[GetJobsSecond4TypedDict, GetJobsSecond3TypedDict, int],
)


GetJobsSecondUnion1 = TypeAliasType(
    "GetJobsSecondUnion1", Union[GetJobsSecond4, GetJobsSecond3, int]
)


class GetJobsSecond2TypedDict(TypedDict):
    start: int
    end: NotRequired[int]


class GetJobsSecond2(BaseModel):
    start: int

    end: Optional[int] = None


class GetJobsSecond1TypedDict(TypedDict):
    start: int
    step: int
    end: int


class GetJobsSecond1(BaseModel):
    start: int

    step: int

    end: int


GetJobsSecondUnion2TypedDict = TypeAliasType(
    "GetJobsSecondUnion2TypedDict",
    Union[
        GetJobsSecond2TypedDict,
        GetJobsSecond1TypedDict,
        int,
        List[GetJobsSecondUnion1TypedDict],
        GetJobsSecondEnum,
    ],
)
r"""Seconds of the calendar, a number in the range 0 - 59"""


GetJobsSecondUnion2 = TypeAliasType(
    "GetJobsSecondUnion2",
    Union[
        GetJobsSecond2,
        GetJobsSecond1,
        int,
        List[GetJobsSecondUnion1],
        GetJobsSecondEnum,
    ],
)
r"""Seconds of the calendar, a number in the range 0 - 59"""


GetJobsMinuteEnum = Literal["*",]


class GetJobsMinute4TypedDict(TypedDict):
    start: int
    end: NotRequired[int]


class GetJobsMinute4(BaseModel):
    start: int

    end: Optional[int] = None


class GetJobsMinute3TypedDict(TypedDict):
    start: int
    step: int
    end: int


class GetJobsMinute3(BaseModel):
    start: int

    step: int

    end: int


GetJobsMinuteUnion1TypedDict = TypeAliasType(
    "GetJobsMinuteUnion1TypedDict",
    Union[GetJobsMinute4TypedDict, GetJobsMinute3TypedDict, int],
)


GetJobsMinuteUnion1 = TypeAliasType(
    "GetJobsMinuteUnion1", Union[GetJobsMinute4, GetJobsMinute3, int]
)


class GetJobsMinute2TypedDict(TypedDict):
    start: int
    end: NotRequired[int]


class GetJobsMinute2(BaseModel):
    start: int

    end: Optional[int] = None


class GetJobsMinute1TypedDict(TypedDict):
    start: int
    step: int
    end: int


class GetJobsMinute1(BaseModel):
    start: int

    step: int

    end: int


GetJobsMinuteUnion2TypedDict = TypeAliasType(
    "GetJobsMinuteUnion2TypedDict",
    Union[
        GetJobsMinute2TypedDict,
        GetJobsMinute1TypedDict,
        int,
        List[GetJobsMinuteUnion1TypedDict],
        GetJobsMinuteEnum,
    ],
)
r"""Minutes of the calendar, a number in the range 0 - 59"""


GetJobsMinuteUnion2 = TypeAliasType(
    "GetJobsMinuteUnion2",
    Union[
        GetJobsMinute2,
        GetJobsMinute1,
        int,
        List[GetJobsMinuteUnion1],
        GetJobsMinuteEnum,
    ],
)
r"""Minutes of the calendar, a number in the range 0 - 59"""


GetJobsHourEnum = Literal["*",]


class GetJobsHour4TypedDict(TypedDict):
    start: int
    end: NotRequired[int]


class GetJobsHour4(BaseModel):
    start: int

    end: Optional[int] = None


class GetJobsHour3TypedDict(TypedDict):
    start: int
    step: int
    end: int


class GetJobsHour3(BaseModel):
    start: int

    step: int

    end: int


GetJobsHourUnion1TypedDict = TypeAliasType(
    "GetJobsHourUnion1TypedDict",
    Union[GetJobsHour4TypedDict, GetJobsHour3TypedDict, int],
)


GetJobsHourUnion1 = TypeAliasType(
    "GetJobsHourUnion1", Union[GetJobsHour4, GetJobsHour3, int]
)


class GetJobsHour2TypedDict(TypedDict):
    start: int
    end: NotRequired[int]


class GetJobsHour2(BaseModel):
    start: int

    end: Optional[int] = None


class GetJobsHour1TypedDict(TypedDict):
    start: int
    step: int
    end: int


class GetJobsHour1(BaseModel):
    start: int

    step: int

    end: int


GetJobsHourUnion2TypedDict = TypeAliasType(
    "GetJobsHourUnion2TypedDict",
    Union[
        GetJobsHour2TypedDict,
        GetJobsHour1TypedDict,
        int,
        List[GetJobsHourUnion1TypedDict],
        GetJobsHourEnum,
    ],
)
r"""Hours of the calendar, a number in the range 0 - 23"""


GetJobsHourUnion2 = TypeAliasType(
    "GetJobsHourUnion2",
    Union[GetJobsHour2, GetJobsHour1, int, List[GetJobsHourUnion1], GetJobsHourEnum],
)
r"""Hours of the calendar, a number in the range 0 - 23"""


GetJobsDayOfWeekWildcard = Literal["*",]


GetJobsDayOfWeekStart4 = Literal[
    "SUNDAY",
    "MONDAY",
    "TUESDAY",
    "WEDNESDAY",
    "THURSDAY",
    "FRIDAY",
    "SATURDAY",
]


GetJobsDayOfWeekEnd4 = Literal[
    "SUNDAY",
    "MONDAY",
    "TUESDAY",
    "WEDNESDAY",
    "THURSDAY",
    "FRIDAY",
    "SATURDAY",
]


class GetJobsDayOfWeek4TypedDict(TypedDict):
    start: GetJobsDayOfWeekStart4
    end: NotRequired[GetJobsDayOfWeekEnd4]


class GetJobsDayOfWeek4(BaseModel):
    start: GetJobsDayOfWeekStart4

    end: Optional[GetJobsDayOfWeekEnd4] = None


GetJobsDayOfWeekStart3 = Literal[
    "SUNDAY",
    "MONDAY",
    "TUESDAY",
    "WEDNESDAY",
    "THURSDAY",
    "FRIDAY",
    "SATURDAY",
]


GetJobsDayOfWeekEnd3 = Literal[
    "SUNDAY",
    "MONDAY",
    "TUESDAY",
    "WEDNESDAY",
    "THURSDAY",
    "FRIDAY",
    "SATURDAY",
]


class GetJobsDayOfWeek3TypedDict(TypedDict):
    start: GetJobsDayOfWeekStart3
    step: int
    end: GetJobsDayOfWeekEnd3


class GetJobsDayOfWeek3(BaseModel):
    start: GetJobsDayOfWeekStart3

    step: int

    end: GetJobsDayOfWeekEnd3


GetJobsDayOfWeekEnum2 = Literal[
    "SUNDAY",
    "MONDAY",
    "TUESDAY",
    "WEDNESDAY",
    "THURSDAY",
    "FRIDAY",
    "SATURDAY",
]


GetJobsDayOfWeekUnion1TypedDict = TypeAliasType(
    "GetJobsDayOfWeekUnion1TypedDict",
    Union[
        GetJobsDayOfWeek4TypedDict, GetJobsDayOfWeek3TypedDict, GetJobsDayOfWeekEnum2
    ],
)


GetJobsDayOfWeekUnion1 = TypeAliasType(
    "GetJobsDayOfWeekUnion1",
    Union[GetJobsDayOfWeek4, GetJobsDayOfWeek3, GetJobsDayOfWeekEnum2],
)


GetJobsDayOfWeekStart2 = Literal[
    "SUNDAY",
    "MONDAY",
    "TUESDAY",
    "WEDNESDAY",
    "THURSDAY",
    "FRIDAY",
    "SATURDAY",
]


GetJobsDayOfWeekEnd2 = Literal[
    "SUNDAY",
    "MONDAY",
    "TUESDAY",
    "WEDNESDAY",
    "THURSDAY",
    "FRIDAY",
    "SATURDAY",
]


class GetJobsDayOfWeek2TypedDict(TypedDict):
    start: GetJobsDayOfWeekStart2
    end: NotRequired[GetJobsDayOfWeekEnd2]


class GetJobsDayOfWeek2(BaseModel):
    start: GetJobsDayOfWeekStart2

    end: Optional[GetJobsDayOfWeekEnd2] = None


GetJobsDayOfWeekStart1 = Literal[
    "SUNDAY",
    "MONDAY",
    "TUESDAY",
    "WEDNESDAY",
    "THURSDAY",
    "FRIDAY",
    "SATURDAY",
]


GetJobsDayOfWeekEnd1 = Literal[
    "SUNDAY",
    "MONDAY",
    "TUESDAY",
    "WEDNESDAY",
    "THURSDAY",
    "FRIDAY",
    "SATURDAY",
]


class GetJobsDayOfWeek1TypedDict(TypedDict):
    start: GetJobsDayOfWeekStart1
    step: int
    end: GetJobsDayOfWeekEnd1


class GetJobsDayOfWeek1(BaseModel):
    start: GetJobsDayOfWeekStart1

    step: int

    end: GetJobsDayOfWeekEnd1


GetJobsDayOfWeekEnum1 = Literal[
    "SUNDAY",
    "MONDAY",
    "TUESDAY",
    "WEDNESDAY",
    "THURSDAY",
    "FRIDAY",
    "SATURDAY",
]


GetJobsDayOfWeekUnion2TypedDict = TypeAliasType(
    "GetJobsDayOfWeekUnion2TypedDict",
    Union[
        GetJobsDayOfWeek2TypedDict,
        GetJobsDayOfWeek1TypedDict,
        GetJobsDayOfWeekEnum1,
        List[GetJobsDayOfWeekUnion1TypedDict],
        GetJobsDayOfWeekWildcard,
    ],
)
r"""Days of week, one of SUNDAY, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY"""


GetJobsDayOfWeekUnion2 = TypeAliasType(
    "GetJobsDayOfWeekUnion2",
    Union[
        GetJobsDayOfWeek2,
        GetJobsDayOfWeek1,
        GetJobsDayOfWeekEnum1,
        List[GetJobsDayOfWeekUnion1],
        GetJobsDayOfWeekWildcard,
    ],
)
r"""Days of week, one of SUNDAY, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY"""


GetJobsDayOfMonthEnum = Literal["*",]


class GetJobsDayOfMonth4TypedDict(TypedDict):
    start: int
    end: NotRequired[int]


class GetJobsDayOfMonth4(BaseModel):
    start: int

    end: Optional[int] = None


class GetJobsDayOfMonth3TypedDict(TypedDict):
    start: int
    step: int
    end: int


class GetJobsDayOfMonth3(BaseModel):
    start: int

    step: int

    end: int


GetJobsDayOfMonthUnion1TypedDict = TypeAliasType(
    "GetJobsDayOfMonthUnion1TypedDict",
    Union[GetJobsDayOfMonth4TypedDict, GetJobsDayOfMonth3TypedDict, int],
)


GetJobsDayOfMonthUnion1 = TypeAliasType(
    "GetJobsDayOfMonthUnion1", Union[GetJobsDayOfMonth4, GetJobsDayOfMonth3, int]
)


class GetJobsDayOfMonth2TypedDict(TypedDict):
    start: int
    end: NotRequired[int]


class GetJobsDayOfMonth2(BaseModel):
    start: int

    end: Optional[int] = None


class GetJobsDayOfMonth1TypedDict(TypedDict):
    start: int
    step: int
    end: int


class GetJobsDayOfMonth1(BaseModel):
    start: int

    step: int

    end: int


GetJobsDayOfMonthUnion2TypedDict = TypeAliasType(
    "GetJobsDayOfMonthUnion2TypedDict",
    Union[
        GetJobsDayOfMonth2TypedDict,
        GetJobsDayOfMonth1TypedDict,
        int,
        List[GetJobsDayOfMonthUnion1TypedDict],
        GetJobsDayOfMonthEnum,
    ],
)
r"""Days of the month, a number in the range 1 - 31"""


GetJobsDayOfMonthUnion2 = TypeAliasType(
    "GetJobsDayOfMonthUnion2",
    Union[
        GetJobsDayOfMonth2,
        GetJobsDayOfMonth1,
        int,
        List[GetJobsDayOfMonthUnion1],
        GetJobsDayOfMonthEnum,
    ],
)
r"""Days of the month, a number in the range 1 - 31"""


GetJobsMonthWildcard = Literal["*",]


GetJobsMonthStart4 = Literal[
    "JANUARY",
    "FEBRUARY",
    "MARCH",
    "APRIL",
    "MAY",
    "JUNE",
    "JULY",
    "AUGUST",
    "SEPTEMBER",
    "OCTOBER",
    "NOVEMBER",
    "DECEMBER",
]


GetJobsMonthEnd4 = Literal[
    "JANUARY",
    "FEBRUARY",
    "MARCH",
    "APRIL",
    "MAY",
    "JUNE",
    "JULY",
    "AUGUST",
    "SEPTEMBER",
    "OCTOBER",
    "NOVEMBER",
    "DECEMBER",
]


class GetJobsMonth4TypedDict(TypedDict):
    start: GetJobsMonthStart4
    end: NotRequired[GetJobsMonthEnd4]


class GetJobsMonth4(BaseModel):
    start: GetJobsMonthStart4

    end: Optional[GetJobsMonthEnd4] = None


GetJobsMonthStart3 = Literal[
    "JANUARY",
    "FEBRUARY",
    "MARCH",
    "APRIL",
    "MAY",
    "JUNE",
    "JULY",
    "AUGUST",
    "SEPTEMBER",
    "OCTOBER",
    "NOVEMBER",
    "DECEMBER",
]


GetJobsMonthEnd3 = Literal[
    "JANUARY",
    "FEBRUARY",
    "MARCH",
    "APRIL",
    "MAY",
    "JUNE",
    "JULY",
    "AUGUST",
    "SEPTEMBER",
    "OCTOBER",
    "NOVEMBER",
    "DECEMBER",
]


class GetJobsMonth3TypedDict(TypedDict):
    start: GetJobsMonthStart3
    step: int
    end: GetJobsMonthEnd3


class GetJobsMonth3(BaseModel):
    start: GetJobsMonthStart3

    step: int

    end: GetJobsMonthEnd3


GetJobsMonthEnum2 = Literal[
    "JANUARY",
    "FEBRUARY",
    "MARCH",
    "APRIL",
    "MAY",
    "JUNE",
    "JULY",
    "AUGUST",
    "SEPTEMBER",
    "OCTOBER",
    "NOVEMBER",
    "DECEMBER",
]


GetJobsMonthUnion1TypedDict = TypeAliasType(
    "GetJobsMonthUnion1TypedDict",
    Union[GetJobsMonth4TypedDict, GetJobsMonth3TypedDict, GetJobsMonthEnum2],
)


GetJobsMonthUnion1 = TypeAliasType(
    "GetJobsMonthUnion1", Union[GetJobsMonth4, GetJobsMonth3, GetJobsMonthEnum2]
)


GetJobsMonthStart2 = Literal[
    "JANUARY",
    "FEBRUARY",
    "MARCH",
    "APRIL",
    "MAY",
    "JUNE",
    "JULY",
    "AUGUST",
    "SEPTEMBER",
    "OCTOBER",
    "NOVEMBER",
    "DECEMBER",
]


GetJobsMonthEnd2 = Literal[
    "JANUARY",
    "FEBRUARY",
    "MARCH",
    "APRIL",
    "MAY",
    "JUNE",
    "JULY",
    "AUGUST",
    "SEPTEMBER",
    "OCTOBER",
    "NOVEMBER",
    "DECEMBER",
]


class GetJobsMonth2TypedDict(TypedDict):
    start: GetJobsMonthStart2
    end: NotRequired[GetJobsMonthEnd2]


class GetJobsMonth2(BaseModel):
    start: GetJobsMonthStart2

    end: Optional[GetJobsMonthEnd2] = None


GetJobsMonthStart1 = Literal[
    "JANUARY",
    "FEBRUARY",
    "MARCH",
    "APRIL",
    "MAY",
    "JUNE",
    "JULY",
    "AUGUST",
    "SEPTEMBER",
    "OCTOBER",
    "NOVEMBER",
    "DECEMBER",
]


GetJobsMonthEnd1 = Literal[
    "JANUARY",
    "FEBRUARY",
    "MARCH",
    "APRIL",
    "MAY",
    "JUNE",
    "JULY",
    "AUGUST",
    "SEPTEMBER",
    "OCTOBER",
    "NOVEMBER",
    "DECEMBER",
]


class GetJobsMonth1TypedDict(TypedDict):
    start: GetJobsMonthStart1
    step: int
    end: GetJobsMonthEnd1


class GetJobsMonth1(BaseModel):
    start: GetJobsMonthStart1

    step: int

    end: GetJobsMonthEnd1


GetJobsMonthEnum1 = Literal[
    "JANUARY",
    "FEBRUARY",
    "MARCH",
    "APRIL",
    "MAY",
    "JUNE",
    "JULY",
    "AUGUST",
    "SEPTEMBER",
    "OCTOBER",
    "NOVEMBER",
    "DECEMBER",
]


GetJobsMonthUnion2TypedDict = TypeAliasType(
    "GetJobsMonthUnion2TypedDict",
    Union[
        GetJobsMonth2TypedDict,
        GetJobsMonth1TypedDict,
        GetJobsMonthEnum1,
        List[GetJobsMonthUnion1TypedDict],
        GetJobsMonthWildcard,
    ],
)
r"""Months, one of JANUARY, FEBRUARY, MARCH, APRIL, MAY, JUNE, JULY, AUGUST, SEPTEMBER, OCTOBER, NOVEMBER, DECEMBER"""


GetJobsMonthUnion2 = TypeAliasType(
    "GetJobsMonthUnion2",
    Union[
        GetJobsMonth2,
        GetJobsMonth1,
        GetJobsMonthEnum1,
        List[GetJobsMonthUnion1],
        GetJobsMonthWildcard,
    ],
)
r"""Months, one of JANUARY, FEBRUARY, MARCH, APRIL, MAY, JUNE, JULY, AUGUST, SEPTEMBER, OCTOBER, NOVEMBER, DECEMBER"""


GetJobsYearEnum = Literal["*",]


class GetJobsYear4TypedDict(TypedDict):
    start: int
    end: NotRequired[int]


class GetJobsYear4(BaseModel):
    start: int

    end: Optional[int] = None


class GetJobsYear3TypedDict(TypedDict):
    start: int
    step: int
    end: int


class GetJobsYear3(BaseModel):
    start: int

    step: int

    end: int


GetJobsYearUnion1TypedDict = TypeAliasType(
    "GetJobsYearUnion1TypedDict",
    Union[GetJobsYear4TypedDict, GetJobsYear3TypedDict, int],
)


GetJobsYearUnion1 = TypeAliasType(
    "GetJobsYearUnion1", Union[GetJobsYear4, GetJobsYear3, int]
)


class GetJobsYear2TypedDict(TypedDict):
    start: int
    end: NotRequired[int]


class GetJobsYear2(BaseModel):
    start: int

    end: Optional[int] = None


class GetJobsYear1TypedDict(TypedDict):
    start: int
    step: int
    end: int


class GetJobsYear1(BaseModel):
    start: int

    step: int

    end: int


GetJobsYearUnion2TypedDict = TypeAliasType(
    "GetJobsYearUnion2TypedDict",
    Union[
        GetJobsYear2TypedDict,
        GetJobsYear1TypedDict,
        int,
        List[GetJobsYearUnion1TypedDict],
        GetJobsYearEnum,
    ],
)
r"""Full year. For example: 2024"""


GetJobsYearUnion2 = TypeAliasType(
    "GetJobsYearUnion2",
    Union[GetJobsYear2, GetJobsYear1, int, List[GetJobsYearUnion1], GetJobsYearEnum],
)
r"""Full year. For example: 2024"""


class GetJobsCalendarTypedDict(TypedDict):
    r"""A calendar object. It is similar to a cron string, but more verbose."""

    second: NotRequired[GetJobsSecondUnion2TypedDict]
    r"""Seconds of the calendar, a number in the range 0 - 59"""
    minute: NotRequired[GetJobsMinuteUnion2TypedDict]
    r"""Minutes of the calendar, a number in the range 0 - 59"""
    hour: NotRequired[GetJobsHourUnion2TypedDict]
    r"""Hours of the calendar, a number in the range 0 - 23"""
    day_of_week: NotRequired[GetJobsDayOfWeekUnion2TypedDict]
    r"""Days of week, one of SUNDAY, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY"""
    day_of_month: NotRequired[GetJobsDayOfMonthUnion2TypedDict]
    r"""Days of the month, a number in the range 1 - 31"""
    month: NotRequired[GetJobsMonthUnion2TypedDict]
    r"""Months, one of JANUARY, FEBRUARY, MARCH, APRIL, MAY, JUNE, JULY, AUGUST, SEPTEMBER, OCTOBER, NOVEMBER, DECEMBER"""
    year: NotRequired[GetJobsYearUnion2TypedDict]
    r"""Full year. For example: 2024"""
    comment: NotRequired[str]
    r"""A comment to describe what the calendar is supposed to represent"""


class GetJobsCalendar(BaseModel):
    r"""A calendar object. It is similar to a cron string, but more verbose."""

    second: Optional[GetJobsSecondUnion2] = None
    r"""Seconds of the calendar, a number in the range 0 - 59"""

    minute: Optional[GetJobsMinuteUnion2] = None
    r"""Minutes of the calendar, a number in the range 0 - 59"""

    hour: Optional[GetJobsHourUnion2] = None
    r"""Hours of the calendar, a number in the range 0 - 23"""

    day_of_week: Annotated[
        Optional[GetJobsDayOfWeekUnion2], pydantic.Field(alias="dayOfWeek")
    ] = None
    r"""Days of week, one of SUNDAY, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY"""

    day_of_month: Annotated[
        Optional[GetJobsDayOfMonthUnion2], pydantic.Field(alias="dayOfMonth")
    ] = None
    r"""Days of the month, a number in the range 1 - 31"""

    month: Optional[GetJobsMonthUnion2] = None
    r"""Months, one of JANUARY, FEBRUARY, MARCH, APRIL, MAY, JUNE, JULY, AUGUST, SEPTEMBER, OCTOBER, NOVEMBER, DECEMBER"""

    year: Optional[GetJobsYearUnion2] = None
    r"""Full year. For example: 2024"""

    comment: Optional[str] = None
    r"""A comment to describe what the calendar is supposed to represent"""


class GetJobsScheduleTypedDict(TypedDict):
    r"""Schedule configurations for the job. If set, the job will periodically run according to this configuration. The configurations are used to calculate the closest next run time."""

    jitter: NotRequired[GetJobsJitterTypedDict]
    intervals: NotRequired[List[GetJobsIntervalTypedDict]]
    r"""An array of interval objects"""
    calendars: NotRequired[List[GetJobsCalendarTypedDict]]
    r"""An array of calendar objects"""


class GetJobsSchedule(BaseModel):
    r"""Schedule configurations for the job. If set, the job will periodically run according to this configuration. The configurations are used to calculate the closest next run time."""

    jitter: Optional[GetJobsJitter] = None

    intervals: Optional[List[GetJobsInterval]] = None
    r"""An array of interval objects"""

    calendars: Optional[List[GetJobsCalendar]] = None
    r"""An array of calendar objects"""


class GetJobsAuthSessionTypedDict(TypedDict):
    r"""Authentication session information for the job"""

    id: str
    check_attempts: NotRequired[int]
    r"""Number of attempts to check the validity of the auth session before recreating it."""
    create_attempts: NotRequired[int]
    r"""Number of attempts to create a new auth session if the current one is invalid or expired."""


class GetJobsAuthSession(BaseModel):
    r"""Authentication session information for the job"""

    id: str

    check_attempts: Annotated[Optional[int], pydantic.Field(alias="checkAttempts")] = 3
    r"""Number of attempts to check the validity of the auth session before recreating it."""

    create_attempts: Annotated[
        Optional[int], pydantic.Field(alias="createAttempts")
    ] = 3
    r"""Number of attempts to create a new auth session if the current one is invalid or expired."""


GetJobsVersion = Literal["v1",]


class GetJobsProxyTypedDict(TypedDict):
    r"""Proxy configuration for the job, stored as JSONB"""

    version: GetJobsVersion
    url: str


class GetJobsProxy(BaseModel):
    r"""Proxy configuration for the job, stored as JSONB"""

    version: GetJobsVersion

    url: str


GetJobsReasonType = Literal[
    "paused",
    "terminated",
]


class GetJobsReasonTypedDict(TypedDict):
    r"""Reason for job state change, stored as JSONB"""

    type: GetJobsReasonType
    message: str
    details: NotRequired[Any]
    timestamp: NotRequired[datetime]


class GetJobsReason(BaseModel):
    r"""Reason for job state change, stored as JSONB"""

    type: GetJobsReasonType

    message: str

    details: Optional[Any] = None

    timestamp: Optional[datetime] = None


GetJobsState = Literal[
    "ACTIVE",
    "PAUSED",
]
r"""Current state of the job"""


class JobDBObjectSchemaTypedDict(TypedDict):
    r"""Complete job object as stored in the database"""

    id: str
    r"""The ID of the job. Has to be a valid URL slug."""
    workspace_id: str
    r"""UUID of the workspace this job belongs to"""
    project_id: str
    r"""UUID of the project this job belongs to"""
    configuration: GetJobsConfigurationTypedDict
    r"""Job configuration settings"""
    payload: List[GetJobsPayloadTypedDict]
    r"""Array of API calls to be executed"""
    created_at: str
    r"""Timestamp when the job was created"""
    state: GetJobsState
    r"""Current state of the job"""
    sink: NotRequired[Nullable[GetJobsSinkTypedDict]]
    r"""Optional sink configuration for the job. Can be a webhook or S3 Compatible sink."""
    schedule: NotRequired[Nullable[GetJobsScheduleTypedDict]]
    r"""Schedule configurations for the job. If set, the job will periodically run according to this configuration. The configurations are used to calculate the closest next run time."""
    next_run_time: NotRequired[Nullable[str]]
    r"""The timestamp of the next scheduled job run. `null` if the job does not have a schedule."""
    last_run_time: NotRequired[Nullable[str]]
    r"""Timestamp of the last completed run"""
    auth_session: NotRequired[Nullable[GetJobsAuthSessionTypedDict]]
    r"""Authentication session information for the job"""
    proxy: NotRequired[Nullable[GetJobsProxyTypedDict]]
    r"""Proxy configuration for the job, stored as JSONB"""
    reason: NotRequired[Nullable[GetJobsReasonTypedDict]]
    r"""Reason for job state change, stored as JSONB"""
    schedule_id: NotRequired[Nullable[str]]
    r"""ID of the temporal schedule associated with this job"""


class JobDBObjectSchema(BaseModel):
    r"""Complete job object as stored in the database"""

    id: str
    r"""The ID of the job. Has to be a valid URL slug."""

    workspace_id: str
    r"""UUID of the workspace this job belongs to"""

    project_id: str
    r"""UUID of the project this job belongs to"""

    configuration: GetJobsConfiguration
    r"""Job configuration settings"""

    payload: List[GetJobsPayload]
    r"""Array of API calls to be executed"""

    created_at: str
    r"""Timestamp when the job was created"""

    state: GetJobsState
    r"""Current state of the job"""

    sink: OptionalNullable[GetJobsSink] = UNSET
    r"""Optional sink configuration for the job. Can be a webhook or S3 Compatible sink."""

    schedule: OptionalNullable[GetJobsSchedule] = UNSET
    r"""Schedule configurations for the job. If set, the job will periodically run according to this configuration. The configurations are used to calculate the closest next run time."""

    next_run_time: OptionalNullable[str] = UNSET
    r"""The timestamp of the next scheduled job run. `null` if the job does not have a schedule."""

    last_run_time: OptionalNullable[str] = UNSET
    r"""Timestamp of the last completed run"""

    auth_session: OptionalNullable[GetJobsAuthSession] = UNSET
    r"""Authentication session information for the job"""

    proxy: OptionalNullable[GetJobsProxy] = UNSET
    r"""Proxy configuration for the job, stored as JSONB"""

    reason: OptionalNullable[GetJobsReason] = UNSET
    r"""Reason for job state change, stored as JSONB"""

    schedule_id: OptionalNullable[str] = UNSET
    r"""ID of the temporal schedule associated with this job"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = [
            "sink",
            "schedule",
            "next_run_time",
            "last_run_time",
            "auth_session",
            "proxy",
            "reason",
            "schedule_id",
        ]
        nullable_fields = [
            "sink",
            "schedule",
            "next_run_time",
            "last_run_time",
            "auth_session",
            "proxy",
            "reason",
            "schedule_id",
        ]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class GetJobsResponseTypedDict(TypedDict):
    r"""List of jobs in the project."""

    jobs: List[JobDBObjectSchemaTypedDict]


class GetJobsResponse(BaseModel):
    r"""List of jobs in the project."""

    jobs: List[JobDBObjectSchema]
