// This file is auto-generated by @hey-api/openapi-ts

import type { Options as ClientOptions, TDataShape, Client } from '@hey-api/client-axios';
import type { ProjectDeleteProjectSessionData, ProjectDeleteProjectSessionResponse, ProjectDeleteProjectSessionError, ProjectGetProjectData, ProjectGetProjectResponse, ProjectGetProjectError, ProjectPostProjectData, ProjectPostProjectResponse, ProjectPostProjectError, ProjectGetGlobalConfigStatusData, ProjectGetGlobalConfigStatusResponse, ProjectInitProjectData, ProjectInitProjectResponse, ProjectInitProjectError, ProjectPostGlobalConfigData, ProjectPostGlobalConfigResponse, ProjectPostLockAcquireData, ProjectPostLockAcquireResponse, ProjectPostLockAcquireError, ProjectGetLockStatusData, ProjectGetLockStatusResponse, ProjectGetLockStatusError, ProjectPatchMasterdataData, ProjectPatchMasterdataResponse, ProjectPatchMasterdataError, ProjectPatchModelData, ProjectPatchModelResponse, ProjectPatchModelError, ProjectPatchAccessData, ProjectPatchAccessResponse, ProjectPatchAccessError, UserGetUserData, UserGetUserResponse, UserGetUserError, UserPatchApiKeyData, UserPatchApiKeyResponse, UserPatchApiKeyError, SessionCreateSessionData, SessionCreateSessionResponse, SessionCreateSessionError, SessionPatchAccessTokenData, SessionPatchAccessTokenResponse, SessionPatchAccessTokenError, SmdaGetHealthData, SmdaGetHealthResponse, SmdaGetHealthError, SmdaPostFieldData, SmdaPostFieldResponse, SmdaPostFieldError, SmdaPostMasterdataData, SmdaPostMasterdataResponse, SmdaPostMasterdataError, HealthV1HealthCheckData, HealthV1HealthCheckResponse, HealthV1HealthCheckError, HealthHealthCheckData, HealthHealthCheckResponse } from './types.gen';
import { client as _heyApiClient } from './client.gen';

export type Options<TData extends TDataShape = TDataShape, ThrowOnError extends boolean = boolean> = ClientOptions<TData, ThrowOnError> & {
    /**
     * You can provide a client instance returned by `createClient()` instead of
     * individual options. This might be also useful if you want to implement a
     * custom client.
     */
    client?: Client;
    /**
     * You can pass arbitrary values through the `meta` object. This can be
     * used to access values that aren't defined as part of the SDK function.
     */
    meta?: Record<string, unknown>;
};

/**
 * Removes a project .fmu directory from a session
 * This route simply removes (closes) a project .fmu directory from a session.
 * This has no other side effects on the session.
 */
export const projectDeleteProjectSession = <ThrowOnError extends boolean = false>(options?: Options<ProjectDeleteProjectSessionData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).delete<ProjectDeleteProjectSessionResponse, ProjectDeleteProjectSessionError, ThrowOnError>({
        url: '/api/v1/project/',
        ...options
    });
};

/**
 * Returns the paths and configuration of the nearest project .fmu directory
 * If a project is not already attached to the session id it will be
 * attached after a call to this route. If one is already attached this
 * route will return data for the project .fmu directory again.
 */
export const projectGetProject = <ThrowOnError extends boolean = false>(options?: Options<ProjectGetProjectData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<ProjectGetProjectResponse, ProjectGetProjectError, ThrowOnError>({
        url: '/api/v1/project/',
        ...options
    });
};

/**
 * Returns the path and configuration of the project .fmu directory at 'path'
 * Used for when a user selects a project .fmu directory in a directory not
 * found above the user's current working directory. Will overwrite the
 * project .fmu directory attached to a session if one exists. If not, it is
 * added to the session.
 */
export const projectPostProject = <ThrowOnError extends boolean = false>(options: Options<ProjectPostProjectData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<ProjectPostProjectResponse, ProjectPostProjectError, ThrowOnError>({
        url: '/api/v1/project/',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Checks if a valid global config exists at the default location.
 * Checks the global config at the default project location. If the global config
 * does not validate, or is not found, a failed status code is returned.
 */
export const projectGetGlobalConfigStatus = <ThrowOnError extends boolean = false>(options?: Options<ProjectGetGlobalConfigStatusData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<ProjectGetGlobalConfigStatusResponse, unknown, ThrowOnError>({
        url: '/api/v1/project/global_config_status',
        ...options
    });
};

/**
 * Initializes a project .fmu directory at 'path' and returns its paths and configuration
 * If a project .fmu directory is already attached to the session, this will
 * switch to use the newly created .fmu directory.
 */
export const projectInitProject = <ThrowOnError extends boolean = false>(options: Options<ProjectInitProjectData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<ProjectInitProjectResponse, ProjectInitProjectError, ThrowOnError>({
        url: '/api/v1/project/init',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Loads the global config into the project masterdata.
 * Loads the global config into the project masterdata. If the global config does
 * not validate, or is not found, a failed status code is returned. The endpoint
 * takes an optional parameter, `path` as input: This should be given as a relative
 * path, relative to the project root. If provided, the global config is searched
 * for at this path. If not, the default project path will be used.
 */
export const projectPostGlobalConfig = <ThrowOnError extends boolean = false>(options?: Options<ProjectPostGlobalConfigData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).post<ProjectPostGlobalConfigResponse, unknown, ThrowOnError>({
        url: '/api/v1/project/global_config',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Attempts to acquire the project lock for editing
 * Tries to upgrade the project session from read-only to editable by acquiring
 * the project lock. If the lock cannot be acquired the project remains read-only
 * and the last lock acquire error is recorded in the session.
 */
export const projectPostLockAcquire = <ThrowOnError extends boolean = false>(options?: Options<ProjectPostLockAcquireData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).post<ProjectPostLockAcquireResponse, ProjectPostLockAcquireError, ThrowOnError>({
        url: '/api/v1/project/lock_acquire',
        ...options
    });
};

/**
 * Returns the lock status and lock file contents
 * Returns information about the project lock including whether the current
 * session holds the lock and the contents of the lock file if it exists.
 * This is useful for debugging lock conflicts and showing users who has
 * the project locked.
 */
export const projectGetLockStatus = <ThrowOnError extends boolean = false>(options?: Options<ProjectGetLockStatusData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<ProjectGetLockStatusResponse, ProjectGetLockStatusError, ThrowOnError>({
        url: '/api/v1/project/lock_status',
        ...options
    });
};

/**
 * Saves SMDA masterdata to the project .fmu directory
 * Saves masterdata from SMDA to the project .fmu directory.
 * If existing masterdata is present, it will be updated with the new masterdata.
 */
export const projectPatchMasterdata = <ThrowOnError extends boolean = false>(options: Options<ProjectPatchMasterdataData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).patch<ProjectPatchMasterdataResponse, ProjectPatchMasterdataError, ThrowOnError>({
        url: '/api/v1/project/masterdata',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Saves model data to the project .fmu directory
 * Saves model data to the project .fmu directory.
 * If existing model data is present, it will be replaced by the new
 * model data.
 */
export const projectPatchModel = <ThrowOnError extends boolean = false>(options: Options<ProjectPatchModelData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).patch<ProjectPatchModelResponse, ProjectPatchModelError, ThrowOnError>({
        url: '/api/v1/project/model',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Saves access data to the project .fmu directory
 * Saves access data to the project .fmu directory.
 * If existing access data is present, it will be replaced by the new
 * access data.
 */
export const projectPatchAccess = <ThrowOnError extends boolean = false>(options: Options<ProjectPatchAccessData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).patch<ProjectPatchAccessResponse, ProjectPatchAccessError, ThrowOnError>({
        url: '/api/v1/project/access',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Returns the user .fmu configuration
 * The user configuration can store API subscription keys or tokens. These are
 * obfuscated as '**********' when returned.
 */
export const userGetUser = <ThrowOnError extends boolean = false>(options?: Options<UserGetUserData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<UserGetUserResponse, UserGetUserError, ThrowOnError>({
        url: '/api/v1/user/',
        ...options
    });
};

/**
 * Saves an API key/token to the user .fmu configuration
 * Currently only known API's can be saved to the user .fmu configuration.
 * Arbitrary API key-value pairs cannot be saved. The currently known APIs are:
 *
 * smda_subscription
 */
export const userPatchApiKey = <ThrowOnError extends boolean = false>(options: Options<UserPatchApiKeyData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).patch<UserPatchApiKeyResponse, UserPatchApiKeyError, ThrowOnError>({
        url: '/api/v1/user/api_key',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Creates a session for the user
 * When creating a session the application will ensure that the user
 * .fmu directory exists by creating it if it does not. It will also
 * heck for the nearest project .fmu directory above the current
 * working directory, and if one exists, add it to the session. If
 * it does not exist its value will be `null`.
 *
 * If a session already exists when POSTing to this route, the existing
 * session will be silently destroyed. This will remove any state for
 * a project .fmu that may be opened.
 *
 * The session cookie set by this route is required for all other
 * routes. Sessions are not persisted when the API is shut down.
 */
export const sessionCreateSession = <ThrowOnError extends boolean = false>(options?: Options<SessionCreateSessionData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).post<SessionCreateSessionResponse, SessionCreateSessionError, ThrowOnError>({
        security: [
            {
                name: 'x-fmu-settings-api',
                type: 'apiKey'
            }
        ],
        url: '/api/v1/session/',
        ...options
    });
};

/**
 * Adds a known access token to the session
 * This route should be used to add a scoped access token to the current
 * session. The token applied via this route is typically a dependency for
 * other routes.
 */
export const sessionPatchAccessToken = <ThrowOnError extends boolean = false>(options: Options<SessionPatchAccessTokenData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).patch<SessionPatchAccessTokenResponse, SessionPatchAccessTokenError, ThrowOnError>({
        url: '/api/v1/session/access_token',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Checks whether or not the current session is capable of querying SMDA
 * A route to check whether the client is capable of querying SMDA APIs
 * with their current session. The requirements for querying the SMDA API via
 * this API are:
 *
 * 1. A valid session
 * 2. An SMDA subscription key in the user's .fmu API key configuration
 * 3. A valid SMDA access token scoped to SMDA's user_impersonation scope
 *
 * A successful response from this route indicates that all other routes on the
 * SMDA router can be used.
 */
export const smdaGetHealth = <ThrowOnError extends boolean = false>(options?: Options<SmdaGetHealthData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<SmdaGetHealthResponse, SmdaGetHealthError, ThrowOnError>({
        url: '/api/v1/smda/health',
        ...options
    });
};

/**
 * Searches for a field identifier in SMDA
 * A route to search SMDA for an field (asset) by its named identifier.
 *
 * This endpoint applies a projection to the SMDA query so that only the relevant
 * data is returned: an identifier known by SMDA and its corresponding UUID. The
 * UUID should be used by other endpoints required the collection of data by a
 * field, i.e. this route is a dependency for most other routes.
 *
 * The number of results (hits) and number of pages those results span over is also
 * returned in the result. This endpoint does not implement pagination. The
 * current expectation is that a user would refine their search rather than page
 * through different results.
 */
export const smdaPostField = <ThrowOnError extends boolean = false>(options: Options<SmdaPostFieldData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<SmdaPostFieldResponse, SmdaPostFieldError, ThrowOnError>({
        url: '/api/v1/smda/field',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Retrieves masterdata for fields to be confirmed in the GUI
 * A route to gather prospective SMDA masterdata relevant to FMU.
 *
 * This route receives a list of valid field names and returns masterdata that
 * pertains to them. The field names should be valid as return from from the
 * `smda/field` routes.
 *
 * The data returned from this endpoint is meant to be confirmed by the user who
 * may need to do some additional selection or pruning based upon the model they
 * are working from.
 *
 * One example of this is changing the coordinate system. A model may use a
 * coordinate system different from the one set as the field's default coordinate
 * system in SMDA. To match the way this works on SMDA, every coordinate system
 * known to SMDA is returned.
 *
 * This endpoint does multiple calls to the SMDA API, any of which may possibly
 * fail. In any of these calls fails incomplete data will _not_ be returned; that
 * is, a successful code with partial data will not be returned.
 */
export const smdaPostMasterdata = <ThrowOnError extends boolean = false>(options: Options<SmdaPostMasterdataData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<SmdaPostMasterdataResponse, SmdaPostMasterdataError, ThrowOnError>({
        url: '/api/v1/smda/masterdata',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * A health check on the /v1 routes.
 * This route requires a valid session to return 200 OK. it can used to check if the user has a valid session.
 */
export const healthV1HealthCheck = <ThrowOnError extends boolean = false>(options?: Options<HealthV1HealthCheckData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<HealthV1HealthCheckResponse, HealthV1HealthCheckError, ThrowOnError>({
        url: '/api/v1/health',
        ...options
    });
};

/**
 * A health check on the application
 * This route requires no form of authentication or authorization. It can be used to check if the application is running and responsive.
 */
export const healthHealthCheck = <ThrowOnError extends boolean = false>(options?: Options<HealthHealthCheckData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<HealthHealthCheckResponse, unknown, ThrowOnError>({
        url: '/health',
        ...options
    });
};