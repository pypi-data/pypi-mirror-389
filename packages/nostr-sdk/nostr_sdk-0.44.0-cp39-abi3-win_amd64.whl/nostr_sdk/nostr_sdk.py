

# This file was autogenerated by some hot garbage in the `uniffi` crate.
# Trust me, you don't want to mess with it!

# Common helper code.
#
# Ideally this would live in a separate .py file where it can be unittested etc
# in isolation, and perhaps even published as a re-useable package.
#
# However, it's important that the details of how this helper code works (e.g. the
# way that different builtin types are passed across the FFI) exactly match what's
# expected by the rust code on the other side of the interface. In practice right
# now that means coming from the exact some version of `uniffi` that was used to
# compile the rust component. The easiest way to ensure this is to bundle the Python
# helpers directly inline like we're doing here.

from __future__ import annotations
import os
import sys
import ctypes
import enum
import struct
import contextlib
import datetime
import threading
import itertools
import traceback
import typing
import asyncio
import platform

# Used for default argument values
_DEFAULT = object() # type: typing.Any


class _UniffiRustBuffer(ctypes.Structure):
    _fields_ = [
        ("capacity", ctypes.c_uint64),
        ("len", ctypes.c_uint64),
        ("data", ctypes.POINTER(ctypes.c_char)),
    ]

    @staticmethod
    def default():
        return _UniffiRustBuffer(0, 0, None)

    @staticmethod
    def alloc(size):
        return _uniffi_rust_call(_UniffiLib.ffi_nostr_sdk_ffi_rustbuffer_alloc, size)

    @staticmethod
    def reserve(rbuf, additional):
        return _uniffi_rust_call(_UniffiLib.ffi_nostr_sdk_ffi_rustbuffer_reserve, rbuf, additional)

    def free(self):
        return _uniffi_rust_call(_UniffiLib.ffi_nostr_sdk_ffi_rustbuffer_free, self)

    def __str__(self):
        return "_UniffiRustBuffer(capacity={}, len={}, data={})".format(
            self.capacity,
            self.len,
            self.data[0:self.len]
        )

    @contextlib.contextmanager
    def alloc_with_builder(*args):
        """Context-manger to allocate a buffer using a _UniffiRustBufferBuilder.

        The allocated buffer will be automatically freed if an error occurs, ensuring that
        we don't accidentally leak it.
        """
        builder = _UniffiRustBufferBuilder()
        try:
            yield builder
        except:
            builder.discard()
            raise

    @contextlib.contextmanager
    def consume_with_stream(self):
        """Context-manager to consume a buffer using a _UniffiRustBufferStream.

        The _UniffiRustBuffer will be freed once the context-manager exits, ensuring that we don't
        leak it even if an error occurs.
        """
        try:
            s = _UniffiRustBufferStream.from_rust_buffer(self)
            yield s
            if s.remaining() != 0:
                raise RuntimeError("junk data left in buffer at end of consume_with_stream")
        finally:
            self.free()

    @contextlib.contextmanager
    def read_with_stream(self):
        """Context-manager to read a buffer using a _UniffiRustBufferStream.

        This is like consume_with_stream, but doesn't free the buffer afterwards.
        It should only be used with borrowed `_UniffiRustBuffer` data.
        """
        s = _UniffiRustBufferStream.from_rust_buffer(self)
        yield s
        if s.remaining() != 0:
            raise RuntimeError("junk data left in buffer at end of read_with_stream")

class _UniffiForeignBytes(ctypes.Structure):
    _fields_ = [
        ("len", ctypes.c_int32),
        ("data", ctypes.POINTER(ctypes.c_char)),
    ]

    def __str__(self):
        return "_UniffiForeignBytes(len={}, data={})".format(self.len, self.data[0:self.len])


class _UniffiRustBufferStream:
    """
    Helper for structured reading of bytes from a _UniffiRustBuffer
    """

    def __init__(self, data, len):
        self.data = data
        self.len = len
        self.offset = 0

    @classmethod
    def from_rust_buffer(cls, buf):
        return cls(buf.data, buf.len)

    def remaining(self):
        return self.len - self.offset

    def _unpack_from(self, size, format):
        if self.offset + size > self.len:
            raise InternalError("read past end of rust buffer")
        value = struct.unpack(format, self.data[self.offset:self.offset+size])[0]
        self.offset += size
        return value

    def read(self, size):
        if self.offset + size > self.len:
            raise InternalError("read past end of rust buffer")
        data = self.data[self.offset:self.offset+size]
        self.offset += size
        return data

    def read_i8(self):
        return self._unpack_from(1, ">b")

    def read_u8(self):
        return self._unpack_from(1, ">B")

    def read_i16(self):
        return self._unpack_from(2, ">h")

    def read_u16(self):
        return self._unpack_from(2, ">H")

    def read_i32(self):
        return self._unpack_from(4, ">i")

    def read_u32(self):
        return self._unpack_from(4, ">I")

    def read_i64(self):
        return self._unpack_from(8, ">q")

    def read_u64(self):
        return self._unpack_from(8, ">Q")

    def read_float(self):
        v = self._unpack_from(4, ">f")
        return v

    def read_double(self):
        return self._unpack_from(8, ">d")

class _UniffiRustBufferBuilder:
    """
    Helper for structured writing of bytes into a _UniffiRustBuffer.
    """

    def __init__(self):
        self.rbuf = _UniffiRustBuffer.alloc(16)
        self.rbuf.len = 0

    def finalize(self):
        rbuf = self.rbuf
        self.rbuf = None
        return rbuf

    def discard(self):
        if self.rbuf is not None:
            rbuf = self.finalize()
            rbuf.free()

    @contextlib.contextmanager
    def _reserve(self, num_bytes):
        if self.rbuf.len + num_bytes > self.rbuf.capacity:
            self.rbuf = _UniffiRustBuffer.reserve(self.rbuf, num_bytes)
        yield None
        self.rbuf.len += num_bytes

    def _pack_into(self, size, format, value):
        with self._reserve(size):
            # XXX TODO: I feel like I should be able to use `struct.pack_into` here but can't figure it out.
            for i, byte in enumerate(struct.pack(format, value)):
                self.rbuf.data[self.rbuf.len + i] = byte

    def write(self, value):
        with self._reserve(len(value)):
            for i, byte in enumerate(value):
                self.rbuf.data[self.rbuf.len + i] = byte

    def write_i8(self, v):
        self._pack_into(1, ">b", v)

    def write_u8(self, v):
        self._pack_into(1, ">B", v)

    def write_i16(self, v):
        self._pack_into(2, ">h", v)

    def write_u16(self, v):
        self._pack_into(2, ">H", v)

    def write_i32(self, v):
        self._pack_into(4, ">i", v)

    def write_u32(self, v):
        self._pack_into(4, ">I", v)

    def write_i64(self, v):
        self._pack_into(8, ">q", v)

    def write_u64(self, v):
        self._pack_into(8, ">Q", v)

    def write_float(self, v):
        self._pack_into(4, ">f", v)

    def write_double(self, v):
        self._pack_into(8, ">d", v)

    def write_c_size_t(self, v):
        self._pack_into(ctypes.sizeof(ctypes.c_size_t) , "@N", v)
# A handful of classes and functions to support the generated data structures.
# This would be a good candidate for isolating in its own ffi-support lib.

class InternalError(Exception):
    pass

class _UniffiRustCallStatus(ctypes.Structure):
    """
    Error runtime.
    """
    _fields_ = [
        ("code", ctypes.c_int8),
        ("error_buf", _UniffiRustBuffer),
    ]

    # These match the values from the uniffi::rustcalls module
    CALL_SUCCESS = 0
    CALL_ERROR = 1
    CALL_UNEXPECTED_ERROR = 2

    @staticmethod
    def default():
        return _UniffiRustCallStatus(code=_UniffiRustCallStatus.CALL_SUCCESS, error_buf=_UniffiRustBuffer.default())

    def __str__(self):
        if self.code == _UniffiRustCallStatus.CALL_SUCCESS:
            return "_UniffiRustCallStatus(CALL_SUCCESS)"
        elif self.code == _UniffiRustCallStatus.CALL_ERROR:
            return "_UniffiRustCallStatus(CALL_ERROR)"
        elif self.code == _UniffiRustCallStatus.CALL_UNEXPECTED_ERROR:
            return "_UniffiRustCallStatus(CALL_UNEXPECTED_ERROR)"
        else:
            return "_UniffiRustCallStatus(<invalid code>)"

def _uniffi_rust_call(fn, *args):
    # Call a rust function
    return _uniffi_rust_call_with_error(None, fn, *args)

def _uniffi_rust_call_with_error(error_ffi_converter, fn, *args):
    # Call a rust function and handle any errors
    #
    # This function is used for rust calls that return Result<> and therefore can set the CALL_ERROR status code.
    # error_ffi_converter must be set to the _UniffiConverter for the error class that corresponds to the result.
    call_status = _UniffiRustCallStatus.default()

    args_with_error = args + (ctypes.byref(call_status),)
    result = fn(*args_with_error)
    _uniffi_check_call_status(error_ffi_converter, call_status)
    return result

def _uniffi_check_call_status(error_ffi_converter, call_status):
    if call_status.code == _UniffiRustCallStatus.CALL_SUCCESS:
        pass
    elif call_status.code == _UniffiRustCallStatus.CALL_ERROR:
        if error_ffi_converter is None:
            call_status.error_buf.free()
            raise InternalError("_uniffi_rust_call_with_error: CALL_ERROR, but error_ffi_converter is None")
        else:
            raise error_ffi_converter.lift(call_status.error_buf)
    elif call_status.code == _UniffiRustCallStatus.CALL_UNEXPECTED_ERROR:
        # When the rust code sees a panic, it tries to construct a _UniffiRustBuffer
        # with the message.  But if that code panics, then it just sends back
        # an empty buffer.
        if call_status.error_buf.len > 0:
            msg = _UniffiConverterString.lift(call_status.error_buf)
        else:
            msg = "Unknown rust panic"
        raise InternalError(msg)
    else:
        raise InternalError("Invalid _UniffiRustCallStatus code: {}".format(
            call_status.code))

def _uniffi_trait_interface_call(call_status, make_call, write_return_value):
    try:
        return write_return_value(make_call())
    except Exception as e:
        call_status.code = _UniffiRustCallStatus.CALL_UNEXPECTED_ERROR
        call_status.error_buf = _UniffiConverterString.lower(repr(e))

def _uniffi_trait_interface_call_with_error(call_status, make_call, write_return_value, error_type, lower_error):
    try:
        try:
            return write_return_value(make_call())
        except error_type as e:
            call_status.code = _UniffiRustCallStatus.CALL_ERROR
            call_status.error_buf = lower_error(e)
    except Exception as e:
        call_status.code = _UniffiRustCallStatus.CALL_UNEXPECTED_ERROR
        call_status.error_buf = _UniffiConverterString.lower(repr(e))
class _UniffiHandleMap:
    """
    A map where inserting, getting and removing data is synchronized with a lock.
    """

    def __init__(self):
        # type Handle = int
        self._map = {}  # type: Dict[Handle, Any]
        self._lock = threading.Lock()
        self._counter = itertools.count()

    def insert(self, obj):
        with self._lock:
            handle = next(self._counter)
            self._map[handle] = obj
            return handle

    def get(self, handle):
        try:
            with self._lock:
                return self._map[handle]
        except KeyError:
            raise InternalError("_UniffiHandleMap.get: Invalid handle")

    def remove(self, handle):
        try:
            with self._lock:
                return self._map.pop(handle)
        except KeyError:
            raise InternalError("_UniffiHandleMap.remove: Invalid handle")

    def __len__(self):
        return len(self._map)
# Types conforming to `_UniffiConverterPrimitive` pass themselves directly over the FFI.
class _UniffiConverterPrimitive:
    @classmethod
    def lift(cls, value):
        return value

    @classmethod
    def lower(cls, value):
        return value

class _UniffiConverterPrimitiveInt(_UniffiConverterPrimitive):
    @classmethod
    def check_lower(cls, value):
        try:
            value = value.__index__()
        except Exception:
            raise TypeError("'{}' object cannot be interpreted as an integer".format(type(value).__name__))
        if not isinstance(value, int):
            raise TypeError("__index__ returned non-int (type {})".format(type(value).__name__))
        if not cls.VALUE_MIN <= value < cls.VALUE_MAX:
            raise ValueError("{} requires {} <= value < {}".format(cls.CLASS_NAME, cls.VALUE_MIN, cls.VALUE_MAX))

class _UniffiConverterPrimitiveFloat(_UniffiConverterPrimitive):
    @classmethod
    def check_lower(cls, value):
        try:
            value = value.__float__()
        except Exception:
            raise TypeError("must be real number, not {}".format(type(value).__name__))
        if not isinstance(value, float):
            raise TypeError("__float__ returned non-float (type {})".format(type(value).__name__))

# Helper class for wrapper types that will always go through a _UniffiRustBuffer.
# Classes should inherit from this and implement the `read` and `write` static methods.
class _UniffiConverterRustBuffer:
    @classmethod
    def lift(cls, rbuf):
        with rbuf.consume_with_stream() as stream:
            return cls.read(stream)

    @classmethod
    def lower(cls, value):
        with _UniffiRustBuffer.alloc_with_builder() as builder:
            cls.write(value, builder)
            return builder.finalize()

# Contains loading, initialization code, and the FFI Function declarations.
# Define some ctypes FFI types that we use in the library

"""
Function pointer for a Rust task, which a callback function that takes a opaque pointer
"""
_UNIFFI_RUST_TASK = ctypes.CFUNCTYPE(None, ctypes.c_void_p, ctypes.c_int8)

def _uniffi_future_callback_t(return_type):
    """
    Factory function to create callback function types for async functions
    """
    return ctypes.CFUNCTYPE(None, ctypes.c_uint64, return_type, _UniffiRustCallStatus)

def _uniffi_load_indirect():
    """
    This is how we find and load the dynamic library provided by the component.
    For now we just look it up by name.
    """
    if sys.platform == "darwin":
        libname = "lib{}.dylib"
    elif sys.platform.startswith("win"):
        # As of python3.8, ctypes does not seem to search $PATH when loading DLLs.
        # We could use `os.add_dll_directory` to configure the search path, but
        # it doesn't feel right to mess with application-wide settings. Let's
        # assume that the `.dll` is next to the `.py` file and load by full path.
        libname = os.path.join(
            os.path.dirname(__file__),
            "{}.dll",
        )
    else:
        # Anything else must be an ELF platform - Linux, *BSD, Solaris/illumos
        libname = "lib{}.so"

    libname = libname.format("nostr_sdk_ffi")
    path = os.path.join(os.path.dirname(__file__), libname)
    lib = ctypes.cdll.LoadLibrary(path)
    return lib

def _uniffi_check_contract_api_version(lib):
    # Get the bindings contract version from our ComponentInterface
    bindings_contract_version = 29
    # Get the scaffolding contract version by calling the into the dylib
    scaffolding_contract_version = lib.ffi_nostr_sdk_ffi_uniffi_contract_version()
    if bindings_contract_version != scaffolding_contract_version:
        raise InternalError("UniFFI contract version mismatch: try cleaning and rebuilding your project")

def _uniffi_check_api_checksums(lib):
    if lib.uniffi_nostr_sdk_ffi_checksum_func_decrypt_received_private_zap_message() != 55155:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_func_decrypt_sent_private_zap_message() != 30641:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_func_extract_relay_list() != 7761:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_func_generate_shared_key() != 60318:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_func_get_leading_zero_bits() != 2779:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_func_get_prefixes_for_difficulty() != 12958:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_func_gift_wrap() != 44375:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_func_gift_wrap_from_seal() != 30742:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_func_git_hash_version() != 2908:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_func_init_logger() != 38847:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_func_make_private_msg() != 13683:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_func_nip04_decrypt() != 23337:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_func_nip04_encrypt() != 29489:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_func_nip05_verify_from_json() != 24282:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_func_nip22_extract_parent() != 43973:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_func_nip22_extract_root() != 22471:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_func_nip44_decrypt() != 18954:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_func_nip44_encrypt() != 41114:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_func_nip57_anonymous_zap_request() != 19524:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_func_nip57_private_zap_request() != 33299:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_func_tag_kind_to_string() != 44698:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_admitpolicy_admit_connection() != 33878:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_admitpolicy_admit_event() != 29006:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_client_add_discovery_relay() != 60047:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_client_add_read_relay() != 51524:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_client_add_relay() != 27015:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_client_add_relay_with_opts() != 15099:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_client_add_write_relay() != 9505:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_client_automatic_authentication() != 51347:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_client_connect() != 19131:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_client_connect_relay() != 45307:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_client_database() != 35722:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_client_disconnect() != 33822:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_client_disconnect_relay() != 59325:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_client_fetch_combined_events() != 8445:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_client_fetch_events() != 22564:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_client_fetch_events_from() != 43272:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_client_fetch_metadata() != 7347:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_client_force_remove_all_relays() != 54159:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_client_force_remove_relay() != 46552:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_client_gift_wrap() != 35151:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_client_gift_wrap_to() != 2:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_client_handle_notifications() != 8916:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_client_relay() != 4314:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_client_relays() != 54123:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_client_remove_all_relays() != 12546:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_client_remove_relay() != 28580:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_client_send_event() != 58506:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_client_send_event_builder() != 23280:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_client_send_event_builder_to() != 58152:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_client_send_event_to() != 25484:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_client_send_msg_to() != 44425:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_client_send_private_msg() != 64645:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_client_send_private_msg_to() != 37895:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_client_set_metadata() != 31801:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_client_shutdown() != 4321:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_client_sign_event_builder() != 14074:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_client_signer() != 31951:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_client_stream_events() != 35273:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_client_stream_events_from() != 5468:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_client_stream_events_targeted() != 40632:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_client_subscribe() != 45449:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_client_subscribe_to() != 54463:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_client_subscribe_with_id() != 37609:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_client_subscribe_with_id_to() != 9029:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_client_subscription() != 58353:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_client_subscriptions() != 20835:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_client_sync() != 10419:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_client_try_connect() != 8744:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_client_unsubscribe() != 16499:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_client_unsubscribe_all() != 37740:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_client_unwrap_gift_wrap() != 24699:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_client_wait_for_connection() != 388:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_clientbuilder_admit_policy() != 1024:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_clientbuilder_build() != 61424:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_clientbuilder_database() != 21061:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_clientbuilder_gossip() != 52386:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_clientbuilder_opts() != 19869:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_clientbuilder_signer() != 30905:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_clientbuilder_websocket_transport() != 48944:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_clientmessage_as_enum() != 46388:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_clientmessage_as_json() != 4674:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_clientoptions_autoconnect() != 32443:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_clientoptions_automatic_authentication() != 18664:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_clientoptions_ban_relay_on_mismatch() != 51741:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_clientoptions_connection() != 7210:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_clientoptions_gossip() != 30879:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_clientoptions_max_avg_latency() != 30357:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_clientoptions_relay_limits() != 65443:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_clientoptions_verify_subscriptions() != 14184:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_connection_addr() != 43068:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_connection_mode() != 217:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_connection_target() != 61648:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_coordinate_identifier() != 38994:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_coordinate_kind() != 7837:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_coordinate_public_key() != 29286:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_coordinate_verify() != 52656:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_customnostrdatabase_backend() != 43310:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_customnostrdatabase_save_event() != 15070:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_customnostrdatabase_check_id() != 56541:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_customnostrdatabase_event_by_id() != 41704:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_customnostrdatabase_count() != 13210:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_customnostrdatabase_query() != 50605:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_customnostrdatabase_delete() != 38569:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_customnostrdatabase_wipe() != 40503:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_customnostrsigner_backend() != 7020:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_customnostrsigner_get_public_key() != 1696:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_customnostrsigner_sign_event() != 35436:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_customnostrsigner_nip04_encrypt() != 382:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_customnostrsigner_nip04_decrypt() != 58024:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_customnostrsigner_nip44_encrypt() != 25563:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_customnostrsigner_nip44_decrypt() != 7340:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_customwebsockettransport_support_ping() != 65059:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_customwebsockettransport_connect() != 8221:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_encryptedsecretkey_decrypt() != 50130:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_encryptedsecretkey_key_security() != 9516:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_encryptedsecretkey_to_bech32() != 44747:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_encryptedsecretkey_version() != 19336:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_event_as_json() != 3171:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_event_as_pretty_json() != 15571:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_event_author() != 33777:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_event_content() != 63997:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_event_created_at() != 44671:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_event_id() != 10840:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_event_is_expired() != 16390:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_event_is_protected() != 60470:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_event_kind() != 37638:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_event_signature() != 24839:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_event_tags() != 32843:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_event_verify() != 3329:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_event_verify_id() != 50510:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_event_verify_signature() != 21120:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_eventbuilder_allow_self_tagging() != 57727:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_eventbuilder_build() != 10100:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_eventbuilder_custom_created_at() != 20379:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_eventbuilder_dedup_tags() != 16426:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_eventbuilder_pow() != 47148:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_eventbuilder_sign() != 24133:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_eventbuilder_sign_with_keys() != 46872:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_eventbuilder_tags() != 22610:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_eventid_as_bytes() != 22930:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_eventid_to_bech32() != 35036:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_eventid_to_hex() != 62987:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_eventid_to_nostr_uri() != 15047:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_eventstream_next() != 5894:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_events_contains() != 39963:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_events_first() != 11892:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_events_is_empty() != 16727:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_events_len() != 22082:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_events_merge() != 57155:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_events_to_vec() != 14351:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_filemetadata_aes_256_gcm() != 15419:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_filemetadata_blurhash() != 58338:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_filemetadata_dimensions() != 7956:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_filemetadata_magnet() != 49047:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_filemetadata_size() != 53216:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_filter_as_json() != 6808:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_filter_as_record() != 6560:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_filter_author() != 30570:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_filter_authors() != 55524:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_filter_coordinate() != 29286:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_filter_coordinates() != 2599:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_filter_custom_tag() != 11314:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_filter_custom_tags() != 44033:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_filter_event() != 9919:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_filter_events() != 6127:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_filter_hashtag() != 45839:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_filter_hashtags() != 34615:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_filter_id() != 61970:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_filter_identifier() != 32910:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_filter_identifiers() != 38883:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_filter_ids() != 23011:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_filter_is_empty() != 21971:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_filter_kind() != 4634:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_filter_kinds() != 4092:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_filter_limit() != 14746:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_filter_match_event() != 43992:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_filter_pubkey() != 17463:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_filter_pubkeys() != 13058:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_filter_reference() != 5361:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_filter_references() != 54226:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_filter_remove_authors() != 9364:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_filter_remove_coordinates() != 47805:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_filter_remove_custom_tags() != 243:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_filter_remove_events() != 30094:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_filter_remove_hashtags() != 33949:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_filter_remove_identifiers() != 53765:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_filter_remove_ids() != 11079:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_filter_remove_kinds() != 55693:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_filter_remove_limit() != 45828:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_filter_remove_pubkeys() != 22880:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_filter_remove_references() != 62395:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_filter_remove_search() != 29028:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_filter_remove_since() != 30254:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_filter_remove_until() != 41736:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_filter_search() != 36347:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_filter_since() != 19595:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_filter_until() != 6520:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_handlenotification_handle_msg() != 15394:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_handlenotification_handle() != 42681:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_jobfeedbackdata_amount() != 2543:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_jobfeedbackdata_extra_info() != 21313:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_jobfeedbackdata_payload() != 45291:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_keys_public_key() != 21581:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_keys_secret_key() != 60506:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_keys_sign_schnorr() != 55396:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_kind_as_std() != 65021:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_kind_as_u16() != 33899:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_kind_is_addressable() != 13541:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_kind_is_ephemeral() != 12268:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_kind_is_job_request() != 21807:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_kind_is_job_result() != 3971:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_kind_is_regular() != 26650:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_kind_is_replaceable() != 31494:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_localrelay_notify_event() != 34103:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_localrelay_run() != 38051:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_localrelay_shutdown() != 2728:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_localrelay_url() != 24416:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_metadata_as_json() != 2258:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_metadata_as_pretty_json() != 48195:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_metadata_as_record() != 2519:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_nwc_get_balance() != 30742:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_nwc_get_info() != 19865:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_nwc_list_transactions() != 15654:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_nwc_lookup_invoice() != 28952:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_nwc_make_invoice() != 56020:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_nwc_pay_invoice() != 842:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_nwc_pay_keysend() != 38155:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_nwc_status() != 31309:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_nip05address_domain() != 60519:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_nip05address_name() != 49203:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_nip05address_url() != 34756:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_nip05profile_nip46() != 41040:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_nip05profile_public_key() != 56263:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_nip05profile_relays() != 9573:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_nip19_as_enum() != 62711:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_nip19coordinate_coordinate() != 31239:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_nip19coordinate_relays() != 52695:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_nip19coordinate_to_bech32() != 787:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_nip19coordinate_to_nostr_uri() != 21870:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_nip19event_author() != 8504:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_nip19event_event_id() != 9799:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_nip19event_kind() != 12835:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_nip19event_relays() != 46165:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_nip19event_to_bech32() != 12367:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_nip19event_to_nostr_uri() != 31723:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_nip19profile_public_key() != 32958:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_nip19profile_relays() != 15918:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_nip19profile_to_bech32() != 36717:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_nip19profile_to_nostr_uri() != 28973:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_nip21_as_enum() != 7140:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_nip21_to_nostr_uri() != 28944:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_nip96serverconfig_api_url() != 37164:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_nip96serverconfig_as_json() != 57964:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_nip96serverconfig_content_types() != 2290:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_nip96serverconfig_delegated_to_url() != 39958:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_nip96serverconfig_download_url() != 23548:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_nip96uploadrequest_authorization() != 1841:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_nip96uploadrequest_url() != 61137:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_nip96uploadresponse_as_json() != 35122:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_nip96uploadresponse_download_url() != 58228:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_nip96uploadresponse_is_success() != 32550:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_nip96uploadresponse_message() != 51400:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_nostrconnect_bunker_uri() != 57336:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_nostrconnect_get_public_key() != 16592:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_nostrconnect_nip04_decrypt() != 9737:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_nostrconnect_nip04_encrypt() != 32405:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_nostrconnect_nip44_decrypt() != 57892:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_nostrconnect_nip44_encrypt() != 7459:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_nostrconnect_relays() != 38451:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_nostrconnect_sign_event() != 11201:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_nostrconnectmetadata_as_json() != 14883:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_nostrconnectmetadata_description() != 63846:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_nostrconnectmetadata_icons() != 20500:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_nostrconnectmetadata_url() != 5634:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_nostrdatabase_count() != 5629:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_nostrdatabase_delete() != 57958:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_nostrdatabase_event_by_id() != 41668:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_nostrdatabase_metadata() != 5609:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_nostrdatabase_query() != 62424:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_nostrdatabase_save_event() != 50750:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_nostrdatabase_wipe() != 58001:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_nostrparser_parse() != 36801:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_nostrsigner_backend() != 42053:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_nostrsigner_get_public_key() != 57508:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_nostrsigner_nip04_decrypt() != 21362:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_nostrsigner_nip04_encrypt() != 56434:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_nostrsigner_nip44_decrypt() != 9052:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_nostrsigner_nip44_encrypt() != 24375:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_nostrsigner_sign_event() != 15564:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_nostrwalletconnectoptions_relay() != 717:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_nostrwalletconnectoptions_timeout() != 18259:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_nostrwalletconnecturi_lud16() != 20036:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_nostrwalletconnecturi_public_key() != 21325:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_nostrwalletconnecturi_relays() != 29202:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_nostrwalletconnecturi_secret() != 15591:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_publickey_to_bech32() != 28181:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_publickey_to_hex() != 25698:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_publickey_to_nostr_uri() != 54491:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_querypolicy_admit_query() != 2747:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_relay_ban() != 43872:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_relay_batch_msg() != 32031:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_relay_connect() != 29641:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_relay_connection_mode() != 52002:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_relay_count_events() != 58311:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_relay_disconnect() != 22001:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_relay_fetch_events() != 61339:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_relay_is_connected() != 18284:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_relay_opts() != 21198:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_relay_queue() != 23174:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_relay_send_event() != 30621:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_relay_send_msg() != 53871:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_relay_stats() != 58574:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_relay_status() != 52365:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_relay_subscribe() != 11379:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_relay_subscribe_with_id() != 41014:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_relay_subscription() != 47719:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_relay_subscriptions() != 31310:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_relay_sync() != 50084:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_relay_sync_with_items() != 50768:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_relay_try_connect() != 39036:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_relay_unsubscribe() != 62991:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_relay_unsubscribe_all() != 18626:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_relay_url() != 28519:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_relaybuilder_addr() != 20999:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_relaybuilder_auth_dm() != 45806:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_relaybuilder_database() != 15598:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_relaybuilder_default_filter_limit() != 28899:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_relaybuilder_max_connections() != 13259:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_relaybuilder_max_filter_limit() != 4872:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_relaybuilder_max_subid_length() != 35156:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_relaybuilder_min_pow() != 24936:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_relaybuilder_nip42() != 31708:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_relaybuilder_port() != 42976:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_relaybuilder_query_policy() != 34124:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_relaybuilder_rate_limit() != 56357:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_relaybuilder_write_policy() != 17411:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_relayconnectionstats_attempts() != 52060:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_relayconnectionstats_bytes_received() != 157:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_relayconnectionstats_bytes_sent() != 64970:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_relayconnectionstats_connected_at() != 27772:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_relayconnectionstats_first_connection_timestamp() != 32759:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_relayconnectionstats_latency() != 14031:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_relayconnectionstats_success() != 52759:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_relayconnectionstats_success_rate() != 58744:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_relayinformationdocument_as_json() != 18024:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_relayinformationdocument_contact() != 33791:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_relayinformationdocument_description() != 55506:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_relayinformationdocument_fees() != 52643:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_relayinformationdocument_icon() != 37182:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_relayinformationdocument_language_tags() != 5241:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_relayinformationdocument_limitation() != 63667:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_relayinformationdocument_name() != 54729:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_relayinformationdocument_payments_url() != 50516:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_relayinformationdocument_posting_policy() != 57849:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_relayinformationdocument_pubkey() != 52169:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_relayinformationdocument_relay_countries() != 43620:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_relayinformationdocument_retention() != 48273:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_relayinformationdocument_software() != 34250:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_relayinformationdocument_supported_nips() != 11144:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_relayinformationdocument_tags() != 65245:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_relayinformationdocument_version() != 38302:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_relaylimits_event_max_num_tags() != 29781:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_relaylimits_event_max_num_tags_per_kind() != 54489:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_relaylimits_event_max_size() != 17341:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_relaylimits_event_max_size_per_kind() != 30650:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_relaylimits_message_max_size() != 39217:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_relaymessage_as_enum() != 673:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_relaymessage_as_json() != 14562:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_relayoptions_adjust_retry_interval() != 25372:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_relayoptions_ban_relay_on_mismatch() != 13665:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_relayoptions_connection_mode() != 24699:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_relayoptions_limits() != 10405:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_relayoptions_max_avg_latency() != 58939:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_relayoptions_ping() != 51607:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_relayoptions_read() != 47081:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_relayoptions_reconnect() != 48820:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_relayoptions_retry_interval() != 30532:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_relayoptions_verify_subscriptions() != 38529:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_relayoptions_write() != 45946:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_relayurl_is_local_addr() != 6616:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_relayurl_is_onion() != 31914:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_request_method() != 17520:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_request_params() != 39349:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_saveeventstatus_is_success() != 48824:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_saveeventstatus_rejection_reason() != 37739:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_secretkey_encrypt() != 49692:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_secretkey_to_bech32() != 38599:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_secretkey_to_hex() != 57941:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_shippingmethod_get_shipping_cost() != 56592:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_shippingmethod_name() != 13755:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_shippingmethod_regions() != 233:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_singlelettertag_is_lowercase() != 53511:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_singlelettertag_is_uppercase() != 16786:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_stalldata_as_json() != 14626:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_stalldata_as_record() != 30522:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_stalldata_currency() != 40639:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_stalldata_description() != 50371:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_stalldata_id() != 34671:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_stalldata_name() != 15071:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_stalldata_shipping() != 17698:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_subscribeautocloseoptions_exit_policy() != 62279:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_subscribeautocloseoptions_idle_timeout() != 9446:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_subscribeautocloseoptions_timeout() != 16202:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_subscribeoptions_close_on() != 54857:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_syncoptions_direction() != 15360:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_syncoptions_dry_run() != 15725:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_syncoptions_initial_timeout() != 19180:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_tag_as_standardized() != 39092:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_tag_as_vec() != 22150:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_tag_content() != 43772:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_tag_is_protected() != 61999:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_tag_is_reply() != 26678:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_tag_is_root() != 42913:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_tag_kind() != 28437:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_tag_kind_str() != 21836:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_tag_len() != 35144:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_tag_single_letter_tag() != 50942:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_tags_coordinates() != 39150:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_tags_event_ids() != 44166:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_tags_expiration() != 15697:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_tags_filter() != 6442:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_tags_filter_standardized() != 23694:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_tags_find() != 19756:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_tags_find_standardized() != 61199:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_tags_first() != 16571:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_tags_get() != 2938:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_tags_hashtags() != 50724:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_tags_identifier() != 44864:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_tags_is_empty() != 16467:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_tags_last() != 22526:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_tags_len() != 28453:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_tags_public_keys() != 15566:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_tags_to_vec() != 38520:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_timestamp_add_duration() != 59895:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_timestamp_as_secs() != 7797:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_timestamp_sub_duration() != 14720:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_timestamp_to_human_datetime() != 24020:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_unsignedevent_add_signature() != 33695:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_unsignedevent_as_json() != 14388:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_unsignedevent_as_pretty_json() != 3289:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_unsignedevent_author() != 33632:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_unsignedevent_content() != 61788:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_unsignedevent_created_at() != 2838:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_unsignedevent_id() != 26673:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_unsignedevent_kind() != 24650:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_unsignedevent_sign() != 17648:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_unsignedevent_sign_with_keys() != 65226:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_unsignedevent_tags() != 23219:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_unwrappedgift__none() != 31106:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_unwrappedgift_rumor() != 9051:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_unwrappedgift_sender() != 65176:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_websocketadapter_send() != 56567:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_websocketadapter_recv() != 39160:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_websocketadapter_close_connection() != 35891:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_writepolicy_admit_event() != 49227:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_zaprequestdata_amount() != 38837:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_zaprequestdata_event_id() != 60606:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_zaprequestdata_lnurl() != 11688:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_method_zaprequestdata_message() != 38998:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_admitstatus_rejected() != 54055:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_admitstatus_success() != 33678:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_client_new() != 54751:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_clientbuilder_new() != 11332:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_clientmessage_auth() != 45144:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_clientmessage_close() != 12470:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_clientmessage_count() != 5292:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_clientmessage_event() != 35014:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_clientmessage_from_enum() != 42986:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_clientmessage_from_json() != 27860:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_clientmessage_req() != 60557:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_clientoptions_new() != 16931:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_connection_new() != 32544:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_coordinate_new() != 25471:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_coordinate_parse() != 59337:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_encryptedsecretkey_from_bech32() != 27546:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_encryptedsecretkey_new() != 35289:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_event_from_json() != 14737:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_articles_curation_set() != 36328:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_auth() != 56367:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_award_badge() != 41119:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_blocked_relays() != 40799:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_bookmarks() != 63306:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_bookmarks_set() != 23068:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_channel() != 21555:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_channel_metadata() != 4153:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_channel_msg() != 10299:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_comment() != 57486:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_communities() != 54557:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_contact_list() != 11242:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_define_badge() != 89:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_delete() != 50417:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_emoji_set() != 6114:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_emojis() != 43073:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_file_metadata() != 8053:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_follow_set() != 32344:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_git_issue() != 26026:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_git_patch() != 34800:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_git_repository_announcement() != 58206:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_hide_channel_msg() != 8353:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_http_auth() != 42464:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_interest_set() != 54183:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_interests() != 55071:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_job_feedback() != 11871:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_job_request() != 14986:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_job_result() != 48936:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_label() != 51492:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_live_event() != 35589:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_live_event_msg() != 34422:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_long_form_text_note() != 4671:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_metadata() != 34149:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_mute_channel_user() != 64300:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_mute_list() != 34705:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_new() != 61972:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_nostr_connect() != 10416:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_pinned_notes() != 5335:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_private_msg_rumor() != 6901:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_product_data() != 57627:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_profile_badges() != 15894:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_public_chats() != 65509:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_public_zap_request() != 49461:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_reaction() != 35984:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_relay_list() != 46091:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_relay_set() != 52775:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_report() != 9803:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_repost() != 44582:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_seal() != 55824:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_search_relays() != 26737:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_stall_data() != 14247:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_text_note() != 19143:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_text_note_reply() != 31849:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_videos_curation_set() != 19505:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_zap_receipt() != 16189:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_eventid_from_bytes() != 63077:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_eventid_new() != 57964:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_eventid_parse() != 39522:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_filemetadata_new() != 27821:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_filter_from_json() != 60806:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_filter_from_record() != 32151:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_filter_new() != 58026:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_jobfeedbackdata_new() != 39189:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_keys_from_mnemonic() != 25690:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_keys_generate() != 61718:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_keys_new() != 46666:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_keys_parse() != 27763:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_kind_from_std() != 49333:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_kind_new() != 53039:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_localrelay_new() != 58754:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_metadata_from_json() != 39685:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_metadata_from_record() != 29877:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_nwc_new() != 24213:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_nwc_with_opts() != 29036:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_nip05address_parse() != 52756:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_nip05profile_from_json() != 19324:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_nip19_from_bech32() != 12847:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_nip19coordinate_from_bech32() != 9233:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_nip19coordinate_from_nostr_uri() != 4130:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_nip19coordinate_new() != 2829:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_nip19event_from_bech32() != 48940:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_nip19event_from_event() != 59343:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_nip19event_from_nostr_uri() != 20420:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_nip19event_new() != 52064:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_nip19profile_from_bech32() != 56532:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_nip19profile_from_nostr_uri() != 54372:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_nip19profile_new() != 54759:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_nip21_parse() != 2093:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_nip96serverconfig_from_json() != 41163:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_nip96uploadrequest_create() != 51933:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_nip96uploadresponse_from_json() != 22627:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_nostrconnect_new() != 60022:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_nostrconnectmetadata_new() != 55577:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_nostrconnecturi_parse() != 36627:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_nostrdatabase_custom() != 8545:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_nostrdatabase_lmdb() != 21752:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_nostrgossip_in_memory() != 46331:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_nostrparser_new() != 55036:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_nostrsigner_custom() != 7081:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_nostrsigner_keys() != 41683:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_nostrsigner_nostr_connect() != 3051:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_nostrwalletconnectoptions_new() != 35456:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_nostrwalletconnecturi_new() != 9060:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_nostrwalletconnecturi_parse() != 31940:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_publickey_from_bytes() != 38006:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_publickey_parse() != 50593:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_relaybuilder_new() != 36778:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_relayinformationdocument_from_json() != 24725:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_relaylimits_disable() != 39641:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_relaylimits_new() != 1364:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_relaymessage_auth() != 49391:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_relaymessage_closed() != 12776:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_relaymessage_count() != 38897:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_relaymessage_eose() != 61100:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_relaymessage_event() != 41233:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_relaymessage_from_enum() != 34939:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_relaymessage_from_json() != 52163:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_relaymessage_notice() != 17916:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_relaymessage_ok() != 56502:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_relayoptions_new() != 32157:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_relayurl_parse() != 11922:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_request_new() != 22154:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_request_parse() != 38336:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_saveeventstatus_rejected() != 31405:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_saveeventstatus_success() != 51549:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_secretkey_from_bytes() != 33002:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_secretkey_generate() != 2297:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_secretkey_parse() != 41672:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_shippingmethod_new() != 54442:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_singlelettertag_lowercase() != 25781:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_singlelettertag_uppercase() != 26245:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_stalldata_from_json() != 26421:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_stalldata_from_record() != 10070:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_stalldata_new() != 11283:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_subscribeautocloseoptions_new() != 39595:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_subscribeoptions_new() != 56214:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_syncoptions_new() != 7169:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_tag_alt() != 61627:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_tag_client() != 18574:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_tag_coordinate() != 21232:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_tag_custom() != 55533:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_tag_description() != 31007:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_tag_event() != 3596:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_tag_event_report() != 12542:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_tag_expiration() != 25703:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_tag_from_standardized() != 10696:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_tag_hashtag() != 56828:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_tag_identifier() != 5344:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_tag_image() != 35229:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_tag_parse() != 63294:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_tag_pow() != 46606:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_tag_protected() != 21460:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_tag_public_key() != 4984:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_tag_public_key_report() != 44501:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_tag_reference() != 43166:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_tag_relay_metadata() != 53501:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_tag_title() != 51619:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_tags_from_list() != 61074:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_tags_parse() != 21642:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_timestamp_from_secs() != 64753:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_timestamp_max() != 61689:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_timestamp_min() != 59395:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_timestamp_now() != 13059:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_unsignedevent_from_json() != 8735:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_unwrappedgift_from_gift_wrap() != 4603:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_websocketadapterwrapper_new() != 27365:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_ffi_checksum_constructor_zaprequestdata_new() != 63828:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")

# A ctypes library to expose the extern-C FFI definitions.
# This is an implementation detail which will be called internally by the public API.

_UniffiLib = _uniffi_load_indirect()
_UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK = ctypes.CFUNCTYPE(None,ctypes.c_uint64,ctypes.c_int8,
)
_UNIFFI_FOREIGN_FUTURE_FREE = ctypes.CFUNCTYPE(None,ctypes.c_uint64,
)
_UNIFFI_CALLBACK_INTERFACE_FREE = ctypes.CFUNCTYPE(None,ctypes.c_uint64,
)
class _UniffiForeignFuture(ctypes.Structure):
    _fields_ = [
        ("handle", ctypes.c_uint64),
        ("free", _UNIFFI_FOREIGN_FUTURE_FREE),
    ]
class _UniffiForeignFutureStructU8(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_uint8),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_U8 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructU8,
)
class _UniffiForeignFutureStructI8(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_int8),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_I8 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructI8,
)
class _UniffiForeignFutureStructU16(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_uint16),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_U16 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructU16,
)
class _UniffiForeignFutureStructI16(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_int16),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_I16 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructI16,
)
class _UniffiForeignFutureStructU32(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_uint32),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_U32 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructU32,
)
class _UniffiForeignFutureStructI32(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_int32),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_I32 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructI32,
)
class _UniffiForeignFutureStructU64(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_uint64),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_U64 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructU64,
)
class _UniffiForeignFutureStructI64(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_int64),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_I64 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructI64,
)
class _UniffiForeignFutureStructF32(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_float),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_F32 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructF32,
)
class _UniffiForeignFutureStructF64(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_double),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_F64 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructF64,
)
class _UniffiForeignFutureStructPointer(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_void_p),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_POINTER = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructPointer,
)
class _UniffiForeignFutureStructRustBuffer(ctypes.Structure):
    _fields_ = [
        ("return_value", _UniffiRustBuffer),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_RUST_BUFFER = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructRustBuffer,
)
class _UniffiForeignFutureStructVoid(ctypes.Structure):
    _fields_ = [
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_VOID = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructVoid,
)
_UNIFFI_CALLBACK_INTERFACE_ADMIT_POLICY_METHOD0 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,ctypes.c_void_p,_UNIFFI_FOREIGN_FUTURE_COMPLETE_RUST_BUFFER,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_ADMIT_POLICY_METHOD1 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,ctypes.c_void_p,_UniffiRustBuffer,ctypes.c_void_p,_UNIFFI_FOREIGN_FUTURE_COMPLETE_RUST_BUFFER,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_CUSTOM_NOSTR_DATABASE_METHOD0 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,ctypes.POINTER(_UniffiRustBuffer),
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UNIFFI_CALLBACK_INTERFACE_CUSTOM_NOSTR_DATABASE_METHOD1 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,ctypes.c_void_p,_UNIFFI_FOREIGN_FUTURE_COMPLETE_RUST_BUFFER,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_CUSTOM_NOSTR_DATABASE_METHOD2 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,ctypes.c_void_p,_UNIFFI_FOREIGN_FUTURE_COMPLETE_RUST_BUFFER,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_CUSTOM_NOSTR_DATABASE_METHOD3 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,ctypes.c_void_p,_UNIFFI_FOREIGN_FUTURE_COMPLETE_RUST_BUFFER,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_CUSTOM_NOSTR_DATABASE_METHOD4 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,ctypes.c_void_p,_UNIFFI_FOREIGN_FUTURE_COMPLETE_U64,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_CUSTOM_NOSTR_DATABASE_METHOD5 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,ctypes.c_void_p,_UNIFFI_FOREIGN_FUTURE_COMPLETE_RUST_BUFFER,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_CUSTOM_NOSTR_DATABASE_METHOD6 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,ctypes.c_void_p,_UNIFFI_FOREIGN_FUTURE_COMPLETE_VOID,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_CUSTOM_NOSTR_DATABASE_METHOD7 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UNIFFI_FOREIGN_FUTURE_COMPLETE_VOID,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_CUSTOM_NOSTR_SIGNER_METHOD0 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,ctypes.POINTER(_UniffiRustBuffer),
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UNIFFI_CALLBACK_INTERFACE_CUSTOM_NOSTR_SIGNER_METHOD1 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UNIFFI_FOREIGN_FUTURE_COMPLETE_RUST_BUFFER,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_CUSTOM_NOSTR_SIGNER_METHOD2 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,ctypes.c_void_p,_UNIFFI_FOREIGN_FUTURE_COMPLETE_RUST_BUFFER,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_CUSTOM_NOSTR_SIGNER_METHOD3 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,ctypes.c_void_p,_UniffiRustBuffer,_UNIFFI_FOREIGN_FUTURE_COMPLETE_RUST_BUFFER,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_CUSTOM_NOSTR_SIGNER_METHOD4 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,ctypes.c_void_p,_UniffiRustBuffer,_UNIFFI_FOREIGN_FUTURE_COMPLETE_RUST_BUFFER,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_CUSTOM_NOSTR_SIGNER_METHOD5 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,ctypes.c_void_p,_UniffiRustBuffer,_UNIFFI_FOREIGN_FUTURE_COMPLETE_RUST_BUFFER,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_CUSTOM_NOSTR_SIGNER_METHOD6 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,ctypes.c_void_p,_UniffiRustBuffer,_UNIFFI_FOREIGN_FUTURE_COMPLETE_RUST_BUFFER,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_CUSTOM_WEB_SOCKET_TRANSPORT_METHOD0 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,ctypes.POINTER(ctypes.c_int8),
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UNIFFI_CALLBACK_INTERFACE_CUSTOM_WEB_SOCKET_TRANSPORT_METHOD1 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiRustBuffer,_UniffiRustBuffer,_UniffiRustBuffer,_UNIFFI_FOREIGN_FUTURE_COMPLETE_RUST_BUFFER,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_HANDLE_NOTIFICATION_METHOD0 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,ctypes.c_void_p,ctypes.c_void_p,_UNIFFI_FOREIGN_FUTURE_COMPLETE_VOID,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_HANDLE_NOTIFICATION_METHOD1 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,ctypes.c_void_p,_UniffiRustBuffer,ctypes.c_void_p,_UNIFFI_FOREIGN_FUTURE_COMPLETE_VOID,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_QUERY_POLICY_METHOD0 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,ctypes.c_void_p,_UniffiRustBuffer,_UNIFFI_FOREIGN_FUTURE_COMPLETE_RUST_BUFFER,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_WEB_SOCKET_ADAPTER_METHOD0 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiRustBuffer,_UNIFFI_FOREIGN_FUTURE_COMPLETE_VOID,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_WEB_SOCKET_ADAPTER_METHOD1 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UNIFFI_FOREIGN_FUTURE_COMPLETE_RUST_BUFFER,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_WEB_SOCKET_ADAPTER_METHOD2 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UNIFFI_FOREIGN_FUTURE_COMPLETE_VOID,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_WRITE_POLICY_METHOD0 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,ctypes.c_void_p,_UniffiRustBuffer,_UNIFFI_FOREIGN_FUTURE_COMPLETE_RUST_BUFFER,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
class _UniffiVTableCallbackInterfaceAdmitPolicy(ctypes.Structure):
    _fields_ = [
        ("admit_connection", _UNIFFI_CALLBACK_INTERFACE_ADMIT_POLICY_METHOD0),
        ("admit_event", _UNIFFI_CALLBACK_INTERFACE_ADMIT_POLICY_METHOD1),
        ("uniffi_free", _UNIFFI_CALLBACK_INTERFACE_FREE),
    ]
class _UniffiVTableCallbackInterfaceCustomNostrDatabase(ctypes.Structure):
    _fields_ = [
        ("backend", _UNIFFI_CALLBACK_INTERFACE_CUSTOM_NOSTR_DATABASE_METHOD0),
        ("save_event", _UNIFFI_CALLBACK_INTERFACE_CUSTOM_NOSTR_DATABASE_METHOD1),
        ("check_id", _UNIFFI_CALLBACK_INTERFACE_CUSTOM_NOSTR_DATABASE_METHOD2),
        ("event_by_id", _UNIFFI_CALLBACK_INTERFACE_CUSTOM_NOSTR_DATABASE_METHOD3),
        ("count", _UNIFFI_CALLBACK_INTERFACE_CUSTOM_NOSTR_DATABASE_METHOD4),
        ("query", _UNIFFI_CALLBACK_INTERFACE_CUSTOM_NOSTR_DATABASE_METHOD5),
        ("delete", _UNIFFI_CALLBACK_INTERFACE_CUSTOM_NOSTR_DATABASE_METHOD6),
        ("wipe", _UNIFFI_CALLBACK_INTERFACE_CUSTOM_NOSTR_DATABASE_METHOD7),
        ("uniffi_free", _UNIFFI_CALLBACK_INTERFACE_FREE),
    ]
class _UniffiVTableCallbackInterfaceCustomNostrSigner(ctypes.Structure):
    _fields_ = [
        ("backend", _UNIFFI_CALLBACK_INTERFACE_CUSTOM_NOSTR_SIGNER_METHOD0),
        ("get_public_key", _UNIFFI_CALLBACK_INTERFACE_CUSTOM_NOSTR_SIGNER_METHOD1),
        ("sign_event", _UNIFFI_CALLBACK_INTERFACE_CUSTOM_NOSTR_SIGNER_METHOD2),
        ("nip04_encrypt", _UNIFFI_CALLBACK_INTERFACE_CUSTOM_NOSTR_SIGNER_METHOD3),
        ("nip04_decrypt", _UNIFFI_CALLBACK_INTERFACE_CUSTOM_NOSTR_SIGNER_METHOD4),
        ("nip44_encrypt", _UNIFFI_CALLBACK_INTERFACE_CUSTOM_NOSTR_SIGNER_METHOD5),
        ("nip44_decrypt", _UNIFFI_CALLBACK_INTERFACE_CUSTOM_NOSTR_SIGNER_METHOD6),
        ("uniffi_free", _UNIFFI_CALLBACK_INTERFACE_FREE),
    ]
class _UniffiVTableCallbackInterfaceCustomWebSocketTransport(ctypes.Structure):
    _fields_ = [
        ("support_ping", _UNIFFI_CALLBACK_INTERFACE_CUSTOM_WEB_SOCKET_TRANSPORT_METHOD0),
        ("connect", _UNIFFI_CALLBACK_INTERFACE_CUSTOM_WEB_SOCKET_TRANSPORT_METHOD1),
        ("uniffi_free", _UNIFFI_CALLBACK_INTERFACE_FREE),
    ]
class _UniffiVTableCallbackInterfaceHandleNotification(ctypes.Structure):
    _fields_ = [
        ("handle_msg", _UNIFFI_CALLBACK_INTERFACE_HANDLE_NOTIFICATION_METHOD0),
        ("handle", _UNIFFI_CALLBACK_INTERFACE_HANDLE_NOTIFICATION_METHOD1),
        ("uniffi_free", _UNIFFI_CALLBACK_INTERFACE_FREE),
    ]
class _UniffiVTableCallbackInterfaceQueryPolicy(ctypes.Structure):
    _fields_ = [
        ("admit_query", _UNIFFI_CALLBACK_INTERFACE_QUERY_POLICY_METHOD0),
        ("uniffi_free", _UNIFFI_CALLBACK_INTERFACE_FREE),
    ]
class _UniffiVTableCallbackInterfaceWebSocketAdapter(ctypes.Structure):
    _fields_ = [
        ("send", _UNIFFI_CALLBACK_INTERFACE_WEB_SOCKET_ADAPTER_METHOD0),
        ("recv", _UNIFFI_CALLBACK_INTERFACE_WEB_SOCKET_ADAPTER_METHOD1),
        ("close_connection", _UNIFFI_CALLBACK_INTERFACE_WEB_SOCKET_ADAPTER_METHOD2),
        ("uniffi_free", _UNIFFI_CALLBACK_INTERFACE_FREE),
    ]
class _UniffiVTableCallbackInterfaceWritePolicy(ctypes.Structure):
    _fields_ = [
        ("admit_event", _UNIFFI_CALLBACK_INTERFACE_WRITE_POLICY_METHOD0),
        ("uniffi_free", _UNIFFI_CALLBACK_INTERFACE_FREE),
    ]
_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_admitpolicy.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_admitpolicy.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_admitpolicy.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_admitpolicy.restype = None
_UniffiLib.uniffi_nostr_sdk_ffi_fn_init_callback_vtable_admitpolicy.argtypes = (
    ctypes.POINTER(_UniffiVTableCallbackInterfaceAdmitPolicy),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_init_callback_vtable_admitpolicy.restype = None
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_admitpolicy_admit_connection.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_admitpolicy_admit_connection.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_admitpolicy_admit_event.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_admitpolicy_admit_event.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_admitstatus.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_admitstatus.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_admitstatus.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_admitstatus.restype = None
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_admitstatus_rejected.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_admitstatus_rejected.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_admitstatus_success.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_admitstatus_success.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_admitstatus_uniffi_trait_debug.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_admitstatus_uniffi_trait_debug.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_admitstatus_uniffi_trait_eq_eq.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_admitstatus_uniffi_trait_eq_eq.restype = ctypes.c_int8
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_admitstatus_uniffi_trait_eq_ne.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_admitstatus_uniffi_trait_eq_ne.restype = ctypes.c_int8
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_admitstatus_uniffi_trait_hash.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_admitstatus_uniffi_trait_hash.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_client.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_client.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_client.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_client.restype = None
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_client_new.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_client_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_client_add_discovery_relay.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_client_add_discovery_relay.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_client_add_read_relay.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_client_add_read_relay.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_client_add_relay.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_client_add_relay.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_client_add_relay_with_opts.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_client_add_relay_with_opts.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_client_add_write_relay.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_client_add_write_relay.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_client_automatic_authentication.argtypes = (
    ctypes.c_void_p,
    ctypes.c_int8,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_client_automatic_authentication.restype = None
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_client_connect.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_client_connect.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_client_connect_relay.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_client_connect_relay.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_client_database.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_client_database.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_client_disconnect.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_client_disconnect.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_client_disconnect_relay.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_client_disconnect_relay.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_client_fetch_combined_events.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_client_fetch_combined_events.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_client_fetch_events.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_client_fetch_events.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_client_fetch_events_from.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_client_fetch_events_from.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_client_fetch_metadata.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_client_fetch_metadata.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_client_force_remove_all_relays.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_client_force_remove_all_relays.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_client_force_remove_relay.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_client_force_remove_relay.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_client_gift_wrap.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_client_gift_wrap.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_client_gift_wrap_to.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_client_gift_wrap_to.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_client_handle_notifications.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_client_handle_notifications.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_client_relay.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_client_relay.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_client_relays.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_client_relays.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_client_remove_all_relays.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_client_remove_all_relays.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_client_remove_relay.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_client_remove_relay.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_client_send_event.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_client_send_event.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_client_send_event_builder.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_client_send_event_builder.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_client_send_event_builder_to.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_client_send_event_builder_to.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_client_send_event_to.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_client_send_event_to.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_client_send_msg_to.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_client_send_msg_to.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_client_send_private_msg.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_client_send_private_msg.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_client_send_private_msg_to.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_client_send_private_msg_to.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_client_set_metadata.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_client_set_metadata.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_client_shutdown.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_client_shutdown.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_client_sign_event_builder.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_client_sign_event_builder.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_client_signer.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_client_signer.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_client_stream_events.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_client_stream_events.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_client_stream_events_from.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_client_stream_events_from.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_client_stream_events_targeted.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_client_stream_events_targeted.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_client_subscribe.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_client_subscribe.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_client_subscribe_to.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_client_subscribe_to.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_client_subscribe_with_id.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_client_subscribe_with_id.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_client_subscribe_with_id_to.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_client_subscribe_with_id_to.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_client_subscription.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_client_subscription.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_client_subscriptions.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_client_subscriptions.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_client_sync.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_client_sync.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_client_try_connect.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_client_try_connect.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_client_unsubscribe.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_client_unsubscribe.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_client_unsubscribe_all.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_client_unsubscribe_all.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_client_unwrap_gift_wrap.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_client_unwrap_gift_wrap.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_client_wait_for_connection.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_client_wait_for_connection.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_clientbuilder.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_clientbuilder.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_clientbuilder.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_clientbuilder.restype = None
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_clientbuilder_new.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_clientbuilder_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_clientbuilder_admit_policy.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_clientbuilder_admit_policy.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_clientbuilder_build.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_clientbuilder_build.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_clientbuilder_database.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_clientbuilder_database.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_clientbuilder_gossip.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_clientbuilder_gossip.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_clientbuilder_opts.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_clientbuilder_opts.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_clientbuilder_signer.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_clientbuilder_signer.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_clientbuilder_websocket_transport.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_clientbuilder_websocket_transport.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_clientmessage.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_clientmessage.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_clientmessage.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_clientmessage.restype = None
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_clientmessage_auth.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_clientmessage_auth.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_clientmessage_close.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_clientmessage_close.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_clientmessage_count.argtypes = (
    _UniffiRustBuffer,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_clientmessage_count.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_clientmessage_event.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_clientmessage_event.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_clientmessage_from_enum.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_clientmessage_from_enum.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_clientmessage_from_json.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_clientmessage_from_json.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_clientmessage_req.argtypes = (
    _UniffiRustBuffer,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_clientmessage_req.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_clientmessage_as_enum.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_clientmessage_as_enum.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_clientmessage_as_json.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_clientmessage_as_json.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_clientmessage_uniffi_trait_debug.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_clientmessage_uniffi_trait_debug.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_clientmessage_uniffi_trait_eq_eq.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_clientmessage_uniffi_trait_eq_eq.restype = ctypes.c_int8
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_clientmessage_uniffi_trait_eq_ne.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_clientmessage_uniffi_trait_eq_ne.restype = ctypes.c_int8
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_clientmessage_uniffi_trait_hash.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_clientmessage_uniffi_trait_hash.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_clientoptions.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_clientoptions.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_clientoptions.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_clientoptions.restype = None
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_clientoptions_new.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_clientoptions_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_clientoptions_autoconnect.argtypes = (
    ctypes.c_void_p,
    ctypes.c_int8,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_clientoptions_autoconnect.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_clientoptions_automatic_authentication.argtypes = (
    ctypes.c_void_p,
    ctypes.c_int8,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_clientoptions_automatic_authentication.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_clientoptions_ban_relay_on_mismatch.argtypes = (
    ctypes.c_void_p,
    ctypes.c_int8,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_clientoptions_ban_relay_on_mismatch.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_clientoptions_connection.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_clientoptions_connection.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_clientoptions_gossip.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_clientoptions_gossip.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_clientoptions_max_avg_latency.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_clientoptions_max_avg_latency.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_clientoptions_relay_limits.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_clientoptions_relay_limits.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_clientoptions_verify_subscriptions.argtypes = (
    ctypes.c_void_p,
    ctypes.c_int8,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_clientoptions_verify_subscriptions.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_connection.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_connection.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_connection.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_connection.restype = None
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_connection_new.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_connection_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_connection_addr.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_connection_addr.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_connection_mode.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_connection_mode.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_connection_target.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_connection_target.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_connection_uniffi_trait_debug.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_connection_uniffi_trait_debug.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_connection_uniffi_trait_eq_eq.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_connection_uniffi_trait_eq_eq.restype = ctypes.c_int8
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_connection_uniffi_trait_eq_ne.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_connection_uniffi_trait_eq_ne.restype = ctypes.c_int8
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_connection_uniffi_trait_hash.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_connection_uniffi_trait_hash.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_coordinate.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_coordinate.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_coordinate.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_coordinate.restype = None
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_coordinate_new.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_coordinate_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_coordinate_parse.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_coordinate_parse.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_coordinate_identifier.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_coordinate_identifier.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_coordinate_kind.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_coordinate_kind.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_coordinate_public_key.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_coordinate_public_key.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_coordinate_verify.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_coordinate_verify.restype = ctypes.c_int8
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_coordinate_uniffi_trait_debug.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_coordinate_uniffi_trait_debug.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_coordinate_uniffi_trait_display.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_coordinate_uniffi_trait_display.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_coordinate_uniffi_trait_eq_eq.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_coordinate_uniffi_trait_eq_eq.restype = ctypes.c_int8
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_coordinate_uniffi_trait_eq_ne.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_coordinate_uniffi_trait_eq_ne.restype = ctypes.c_int8
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_coordinate_uniffi_trait_hash.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_coordinate_uniffi_trait_hash.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_customnostrdatabase.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_customnostrdatabase.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_customnostrdatabase.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_customnostrdatabase.restype = None
_UniffiLib.uniffi_nostr_sdk_ffi_fn_init_callback_vtable_customnostrdatabase.argtypes = (
    ctypes.POINTER(_UniffiVTableCallbackInterfaceCustomNostrDatabase),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_init_callback_vtable_customnostrdatabase.restype = None
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_customnostrdatabase_backend.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_customnostrdatabase_backend.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_customnostrdatabase_save_event.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_customnostrdatabase_save_event.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_customnostrdatabase_check_id.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_customnostrdatabase_check_id.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_customnostrdatabase_event_by_id.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_customnostrdatabase_event_by_id.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_customnostrdatabase_count.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_customnostrdatabase_count.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_customnostrdatabase_query.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_customnostrdatabase_query.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_customnostrdatabase_delete.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_customnostrdatabase_delete.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_customnostrdatabase_wipe.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_customnostrdatabase_wipe.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_customnostrsigner.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_customnostrsigner.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_customnostrsigner.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_customnostrsigner.restype = None
_UniffiLib.uniffi_nostr_sdk_ffi_fn_init_callback_vtable_customnostrsigner.argtypes = (
    ctypes.POINTER(_UniffiVTableCallbackInterfaceCustomNostrSigner),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_init_callback_vtable_customnostrsigner.restype = None
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_customnostrsigner_backend.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_customnostrsigner_backend.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_customnostrsigner_get_public_key.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_customnostrsigner_get_public_key.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_customnostrsigner_sign_event.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_customnostrsigner_sign_event.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_customnostrsigner_nip04_encrypt.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_customnostrsigner_nip04_encrypt.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_customnostrsigner_nip04_decrypt.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_customnostrsigner_nip04_decrypt.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_customnostrsigner_nip44_encrypt.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_customnostrsigner_nip44_encrypt.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_customnostrsigner_nip44_decrypt.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_customnostrsigner_nip44_decrypt.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_customwebsockettransport.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_customwebsockettransport.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_customwebsockettransport.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_customwebsockettransport.restype = None
_UniffiLib.uniffi_nostr_sdk_ffi_fn_init_callback_vtable_customwebsockettransport.argtypes = (
    ctypes.POINTER(_UniffiVTableCallbackInterfaceCustomWebSocketTransport),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_init_callback_vtable_customwebsockettransport.restype = None
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_customwebsockettransport_support_ping.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_customwebsockettransport_support_ping.restype = ctypes.c_int8
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_customwebsockettransport_connect.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_customwebsockettransport_connect.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_encryptedsecretkey.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_encryptedsecretkey.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_encryptedsecretkey.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_encryptedsecretkey.restype = None
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_encryptedsecretkey_from_bech32.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_encryptedsecretkey_from_bech32.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_encryptedsecretkey_new.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_uint8,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_encryptedsecretkey_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_encryptedsecretkey_decrypt.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_encryptedsecretkey_decrypt.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_encryptedsecretkey_key_security.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_encryptedsecretkey_key_security.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_encryptedsecretkey_to_bech32.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_encryptedsecretkey_to_bech32.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_encryptedsecretkey_version.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_encryptedsecretkey_version.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_encryptedsecretkey_uniffi_trait_debug.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_encryptedsecretkey_uniffi_trait_debug.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_encryptedsecretkey_uniffi_trait_eq_eq.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_encryptedsecretkey_uniffi_trait_eq_eq.restype = ctypes.c_int8
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_encryptedsecretkey_uniffi_trait_eq_ne.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_encryptedsecretkey_uniffi_trait_eq_ne.restype = ctypes.c_int8
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_encryptedsecretkey_uniffi_trait_hash.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_encryptedsecretkey_uniffi_trait_hash.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_event.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_event.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_event.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_event.restype = None
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_event_from_json.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_event_from_json.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_event_as_json.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_event_as_json.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_event_as_pretty_json.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_event_as_pretty_json.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_event_author.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_event_author.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_event_content.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_event_content.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_event_created_at.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_event_created_at.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_event_id.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_event_id.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_event_is_expired.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_event_is_expired.restype = ctypes.c_int8
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_event_is_protected.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_event_is_protected.restype = ctypes.c_int8
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_event_kind.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_event_kind.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_event_signature.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_event_signature.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_event_tags.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_event_tags.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_event_verify.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_event_verify.restype = ctypes.c_int8
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_event_verify_id.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_event_verify_id.restype = ctypes.c_int8
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_event_verify_signature.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_event_verify_signature.restype = ctypes.c_int8
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_event_uniffi_trait_debug.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_event_uniffi_trait_debug.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_event_uniffi_trait_eq_eq.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_event_uniffi_trait_eq_eq.restype = ctypes.c_int8
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_event_uniffi_trait_eq_ne.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_event_uniffi_trait_eq_ne.restype = ctypes.c_int8
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_event_uniffi_trait_hash.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_event_uniffi_trait_hash.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_eventbuilder.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_eventbuilder.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_eventbuilder.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_eventbuilder.restype = None
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_articles_curation_set.argtypes = (
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_articles_curation_set.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_auth.argtypes = (
    _UniffiRustBuffer,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_auth.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_award_badge.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_award_badge.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_blocked_relays.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_blocked_relays.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_bookmarks.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_bookmarks.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_bookmarks_set.argtypes = (
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_bookmarks_set.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_channel.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_channel.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_channel_metadata.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_channel_metadata.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_channel_msg.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_channel_msg.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_comment.argtypes = (
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_comment.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_communities.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_communities.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_contact_list.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_contact_list.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_define_badge.argtypes = (
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_define_badge.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_delete.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_delete.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_emoji_set.argtypes = (
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_emoji_set.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_emojis.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_emojis.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_file_metadata.argtypes = (
    _UniffiRustBuffer,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_file_metadata.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_follow_set.argtypes = (
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_follow_set.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_git_issue.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_git_issue.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_git_patch.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_git_patch.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_git_repository_announcement.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_git_repository_announcement.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_hide_channel_msg.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_hide_channel_msg.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_http_auth.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_http_auth.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_interest_set.argtypes = (
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_interest_set.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_interests.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_interests.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_job_feedback.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_job_feedback.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_job_request.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_job_request.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_job_result.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_uint64,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_job_result.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_label.argtypes = (
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_label.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_live_event.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_live_event.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_live_event_msg.argtypes = (
    _UniffiRustBuffer,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_live_event_msg.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_long_form_text_note.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_long_form_text_note.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_metadata.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_metadata.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_mute_channel_user.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_mute_channel_user.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_mute_list.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_mute_list.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_new.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_nostr_connect.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_nostr_connect.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_pinned_notes.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_pinned_notes.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_private_msg_rumor.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_private_msg_rumor.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_product_data.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_product_data.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_profile_badges.argtypes = (
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_profile_badges.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_public_chats.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_public_chats.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_public_zap_request.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_public_zap_request.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_reaction.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_reaction.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_relay_list.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_relay_list.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_relay_set.argtypes = (
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_relay_set.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_report.argtypes = (
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_report.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_repost.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_repost.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_seal.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_seal.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_search_relays.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_search_relays.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_stall_data.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_stall_data.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_text_note.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_text_note.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_text_note_reply.argtypes = (
    _UniffiRustBuffer,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_text_note_reply.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_videos_curation_set.argtypes = (
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_videos_curation_set.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_zap_receipt.argtypes = (
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_zap_receipt.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_eventbuilder_allow_self_tagging.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_eventbuilder_allow_self_tagging.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_eventbuilder_build.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_eventbuilder_build.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_eventbuilder_custom_created_at.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_eventbuilder_custom_created_at.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_eventbuilder_dedup_tags.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_eventbuilder_dedup_tags.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_eventbuilder_pow.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint8,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_eventbuilder_pow.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_eventbuilder_sign.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_eventbuilder_sign.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_eventbuilder_sign_with_keys.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_eventbuilder_sign_with_keys.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_eventbuilder_tags.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_eventbuilder_tags.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_eventbuilder_uniffi_trait_debug.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_eventbuilder_uniffi_trait_debug.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_eventbuilder_uniffi_trait_eq_eq.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_eventbuilder_uniffi_trait_eq_eq.restype = ctypes.c_int8
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_eventbuilder_uniffi_trait_eq_ne.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_eventbuilder_uniffi_trait_eq_ne.restype = ctypes.c_int8
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_eventbuilder_uniffi_trait_hash.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_eventbuilder_uniffi_trait_hash.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_eventid.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_eventid.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_eventid.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_eventid.restype = None
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventid_from_bytes.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventid_from_bytes.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventid_new.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventid_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventid_parse.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventid_parse.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_eventid_as_bytes.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_eventid_as_bytes.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_eventid_to_bech32.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_eventid_to_bech32.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_eventid_to_hex.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_eventid_to_hex.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_eventid_to_nostr_uri.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_eventid_to_nostr_uri.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_eventid_uniffi_trait_debug.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_eventid_uniffi_trait_debug.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_eventid_uniffi_trait_eq_eq.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_eventid_uniffi_trait_eq_eq.restype = ctypes.c_int8
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_eventid_uniffi_trait_eq_ne.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_eventid_uniffi_trait_eq_ne.restype = ctypes.c_int8
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_eventid_uniffi_trait_hash.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_eventid_uniffi_trait_hash.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_eventstream.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_eventstream.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_eventstream.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_eventstream.restype = None
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_eventstream_next.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_eventstream_next.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_events.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_events.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_events.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_events.restype = None
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_events_contains.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_events_contains.restype = ctypes.c_int8
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_events_first.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_events_first.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_events_is_empty.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_events_is_empty.restype = ctypes.c_int8
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_events_len.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_events_len.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_events_merge.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_events_merge.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_events_to_vec.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_events_to_vec.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_filemetadata.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_filemetadata.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_filemetadata.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_filemetadata.restype = None
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_filemetadata_new.argtypes = (
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_filemetadata_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filemetadata_aes_256_gcm.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filemetadata_aes_256_gcm.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filemetadata_blurhash.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filemetadata_blurhash.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filemetadata_dimensions.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filemetadata_dimensions.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filemetadata_magnet.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filemetadata_magnet.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filemetadata_size.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filemetadata_size.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filemetadata_uniffi_trait_debug.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filemetadata_uniffi_trait_debug.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filemetadata_uniffi_trait_eq_eq.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filemetadata_uniffi_trait_eq_eq.restype = ctypes.c_int8
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filemetadata_uniffi_trait_eq_ne.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filemetadata_uniffi_trait_eq_ne.restype = ctypes.c_int8
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filemetadata_uniffi_trait_hash.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filemetadata_uniffi_trait_hash.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_filter.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_filter.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_filter.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_filter.restype = None
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_filter_from_json.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_filter_from_json.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_filter_from_record.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_filter_from_record.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_filter_new.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_filter_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filter_as_json.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filter_as_json.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filter_as_record.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filter_as_record.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filter_author.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filter_author.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filter_authors.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filter_authors.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filter_coordinate.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filter_coordinate.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filter_coordinates.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filter_coordinates.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filter_custom_tag.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filter_custom_tag.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filter_custom_tags.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filter_custom_tags.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filter_event.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filter_event.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filter_events.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filter_events.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filter_hashtag.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filter_hashtag.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filter_hashtags.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filter_hashtags.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filter_id.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filter_id.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filter_identifier.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filter_identifier.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filter_identifiers.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filter_identifiers.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filter_ids.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filter_ids.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filter_is_empty.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filter_is_empty.restype = ctypes.c_int8
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filter_kind.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filter_kind.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filter_kinds.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filter_kinds.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filter_limit.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filter_limit.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filter_match_event.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filter_match_event.restype = ctypes.c_int8
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filter_pubkey.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filter_pubkey.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filter_pubkeys.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filter_pubkeys.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filter_reference.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filter_reference.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filter_references.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filter_references.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filter_remove_authors.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filter_remove_authors.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filter_remove_coordinates.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filter_remove_coordinates.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filter_remove_custom_tags.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filter_remove_custom_tags.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filter_remove_events.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filter_remove_events.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filter_remove_hashtags.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filter_remove_hashtags.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filter_remove_identifiers.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filter_remove_identifiers.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filter_remove_ids.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filter_remove_ids.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filter_remove_kinds.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filter_remove_kinds.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filter_remove_limit.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filter_remove_limit.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filter_remove_pubkeys.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filter_remove_pubkeys.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filter_remove_references.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filter_remove_references.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filter_remove_search.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filter_remove_search.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filter_remove_since.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filter_remove_since.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filter_remove_until.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filter_remove_until.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filter_search.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filter_search.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filter_since.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filter_since.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filter_until.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filter_until.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filter_uniffi_trait_debug.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filter_uniffi_trait_debug.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filter_uniffi_trait_eq_eq.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filter_uniffi_trait_eq_eq.restype = ctypes.c_int8
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filter_uniffi_trait_eq_ne.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filter_uniffi_trait_eq_ne.restype = ctypes.c_int8
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filter_uniffi_trait_hash.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filter_uniffi_trait_hash.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_handlenotification.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_handlenotification.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_handlenotification.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_handlenotification.restype = None
_UniffiLib.uniffi_nostr_sdk_ffi_fn_init_callback_vtable_handlenotification.argtypes = (
    ctypes.POINTER(_UniffiVTableCallbackInterfaceHandleNotification),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_init_callback_vtable_handlenotification.restype = None
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_handlenotification_handle_msg.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_handlenotification_handle_msg.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_handlenotification_handle.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_handlenotification_handle.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_jobfeedbackdata.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_jobfeedbackdata.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_jobfeedbackdata.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_jobfeedbackdata.restype = None
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_jobfeedbackdata_new.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_jobfeedbackdata_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_jobfeedbackdata_amount.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint64,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_jobfeedbackdata_amount.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_jobfeedbackdata_extra_info.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_jobfeedbackdata_extra_info.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_jobfeedbackdata_payload.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_jobfeedbackdata_payload.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_keys.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_keys.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_keys.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_keys.restype = None
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_keys_from_mnemonic.argtypes = (
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_keys_from_mnemonic.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_keys_generate.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_keys_generate.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_keys_new.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_keys_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_keys_parse.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_keys_parse.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_keys_public_key.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_keys_public_key.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_keys_secret_key.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_keys_secret_key.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_keys_sign_schnorr.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_keys_sign_schnorr.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_keys_uniffi_trait_debug.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_keys_uniffi_trait_debug.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_keys_uniffi_trait_eq_eq.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_keys_uniffi_trait_eq_eq.restype = ctypes.c_int8
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_keys_uniffi_trait_eq_ne.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_keys_uniffi_trait_eq_ne.restype = ctypes.c_int8
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_keys_uniffi_trait_hash.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_keys_uniffi_trait_hash.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_kind.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_kind.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_kind.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_kind.restype = None
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_kind_from_std.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_kind_from_std.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_kind_new.argtypes = (
    ctypes.c_uint16,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_kind_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_kind_as_std.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_kind_as_std.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_kind_as_u16.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_kind_as_u16.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_kind_is_addressable.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_kind_is_addressable.restype = ctypes.c_int8
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_kind_is_ephemeral.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_kind_is_ephemeral.restype = ctypes.c_int8
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_kind_is_job_request.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_kind_is_job_request.restype = ctypes.c_int8
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_kind_is_job_result.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_kind_is_job_result.restype = ctypes.c_int8
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_kind_is_regular.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_kind_is_regular.restype = ctypes.c_int8
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_kind_is_replaceable.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_kind_is_replaceable.restype = ctypes.c_int8
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_kind_uniffi_trait_debug.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_kind_uniffi_trait_debug.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_kind_uniffi_trait_display.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_kind_uniffi_trait_display.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_kind_uniffi_trait_eq_eq.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_kind_uniffi_trait_eq_eq.restype = ctypes.c_int8
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_kind_uniffi_trait_eq_ne.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_kind_uniffi_trait_eq_ne.restype = ctypes.c_int8
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_kind_uniffi_trait_hash.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_kind_uniffi_trait_hash.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_localrelay.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_localrelay.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_localrelay.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_localrelay.restype = None
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_localrelay_new.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_localrelay_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_localrelay_notify_event.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_localrelay_notify_event.restype = ctypes.c_int8
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_localrelay_run.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_localrelay_run.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_localrelay_shutdown.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_localrelay_shutdown.restype = None
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_localrelay_url.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_localrelay_url.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_metadata.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_metadata.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_metadata.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_metadata.restype = None
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_metadata_from_json.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_metadata_from_json.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_metadata_from_record.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_metadata_from_record.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_metadata_as_json.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_metadata_as_json.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_metadata_as_pretty_json.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_metadata_as_pretty_json.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_metadata_as_record.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_metadata_as_record.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_metadata_uniffi_trait_debug.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_metadata_uniffi_trait_debug.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_metadata_uniffi_trait_eq_eq.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_metadata_uniffi_trait_eq_eq.restype = ctypes.c_int8
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_metadata_uniffi_trait_eq_ne.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_metadata_uniffi_trait_eq_ne.restype = ctypes.c_int8
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_metadata_uniffi_trait_hash.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_metadata_uniffi_trait_hash.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_nwc.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_nwc.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_nwc.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_nwc.restype = None
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_nwc_new.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_nwc_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_nwc_with_opts.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_nwc_with_opts.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nwc_get_balance.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nwc_get_balance.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nwc_get_info.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nwc_get_info.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nwc_list_transactions.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nwc_list_transactions.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nwc_lookup_invoice.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nwc_lookup_invoice.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nwc_make_invoice.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nwc_make_invoice.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nwc_pay_invoice.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nwc_pay_invoice.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nwc_pay_keysend.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nwc_pay_keysend.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nwc_status.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nwc_status.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_nip05address.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_nip05address.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_nip05address.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_nip05address.restype = None
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_nip05address_parse.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_nip05address_parse.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip05address_domain.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip05address_domain.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip05address_name.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip05address_name.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip05address_url.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip05address_url.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip05address_uniffi_trait_debug.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip05address_uniffi_trait_debug.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip05address_uniffi_trait_display.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip05address_uniffi_trait_display.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip05address_uniffi_trait_eq_eq.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip05address_uniffi_trait_eq_eq.restype = ctypes.c_int8
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip05address_uniffi_trait_eq_ne.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip05address_uniffi_trait_eq_ne.restype = ctypes.c_int8
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip05address_uniffi_trait_hash.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip05address_uniffi_trait_hash.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_nip05profile.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_nip05profile.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_nip05profile.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_nip05profile.restype = None
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_nip05profile_from_json.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_nip05profile_from_json.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip05profile_nip46.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip05profile_nip46.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip05profile_public_key.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip05profile_public_key.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip05profile_relays.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip05profile_relays.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip05profile_uniffi_trait_debug.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip05profile_uniffi_trait_debug.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip05profile_uniffi_trait_eq_eq.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip05profile_uniffi_trait_eq_eq.restype = ctypes.c_int8
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip05profile_uniffi_trait_eq_ne.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip05profile_uniffi_trait_eq_ne.restype = ctypes.c_int8
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip05profile_uniffi_trait_hash.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip05profile_uniffi_trait_hash.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_nip19.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_nip19.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_nip19.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_nip19.restype = None
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_nip19_from_bech32.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_nip19_from_bech32.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip19_as_enum.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip19_as_enum.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip19_uniffi_trait_debug.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip19_uniffi_trait_debug.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip19_uniffi_trait_eq_eq.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip19_uniffi_trait_eq_eq.restype = ctypes.c_int8
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip19_uniffi_trait_eq_ne.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip19_uniffi_trait_eq_ne.restype = ctypes.c_int8
_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_nip19coordinate.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_nip19coordinate.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_nip19coordinate.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_nip19coordinate.restype = None
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_nip19coordinate_from_bech32.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_nip19coordinate_from_bech32.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_nip19coordinate_from_nostr_uri.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_nip19coordinate_from_nostr_uri.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_nip19coordinate_new.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_nip19coordinate_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip19coordinate_coordinate.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip19coordinate_coordinate.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip19coordinate_relays.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip19coordinate_relays.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip19coordinate_to_bech32.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip19coordinate_to_bech32.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip19coordinate_to_nostr_uri.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip19coordinate_to_nostr_uri.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip19coordinate_uniffi_trait_debug.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip19coordinate_uniffi_trait_debug.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip19coordinate_uniffi_trait_eq_eq.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip19coordinate_uniffi_trait_eq_eq.restype = ctypes.c_int8
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip19coordinate_uniffi_trait_eq_ne.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip19coordinate_uniffi_trait_eq_ne.restype = ctypes.c_int8
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip19coordinate_uniffi_trait_hash.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip19coordinate_uniffi_trait_hash.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_nip19event.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_nip19event.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_nip19event.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_nip19event.restype = None
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_nip19event_from_bech32.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_nip19event_from_bech32.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_nip19event_from_event.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_nip19event_from_event.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_nip19event_from_nostr_uri.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_nip19event_from_nostr_uri.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_nip19event_new.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_nip19event_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip19event_author.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip19event_author.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip19event_event_id.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip19event_event_id.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip19event_kind.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip19event_kind.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip19event_relays.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip19event_relays.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip19event_to_bech32.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip19event_to_bech32.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip19event_to_nostr_uri.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip19event_to_nostr_uri.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip19event_uniffi_trait_debug.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip19event_uniffi_trait_debug.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip19event_uniffi_trait_eq_eq.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip19event_uniffi_trait_eq_eq.restype = ctypes.c_int8
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip19event_uniffi_trait_eq_ne.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip19event_uniffi_trait_eq_ne.restype = ctypes.c_int8
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip19event_uniffi_trait_hash.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip19event_uniffi_trait_hash.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_nip19profile.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_nip19profile.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_nip19profile.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_nip19profile.restype = None
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_nip19profile_from_bech32.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_nip19profile_from_bech32.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_nip19profile_from_nostr_uri.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_nip19profile_from_nostr_uri.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_nip19profile_new.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_nip19profile_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip19profile_public_key.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip19profile_public_key.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip19profile_relays.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip19profile_relays.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip19profile_to_bech32.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip19profile_to_bech32.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip19profile_to_nostr_uri.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip19profile_to_nostr_uri.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip19profile_uniffi_trait_debug.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip19profile_uniffi_trait_debug.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip19profile_uniffi_trait_eq_eq.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip19profile_uniffi_trait_eq_eq.restype = ctypes.c_int8
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip19profile_uniffi_trait_eq_ne.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip19profile_uniffi_trait_eq_ne.restype = ctypes.c_int8
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip19profile_uniffi_trait_hash.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip19profile_uniffi_trait_hash.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_nip21.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_nip21.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_nip21.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_nip21.restype = None
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_nip21_parse.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_nip21_parse.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip21_as_enum.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip21_as_enum.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip21_to_nostr_uri.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip21_to_nostr_uri.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip21_uniffi_trait_debug.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip21_uniffi_trait_debug.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip21_uniffi_trait_eq_eq.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip21_uniffi_trait_eq_eq.restype = ctypes.c_int8
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip21_uniffi_trait_eq_ne.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip21_uniffi_trait_eq_ne.restype = ctypes.c_int8
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip21_uniffi_trait_hash.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip21_uniffi_trait_hash.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_nip96serverconfig.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_nip96serverconfig.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_nip96serverconfig.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_nip96serverconfig.restype = None
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_nip96serverconfig_from_json.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_nip96serverconfig_from_json.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip96serverconfig_api_url.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip96serverconfig_api_url.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip96serverconfig_as_json.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip96serverconfig_as_json.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip96serverconfig_content_types.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip96serverconfig_content_types.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip96serverconfig_delegated_to_url.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip96serverconfig_delegated_to_url.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip96serverconfig_download_url.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip96serverconfig_download_url.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip96serverconfig_uniffi_trait_debug.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip96serverconfig_uniffi_trait_debug.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip96serverconfig_uniffi_trait_eq_eq.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip96serverconfig_uniffi_trait_eq_eq.restype = ctypes.c_int8
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip96serverconfig_uniffi_trait_eq_ne.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip96serverconfig_uniffi_trait_eq_ne.restype = ctypes.c_int8
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip96serverconfig_uniffi_trait_hash.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip96serverconfig_uniffi_trait_hash.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_nip96uploadrequest.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_nip96uploadrequest.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_nip96uploadrequest.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_nip96uploadrequest.restype = None
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_nip96uploadrequest_create.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_nip96uploadrequest_create.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip96uploadrequest_authorization.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip96uploadrequest_authorization.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip96uploadrequest_url.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip96uploadrequest_url.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip96uploadrequest_uniffi_trait_debug.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip96uploadrequest_uniffi_trait_debug.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip96uploadrequest_uniffi_trait_eq_eq.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip96uploadrequest_uniffi_trait_eq_eq.restype = ctypes.c_int8
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip96uploadrequest_uniffi_trait_eq_ne.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip96uploadrequest_uniffi_trait_eq_ne.restype = ctypes.c_int8
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip96uploadrequest_uniffi_trait_hash.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip96uploadrequest_uniffi_trait_hash.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_nip96uploadresponse.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_nip96uploadresponse.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_nip96uploadresponse.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_nip96uploadresponse.restype = None
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_nip96uploadresponse_from_json.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_nip96uploadresponse_from_json.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip96uploadresponse_as_json.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip96uploadresponse_as_json.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip96uploadresponse_download_url.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip96uploadresponse_download_url.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip96uploadresponse_is_success.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip96uploadresponse_is_success.restype = ctypes.c_int8
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip96uploadresponse_message.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip96uploadresponse_message.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip96uploadresponse_uniffi_trait_debug.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip96uploadresponse_uniffi_trait_debug.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip96uploadresponse_uniffi_trait_eq_eq.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip96uploadresponse_uniffi_trait_eq_eq.restype = ctypes.c_int8
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip96uploadresponse_uniffi_trait_eq_ne.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip96uploadresponse_uniffi_trait_eq_ne.restype = ctypes.c_int8
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip96uploadresponse_uniffi_trait_hash.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip96uploadresponse_uniffi_trait_hash.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_nostrconnect.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_nostrconnect.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_nostrconnect.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_nostrconnect.restype = None
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_nostrconnect_new.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_nostrconnect_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nostrconnect_bunker_uri.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nostrconnect_bunker_uri.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nostrconnect_get_public_key.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nostrconnect_get_public_key.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nostrconnect_nip04_decrypt.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nostrconnect_nip04_decrypt.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nostrconnect_nip04_encrypt.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nostrconnect_nip04_encrypt.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nostrconnect_nip44_decrypt.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nostrconnect_nip44_decrypt.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nostrconnect_nip44_encrypt.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nostrconnect_nip44_encrypt.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nostrconnect_relays.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nostrconnect_relays.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nostrconnect_sign_event.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nostrconnect_sign_event.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_nostrconnectmetadata.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_nostrconnectmetadata.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_nostrconnectmetadata.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_nostrconnectmetadata.restype = None
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_nostrconnectmetadata_new.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_nostrconnectmetadata_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nostrconnectmetadata_as_json.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nostrconnectmetadata_as_json.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nostrconnectmetadata_description.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nostrconnectmetadata_description.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nostrconnectmetadata_icons.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nostrconnectmetadata_icons.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nostrconnectmetadata_url.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nostrconnectmetadata_url.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nostrconnectmetadata_uniffi_trait_debug.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nostrconnectmetadata_uniffi_trait_debug.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nostrconnectmetadata_uniffi_trait_eq_eq.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nostrconnectmetadata_uniffi_trait_eq_eq.restype = ctypes.c_int8
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nostrconnectmetadata_uniffi_trait_eq_ne.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nostrconnectmetadata_uniffi_trait_eq_ne.restype = ctypes.c_int8
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nostrconnectmetadata_uniffi_trait_hash.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nostrconnectmetadata_uniffi_trait_hash.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_nostrconnecturi.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_nostrconnecturi.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_nostrconnecturi.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_nostrconnecturi.restype = None
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_nostrconnecturi_parse.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_nostrconnecturi_parse.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nostrconnecturi_uniffi_trait_debug.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nostrconnecturi_uniffi_trait_debug.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nostrconnecturi_uniffi_trait_display.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nostrconnecturi_uniffi_trait_display.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nostrconnecturi_uniffi_trait_eq_eq.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nostrconnecturi_uniffi_trait_eq_eq.restype = ctypes.c_int8
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nostrconnecturi_uniffi_trait_eq_ne.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nostrconnecturi_uniffi_trait_eq_ne.restype = ctypes.c_int8
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nostrconnecturi_uniffi_trait_hash.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nostrconnecturi_uniffi_trait_hash.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_nostrdatabase.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_nostrdatabase.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_nostrdatabase.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_nostrdatabase.restype = None
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_nostrdatabase_custom.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_nostrdatabase_custom.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_nostrdatabase_lmdb.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_nostrdatabase_lmdb.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nostrdatabase_count.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nostrdatabase_count.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nostrdatabase_delete.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nostrdatabase_delete.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nostrdatabase_event_by_id.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nostrdatabase_event_by_id.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nostrdatabase_metadata.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nostrdatabase_metadata.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nostrdatabase_query.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nostrdatabase_query.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nostrdatabase_save_event.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nostrdatabase_save_event.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nostrdatabase_wipe.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nostrdatabase_wipe.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_nostrgossip.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_nostrgossip.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_nostrgossip.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_nostrgossip.restype = None
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_nostrgossip_in_memory.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_nostrgossip_in_memory.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_nostrparser.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_nostrparser.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_nostrparser.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_nostrparser.restype = None
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_nostrparser_new.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_nostrparser_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nostrparser_parse.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nostrparser_parse.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_nostrsigner.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_nostrsigner.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_nostrsigner.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_nostrsigner.restype = None
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_nostrsigner_custom.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_nostrsigner_custom.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_nostrsigner_keys.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_nostrsigner_keys.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_nostrsigner_nostr_connect.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_nostrsigner_nostr_connect.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nostrsigner_backend.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nostrsigner_backend.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nostrsigner_get_public_key.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nostrsigner_get_public_key.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nostrsigner_nip04_decrypt.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nostrsigner_nip04_decrypt.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nostrsigner_nip04_encrypt.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nostrsigner_nip04_encrypt.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nostrsigner_nip44_decrypt.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nostrsigner_nip44_decrypt.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nostrsigner_nip44_encrypt.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nostrsigner_nip44_encrypt.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nostrsigner_sign_event.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nostrsigner_sign_event.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_nostrwalletconnectoptions.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_nostrwalletconnectoptions.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_nostrwalletconnectoptions.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_nostrwalletconnectoptions.restype = None
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_nostrwalletconnectoptions_new.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_nostrwalletconnectoptions_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nostrwalletconnectoptions_relay.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nostrwalletconnectoptions_relay.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nostrwalletconnectoptions_timeout.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nostrwalletconnectoptions_timeout.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_nostrwalletconnecturi.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_nostrwalletconnecturi.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_nostrwalletconnecturi.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_nostrwalletconnecturi.restype = None
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_nostrwalletconnecturi_new.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_nostrwalletconnecturi_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_nostrwalletconnecturi_parse.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_nostrwalletconnecturi_parse.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nostrwalletconnecturi_lud16.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nostrwalletconnecturi_lud16.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nostrwalletconnecturi_public_key.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nostrwalletconnecturi_public_key.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nostrwalletconnecturi_relays.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nostrwalletconnecturi_relays.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nostrwalletconnecturi_secret.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nostrwalletconnecturi_secret.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nostrwalletconnecturi_uniffi_trait_debug.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nostrwalletconnecturi_uniffi_trait_debug.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nostrwalletconnecturi_uniffi_trait_display.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nostrwalletconnecturi_uniffi_trait_display.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nostrwalletconnecturi_uniffi_trait_eq_eq.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nostrwalletconnecturi_uniffi_trait_eq_eq.restype = ctypes.c_int8
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nostrwalletconnecturi_uniffi_trait_eq_ne.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nostrwalletconnecturi_uniffi_trait_eq_ne.restype = ctypes.c_int8
_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_publickey.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_publickey.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_publickey.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_publickey.restype = None
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_publickey_from_bytes.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_publickey_from_bytes.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_publickey_parse.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_publickey_parse.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_publickey_to_bech32.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_publickey_to_bech32.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_publickey_to_hex.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_publickey_to_hex.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_publickey_to_nostr_uri.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_publickey_to_nostr_uri.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_publickey_uniffi_trait_debug.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_publickey_uniffi_trait_debug.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_publickey_uniffi_trait_eq_eq.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_publickey_uniffi_trait_eq_eq.restype = ctypes.c_int8
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_publickey_uniffi_trait_eq_ne.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_publickey_uniffi_trait_eq_ne.restype = ctypes.c_int8
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_publickey_uniffi_trait_hash.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_publickey_uniffi_trait_hash.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_querypolicy.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_querypolicy.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_querypolicy.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_querypolicy.restype = None
_UniffiLib.uniffi_nostr_sdk_ffi_fn_init_callback_vtable_querypolicy.argtypes = (
    ctypes.POINTER(_UniffiVTableCallbackInterfaceQueryPolicy),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_init_callback_vtable_querypolicy.restype = None
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_querypolicy_admit_query.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_querypolicy_admit_query.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_relay.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_relay.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_relay.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_relay.restype = None
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relay_ban.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relay_ban.restype = None
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relay_batch_msg.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relay_batch_msg.restype = None
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relay_connect.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relay_connect.restype = None
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relay_connection_mode.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relay_connection_mode.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relay_count_events.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relay_count_events.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relay_disconnect.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relay_disconnect.restype = None
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relay_fetch_events.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relay_fetch_events.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relay_is_connected.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relay_is_connected.restype = ctypes.c_int8
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relay_opts.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relay_opts.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relay_queue.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relay_queue.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relay_send_event.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relay_send_event.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relay_send_msg.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relay_send_msg.restype = None
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relay_stats.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relay_stats.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relay_status.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relay_status.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relay_subscribe.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relay_subscribe.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relay_subscribe_with_id.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_void_p,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relay_subscribe_with_id.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relay_subscription.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relay_subscription.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relay_subscriptions.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relay_subscriptions.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relay_sync.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relay_sync.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relay_sync_with_items.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relay_sync_with_items.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relay_try_connect.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relay_try_connect.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relay_unsubscribe.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relay_unsubscribe.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relay_unsubscribe_all.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relay_unsubscribe_all.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relay_url.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relay_url.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_relaybuilder.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_relaybuilder.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_relaybuilder.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_relaybuilder.restype = None
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_relaybuilder_new.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_relaybuilder_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relaybuilder_addr.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relaybuilder_addr.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relaybuilder_auth_dm.argtypes = (
    ctypes.c_void_p,
    ctypes.c_int8,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relaybuilder_auth_dm.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relaybuilder_database.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relaybuilder_database.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relaybuilder_default_filter_limit.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relaybuilder_default_filter_limit.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relaybuilder_max_connections.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relaybuilder_max_connections.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relaybuilder_max_filter_limit.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relaybuilder_max_filter_limit.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relaybuilder_max_subid_length.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relaybuilder_max_subid_length.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relaybuilder_min_pow.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint8,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relaybuilder_min_pow.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relaybuilder_nip42.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relaybuilder_nip42.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relaybuilder_port.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint16,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relaybuilder_port.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relaybuilder_query_policy.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relaybuilder_query_policy.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relaybuilder_rate_limit.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relaybuilder_rate_limit.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relaybuilder_write_policy.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relaybuilder_write_policy.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_relayconnectionstats.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_relayconnectionstats.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_relayconnectionstats.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_relayconnectionstats.restype = None
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relayconnectionstats_attempts.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relayconnectionstats_attempts.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relayconnectionstats_bytes_received.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relayconnectionstats_bytes_received.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relayconnectionstats_bytes_sent.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relayconnectionstats_bytes_sent.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relayconnectionstats_connected_at.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relayconnectionstats_connected_at.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relayconnectionstats_first_connection_timestamp.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relayconnectionstats_first_connection_timestamp.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relayconnectionstats_latency.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relayconnectionstats_latency.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relayconnectionstats_success.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relayconnectionstats_success.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relayconnectionstats_success_rate.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relayconnectionstats_success_rate.restype = ctypes.c_double
_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_relayinformationdocument.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_relayinformationdocument.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_relayinformationdocument.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_relayinformationdocument.restype = None
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_relayinformationdocument_from_json.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_relayinformationdocument_from_json.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relayinformationdocument_as_json.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relayinformationdocument_as_json.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relayinformationdocument_contact.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relayinformationdocument_contact.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relayinformationdocument_description.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relayinformationdocument_description.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relayinformationdocument_fees.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relayinformationdocument_fees.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relayinformationdocument_icon.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relayinformationdocument_icon.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relayinformationdocument_language_tags.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relayinformationdocument_language_tags.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relayinformationdocument_limitation.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relayinformationdocument_limitation.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relayinformationdocument_name.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relayinformationdocument_name.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relayinformationdocument_payments_url.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relayinformationdocument_payments_url.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relayinformationdocument_posting_policy.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relayinformationdocument_posting_policy.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relayinformationdocument_pubkey.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relayinformationdocument_pubkey.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relayinformationdocument_relay_countries.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relayinformationdocument_relay_countries.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relayinformationdocument_retention.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relayinformationdocument_retention.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relayinformationdocument_software.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relayinformationdocument_software.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relayinformationdocument_supported_nips.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relayinformationdocument_supported_nips.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relayinformationdocument_tags.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relayinformationdocument_tags.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relayinformationdocument_version.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relayinformationdocument_version.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relayinformationdocument_uniffi_trait_debug.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relayinformationdocument_uniffi_trait_debug.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relayinformationdocument_uniffi_trait_eq_eq.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relayinformationdocument_uniffi_trait_eq_eq.restype = ctypes.c_int8
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relayinformationdocument_uniffi_trait_eq_ne.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relayinformationdocument_uniffi_trait_eq_ne.restype = ctypes.c_int8
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relayinformationdocument_uniffi_trait_hash.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relayinformationdocument_uniffi_trait_hash.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_relaylimits.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_relaylimits.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_relaylimits.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_relaylimits.restype = None
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_relaylimits_disable.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_relaylimits_disable.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_relaylimits_new.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_relaylimits_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relaylimits_event_max_num_tags.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relaylimits_event_max_num_tags.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relaylimits_event_max_num_tags_per_kind.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relaylimits_event_max_num_tags_per_kind.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relaylimits_event_max_size.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relaylimits_event_max_size.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relaylimits_event_max_size_per_kind.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relaylimits_event_max_size_per_kind.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relaylimits_message_max_size.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relaylimits_message_max_size.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relaylimits_uniffi_trait_debug.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relaylimits_uniffi_trait_debug.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relaylimits_uniffi_trait_eq_eq.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relaylimits_uniffi_trait_eq_eq.restype = ctypes.c_int8
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relaylimits_uniffi_trait_eq_ne.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relaylimits_uniffi_trait_eq_ne.restype = ctypes.c_int8
_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_relaymessage.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_relaymessage.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_relaymessage.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_relaymessage.restype = None
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_relaymessage_auth.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_relaymessage_auth.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_relaymessage_closed.argtypes = (
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_relaymessage_closed.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_relaymessage_count.argtypes = (
    _UniffiRustBuffer,
    ctypes.c_double,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_relaymessage_count.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_relaymessage_eose.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_relaymessage_eose.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_relaymessage_event.argtypes = (
    _UniffiRustBuffer,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_relaymessage_event.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_relaymessage_from_enum.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_relaymessage_from_enum.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_relaymessage_from_json.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_relaymessage_from_json.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_relaymessage_notice.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_relaymessage_notice.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_relaymessage_ok.argtypes = (
    ctypes.c_void_p,
    ctypes.c_int8,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_relaymessage_ok.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relaymessage_as_enum.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relaymessage_as_enum.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relaymessage_as_json.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relaymessage_as_json.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relaymessage_uniffi_trait_debug.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relaymessage_uniffi_trait_debug.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relaymessage_uniffi_trait_eq_eq.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relaymessage_uniffi_trait_eq_eq.restype = ctypes.c_int8
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relaymessage_uniffi_trait_eq_ne.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relaymessage_uniffi_trait_eq_ne.restype = ctypes.c_int8
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relaymessage_uniffi_trait_hash.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relaymessage_uniffi_trait_hash.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_relayoptions.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_relayoptions.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_relayoptions.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_relayoptions.restype = None
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_relayoptions_new.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_relayoptions_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relayoptions_adjust_retry_interval.argtypes = (
    ctypes.c_void_p,
    ctypes.c_int8,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relayoptions_adjust_retry_interval.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relayoptions_ban_relay_on_mismatch.argtypes = (
    ctypes.c_void_p,
    ctypes.c_int8,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relayoptions_ban_relay_on_mismatch.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relayoptions_connection_mode.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relayoptions_connection_mode.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relayoptions_limits.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relayoptions_limits.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relayoptions_max_avg_latency.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relayoptions_max_avg_latency.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relayoptions_ping.argtypes = (
    ctypes.c_void_p,
    ctypes.c_int8,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relayoptions_ping.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relayoptions_read.argtypes = (
    ctypes.c_void_p,
    ctypes.c_int8,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relayoptions_read.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relayoptions_reconnect.argtypes = (
    ctypes.c_void_p,
    ctypes.c_int8,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relayoptions_reconnect.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relayoptions_retry_interval.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relayoptions_retry_interval.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relayoptions_verify_subscriptions.argtypes = (
    ctypes.c_void_p,
    ctypes.c_int8,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relayoptions_verify_subscriptions.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relayoptions_write.argtypes = (
    ctypes.c_void_p,
    ctypes.c_int8,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relayoptions_write.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_relayurl.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_relayurl.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_relayurl.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_relayurl.restype = None
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_relayurl_parse.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_relayurl_parse.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relayurl_is_local_addr.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relayurl_is_local_addr.restype = ctypes.c_int8
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relayurl_is_onion.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relayurl_is_onion.restype = ctypes.c_int8
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relayurl_uniffi_trait_debug.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relayurl_uniffi_trait_debug.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relayurl_uniffi_trait_display.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relayurl_uniffi_trait_display.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relayurl_uniffi_trait_eq_eq.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relayurl_uniffi_trait_eq_eq.restype = ctypes.c_int8
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relayurl_uniffi_trait_eq_ne.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relayurl_uniffi_trait_eq_ne.restype = ctypes.c_int8
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relayurl_uniffi_trait_hash.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relayurl_uniffi_trait_hash.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_request.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_request.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_request.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_request.restype = None
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_request_new.argtypes = (
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_request_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_request_parse.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_request_parse.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_request_method.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_request_method.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_request_params.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_request_params.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_request_uniffi_trait_debug.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_request_uniffi_trait_debug.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_request_uniffi_trait_eq_eq.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_request_uniffi_trait_eq_eq.restype = ctypes.c_int8
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_request_uniffi_trait_eq_ne.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_request_uniffi_trait_eq_ne.restype = ctypes.c_int8
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_request_uniffi_trait_hash.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_request_uniffi_trait_hash.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_response.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_response.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_response.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_response.restype = None
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_response_uniffi_trait_debug.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_response_uniffi_trait_debug.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_response_uniffi_trait_eq_eq.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_response_uniffi_trait_eq_eq.restype = ctypes.c_int8
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_response_uniffi_trait_eq_ne.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_response_uniffi_trait_eq_ne.restype = ctypes.c_int8
_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_saveeventstatus.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_saveeventstatus.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_saveeventstatus.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_saveeventstatus.restype = None
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_saveeventstatus_rejected.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_saveeventstatus_rejected.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_saveeventstatus_success.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_saveeventstatus_success.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_saveeventstatus_is_success.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_saveeventstatus_is_success.restype = ctypes.c_int8
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_saveeventstatus_rejection_reason.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_saveeventstatus_rejection_reason.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_secretkey.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_secretkey.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_secretkey.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_secretkey.restype = None
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_secretkey_from_bytes.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_secretkey_from_bytes.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_secretkey_generate.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_secretkey_generate.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_secretkey_parse.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_secretkey_parse.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_secretkey_encrypt.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_secretkey_encrypt.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_secretkey_to_bech32.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_secretkey_to_bech32.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_secretkey_to_hex.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_secretkey_to_hex.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_secretkey_uniffi_trait_debug.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_secretkey_uniffi_trait_debug.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_secretkey_uniffi_trait_eq_eq.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_secretkey_uniffi_trait_eq_eq.restype = ctypes.c_int8
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_secretkey_uniffi_trait_eq_ne.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_secretkey_uniffi_trait_eq_ne.restype = ctypes.c_int8
_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_shippingmethod.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_shippingmethod.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_shippingmethod.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_shippingmethod.restype = None
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_shippingmethod_new.argtypes = (
    _UniffiRustBuffer,
    ctypes.c_double,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_shippingmethod_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_shippingmethod_get_shipping_cost.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_shippingmethod_get_shipping_cost.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_shippingmethod_name.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_shippingmethod_name.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_shippingmethod_regions.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_shippingmethod_regions.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_singlelettertag.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_singlelettertag.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_singlelettertag.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_singlelettertag.restype = None
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_singlelettertag_lowercase.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_singlelettertag_lowercase.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_singlelettertag_uppercase.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_singlelettertag_uppercase.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_singlelettertag_is_lowercase.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_singlelettertag_is_lowercase.restype = ctypes.c_int8
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_singlelettertag_is_uppercase.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_singlelettertag_is_uppercase.restype = ctypes.c_int8
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_singlelettertag_uniffi_trait_debug.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_singlelettertag_uniffi_trait_debug.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_singlelettertag_uniffi_trait_eq_eq.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_singlelettertag_uniffi_trait_eq_eq.restype = ctypes.c_int8
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_singlelettertag_uniffi_trait_eq_ne.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_singlelettertag_uniffi_trait_eq_ne.restype = ctypes.c_int8
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_singlelettertag_uniffi_trait_hash.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_singlelettertag_uniffi_trait_hash.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_stalldata.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_stalldata.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_stalldata.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_stalldata.restype = None
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_stalldata_from_json.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_stalldata_from_json.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_stalldata_from_record.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_stalldata_from_record.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_stalldata_new.argtypes = (
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_stalldata_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_stalldata_as_json.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_stalldata_as_json.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_stalldata_as_record.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_stalldata_as_record.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_stalldata_currency.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_stalldata_currency.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_stalldata_description.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_stalldata_description.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_stalldata_id.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_stalldata_id.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_stalldata_name.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_stalldata_name.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_stalldata_shipping.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_stalldata_shipping.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_subscribeautocloseoptions.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_subscribeautocloseoptions.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_subscribeautocloseoptions.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_subscribeautocloseoptions.restype = None
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_subscribeautocloseoptions_new.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_subscribeautocloseoptions_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_subscribeautocloseoptions_exit_policy.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_subscribeautocloseoptions_exit_policy.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_subscribeautocloseoptions_idle_timeout.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_subscribeautocloseoptions_idle_timeout.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_subscribeautocloseoptions_timeout.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_subscribeautocloseoptions_timeout.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_subscribeoptions.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_subscribeoptions.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_subscribeoptions.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_subscribeoptions.restype = None
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_subscribeoptions_new.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_subscribeoptions_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_subscribeoptions_close_on.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_subscribeoptions_close_on.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_syncoptions.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_syncoptions.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_syncoptions.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_syncoptions.restype = None
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_syncoptions_new.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_syncoptions_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_syncoptions_direction.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_syncoptions_direction.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_syncoptions_dry_run.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_syncoptions_dry_run.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_syncoptions_initial_timeout.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_syncoptions_initial_timeout.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_tag.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_tag.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_tag.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_tag.restype = None
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_tag_alt.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_tag_alt.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_tag_client.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_tag_client.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_tag_coordinate.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_tag_coordinate.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_tag_custom.argtypes = (
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_tag_custom.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_tag_description.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_tag_description.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_tag_event.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_tag_event.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_tag_event_report.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_tag_event_report.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_tag_expiration.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_tag_expiration.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_tag_from_standardized.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_tag_from_standardized.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_tag_hashtag.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_tag_hashtag.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_tag_identifier.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_tag_identifier.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_tag_image.argtypes = (
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_tag_image.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_tag_parse.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_tag_parse.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_tag_pow.argtypes = (
    ctypes.c_uint64,
    ctypes.c_uint8,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_tag_pow.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_tag_protected.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_tag_protected.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_tag_public_key.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_tag_public_key.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_tag_public_key_report.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_tag_public_key_report.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_tag_reference.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_tag_reference.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_tag_relay_metadata.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_tag_relay_metadata.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_tag_title.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_tag_title.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_tag_as_standardized.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_tag_as_standardized.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_tag_as_vec.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_tag_as_vec.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_tag_content.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_tag_content.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_tag_is_protected.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_tag_is_protected.restype = ctypes.c_int8
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_tag_is_reply.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_tag_is_reply.restype = ctypes.c_int8
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_tag_is_root.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_tag_is_root.restype = ctypes.c_int8
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_tag_kind.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_tag_kind.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_tag_kind_str.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_tag_kind_str.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_tag_len.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_tag_len.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_tag_single_letter_tag.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_tag_single_letter_tag.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_tag_uniffi_trait_debug.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_tag_uniffi_trait_debug.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_tag_uniffi_trait_eq_eq.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_tag_uniffi_trait_eq_eq.restype = ctypes.c_int8
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_tag_uniffi_trait_eq_ne.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_tag_uniffi_trait_eq_ne.restype = ctypes.c_int8
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_tag_uniffi_trait_hash.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_tag_uniffi_trait_hash.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_tags.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_tags.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_tags.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_tags.restype = None
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_tags_from_list.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_tags_from_list.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_tags_parse.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_tags_parse.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_tags_coordinates.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_tags_coordinates.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_tags_event_ids.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_tags_event_ids.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_tags_expiration.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_tags_expiration.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_tags_filter.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_tags_filter.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_tags_filter_standardized.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_tags_filter_standardized.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_tags_find.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_tags_find.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_tags_find_standardized.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_tags_find_standardized.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_tags_first.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_tags_first.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_tags_get.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_tags_get.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_tags_hashtags.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_tags_hashtags.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_tags_identifier.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_tags_identifier.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_tags_is_empty.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_tags_is_empty.restype = ctypes.c_int8
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_tags_last.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_tags_last.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_tags_len.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_tags_len.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_tags_public_keys.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_tags_public_keys.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_tags_to_vec.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_tags_to_vec.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_tags_uniffi_trait_debug.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_tags_uniffi_trait_debug.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_tags_uniffi_trait_eq_eq.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_tags_uniffi_trait_eq_eq.restype = ctypes.c_int8
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_tags_uniffi_trait_eq_ne.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_tags_uniffi_trait_eq_ne.restype = ctypes.c_int8
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_tags_uniffi_trait_hash.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_tags_uniffi_trait_hash.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_timestamp.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_timestamp.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_timestamp.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_timestamp.restype = None
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_timestamp_from_secs.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_timestamp_from_secs.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_timestamp_max.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_timestamp_max.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_timestamp_min.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_timestamp_min.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_timestamp_now.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_timestamp_now.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_timestamp_add_duration.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_timestamp_add_duration.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_timestamp_as_secs.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_timestamp_as_secs.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_timestamp_sub_duration.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_timestamp_sub_duration.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_timestamp_to_human_datetime.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_timestamp_to_human_datetime.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_timestamp_uniffi_trait_debug.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_timestamp_uniffi_trait_debug.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_timestamp_uniffi_trait_eq_eq.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_timestamp_uniffi_trait_eq_eq.restype = ctypes.c_int8
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_timestamp_uniffi_trait_eq_ne.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_timestamp_uniffi_trait_eq_ne.restype = ctypes.c_int8
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_timestamp_uniffi_trait_hash.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_timestamp_uniffi_trait_hash.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_unsignedevent.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_unsignedevent.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_unsignedevent.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_unsignedevent.restype = None
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_unsignedevent_from_json.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_unsignedevent_from_json.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_unsignedevent_add_signature.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_unsignedevent_add_signature.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_unsignedevent_as_json.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_unsignedevent_as_json.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_unsignedevent_as_pretty_json.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_unsignedevent_as_pretty_json.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_unsignedevent_author.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_unsignedevent_author.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_unsignedevent_content.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_unsignedevent_content.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_unsignedevent_created_at.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_unsignedevent_created_at.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_unsignedevent_id.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_unsignedevent_id.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_unsignedevent_kind.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_unsignedevent_kind.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_unsignedevent_sign.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_unsignedevent_sign.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_unsignedevent_sign_with_keys.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_unsignedevent_sign_with_keys.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_unsignedevent_tags.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_unsignedevent_tags.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_unsignedevent_uniffi_trait_debug.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_unsignedevent_uniffi_trait_debug.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_unsignedevent_uniffi_trait_eq_eq.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_unsignedevent_uniffi_trait_eq_eq.restype = ctypes.c_int8
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_unsignedevent_uniffi_trait_eq_ne.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_unsignedevent_uniffi_trait_eq_ne.restype = ctypes.c_int8
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_unsignedevent_uniffi_trait_hash.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_unsignedevent_uniffi_trait_hash.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_unwrappedgift.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_unwrappedgift.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_unwrappedgift.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_unwrappedgift.restype = None
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_unwrappedgift_from_gift_wrap.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_unwrappedgift_from_gift_wrap.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_unwrappedgift__none.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_unwrappedgift__none.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_unwrappedgift_rumor.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_unwrappedgift_rumor.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_unwrappedgift_sender.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_unwrappedgift_sender.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_unwrappedgift_uniffi_trait_debug.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_unwrappedgift_uniffi_trait_debug.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_unwrappedgift_uniffi_trait_eq_eq.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_unwrappedgift_uniffi_trait_eq_eq.restype = ctypes.c_int8
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_unwrappedgift_uniffi_trait_eq_ne.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_unwrappedgift_uniffi_trait_eq_ne.restype = ctypes.c_int8
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_unwrappedgift_uniffi_trait_hash.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_unwrappedgift_uniffi_trait_hash.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_websocketadapter.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_websocketadapter.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_websocketadapter.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_websocketadapter.restype = None
_UniffiLib.uniffi_nostr_sdk_ffi_fn_init_callback_vtable_websocketadapter.argtypes = (
    ctypes.POINTER(_UniffiVTableCallbackInterfaceWebSocketAdapter),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_init_callback_vtable_websocketadapter.restype = None
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_websocketadapter_send.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_websocketadapter_send.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_websocketadapter_recv.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_websocketadapter_recv.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_websocketadapter_close_connection.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_websocketadapter_close_connection.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_websocketadapterwrapper.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_websocketadapterwrapper.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_websocketadapterwrapper.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_websocketadapterwrapper.restype = None
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_websocketadapterwrapper_new.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_websocketadapterwrapper_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_writepolicy.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_writepolicy.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_writepolicy.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_writepolicy.restype = None
_UniffiLib.uniffi_nostr_sdk_ffi_fn_init_callback_vtable_writepolicy.argtypes = (
    ctypes.POINTER(_UniffiVTableCallbackInterfaceWritePolicy),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_init_callback_vtable_writepolicy.restype = None
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_writepolicy_admit_event.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_writepolicy_admit_event.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_zaprequestdata.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_zaprequestdata.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_zaprequestdata.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_zaprequestdata.restype = None
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_zaprequestdata_new.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_zaprequestdata_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_zaprequestdata_amount.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_zaprequestdata_amount.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_zaprequestdata_event_id.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_zaprequestdata_event_id.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_zaprequestdata_lnurl.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_zaprequestdata_lnurl.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_zaprequestdata_message.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_zaprequestdata_message.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_zaprequestdata_uniffi_trait_debug.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_zaprequestdata_uniffi_trait_debug.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_zaprequestdata_uniffi_trait_eq_eq.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_zaprequestdata_uniffi_trait_eq_eq.restype = ctypes.c_int8
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_zaprequestdata_uniffi_trait_eq_ne.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_zaprequestdata_uniffi_trait_eq_ne.restype = ctypes.c_int8
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_zaprequestdata_uniffi_trait_hash.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_zaprequestdata_uniffi_trait_hash.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_func_decrypt_received_private_zap_message.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_func_decrypt_received_private_zap_message.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_func_decrypt_sent_private_zap_message.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_func_decrypt_sent_private_zap_message.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_func_extract_relay_list.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_func_extract_relay_list.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_func_generate_shared_key.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_func_generate_shared_key.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_func_get_leading_zero_bits.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_func_get_leading_zero_bits.restype = ctypes.c_uint8
_UniffiLib.uniffi_nostr_sdk_ffi_fn_func_get_prefixes_for_difficulty.argtypes = (
    ctypes.c_uint8,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_func_get_prefixes_for_difficulty.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_func_gift_wrap.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_func_gift_wrap.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_func_gift_wrap_from_seal.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_func_gift_wrap_from_seal.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_func_git_hash_version.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_func_git_hash_version.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_func_init_logger.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_func_init_logger.restype = None
_UniffiLib.uniffi_nostr_sdk_ffi_fn_func_make_private_msg.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_func_make_private_msg.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_sdk_ffi_fn_func_nip04_decrypt.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_func_nip04_decrypt.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_func_nip04_encrypt.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_func_nip04_encrypt.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_func_nip05_verify_from_json.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_func_nip05_verify_from_json.restype = ctypes.c_int8
_UniffiLib.uniffi_nostr_sdk_ffi_fn_func_nip22_extract_parent.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_func_nip22_extract_parent.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_func_nip22_extract_root.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_func_nip22_extract_root.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_func_nip44_decrypt.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_func_nip44_decrypt.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_func_nip44_encrypt.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_func_nip44_encrypt.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_sdk_ffi_fn_func_nip57_anonymous_zap_request.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_func_nip57_anonymous_zap_request.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_func_nip57_private_zap_request.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_func_nip57_private_zap_request.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_sdk_ffi_fn_func_tag_kind_to_string.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_sdk_ffi_fn_func_tag_kind_to_string.restype = _UniffiRustBuffer
_UniffiLib.ffi_nostr_sdk_ffi_rustbuffer_alloc.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_nostr_sdk_ffi_rustbuffer_alloc.restype = _UniffiRustBuffer
_UniffiLib.ffi_nostr_sdk_ffi_rustbuffer_from_bytes.argtypes = (
    _UniffiForeignBytes,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_nostr_sdk_ffi_rustbuffer_from_bytes.restype = _UniffiRustBuffer
_UniffiLib.ffi_nostr_sdk_ffi_rustbuffer_free.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_nostr_sdk_ffi_rustbuffer_free.restype = None
_UniffiLib.ffi_nostr_sdk_ffi_rustbuffer_reserve.argtypes = (
    _UniffiRustBuffer,
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_nostr_sdk_ffi_rustbuffer_reserve.restype = _UniffiRustBuffer
_UniffiLib.ffi_nostr_sdk_ffi_rust_future_poll_u8.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_nostr_sdk_ffi_rust_future_poll_u8.restype = None
_UniffiLib.ffi_nostr_sdk_ffi_rust_future_cancel_u8.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_nostr_sdk_ffi_rust_future_cancel_u8.restype = None
_UniffiLib.ffi_nostr_sdk_ffi_rust_future_free_u8.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_nostr_sdk_ffi_rust_future_free_u8.restype = None
_UniffiLib.ffi_nostr_sdk_ffi_rust_future_complete_u8.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_nostr_sdk_ffi_rust_future_complete_u8.restype = ctypes.c_uint8
_UniffiLib.ffi_nostr_sdk_ffi_rust_future_poll_i8.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_nostr_sdk_ffi_rust_future_poll_i8.restype = None
_UniffiLib.ffi_nostr_sdk_ffi_rust_future_cancel_i8.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_nostr_sdk_ffi_rust_future_cancel_i8.restype = None
_UniffiLib.ffi_nostr_sdk_ffi_rust_future_free_i8.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_nostr_sdk_ffi_rust_future_free_i8.restype = None
_UniffiLib.ffi_nostr_sdk_ffi_rust_future_complete_i8.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_nostr_sdk_ffi_rust_future_complete_i8.restype = ctypes.c_int8
_UniffiLib.ffi_nostr_sdk_ffi_rust_future_poll_u16.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_nostr_sdk_ffi_rust_future_poll_u16.restype = None
_UniffiLib.ffi_nostr_sdk_ffi_rust_future_cancel_u16.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_nostr_sdk_ffi_rust_future_cancel_u16.restype = None
_UniffiLib.ffi_nostr_sdk_ffi_rust_future_free_u16.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_nostr_sdk_ffi_rust_future_free_u16.restype = None
_UniffiLib.ffi_nostr_sdk_ffi_rust_future_complete_u16.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_nostr_sdk_ffi_rust_future_complete_u16.restype = ctypes.c_uint16
_UniffiLib.ffi_nostr_sdk_ffi_rust_future_poll_i16.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_nostr_sdk_ffi_rust_future_poll_i16.restype = None
_UniffiLib.ffi_nostr_sdk_ffi_rust_future_cancel_i16.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_nostr_sdk_ffi_rust_future_cancel_i16.restype = None
_UniffiLib.ffi_nostr_sdk_ffi_rust_future_free_i16.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_nostr_sdk_ffi_rust_future_free_i16.restype = None
_UniffiLib.ffi_nostr_sdk_ffi_rust_future_complete_i16.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_nostr_sdk_ffi_rust_future_complete_i16.restype = ctypes.c_int16
_UniffiLib.ffi_nostr_sdk_ffi_rust_future_poll_u32.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_nostr_sdk_ffi_rust_future_poll_u32.restype = None
_UniffiLib.ffi_nostr_sdk_ffi_rust_future_cancel_u32.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_nostr_sdk_ffi_rust_future_cancel_u32.restype = None
_UniffiLib.ffi_nostr_sdk_ffi_rust_future_free_u32.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_nostr_sdk_ffi_rust_future_free_u32.restype = None
_UniffiLib.ffi_nostr_sdk_ffi_rust_future_complete_u32.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_nostr_sdk_ffi_rust_future_complete_u32.restype = ctypes.c_uint32
_UniffiLib.ffi_nostr_sdk_ffi_rust_future_poll_i32.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_nostr_sdk_ffi_rust_future_poll_i32.restype = None
_UniffiLib.ffi_nostr_sdk_ffi_rust_future_cancel_i32.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_nostr_sdk_ffi_rust_future_cancel_i32.restype = None
_UniffiLib.ffi_nostr_sdk_ffi_rust_future_free_i32.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_nostr_sdk_ffi_rust_future_free_i32.restype = None
_UniffiLib.ffi_nostr_sdk_ffi_rust_future_complete_i32.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_nostr_sdk_ffi_rust_future_complete_i32.restype = ctypes.c_int32
_UniffiLib.ffi_nostr_sdk_ffi_rust_future_poll_u64.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_nostr_sdk_ffi_rust_future_poll_u64.restype = None
_UniffiLib.ffi_nostr_sdk_ffi_rust_future_cancel_u64.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_nostr_sdk_ffi_rust_future_cancel_u64.restype = None
_UniffiLib.ffi_nostr_sdk_ffi_rust_future_free_u64.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_nostr_sdk_ffi_rust_future_free_u64.restype = None
_UniffiLib.ffi_nostr_sdk_ffi_rust_future_complete_u64.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_nostr_sdk_ffi_rust_future_complete_u64.restype = ctypes.c_uint64
_UniffiLib.ffi_nostr_sdk_ffi_rust_future_poll_i64.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_nostr_sdk_ffi_rust_future_poll_i64.restype = None
_UniffiLib.ffi_nostr_sdk_ffi_rust_future_cancel_i64.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_nostr_sdk_ffi_rust_future_cancel_i64.restype = None
_UniffiLib.ffi_nostr_sdk_ffi_rust_future_free_i64.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_nostr_sdk_ffi_rust_future_free_i64.restype = None
_UniffiLib.ffi_nostr_sdk_ffi_rust_future_complete_i64.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_nostr_sdk_ffi_rust_future_complete_i64.restype = ctypes.c_int64
_UniffiLib.ffi_nostr_sdk_ffi_rust_future_poll_f32.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_nostr_sdk_ffi_rust_future_poll_f32.restype = None
_UniffiLib.ffi_nostr_sdk_ffi_rust_future_cancel_f32.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_nostr_sdk_ffi_rust_future_cancel_f32.restype = None
_UniffiLib.ffi_nostr_sdk_ffi_rust_future_free_f32.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_nostr_sdk_ffi_rust_future_free_f32.restype = None
_UniffiLib.ffi_nostr_sdk_ffi_rust_future_complete_f32.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_nostr_sdk_ffi_rust_future_complete_f32.restype = ctypes.c_float
_UniffiLib.ffi_nostr_sdk_ffi_rust_future_poll_f64.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_nostr_sdk_ffi_rust_future_poll_f64.restype = None
_UniffiLib.ffi_nostr_sdk_ffi_rust_future_cancel_f64.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_nostr_sdk_ffi_rust_future_cancel_f64.restype = None
_UniffiLib.ffi_nostr_sdk_ffi_rust_future_free_f64.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_nostr_sdk_ffi_rust_future_free_f64.restype = None
_UniffiLib.ffi_nostr_sdk_ffi_rust_future_complete_f64.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_nostr_sdk_ffi_rust_future_complete_f64.restype = ctypes.c_double
_UniffiLib.ffi_nostr_sdk_ffi_rust_future_poll_pointer.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_nostr_sdk_ffi_rust_future_poll_pointer.restype = None
_UniffiLib.ffi_nostr_sdk_ffi_rust_future_cancel_pointer.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_nostr_sdk_ffi_rust_future_cancel_pointer.restype = None
_UniffiLib.ffi_nostr_sdk_ffi_rust_future_free_pointer.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_nostr_sdk_ffi_rust_future_free_pointer.restype = None
_UniffiLib.ffi_nostr_sdk_ffi_rust_future_complete_pointer.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_nostr_sdk_ffi_rust_future_complete_pointer.restype = ctypes.c_void_p
_UniffiLib.ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer.restype = None
_UniffiLib.ffi_nostr_sdk_ffi_rust_future_cancel_rust_buffer.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_nostr_sdk_ffi_rust_future_cancel_rust_buffer.restype = None
_UniffiLib.ffi_nostr_sdk_ffi_rust_future_free_rust_buffer.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_nostr_sdk_ffi_rust_future_free_rust_buffer.restype = None
_UniffiLib.ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer.restype = _UniffiRustBuffer
_UniffiLib.ffi_nostr_sdk_ffi_rust_future_poll_void.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_nostr_sdk_ffi_rust_future_poll_void.restype = None
_UniffiLib.ffi_nostr_sdk_ffi_rust_future_cancel_void.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_nostr_sdk_ffi_rust_future_cancel_void.restype = None
_UniffiLib.ffi_nostr_sdk_ffi_rust_future_free_void.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_nostr_sdk_ffi_rust_future_free_void.restype = None
_UniffiLib.ffi_nostr_sdk_ffi_rust_future_complete_void.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_nostr_sdk_ffi_rust_future_complete_void.restype = None
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_func_decrypt_received_private_zap_message.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_func_decrypt_received_private_zap_message.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_func_decrypt_sent_private_zap_message.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_func_decrypt_sent_private_zap_message.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_func_extract_relay_list.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_func_extract_relay_list.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_func_generate_shared_key.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_func_generate_shared_key.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_func_get_leading_zero_bits.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_func_get_leading_zero_bits.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_func_get_prefixes_for_difficulty.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_func_get_prefixes_for_difficulty.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_func_gift_wrap.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_func_gift_wrap.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_func_gift_wrap_from_seal.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_func_gift_wrap_from_seal.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_func_git_hash_version.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_func_git_hash_version.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_func_init_logger.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_func_init_logger.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_func_make_private_msg.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_func_make_private_msg.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_func_nip04_decrypt.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_func_nip04_decrypt.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_func_nip04_encrypt.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_func_nip04_encrypt.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_func_nip05_verify_from_json.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_func_nip05_verify_from_json.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_func_nip22_extract_parent.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_func_nip22_extract_parent.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_func_nip22_extract_root.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_func_nip22_extract_root.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_func_nip44_decrypt.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_func_nip44_decrypt.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_func_nip44_encrypt.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_func_nip44_encrypt.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_func_nip57_anonymous_zap_request.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_func_nip57_anonymous_zap_request.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_func_nip57_private_zap_request.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_func_nip57_private_zap_request.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_func_tag_kind_to_string.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_func_tag_kind_to_string.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_admitpolicy_admit_connection.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_admitpolicy_admit_connection.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_admitpolicy_admit_event.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_admitpolicy_admit_event.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_client_add_discovery_relay.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_client_add_discovery_relay.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_client_add_read_relay.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_client_add_read_relay.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_client_add_relay.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_client_add_relay.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_client_add_relay_with_opts.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_client_add_relay_with_opts.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_client_add_write_relay.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_client_add_write_relay.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_client_automatic_authentication.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_client_automatic_authentication.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_client_connect.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_client_connect.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_client_connect_relay.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_client_connect_relay.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_client_database.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_client_database.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_client_disconnect.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_client_disconnect.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_client_disconnect_relay.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_client_disconnect_relay.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_client_fetch_combined_events.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_client_fetch_combined_events.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_client_fetch_events.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_client_fetch_events.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_client_fetch_events_from.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_client_fetch_events_from.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_client_fetch_metadata.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_client_fetch_metadata.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_client_force_remove_all_relays.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_client_force_remove_all_relays.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_client_force_remove_relay.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_client_force_remove_relay.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_client_gift_wrap.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_client_gift_wrap.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_client_gift_wrap_to.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_client_gift_wrap_to.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_client_handle_notifications.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_client_handle_notifications.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_client_relay.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_client_relay.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_client_relays.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_client_relays.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_client_remove_all_relays.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_client_remove_all_relays.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_client_remove_relay.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_client_remove_relay.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_client_send_event.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_client_send_event.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_client_send_event_builder.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_client_send_event_builder.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_client_send_event_builder_to.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_client_send_event_builder_to.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_client_send_event_to.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_client_send_event_to.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_client_send_msg_to.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_client_send_msg_to.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_client_send_private_msg.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_client_send_private_msg.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_client_send_private_msg_to.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_client_send_private_msg_to.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_client_set_metadata.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_client_set_metadata.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_client_shutdown.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_client_shutdown.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_client_sign_event_builder.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_client_sign_event_builder.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_client_signer.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_client_signer.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_client_stream_events.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_client_stream_events.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_client_stream_events_from.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_client_stream_events_from.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_client_stream_events_targeted.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_client_stream_events_targeted.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_client_subscribe.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_client_subscribe.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_client_subscribe_to.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_client_subscribe_to.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_client_subscribe_with_id.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_client_subscribe_with_id.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_client_subscribe_with_id_to.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_client_subscribe_with_id_to.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_client_subscription.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_client_subscription.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_client_subscriptions.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_client_subscriptions.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_client_sync.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_client_sync.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_client_try_connect.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_client_try_connect.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_client_unsubscribe.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_client_unsubscribe.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_client_unsubscribe_all.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_client_unsubscribe_all.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_client_unwrap_gift_wrap.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_client_unwrap_gift_wrap.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_client_wait_for_connection.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_client_wait_for_connection.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_clientbuilder_admit_policy.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_clientbuilder_admit_policy.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_clientbuilder_build.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_clientbuilder_build.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_clientbuilder_database.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_clientbuilder_database.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_clientbuilder_gossip.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_clientbuilder_gossip.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_clientbuilder_opts.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_clientbuilder_opts.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_clientbuilder_signer.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_clientbuilder_signer.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_clientbuilder_websocket_transport.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_clientbuilder_websocket_transport.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_clientmessage_as_enum.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_clientmessage_as_enum.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_clientmessage_as_json.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_clientmessage_as_json.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_clientoptions_autoconnect.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_clientoptions_autoconnect.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_clientoptions_automatic_authentication.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_clientoptions_automatic_authentication.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_clientoptions_ban_relay_on_mismatch.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_clientoptions_ban_relay_on_mismatch.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_clientoptions_connection.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_clientoptions_connection.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_clientoptions_gossip.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_clientoptions_gossip.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_clientoptions_max_avg_latency.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_clientoptions_max_avg_latency.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_clientoptions_relay_limits.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_clientoptions_relay_limits.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_clientoptions_verify_subscriptions.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_clientoptions_verify_subscriptions.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_connection_addr.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_connection_addr.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_connection_mode.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_connection_mode.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_connection_target.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_connection_target.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_coordinate_identifier.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_coordinate_identifier.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_coordinate_kind.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_coordinate_kind.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_coordinate_public_key.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_coordinate_public_key.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_coordinate_verify.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_coordinate_verify.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_customnostrdatabase_backend.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_customnostrdatabase_backend.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_customnostrdatabase_save_event.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_customnostrdatabase_save_event.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_customnostrdatabase_check_id.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_customnostrdatabase_check_id.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_customnostrdatabase_event_by_id.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_customnostrdatabase_event_by_id.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_customnostrdatabase_count.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_customnostrdatabase_count.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_customnostrdatabase_query.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_customnostrdatabase_query.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_customnostrdatabase_delete.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_customnostrdatabase_delete.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_customnostrdatabase_wipe.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_customnostrdatabase_wipe.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_customnostrsigner_backend.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_customnostrsigner_backend.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_customnostrsigner_get_public_key.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_customnostrsigner_get_public_key.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_customnostrsigner_sign_event.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_customnostrsigner_sign_event.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_customnostrsigner_nip04_encrypt.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_customnostrsigner_nip04_encrypt.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_customnostrsigner_nip04_decrypt.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_customnostrsigner_nip04_decrypt.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_customnostrsigner_nip44_encrypt.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_customnostrsigner_nip44_encrypt.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_customnostrsigner_nip44_decrypt.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_customnostrsigner_nip44_decrypt.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_customwebsockettransport_support_ping.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_customwebsockettransport_support_ping.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_customwebsockettransport_connect.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_customwebsockettransport_connect.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_encryptedsecretkey_decrypt.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_encryptedsecretkey_decrypt.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_encryptedsecretkey_key_security.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_encryptedsecretkey_key_security.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_encryptedsecretkey_to_bech32.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_encryptedsecretkey_to_bech32.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_encryptedsecretkey_version.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_encryptedsecretkey_version.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_event_as_json.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_event_as_json.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_event_as_pretty_json.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_event_as_pretty_json.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_event_author.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_event_author.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_event_content.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_event_content.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_event_created_at.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_event_created_at.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_event_id.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_event_id.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_event_is_expired.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_event_is_expired.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_event_is_protected.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_event_is_protected.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_event_kind.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_event_kind.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_event_signature.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_event_signature.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_event_tags.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_event_tags.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_event_verify.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_event_verify.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_event_verify_id.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_event_verify_id.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_event_verify_signature.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_event_verify_signature.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_eventbuilder_allow_self_tagging.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_eventbuilder_allow_self_tagging.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_eventbuilder_build.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_eventbuilder_build.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_eventbuilder_custom_created_at.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_eventbuilder_custom_created_at.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_eventbuilder_dedup_tags.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_eventbuilder_dedup_tags.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_eventbuilder_pow.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_eventbuilder_pow.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_eventbuilder_sign.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_eventbuilder_sign.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_eventbuilder_sign_with_keys.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_eventbuilder_sign_with_keys.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_eventbuilder_tags.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_eventbuilder_tags.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_eventid_as_bytes.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_eventid_as_bytes.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_eventid_to_bech32.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_eventid_to_bech32.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_eventid_to_hex.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_eventid_to_hex.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_eventid_to_nostr_uri.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_eventid_to_nostr_uri.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_eventstream_next.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_eventstream_next.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_events_contains.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_events_contains.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_events_first.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_events_first.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_events_is_empty.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_events_is_empty.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_events_len.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_events_len.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_events_merge.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_events_merge.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_events_to_vec.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_events_to_vec.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_filemetadata_aes_256_gcm.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_filemetadata_aes_256_gcm.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_filemetadata_blurhash.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_filemetadata_blurhash.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_filemetadata_dimensions.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_filemetadata_dimensions.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_filemetadata_magnet.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_filemetadata_magnet.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_filemetadata_size.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_filemetadata_size.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_filter_as_json.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_filter_as_json.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_filter_as_record.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_filter_as_record.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_filter_author.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_filter_author.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_filter_authors.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_filter_authors.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_filter_coordinate.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_filter_coordinate.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_filter_coordinates.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_filter_coordinates.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_filter_custom_tag.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_filter_custom_tag.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_filter_custom_tags.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_filter_custom_tags.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_filter_event.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_filter_event.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_filter_events.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_filter_events.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_filter_hashtag.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_filter_hashtag.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_filter_hashtags.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_filter_hashtags.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_filter_id.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_filter_id.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_filter_identifier.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_filter_identifier.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_filter_identifiers.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_filter_identifiers.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_filter_ids.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_filter_ids.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_filter_is_empty.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_filter_is_empty.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_filter_kind.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_filter_kind.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_filter_kinds.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_filter_kinds.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_filter_limit.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_filter_limit.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_filter_match_event.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_filter_match_event.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_filter_pubkey.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_filter_pubkey.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_filter_pubkeys.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_filter_pubkeys.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_filter_reference.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_filter_reference.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_filter_references.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_filter_references.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_filter_remove_authors.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_filter_remove_authors.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_filter_remove_coordinates.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_filter_remove_coordinates.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_filter_remove_custom_tags.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_filter_remove_custom_tags.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_filter_remove_events.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_filter_remove_events.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_filter_remove_hashtags.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_filter_remove_hashtags.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_filter_remove_identifiers.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_filter_remove_identifiers.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_filter_remove_ids.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_filter_remove_ids.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_filter_remove_kinds.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_filter_remove_kinds.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_filter_remove_limit.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_filter_remove_limit.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_filter_remove_pubkeys.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_filter_remove_pubkeys.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_filter_remove_references.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_filter_remove_references.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_filter_remove_search.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_filter_remove_search.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_filter_remove_since.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_filter_remove_since.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_filter_remove_until.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_filter_remove_until.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_filter_search.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_filter_search.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_filter_since.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_filter_since.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_filter_until.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_filter_until.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_handlenotification_handle_msg.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_handlenotification_handle_msg.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_handlenotification_handle.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_handlenotification_handle.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_jobfeedbackdata_amount.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_jobfeedbackdata_amount.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_jobfeedbackdata_extra_info.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_jobfeedbackdata_extra_info.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_jobfeedbackdata_payload.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_jobfeedbackdata_payload.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_keys_public_key.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_keys_public_key.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_keys_secret_key.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_keys_secret_key.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_keys_sign_schnorr.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_keys_sign_schnorr.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_kind_as_std.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_kind_as_std.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_kind_as_u16.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_kind_as_u16.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_kind_is_addressable.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_kind_is_addressable.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_kind_is_ephemeral.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_kind_is_ephemeral.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_kind_is_job_request.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_kind_is_job_request.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_kind_is_job_result.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_kind_is_job_result.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_kind_is_regular.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_kind_is_regular.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_kind_is_replaceable.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_kind_is_replaceable.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_localrelay_notify_event.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_localrelay_notify_event.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_localrelay_run.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_localrelay_run.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_localrelay_shutdown.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_localrelay_shutdown.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_localrelay_url.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_localrelay_url.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_metadata_as_json.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_metadata_as_json.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_metadata_as_pretty_json.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_metadata_as_pretty_json.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_metadata_as_record.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_metadata_as_record.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_nwc_get_balance.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_nwc_get_balance.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_nwc_get_info.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_nwc_get_info.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_nwc_list_transactions.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_nwc_list_transactions.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_nwc_lookup_invoice.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_nwc_lookup_invoice.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_nwc_make_invoice.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_nwc_make_invoice.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_nwc_pay_invoice.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_nwc_pay_invoice.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_nwc_pay_keysend.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_nwc_pay_keysend.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_nwc_status.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_nwc_status.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_nip05address_domain.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_nip05address_domain.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_nip05address_name.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_nip05address_name.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_nip05address_url.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_nip05address_url.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_nip05profile_nip46.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_nip05profile_nip46.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_nip05profile_public_key.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_nip05profile_public_key.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_nip05profile_relays.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_nip05profile_relays.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_nip19_as_enum.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_nip19_as_enum.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_nip19coordinate_coordinate.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_nip19coordinate_coordinate.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_nip19coordinate_relays.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_nip19coordinate_relays.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_nip19coordinate_to_bech32.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_nip19coordinate_to_bech32.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_nip19coordinate_to_nostr_uri.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_nip19coordinate_to_nostr_uri.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_nip19event_author.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_nip19event_author.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_nip19event_event_id.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_nip19event_event_id.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_nip19event_kind.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_nip19event_kind.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_nip19event_relays.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_nip19event_relays.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_nip19event_to_bech32.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_nip19event_to_bech32.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_nip19event_to_nostr_uri.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_nip19event_to_nostr_uri.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_nip19profile_public_key.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_nip19profile_public_key.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_nip19profile_relays.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_nip19profile_relays.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_nip19profile_to_bech32.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_nip19profile_to_bech32.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_nip19profile_to_nostr_uri.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_nip19profile_to_nostr_uri.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_nip21_as_enum.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_nip21_as_enum.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_nip21_to_nostr_uri.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_nip21_to_nostr_uri.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_nip96serverconfig_api_url.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_nip96serverconfig_api_url.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_nip96serverconfig_as_json.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_nip96serverconfig_as_json.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_nip96serverconfig_content_types.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_nip96serverconfig_content_types.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_nip96serverconfig_delegated_to_url.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_nip96serverconfig_delegated_to_url.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_nip96serverconfig_download_url.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_nip96serverconfig_download_url.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_nip96uploadrequest_authorization.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_nip96uploadrequest_authorization.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_nip96uploadrequest_url.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_nip96uploadrequest_url.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_nip96uploadresponse_as_json.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_nip96uploadresponse_as_json.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_nip96uploadresponse_download_url.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_nip96uploadresponse_download_url.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_nip96uploadresponse_is_success.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_nip96uploadresponse_is_success.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_nip96uploadresponse_message.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_nip96uploadresponse_message.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_nostrconnect_bunker_uri.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_nostrconnect_bunker_uri.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_nostrconnect_get_public_key.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_nostrconnect_get_public_key.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_nostrconnect_nip04_decrypt.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_nostrconnect_nip04_decrypt.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_nostrconnect_nip04_encrypt.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_nostrconnect_nip04_encrypt.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_nostrconnect_nip44_decrypt.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_nostrconnect_nip44_decrypt.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_nostrconnect_nip44_encrypt.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_nostrconnect_nip44_encrypt.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_nostrconnect_relays.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_nostrconnect_relays.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_nostrconnect_sign_event.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_nostrconnect_sign_event.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_nostrconnectmetadata_as_json.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_nostrconnectmetadata_as_json.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_nostrconnectmetadata_description.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_nostrconnectmetadata_description.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_nostrconnectmetadata_icons.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_nostrconnectmetadata_icons.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_nostrconnectmetadata_url.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_nostrconnectmetadata_url.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_nostrdatabase_count.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_nostrdatabase_count.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_nostrdatabase_delete.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_nostrdatabase_delete.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_nostrdatabase_event_by_id.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_nostrdatabase_event_by_id.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_nostrdatabase_metadata.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_nostrdatabase_metadata.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_nostrdatabase_query.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_nostrdatabase_query.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_nostrdatabase_save_event.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_nostrdatabase_save_event.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_nostrdatabase_wipe.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_nostrdatabase_wipe.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_nostrparser_parse.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_nostrparser_parse.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_nostrsigner_backend.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_nostrsigner_backend.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_nostrsigner_get_public_key.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_nostrsigner_get_public_key.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_nostrsigner_nip04_decrypt.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_nostrsigner_nip04_decrypt.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_nostrsigner_nip04_encrypt.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_nostrsigner_nip04_encrypt.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_nostrsigner_nip44_decrypt.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_nostrsigner_nip44_decrypt.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_nostrsigner_nip44_encrypt.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_nostrsigner_nip44_encrypt.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_nostrsigner_sign_event.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_nostrsigner_sign_event.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_nostrwalletconnectoptions_relay.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_nostrwalletconnectoptions_relay.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_nostrwalletconnectoptions_timeout.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_nostrwalletconnectoptions_timeout.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_nostrwalletconnecturi_lud16.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_nostrwalletconnecturi_lud16.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_nostrwalletconnecturi_public_key.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_nostrwalletconnecturi_public_key.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_nostrwalletconnecturi_relays.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_nostrwalletconnecturi_relays.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_nostrwalletconnecturi_secret.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_nostrwalletconnecturi_secret.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_publickey_to_bech32.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_publickey_to_bech32.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_publickey_to_hex.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_publickey_to_hex.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_publickey_to_nostr_uri.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_publickey_to_nostr_uri.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_querypolicy_admit_query.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_querypolicy_admit_query.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relay_ban.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relay_ban.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relay_batch_msg.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relay_batch_msg.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relay_connect.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relay_connect.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relay_connection_mode.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relay_connection_mode.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relay_count_events.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relay_count_events.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relay_disconnect.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relay_disconnect.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relay_fetch_events.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relay_fetch_events.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relay_is_connected.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relay_is_connected.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relay_opts.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relay_opts.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relay_queue.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relay_queue.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relay_send_event.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relay_send_event.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relay_send_msg.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relay_send_msg.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relay_stats.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relay_stats.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relay_status.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relay_status.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relay_subscribe.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relay_subscribe.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relay_subscribe_with_id.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relay_subscribe_with_id.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relay_subscription.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relay_subscription.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relay_subscriptions.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relay_subscriptions.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relay_sync.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relay_sync.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relay_sync_with_items.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relay_sync_with_items.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relay_try_connect.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relay_try_connect.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relay_unsubscribe.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relay_unsubscribe.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relay_unsubscribe_all.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relay_unsubscribe_all.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relay_url.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relay_url.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relaybuilder_addr.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relaybuilder_addr.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relaybuilder_auth_dm.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relaybuilder_auth_dm.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relaybuilder_database.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relaybuilder_database.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relaybuilder_default_filter_limit.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relaybuilder_default_filter_limit.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relaybuilder_max_connections.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relaybuilder_max_connections.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relaybuilder_max_filter_limit.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relaybuilder_max_filter_limit.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relaybuilder_max_subid_length.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relaybuilder_max_subid_length.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relaybuilder_min_pow.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relaybuilder_min_pow.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relaybuilder_nip42.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relaybuilder_nip42.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relaybuilder_port.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relaybuilder_port.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relaybuilder_query_policy.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relaybuilder_query_policy.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relaybuilder_rate_limit.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relaybuilder_rate_limit.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relaybuilder_write_policy.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relaybuilder_write_policy.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relayconnectionstats_attempts.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relayconnectionstats_attempts.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relayconnectionstats_bytes_received.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relayconnectionstats_bytes_received.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relayconnectionstats_bytes_sent.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relayconnectionstats_bytes_sent.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relayconnectionstats_connected_at.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relayconnectionstats_connected_at.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relayconnectionstats_first_connection_timestamp.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relayconnectionstats_first_connection_timestamp.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relayconnectionstats_latency.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relayconnectionstats_latency.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relayconnectionstats_success.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relayconnectionstats_success.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relayconnectionstats_success_rate.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relayconnectionstats_success_rate.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relayinformationdocument_as_json.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relayinformationdocument_as_json.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relayinformationdocument_contact.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relayinformationdocument_contact.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relayinformationdocument_description.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relayinformationdocument_description.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relayinformationdocument_fees.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relayinformationdocument_fees.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relayinformationdocument_icon.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relayinformationdocument_icon.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relayinformationdocument_language_tags.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relayinformationdocument_language_tags.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relayinformationdocument_limitation.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relayinformationdocument_limitation.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relayinformationdocument_name.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relayinformationdocument_name.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relayinformationdocument_payments_url.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relayinformationdocument_payments_url.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relayinformationdocument_posting_policy.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relayinformationdocument_posting_policy.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relayinformationdocument_pubkey.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relayinformationdocument_pubkey.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relayinformationdocument_relay_countries.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relayinformationdocument_relay_countries.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relayinformationdocument_retention.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relayinformationdocument_retention.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relayinformationdocument_software.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relayinformationdocument_software.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relayinformationdocument_supported_nips.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relayinformationdocument_supported_nips.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relayinformationdocument_tags.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relayinformationdocument_tags.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relayinformationdocument_version.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relayinformationdocument_version.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relaylimits_event_max_num_tags.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relaylimits_event_max_num_tags.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relaylimits_event_max_num_tags_per_kind.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relaylimits_event_max_num_tags_per_kind.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relaylimits_event_max_size.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relaylimits_event_max_size.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relaylimits_event_max_size_per_kind.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relaylimits_event_max_size_per_kind.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relaylimits_message_max_size.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relaylimits_message_max_size.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relaymessage_as_enum.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relaymessage_as_enum.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relaymessage_as_json.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relaymessage_as_json.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relayoptions_adjust_retry_interval.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relayoptions_adjust_retry_interval.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relayoptions_ban_relay_on_mismatch.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relayoptions_ban_relay_on_mismatch.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relayoptions_connection_mode.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relayoptions_connection_mode.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relayoptions_limits.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relayoptions_limits.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relayoptions_max_avg_latency.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relayoptions_max_avg_latency.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relayoptions_ping.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relayoptions_ping.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relayoptions_read.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relayoptions_read.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relayoptions_reconnect.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relayoptions_reconnect.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relayoptions_retry_interval.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relayoptions_retry_interval.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relayoptions_verify_subscriptions.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relayoptions_verify_subscriptions.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relayoptions_write.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relayoptions_write.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relayurl_is_local_addr.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relayurl_is_local_addr.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relayurl_is_onion.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_relayurl_is_onion.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_request_method.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_request_method.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_request_params.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_request_params.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_saveeventstatus_is_success.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_saveeventstatus_is_success.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_saveeventstatus_rejection_reason.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_saveeventstatus_rejection_reason.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_secretkey_encrypt.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_secretkey_encrypt.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_secretkey_to_bech32.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_secretkey_to_bech32.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_secretkey_to_hex.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_secretkey_to_hex.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_shippingmethod_get_shipping_cost.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_shippingmethod_get_shipping_cost.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_shippingmethod_name.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_shippingmethod_name.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_shippingmethod_regions.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_shippingmethod_regions.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_singlelettertag_is_lowercase.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_singlelettertag_is_lowercase.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_singlelettertag_is_uppercase.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_singlelettertag_is_uppercase.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_stalldata_as_json.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_stalldata_as_json.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_stalldata_as_record.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_stalldata_as_record.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_stalldata_currency.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_stalldata_currency.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_stalldata_description.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_stalldata_description.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_stalldata_id.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_stalldata_id.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_stalldata_name.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_stalldata_name.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_stalldata_shipping.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_stalldata_shipping.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_subscribeautocloseoptions_exit_policy.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_subscribeautocloseoptions_exit_policy.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_subscribeautocloseoptions_idle_timeout.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_subscribeautocloseoptions_idle_timeout.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_subscribeautocloseoptions_timeout.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_subscribeautocloseoptions_timeout.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_subscribeoptions_close_on.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_subscribeoptions_close_on.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_syncoptions_direction.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_syncoptions_direction.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_syncoptions_dry_run.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_syncoptions_dry_run.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_syncoptions_initial_timeout.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_syncoptions_initial_timeout.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_tag_as_standardized.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_tag_as_standardized.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_tag_as_vec.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_tag_as_vec.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_tag_content.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_tag_content.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_tag_is_protected.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_tag_is_protected.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_tag_is_reply.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_tag_is_reply.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_tag_is_root.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_tag_is_root.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_tag_kind.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_tag_kind.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_tag_kind_str.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_tag_kind_str.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_tag_len.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_tag_len.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_tag_single_letter_tag.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_tag_single_letter_tag.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_tags_coordinates.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_tags_coordinates.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_tags_event_ids.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_tags_event_ids.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_tags_expiration.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_tags_expiration.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_tags_filter.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_tags_filter.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_tags_filter_standardized.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_tags_filter_standardized.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_tags_find.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_tags_find.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_tags_find_standardized.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_tags_find_standardized.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_tags_first.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_tags_first.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_tags_get.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_tags_get.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_tags_hashtags.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_tags_hashtags.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_tags_identifier.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_tags_identifier.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_tags_is_empty.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_tags_is_empty.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_tags_last.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_tags_last.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_tags_len.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_tags_len.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_tags_public_keys.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_tags_public_keys.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_tags_to_vec.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_tags_to_vec.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_timestamp_add_duration.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_timestamp_add_duration.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_timestamp_as_secs.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_timestamp_as_secs.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_timestamp_sub_duration.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_timestamp_sub_duration.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_timestamp_to_human_datetime.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_timestamp_to_human_datetime.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_unsignedevent_add_signature.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_unsignedevent_add_signature.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_unsignedevent_as_json.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_unsignedevent_as_json.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_unsignedevent_as_pretty_json.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_unsignedevent_as_pretty_json.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_unsignedevent_author.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_unsignedevent_author.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_unsignedevent_content.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_unsignedevent_content.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_unsignedevent_created_at.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_unsignedevent_created_at.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_unsignedevent_id.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_unsignedevent_id.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_unsignedevent_kind.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_unsignedevent_kind.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_unsignedevent_sign.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_unsignedevent_sign.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_unsignedevent_sign_with_keys.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_unsignedevent_sign_with_keys.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_unsignedevent_tags.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_unsignedevent_tags.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_unwrappedgift__none.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_unwrappedgift__none.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_unwrappedgift_rumor.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_unwrappedgift_rumor.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_unwrappedgift_sender.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_unwrappedgift_sender.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_websocketadapter_send.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_websocketadapter_send.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_websocketadapter_recv.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_websocketadapter_recv.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_websocketadapter_close_connection.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_websocketadapter_close_connection.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_writepolicy_admit_event.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_writepolicy_admit_event.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_zaprequestdata_amount.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_zaprequestdata_amount.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_zaprequestdata_event_id.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_zaprequestdata_event_id.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_zaprequestdata_lnurl.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_zaprequestdata_lnurl.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_zaprequestdata_message.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_method_zaprequestdata_message.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_admitstatus_rejected.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_admitstatus_rejected.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_admitstatus_success.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_admitstatus_success.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_client_new.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_client_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_clientbuilder_new.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_clientbuilder_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_clientmessage_auth.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_clientmessage_auth.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_clientmessage_close.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_clientmessage_close.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_clientmessage_count.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_clientmessage_count.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_clientmessage_event.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_clientmessage_event.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_clientmessage_from_enum.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_clientmessage_from_enum.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_clientmessage_from_json.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_clientmessage_from_json.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_clientmessage_req.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_clientmessage_req.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_clientoptions_new.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_clientoptions_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_connection_new.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_connection_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_coordinate_new.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_coordinate_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_coordinate_parse.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_coordinate_parse.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_encryptedsecretkey_from_bech32.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_encryptedsecretkey_from_bech32.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_encryptedsecretkey_new.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_encryptedsecretkey_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_event_from_json.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_event_from_json.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_articles_curation_set.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_articles_curation_set.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_auth.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_auth.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_award_badge.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_award_badge.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_blocked_relays.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_blocked_relays.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_bookmarks.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_bookmarks.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_bookmarks_set.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_bookmarks_set.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_channel.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_channel.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_channel_metadata.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_channel_metadata.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_channel_msg.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_channel_msg.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_comment.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_comment.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_communities.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_communities.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_contact_list.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_contact_list.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_define_badge.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_define_badge.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_delete.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_delete.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_emoji_set.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_emoji_set.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_emojis.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_emojis.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_file_metadata.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_file_metadata.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_follow_set.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_follow_set.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_git_issue.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_git_issue.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_git_patch.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_git_patch.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_git_repository_announcement.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_git_repository_announcement.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_hide_channel_msg.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_hide_channel_msg.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_http_auth.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_http_auth.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_interest_set.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_interest_set.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_interests.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_interests.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_job_feedback.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_job_feedback.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_job_request.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_job_request.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_job_result.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_job_result.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_label.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_label.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_live_event.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_live_event.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_live_event_msg.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_live_event_msg.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_long_form_text_note.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_long_form_text_note.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_metadata.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_metadata.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_mute_channel_user.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_mute_channel_user.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_mute_list.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_mute_list.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_new.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_nostr_connect.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_nostr_connect.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_pinned_notes.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_pinned_notes.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_private_msg_rumor.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_private_msg_rumor.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_product_data.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_product_data.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_profile_badges.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_profile_badges.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_public_chats.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_public_chats.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_public_zap_request.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_public_zap_request.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_reaction.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_reaction.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_relay_list.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_relay_list.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_relay_set.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_relay_set.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_report.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_report.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_repost.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_repost.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_seal.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_seal.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_search_relays.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_search_relays.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_stall_data.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_stall_data.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_text_note.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_text_note.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_text_note_reply.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_text_note_reply.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_videos_curation_set.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_videos_curation_set.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_zap_receipt.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_zap_receipt.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_eventid_from_bytes.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_eventid_from_bytes.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_eventid_new.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_eventid_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_eventid_parse.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_eventid_parse.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_filemetadata_new.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_filemetadata_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_filter_from_json.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_filter_from_json.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_filter_from_record.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_filter_from_record.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_filter_new.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_filter_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_jobfeedbackdata_new.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_jobfeedbackdata_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_keys_from_mnemonic.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_keys_from_mnemonic.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_keys_generate.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_keys_generate.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_keys_new.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_keys_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_keys_parse.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_keys_parse.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_kind_from_std.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_kind_from_std.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_kind_new.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_kind_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_localrelay_new.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_localrelay_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_metadata_from_json.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_metadata_from_json.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_metadata_from_record.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_metadata_from_record.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_nwc_new.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_nwc_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_nwc_with_opts.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_nwc_with_opts.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_nip05address_parse.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_nip05address_parse.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_nip05profile_from_json.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_nip05profile_from_json.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_nip19_from_bech32.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_nip19_from_bech32.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_nip19coordinate_from_bech32.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_nip19coordinate_from_bech32.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_nip19coordinate_from_nostr_uri.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_nip19coordinate_from_nostr_uri.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_nip19coordinate_new.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_nip19coordinate_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_nip19event_from_bech32.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_nip19event_from_bech32.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_nip19event_from_event.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_nip19event_from_event.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_nip19event_from_nostr_uri.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_nip19event_from_nostr_uri.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_nip19event_new.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_nip19event_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_nip19profile_from_bech32.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_nip19profile_from_bech32.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_nip19profile_from_nostr_uri.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_nip19profile_from_nostr_uri.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_nip19profile_new.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_nip19profile_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_nip21_parse.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_nip21_parse.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_nip96serverconfig_from_json.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_nip96serverconfig_from_json.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_nip96uploadrequest_create.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_nip96uploadrequest_create.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_nip96uploadresponse_from_json.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_nip96uploadresponse_from_json.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_nostrconnect_new.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_nostrconnect_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_nostrconnectmetadata_new.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_nostrconnectmetadata_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_nostrconnecturi_parse.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_nostrconnecturi_parse.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_nostrdatabase_custom.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_nostrdatabase_custom.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_nostrdatabase_lmdb.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_nostrdatabase_lmdb.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_nostrgossip_in_memory.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_nostrgossip_in_memory.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_nostrparser_new.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_nostrparser_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_nostrsigner_custom.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_nostrsigner_custom.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_nostrsigner_keys.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_nostrsigner_keys.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_nostrsigner_nostr_connect.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_nostrsigner_nostr_connect.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_nostrwalletconnectoptions_new.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_nostrwalletconnectoptions_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_nostrwalletconnecturi_new.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_nostrwalletconnecturi_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_nostrwalletconnecturi_parse.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_nostrwalletconnecturi_parse.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_publickey_from_bytes.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_publickey_from_bytes.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_publickey_parse.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_publickey_parse.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_relaybuilder_new.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_relaybuilder_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_relayinformationdocument_from_json.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_relayinformationdocument_from_json.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_relaylimits_disable.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_relaylimits_disable.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_relaylimits_new.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_relaylimits_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_relaymessage_auth.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_relaymessage_auth.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_relaymessage_closed.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_relaymessage_closed.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_relaymessage_count.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_relaymessage_count.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_relaymessage_eose.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_relaymessage_eose.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_relaymessage_event.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_relaymessage_event.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_relaymessage_from_enum.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_relaymessage_from_enum.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_relaymessage_from_json.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_relaymessage_from_json.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_relaymessage_notice.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_relaymessage_notice.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_relaymessage_ok.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_relaymessage_ok.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_relayoptions_new.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_relayoptions_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_relayurl_parse.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_relayurl_parse.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_request_new.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_request_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_request_parse.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_request_parse.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_saveeventstatus_rejected.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_saveeventstatus_rejected.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_saveeventstatus_success.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_saveeventstatus_success.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_secretkey_from_bytes.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_secretkey_from_bytes.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_secretkey_generate.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_secretkey_generate.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_secretkey_parse.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_secretkey_parse.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_shippingmethod_new.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_shippingmethod_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_singlelettertag_lowercase.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_singlelettertag_lowercase.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_singlelettertag_uppercase.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_singlelettertag_uppercase.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_stalldata_from_json.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_stalldata_from_json.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_stalldata_from_record.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_stalldata_from_record.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_stalldata_new.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_stalldata_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_subscribeautocloseoptions_new.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_subscribeautocloseoptions_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_subscribeoptions_new.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_subscribeoptions_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_syncoptions_new.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_syncoptions_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_tag_alt.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_tag_alt.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_tag_client.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_tag_client.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_tag_coordinate.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_tag_coordinate.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_tag_custom.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_tag_custom.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_tag_description.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_tag_description.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_tag_event.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_tag_event.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_tag_event_report.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_tag_event_report.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_tag_expiration.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_tag_expiration.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_tag_from_standardized.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_tag_from_standardized.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_tag_hashtag.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_tag_hashtag.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_tag_identifier.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_tag_identifier.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_tag_image.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_tag_image.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_tag_parse.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_tag_parse.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_tag_pow.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_tag_pow.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_tag_protected.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_tag_protected.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_tag_public_key.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_tag_public_key.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_tag_public_key_report.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_tag_public_key_report.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_tag_reference.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_tag_reference.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_tag_relay_metadata.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_tag_relay_metadata.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_tag_title.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_tag_title.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_tags_from_list.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_tags_from_list.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_tags_parse.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_tags_parse.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_timestamp_from_secs.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_timestamp_from_secs.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_timestamp_max.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_timestamp_max.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_timestamp_min.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_timestamp_min.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_timestamp_now.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_timestamp_now.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_unsignedevent_from_json.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_unsignedevent_from_json.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_unwrappedgift_from_gift_wrap.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_unwrappedgift_from_gift_wrap.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_websocketadapterwrapper_new.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_websocketadapterwrapper_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_zaprequestdata_new.argtypes = (
)
_UniffiLib.uniffi_nostr_sdk_ffi_checksum_constructor_zaprequestdata_new.restype = ctypes.c_uint16
_UniffiLib.ffi_nostr_sdk_ffi_uniffi_contract_version.argtypes = (
)
_UniffiLib.ffi_nostr_sdk_ffi_uniffi_contract_version.restype = ctypes.c_uint32

_uniffi_check_contract_api_version(_UniffiLib)
# _uniffi_check_api_checksums(_UniffiLib)

# Public interface members begin here.
# Magic number for the Rust proxy to call using the same mechanism as every other method,
# to free the callback once it's dropped by Rust.
_UNIFFI_IDX_CALLBACK_FREE = 0
# Return codes for callback calls
_UNIFFI_CALLBACK_SUCCESS = 0
_UNIFFI_CALLBACK_ERROR = 1
_UNIFFI_CALLBACK_UNEXPECTED_ERROR = 2

class _UniffiCallbackInterfaceFfiConverter:
    _handle_map = _UniffiHandleMap()

    @classmethod
    def lift(cls, handle):
        return cls._handle_map.get(handle)

    @classmethod
    def read(cls, buf):
        handle = buf.read_u64()
        cls.lift(handle)

    @classmethod
    def check_lower(cls, cb):
        pass

    @classmethod
    def lower(cls, cb):
        handle = cls._handle_map.insert(cb)
        return handle

    @classmethod
    def write(cls, cb, buf):
        buf.write_u64(cls.lower(cb))

class _UniffiConverterUInt8(_UniffiConverterPrimitiveInt):
    CLASS_NAME = "u8"
    VALUE_MIN = 0
    VALUE_MAX = 2**8

    @staticmethod
    def read(buf):
        return buf.read_u8()

    @staticmethod
    def write(value, buf):
        buf.write_u8(value)

class _UniffiConverterUInt16(_UniffiConverterPrimitiveInt):
    CLASS_NAME = "u16"
    VALUE_MIN = 0
    VALUE_MAX = 2**16

    @staticmethod
    def read(buf):
        return buf.read_u16()

    @staticmethod
    def write(value, buf):
        buf.write_u16(value)

class _UniffiConverterUInt32(_UniffiConverterPrimitiveInt):
    CLASS_NAME = "u32"
    VALUE_MIN = 0
    VALUE_MAX = 2**32

    @staticmethod
    def read(buf):
        return buf.read_u32()

    @staticmethod
    def write(value, buf):
        buf.write_u32(value)

class _UniffiConverterInt32(_UniffiConverterPrimitiveInt):
    CLASS_NAME = "i32"
    VALUE_MIN = -2**31
    VALUE_MAX = 2**31

    @staticmethod
    def read(buf):
        return buf.read_i32()

    @staticmethod
    def write(value, buf):
        buf.write_i32(value)

class _UniffiConverterUInt64(_UniffiConverterPrimitiveInt):
    CLASS_NAME = "u64"
    VALUE_MIN = 0
    VALUE_MAX = 2**64

    @staticmethod
    def read(buf):
        return buf.read_u64()

    @staticmethod
    def write(value, buf):
        buf.write_u64(value)

class _UniffiConverterInt64(_UniffiConverterPrimitiveInt):
    CLASS_NAME = "i64"
    VALUE_MIN = -2**63
    VALUE_MAX = 2**63

    @staticmethod
    def read(buf):
        return buf.read_i64()

    @staticmethod
    def write(value, buf):
        buf.write_i64(value)

class _UniffiConverterDouble(_UniffiConverterPrimitiveFloat):
    @staticmethod
    def read(buf):
        return buf.read_double()

    @staticmethod
    def write(value, buf):
        buf.write_double(value)

class _UniffiConverterBool:
    @classmethod
    def check_lower(cls, value):
        return not not value

    @classmethod
    def lower(cls, value):
        return 1 if value else 0

    @staticmethod
    def lift(value):
        return value != 0

    @classmethod
    def read(cls, buf):
        return cls.lift(buf.read_u8())

    @classmethod
    def write(cls, value, buf):
        buf.write_u8(value)

class _UniffiConverterString:
    @staticmethod
    def check_lower(value):
        if not isinstance(value, str):
            raise TypeError("argument must be str, not {}".format(type(value).__name__))
        return value

    @staticmethod
    def read(buf):
        size = buf.read_i32()
        if size < 0:
            raise InternalError("Unexpected negative string length")
        utf8_bytes = buf.read(size)
        return utf8_bytes.decode("utf-8")

    @staticmethod
    def write(value, buf):
        utf8_bytes = value.encode("utf-8")
        buf.write_i32(len(utf8_bytes))
        buf.write(utf8_bytes)

    @staticmethod
    def lift(buf):
        with buf.consume_with_stream() as stream:
            return stream.read(stream.remaining()).decode("utf-8")

    @staticmethod
    def lower(value):
        with _UniffiRustBuffer.alloc_with_builder() as builder:
            builder.write(value.encode("utf-8"))
            return builder.finalize()

class _UniffiConverterBytes(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        size = buf.read_i32()
        if size < 0:
            raise InternalError("Unexpected negative byte string length")
        return buf.read(size)

    @staticmethod
    def check_lower(value):
        try:
            memoryview(value)
        except TypeError:
            raise TypeError("a bytes-like object is required, not {!r}".format(type(value).__name__))

    @staticmethod
    def write(value, buf):
        buf.write_i32(len(value))
        buf.write(value)

# The Duration type.
Duration = datetime.timedelta

# There is a loss of precision when converting from Rust durations,
# which are accurate to the nanosecond,
# to Python durations, which are only accurate to the microsecond.
class _UniffiConverterDuration(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        seconds = buf.read_u64()
        microseconds = buf.read_u32() / 1.0e3
        return datetime.timedelta(seconds=seconds, microseconds=microseconds)

    @staticmethod
    def check_lower(value):
        seconds = value.seconds + value.days * 24 * 3600
        if seconds < 0:
            raise ValueError("Invalid duration, must be non-negative")

    @staticmethod
    def write(value, buf):
        seconds = value.seconds + value.days * 24 * 3600
        nanoseconds = value.microseconds * 1000
        buf.write_i64(seconds)
        buf.write_u32(nanoseconds)






















































































































































class ArticlesCuration:
    """
    Groups of articles picked by users as interesting and/or belonging to the same category

    <https://github.com/nostr-protocol/nips/blob/master/51.md>
    """

    coordinate: "typing.List[Coordinate]"
    """
    Coordinates
    """

    event_ids: "typing.List[EventId]"
    """
    Event IDs
    """

    def __init__(self, *, coordinate: "typing.List[Coordinate]" = _DEFAULT, event_ids: "typing.List[EventId]" = _DEFAULT):
        if coordinate is _DEFAULT:
            self.coordinate = []
        else:
            self.coordinate = coordinate
        if event_ids is _DEFAULT:
            self.event_ids = []
        else:
            self.event_ids = event_ids

    def __str__(self):
        return "ArticlesCuration(coordinate={}, event_ids={})".format(self.coordinate, self.event_ids)

    def __eq__(self, other):
        if self.coordinate != other.coordinate:
            return False
        if self.event_ids != other.event_ids:
            return False
        return True

class _UniffiConverterTypeArticlesCuration(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ArticlesCuration(
            coordinate=_UniffiConverterSequenceTypeCoordinate.read(buf),
            event_ids=_UniffiConverterSequenceTypeEventId.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterSequenceTypeCoordinate.check_lower(value.coordinate)
        _UniffiConverterSequenceTypeEventId.check_lower(value.event_ids)

    @staticmethod
    def write(value, buf):
        _UniffiConverterSequenceTypeCoordinate.write(value.coordinate, buf)
        _UniffiConverterSequenceTypeEventId.write(value.event_ids, buf)


class Bookmarks:
    """
    Uncategorized, "global" list of things a user wants to save

    <https://github.com/nostr-protocol/nips/blob/master/51.md>
    """

    event_ids: "typing.List[EventId]"
    coordinate: "typing.List[Coordinate]"
    hashtags: "typing.List[str]"
    urls: "typing.List[str]"
    def __init__(self, *, event_ids: "typing.List[EventId]" = _DEFAULT, coordinate: "typing.List[Coordinate]" = _DEFAULT, hashtags: "typing.List[str]" = _DEFAULT, urls: "typing.List[str]" = _DEFAULT):
        if event_ids is _DEFAULT:
            self.event_ids = []
        else:
            self.event_ids = event_ids
        if coordinate is _DEFAULT:
            self.coordinate = []
        else:
            self.coordinate = coordinate
        if hashtags is _DEFAULT:
            self.hashtags = []
        else:
            self.hashtags = hashtags
        if urls is _DEFAULT:
            self.urls = []
        else:
            self.urls = urls

    def __str__(self):
        return "Bookmarks(event_ids={}, coordinate={}, hashtags={}, urls={})".format(self.event_ids, self.coordinate, self.hashtags, self.urls)

    def __eq__(self, other):
        if self.event_ids != other.event_ids:
            return False
        if self.coordinate != other.coordinate:
            return False
        if self.hashtags != other.hashtags:
            return False
        if self.urls != other.urls:
            return False
        return True

class _UniffiConverterTypeBookmarks(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return Bookmarks(
            event_ids=_UniffiConverterSequenceTypeEventId.read(buf),
            coordinate=_UniffiConverterSequenceTypeCoordinate.read(buf),
            hashtags=_UniffiConverterSequenceString.read(buf),
            urls=_UniffiConverterSequenceString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterSequenceTypeEventId.check_lower(value.event_ids)
        _UniffiConverterSequenceTypeCoordinate.check_lower(value.coordinate)
        _UniffiConverterSequenceString.check_lower(value.hashtags)
        _UniffiConverterSequenceString.check_lower(value.urls)

    @staticmethod
    def write(value, buf):
        _UniffiConverterSequenceTypeEventId.write(value.event_ids, buf)
        _UniffiConverterSequenceTypeCoordinate.write(value.coordinate, buf)
        _UniffiConverterSequenceString.write(value.hashtags, buf)
        _UniffiConverterSequenceString.write(value.urls, buf)


class CancelHoldInvoiceRequest:
    """
    Cancel Hold Invoice Request
    """

    payment_hash: "str"
    """
    payment_hash
    """

    def __init__(self, *, payment_hash: "str"):
        self.payment_hash = payment_hash

    def __str__(self):
        return "CancelHoldInvoiceRequest(payment_hash={})".format(self.payment_hash)

    def __eq__(self, other):
        if self.payment_hash != other.payment_hash:
            return False
        return True

class _UniffiConverterTypeCancelHoldInvoiceRequest(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return CancelHoldInvoiceRequest(
            payment_hash=_UniffiConverterString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.payment_hash)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.payment_hash, buf)


class CancelHoldInvoiceResponse:
    """
    Cancel Hold Invoice Response
    """


    def __str__(self):
        return "CancelHoldInvoiceResponse()".format()

    def __eq__(self, other):
        return True

class _UniffiConverterTypeCancelHoldInvoiceResponse(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return CancelHoldInvoiceResponse(
        )

    @staticmethod
    def check_lower(value):
        pass

    @staticmethod
    def write(value, buf):
        pass


class Contact:
    public_key: "PublicKey"
    relay_url: "typing.Optional[RelayUrl]"
    alias: "typing.Optional[str]"
    def __init__(self, *, public_key: "PublicKey", relay_url: "typing.Optional[RelayUrl]" = _DEFAULT, alias: "typing.Optional[str]" = _DEFAULT):
        self.public_key = public_key
        if relay_url is _DEFAULT:
            self.relay_url = None
        else:
            self.relay_url = relay_url
        if alias is _DEFAULT:
            self.alias = None
        else:
            self.alias = alias

    def __str__(self):
        return "Contact(public_key={}, relay_url={}, alias={})".format(self.public_key, self.relay_url, self.alias)

    def __eq__(self, other):
        if self.public_key != other.public_key:
            return False
        if self.relay_url != other.relay_url:
            return False
        if self.alias != other.alias:
            return False
        return True

class _UniffiConverterTypeContact(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return Contact(
            public_key=_UniffiConverterTypePublicKey.read(buf),
            relay_url=_UniffiConverterOptionalTypeRelayUrl.read(buf),
            alias=_UniffiConverterOptionalString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypePublicKey.check_lower(value.public_key)
        _UniffiConverterOptionalTypeRelayUrl.check_lower(value.relay_url)
        _UniffiConverterOptionalString.check_lower(value.alias)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypePublicKey.write(value.public_key, buf)
        _UniffiConverterOptionalTypeRelayUrl.write(value.relay_url, buf)
        _UniffiConverterOptionalString.write(value.alias, buf)


class EmojiInfo:
    """
    Emoji

    <https://github.com/nostr-protocol/nips/blob/master/51.md>
    """

    shortcode: "str"
    url: "str"
    def __init__(self, *, shortcode: "str", url: "str"):
        self.shortcode = shortcode
        self.url = url

    def __str__(self):
        return "EmojiInfo(shortcode={}, url={})".format(self.shortcode, self.url)

    def __eq__(self, other):
        if self.shortcode != other.shortcode:
            return False
        if self.url != other.url:
            return False
        return True

class _UniffiConverterTypeEmojiInfo(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return EmojiInfo(
            shortcode=_UniffiConverterString.read(buf),
            url=_UniffiConverterString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.shortcode)
        _UniffiConverterString.check_lower(value.url)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.shortcode, buf)
        _UniffiConverterString.write(value.url, buf)


class Emojis:
    """
    User preferred emojis and pointers to emoji sets

    <https://github.com/nostr-protocol/nips/blob/master/51.md>
    """

    emojis: "typing.List[EmojiInfo]"
    """
    Emojis
    """

    coordinate: "typing.List[Coordinate]"
    """
    Coordinates
    """

    def __init__(self, *, emojis: "typing.List[EmojiInfo]" = _DEFAULT, coordinate: "typing.List[Coordinate]" = _DEFAULT):
        if emojis is _DEFAULT:
            self.emojis = []
        else:
            self.emojis = emojis
        if coordinate is _DEFAULT:
            self.coordinate = []
        else:
            self.coordinate = coordinate

    def __str__(self):
        return "Emojis(emojis={}, coordinate={})".format(self.emojis, self.coordinate)

    def __eq__(self, other):
        if self.emojis != other.emojis:
            return False
        if self.coordinate != other.coordinate:
            return False
        return True

class _UniffiConverterTypeEmojis(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return Emojis(
            emojis=_UniffiConverterSequenceTypeEmojiInfo.read(buf),
            coordinate=_UniffiConverterSequenceTypeCoordinate.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterSequenceTypeEmojiInfo.check_lower(value.emojis)
        _UniffiConverterSequenceTypeCoordinate.check_lower(value.coordinate)

    @staticmethod
    def write(value, buf):
        _UniffiConverterSequenceTypeEmojiInfo.write(value.emojis, buf)
        _UniffiConverterSequenceTypeCoordinate.write(value.coordinate, buf)


class EventDeletionRequest:
    """
    Event deletion request
    """

    ids: "typing.List[EventId]"
    """
    Event IDs
    """

    coordinates: "typing.List[Coordinate]"
    """
    Event coordinates
    """

    reason: "typing.Optional[str]"
    """
    Optional reason
    """

    def __init__(self, *, ids: "typing.List[EventId]", coordinates: "typing.List[Coordinate]", reason: "typing.Optional[str]" = _DEFAULT):
        self.ids = ids
        self.coordinates = coordinates
        if reason is _DEFAULT:
            self.reason = None
        else:
            self.reason = reason

    def __str__(self):
        return "EventDeletionRequest(ids={}, coordinates={}, reason={})".format(self.ids, self.coordinates, self.reason)

    def __eq__(self, other):
        if self.ids != other.ids:
            return False
        if self.coordinates != other.coordinates:
            return False
        if self.reason != other.reason:
            return False
        return True

class _UniffiConverterTypeEventDeletionRequest(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return EventDeletionRequest(
            ids=_UniffiConverterSequenceTypeEventId.read(buf),
            coordinates=_UniffiConverterSequenceTypeCoordinate.read(buf),
            reason=_UniffiConverterOptionalString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterSequenceTypeEventId.check_lower(value.ids)
        _UniffiConverterSequenceTypeCoordinate.check_lower(value.coordinates)
        _UniffiConverterOptionalString.check_lower(value.reason)

    @staticmethod
    def write(value, buf):
        _UniffiConverterSequenceTypeEventId.write(value.ids, buf)
        _UniffiConverterSequenceTypeCoordinate.write(value.coordinates, buf)
        _UniffiConverterOptionalString.write(value.reason, buf)


class FeeSchedule:
    """
    The specific information about a fee schedule
    """

    amount: "int"
    """
    The fee amount
    """

    unit: "str"
    """
    The denomination of the feed
    """

    period: "typing.Optional[int]"
    """
    The duration for which the fee is valid
    """

    kinds: "typing.Optional[typing.List[str]]"
    """
    The event kinds the fee allows the client to publish to the relay
    """

    def __init__(self, *, amount: "int", unit: "str", period: "typing.Optional[int]", kinds: "typing.Optional[typing.List[str]]"):
        self.amount = amount
        self.unit = unit
        self.period = period
        self.kinds = kinds

    def __str__(self):
        return "FeeSchedule(amount={}, unit={}, period={}, kinds={})".format(self.amount, self.unit, self.period, self.kinds)

    def __eq__(self, other):
        if self.amount != other.amount:
            return False
        if self.unit != other.unit:
            return False
        if self.period != other.period:
            return False
        if self.kinds != other.kinds:
            return False
        return True

class _UniffiConverterTypeFeeSchedule(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return FeeSchedule(
            amount=_UniffiConverterInt32.read(buf),
            unit=_UniffiConverterString.read(buf),
            period=_UniffiConverterOptionalInt32.read(buf),
            kinds=_UniffiConverterOptionalSequenceString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterInt32.check_lower(value.amount)
        _UniffiConverterString.check_lower(value.unit)
        _UniffiConverterOptionalInt32.check_lower(value.period)
        _UniffiConverterOptionalSequenceString.check_lower(value.kinds)

    @staticmethod
    def write(value, buf):
        _UniffiConverterInt32.write(value.amount, buf)
        _UniffiConverterString.write(value.unit, buf)
        _UniffiConverterOptionalInt32.write(value.period, buf)
        _UniffiConverterOptionalSequenceString.write(value.kinds, buf)


class FeeSchedules:
    """
    Available fee schedules
    """

    admission: "typing.List[FeeSchedule]"
    """
    Fees for admission to use the relay
    """

    subscription: "typing.List[FeeSchedule]"
    """
    Fees for subscription to use the relay
    """

    publication: "typing.List[FeeSchedule]"
    """
    Fees to publish to the relay
    """

    def __init__(self, *, admission: "typing.List[FeeSchedule]", subscription: "typing.List[FeeSchedule]", publication: "typing.List[FeeSchedule]"):
        self.admission = admission
        self.subscription = subscription
        self.publication = publication

    def __str__(self):
        return "FeeSchedules(admission={}, subscription={}, publication={})".format(self.admission, self.subscription, self.publication)

    def __eq__(self, other):
        if self.admission != other.admission:
            return False
        if self.subscription != other.subscription:
            return False
        if self.publication != other.publication:
            return False
        return True

class _UniffiConverterTypeFeeSchedules(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return FeeSchedules(
            admission=_UniffiConverterSequenceTypeFeeSchedule.read(buf),
            subscription=_UniffiConverterSequenceTypeFeeSchedule.read(buf),
            publication=_UniffiConverterSequenceTypeFeeSchedule.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterSequenceTypeFeeSchedule.check_lower(value.admission)
        _UniffiConverterSequenceTypeFeeSchedule.check_lower(value.subscription)
        _UniffiConverterSequenceTypeFeeSchedule.check_lower(value.publication)

    @staticmethod
    def write(value, buf):
        _UniffiConverterSequenceTypeFeeSchedule.write(value.admission, buf)
        _UniffiConverterSequenceTypeFeeSchedule.write(value.subscription, buf)
        _UniffiConverterSequenceTypeFeeSchedule.write(value.publication, buf)


class FilterRecord:
    ids: "typing.Optional[typing.List[EventId]]"
    authors: "typing.Optional[typing.List[PublicKey]]"
    kinds: "typing.Optional[typing.List[Kind]]"
    search: "typing.Optional[str]"
    """
    It's a string describing a query in a human-readable form, i.e. "best nostr apps"

    <https://github.com/nostr-protocol/nips/blob/master/50.md>
    """

    since: "typing.Optional[Timestamp]"
    """
    An integer unix timestamp, events must be newer than this to pass
    """

    until: "typing.Optional[Timestamp]"
    """
    An integer unix timestamp, events must be older than this to pass
    """

    limit: "typing.Optional[int]"
    """
    Maximum number of events to be returned in the initial query
    """

    generic_tags: "typing.List[GenericTag]"
    """
    Generic tag queries
    """

    def __init__(self, *, ids: "typing.Optional[typing.List[EventId]]", authors: "typing.Optional[typing.List[PublicKey]]", kinds: "typing.Optional[typing.List[Kind]]", search: "typing.Optional[str]", since: "typing.Optional[Timestamp]", until: "typing.Optional[Timestamp]", limit: "typing.Optional[int]", generic_tags: "typing.List[GenericTag]"):
        self.ids = ids
        self.authors = authors
        self.kinds = kinds
        self.search = search
        self.since = since
        self.until = until
        self.limit = limit
        self.generic_tags = generic_tags

    def __str__(self):
        return "FilterRecord(ids={}, authors={}, kinds={}, search={}, since={}, until={}, limit={}, generic_tags={})".format(self.ids, self.authors, self.kinds, self.search, self.since, self.until, self.limit, self.generic_tags)

    def __eq__(self, other):
        if self.ids != other.ids:
            return False
        if self.authors != other.authors:
            return False
        if self.kinds != other.kinds:
            return False
        if self.search != other.search:
            return False
        if self.since != other.since:
            return False
        if self.until != other.until:
            return False
        if self.limit != other.limit:
            return False
        if self.generic_tags != other.generic_tags:
            return False
        return True

class _UniffiConverterTypeFilterRecord(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return FilterRecord(
            ids=_UniffiConverterOptionalSequenceTypeEventId.read(buf),
            authors=_UniffiConverterOptionalSequenceTypePublicKey.read(buf),
            kinds=_UniffiConverterOptionalSequenceTypeKind.read(buf),
            search=_UniffiConverterOptionalString.read(buf),
            since=_UniffiConverterOptionalTypeTimestamp.read(buf),
            until=_UniffiConverterOptionalTypeTimestamp.read(buf),
            limit=_UniffiConverterOptionalUInt64.read(buf),
            generic_tags=_UniffiConverterSequenceTypeGenericTag.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterOptionalSequenceTypeEventId.check_lower(value.ids)
        _UniffiConverterOptionalSequenceTypePublicKey.check_lower(value.authors)
        _UniffiConverterOptionalSequenceTypeKind.check_lower(value.kinds)
        _UniffiConverterOptionalString.check_lower(value.search)
        _UniffiConverterOptionalTypeTimestamp.check_lower(value.since)
        _UniffiConverterOptionalTypeTimestamp.check_lower(value.until)
        _UniffiConverterOptionalUInt64.check_lower(value.limit)
        _UniffiConverterSequenceTypeGenericTag.check_lower(value.generic_tags)

    @staticmethod
    def write(value, buf):
        _UniffiConverterOptionalSequenceTypeEventId.write(value.ids, buf)
        _UniffiConverterOptionalSequenceTypePublicKey.write(value.authors, buf)
        _UniffiConverterOptionalSequenceTypeKind.write(value.kinds, buf)
        _UniffiConverterOptionalString.write(value.search, buf)
        _UniffiConverterOptionalTypeTimestamp.write(value.since, buf)
        _UniffiConverterOptionalTypeTimestamp.write(value.until, buf)
        _UniffiConverterOptionalUInt64.write(value.limit, buf)
        _UniffiConverterSequenceTypeGenericTag.write(value.generic_tags, buf)


class GenericTag:
    key: "SingleLetterTag"
    value: "typing.List[str]"
    def __init__(self, *, key: "SingleLetterTag", value: "typing.List[str]"):
        self.key = key
        self.value = value

    def __str__(self):
        return "GenericTag(key={}, value={})".format(self.key, self.value)

    def __eq__(self, other):
        if self.key != other.key:
            return False
        if self.value != other.value:
            return False
        return True

class _UniffiConverterTypeGenericTag(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return GenericTag(
            key=_UniffiConverterTypeSingleLetterTag.read(buf),
            value=_UniffiConverterSequenceString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypeSingleLetterTag.check_lower(value.key)
        _UniffiConverterSequenceString.check_lower(value.value)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeSingleLetterTag.write(value.key, buf)
        _UniffiConverterSequenceString.write(value.value, buf)


class GetBalanceResponse:
    """
    NIP47 Response Result
    """

    balance: "int"
    """
    Balance amount in msats
    """

    def __init__(self, *, balance: "int"):
        self.balance = balance

    def __str__(self):
        return "GetBalanceResponse(balance={})".format(self.balance)

    def __eq__(self, other):
        if self.balance != other.balance:
            return False
        return True

class _UniffiConverterTypeGetBalanceResponse(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return GetBalanceResponse(
            balance=_UniffiConverterUInt64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterUInt64.check_lower(value.balance)

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt64.write(value.balance, buf)


class GetInfoResponse:
    """
    NIP47 Response Result
    """

    alias: "typing.Optional[str]"
    """
    The alias of the lightning node
    """

    color: "typing.Optional[str]"
    """
    The color of the current node in hex code format
    """

    pubkey: "typing.Optional[str]"
    """
    Lightning Node's public key
    """

    network: "typing.Optional[str]"
    """
    Active network
    """

    block_height: "typing.Optional[int]"
    """
    Current block height
    """

    block_hash: "typing.Optional[str]"
    """
    Most Recent Block Hash
    """

    methods: "typing.List[Method]"
    """
    Available methods for this connection
    """

    notifications: "typing.List[str]"
    """
    List of supported notifications for this connection (optional)
    """

    def __init__(self, *, alias: "typing.Optional[str]", color: "typing.Optional[str]", pubkey: "typing.Optional[str]", network: "typing.Optional[str]", block_height: "typing.Optional[int]", block_hash: "typing.Optional[str]", methods: "typing.List[Method]", notifications: "typing.List[str]"):
        self.alias = alias
        self.color = color
        self.pubkey = pubkey
        self.network = network
        self.block_height = block_height
        self.block_hash = block_hash
        self.methods = methods
        self.notifications = notifications

    def __str__(self):
        return "GetInfoResponse(alias={}, color={}, pubkey={}, network={}, block_height={}, block_hash={}, methods={}, notifications={})".format(self.alias, self.color, self.pubkey, self.network, self.block_height, self.block_hash, self.methods, self.notifications)

    def __eq__(self, other):
        if self.alias != other.alias:
            return False
        if self.color != other.color:
            return False
        if self.pubkey != other.pubkey:
            return False
        if self.network != other.network:
            return False
        if self.block_height != other.block_height:
            return False
        if self.block_hash != other.block_hash:
            return False
        if self.methods != other.methods:
            return False
        if self.notifications != other.notifications:
            return False
        return True

class _UniffiConverterTypeGetInfoResponse(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return GetInfoResponse(
            alias=_UniffiConverterOptionalString.read(buf),
            color=_UniffiConverterOptionalString.read(buf),
            pubkey=_UniffiConverterOptionalString.read(buf),
            network=_UniffiConverterOptionalString.read(buf),
            block_height=_UniffiConverterOptionalUInt32.read(buf),
            block_hash=_UniffiConverterOptionalString.read(buf),
            methods=_UniffiConverterSequenceTypeMethod.read(buf),
            notifications=_UniffiConverterSequenceString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterOptionalString.check_lower(value.alias)
        _UniffiConverterOptionalString.check_lower(value.color)
        _UniffiConverterOptionalString.check_lower(value.pubkey)
        _UniffiConverterOptionalString.check_lower(value.network)
        _UniffiConverterOptionalUInt32.check_lower(value.block_height)
        _UniffiConverterOptionalString.check_lower(value.block_hash)
        _UniffiConverterSequenceTypeMethod.check_lower(value.methods)
        _UniffiConverterSequenceString.check_lower(value.notifications)

    @staticmethod
    def write(value, buf):
        _UniffiConverterOptionalString.write(value.alias, buf)
        _UniffiConverterOptionalString.write(value.color, buf)
        _UniffiConverterOptionalString.write(value.pubkey, buf)
        _UniffiConverterOptionalString.write(value.network, buf)
        _UniffiConverterOptionalUInt32.write(value.block_height, buf)
        _UniffiConverterOptionalString.write(value.block_hash, buf)
        _UniffiConverterSequenceTypeMethod.write(value.methods, buf)
        _UniffiConverterSequenceString.write(value.notifications, buf)


class GitIssue:
    """
    Git Issue
    """

    repository: "Coordinate"
    """
    The repository address
    """

    content: "str"
    """
    The issue content (markdown)
    """

    subject: "typing.Optional[str]"
    """
    Subject
    """

    labels: "typing.List[str]"
    """
    Labels
    """

    def __init__(self, *, repository: "Coordinate", content: "str", subject: "typing.Optional[str]", labels: "typing.List[str]"):
        self.repository = repository
        self.content = content
        self.subject = subject
        self.labels = labels

    def __str__(self):
        return "GitIssue(repository={}, content={}, subject={}, labels={})".format(self.repository, self.content, self.subject, self.labels)

    def __eq__(self, other):
        if self.repository != other.repository:
            return False
        if self.content != other.content:
            return False
        if self.subject != other.subject:
            return False
        if self.labels != other.labels:
            return False
        return True

class _UniffiConverterTypeGitIssue(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return GitIssue(
            repository=_UniffiConverterTypeCoordinate.read(buf),
            content=_UniffiConverterString.read(buf),
            subject=_UniffiConverterOptionalString.read(buf),
            labels=_UniffiConverterSequenceString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypeCoordinate.check_lower(value.repository)
        _UniffiConverterString.check_lower(value.content)
        _UniffiConverterOptionalString.check_lower(value.subject)
        _UniffiConverterSequenceString.check_lower(value.labels)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeCoordinate.write(value.repository, buf)
        _UniffiConverterString.write(value.content, buf)
        _UniffiConverterOptionalString.write(value.subject, buf)
        _UniffiConverterSequenceString.write(value.labels, buf)


class GitPatch:
    """
    Git Patch
    """

    repository: "Coordinate"
    """
    Repository
    """

    content: "GitPatchContent"
    """
    Patch
    """

    euc: "str"
    """
    Earliest unique commit ID of repo
    """

    labels: "typing.List[str]"
    """
    Labels
    """

    def __init__(self, *, repository: "Coordinate", content: "GitPatchContent", euc: "str", labels: "typing.List[str]"):
        self.repository = repository
        self.content = content
        self.euc = euc
        self.labels = labels

    def __str__(self):
        return "GitPatch(repository={}, content={}, euc={}, labels={})".format(self.repository, self.content, self.euc, self.labels)

    def __eq__(self, other):
        if self.repository != other.repository:
            return False
        if self.content != other.content:
            return False
        if self.euc != other.euc:
            return False
        if self.labels != other.labels:
            return False
        return True

class _UniffiConverterTypeGitPatch(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return GitPatch(
            repository=_UniffiConverterTypeCoordinate.read(buf),
            content=_UniffiConverterTypeGitPatchContent.read(buf),
            euc=_UniffiConverterString.read(buf),
            labels=_UniffiConverterSequenceString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypeCoordinate.check_lower(value.repository)
        _UniffiConverterTypeGitPatchContent.check_lower(value.content)
        _UniffiConverterString.check_lower(value.euc)
        _UniffiConverterSequenceString.check_lower(value.labels)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeCoordinate.write(value.repository, buf)
        _UniffiConverterTypeGitPatchContent.write(value.content, buf)
        _UniffiConverterString.write(value.euc, buf)
        _UniffiConverterSequenceString.write(value.labels, buf)


class GitPatchCommitter:
    """
    Git Patch Committer
    """

    name: "typing.Optional[str]"
    """
    Name
    """

    email: "typing.Optional[str]"
    """
    Email
    """

    timestamp: "Timestamp"
    """
    Timestamp
    """

    offset_minutes: "int"
    """
    Timezone offset in minutes
    """

    def __init__(self, *, name: "typing.Optional[str]", email: "typing.Optional[str]", timestamp: "Timestamp", offset_minutes: "int"):
        self.name = name
        self.email = email
        self.timestamp = timestamp
        self.offset_minutes = offset_minutes

    def __str__(self):
        return "GitPatchCommitter(name={}, email={}, timestamp={}, offset_minutes={})".format(self.name, self.email, self.timestamp, self.offset_minutes)

    def __eq__(self, other):
        if self.name != other.name:
            return False
        if self.email != other.email:
            return False
        if self.timestamp != other.timestamp:
            return False
        if self.offset_minutes != other.offset_minutes:
            return False
        return True

class _UniffiConverterTypeGitPatchCommitter(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return GitPatchCommitter(
            name=_UniffiConverterOptionalString.read(buf),
            email=_UniffiConverterOptionalString.read(buf),
            timestamp=_UniffiConverterTypeTimestamp.read(buf),
            offset_minutes=_UniffiConverterInt32.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterOptionalString.check_lower(value.name)
        _UniffiConverterOptionalString.check_lower(value.email)
        _UniffiConverterTypeTimestamp.check_lower(value.timestamp)
        _UniffiConverterInt32.check_lower(value.offset_minutes)

    @staticmethod
    def write(value, buf):
        _UniffiConverterOptionalString.write(value.name, buf)
        _UniffiConverterOptionalString.write(value.email, buf)
        _UniffiConverterTypeTimestamp.write(value.timestamp, buf)
        _UniffiConverterInt32.write(value.offset_minutes, buf)


class GitRepositoryAnnouncement:
    """
    Git Repository Announcement

    Git repositories are hosted in Git-enabled servers, but their existence can be announced using Nostr events,
    as well as their willingness to receive patches, bug reports and comments in general.
    """

    id: "str"
    """
    Repository ID (usually kebab-case short name)
    """

    name: "typing.Optional[str]"
    """
    Human-readable project name
    """

    description: "typing.Optional[str]"
    """
    Brief human-readable project description
    """

    web: "typing.List[str]"
    """
    Webpage urls, if the git server being used provides such a thing
    """

    clone: "typing.List[str]"
    """
    Urls for git-cloning
    """

    relays: "typing.List[RelayUrl]"
    """
    Relays that this repository will monitor for patches and issues
    """

    euc: "typing.Optional[str]"
    """
    Earliest unique commit ID

    `euc` marker should be the commit ID of the earliest unique commit of this repo,
    made to identify it among forks and group it with other repositories hosted elsewhere that may represent essentially the same project.
    In most cases it will be the root commit of a repository.
    In case of a permanent fork between two projects, then the first commit after the fork should be used.
    """

    maintainers: "typing.List[PublicKey]"
    """
    Other recognized maintainers
    """

    def __init__(self, *, id: "str", name: "typing.Optional[str]", description: "typing.Optional[str]", web: "typing.List[str]", clone: "typing.List[str]", relays: "typing.List[RelayUrl]", euc: "typing.Optional[str]", maintainers: "typing.List[PublicKey]"):
        self.id = id
        self.name = name
        self.description = description
        self.web = web
        self.clone = clone
        self.relays = relays
        self.euc = euc
        self.maintainers = maintainers

    def __str__(self):
        return "GitRepositoryAnnouncement(id={}, name={}, description={}, web={}, clone={}, relays={}, euc={}, maintainers={})".format(self.id, self.name, self.description, self.web, self.clone, self.relays, self.euc, self.maintainers)

    def __eq__(self, other):
        if self.id != other.id:
            return False
        if self.name != other.name:
            return False
        if self.description != other.description:
            return False
        if self.web != other.web:
            return False
        if self.clone != other.clone:
            return False
        if self.relays != other.relays:
            return False
        if self.euc != other.euc:
            return False
        if self.maintainers != other.maintainers:
            return False
        return True

class _UniffiConverterTypeGitRepositoryAnnouncement(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return GitRepositoryAnnouncement(
            id=_UniffiConverterString.read(buf),
            name=_UniffiConverterOptionalString.read(buf),
            description=_UniffiConverterOptionalString.read(buf),
            web=_UniffiConverterSequenceString.read(buf),
            clone=_UniffiConverterSequenceString.read(buf),
            relays=_UniffiConverterSequenceTypeRelayUrl.read(buf),
            euc=_UniffiConverterOptionalString.read(buf),
            maintainers=_UniffiConverterSequenceTypePublicKey.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.id)
        _UniffiConverterOptionalString.check_lower(value.name)
        _UniffiConverterOptionalString.check_lower(value.description)
        _UniffiConverterSequenceString.check_lower(value.web)
        _UniffiConverterSequenceString.check_lower(value.clone)
        _UniffiConverterSequenceTypeRelayUrl.check_lower(value.relays)
        _UniffiConverterOptionalString.check_lower(value.euc)
        _UniffiConverterSequenceTypePublicKey.check_lower(value.maintainers)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.id, buf)
        _UniffiConverterOptionalString.write(value.name, buf)
        _UniffiConverterOptionalString.write(value.description, buf)
        _UniffiConverterSequenceString.write(value.web, buf)
        _UniffiConverterSequenceString.write(value.clone, buf)
        _UniffiConverterSequenceTypeRelayUrl.write(value.relays, buf)
        _UniffiConverterOptionalString.write(value.euc, buf)
        _UniffiConverterSequenceTypePublicKey.write(value.maintainers, buf)


class GossipOptions:
    """
    Gossip options
    """

    limits: "GossipRelayLimits"
    """
    Max number of relays to use
    """

    def __init__(self, *, limits: "GossipRelayLimits"):
        self.limits = limits

    def __str__(self):
        return "GossipOptions(limits={})".format(self.limits)

    def __eq__(self, other):
        if self.limits != other.limits:
            return False
        return True

class _UniffiConverterTypeGossipOptions(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return GossipOptions(
            limits=_UniffiConverterTypeGossipRelayLimits.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypeGossipRelayLimits.check_lower(value.limits)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeGossipRelayLimits.write(value.limits, buf)


class GossipRelayLimits:
    """
    Max number of relays to use for gossip
    """

    read_relays_per_user: "int"
    """
    Max number of **read** relays per user (default: 3)
    """

    write_relays_per_user: "int"
    """
    Max number of **write** relays per user (default: 3)
    """

    hint_relays_per_user: "int"
    """
    Max number of **hint** relays per user (default: 1)
    """

    most_used_relays_per_user: "int"
    """
    Max number of **most used** relays per user (default: 1)
    """

    nip17_relays: "int"
    """
    Max number of NIP-17 relays per user (default: 3)
    """

    def __init__(self, *, read_relays_per_user: "int", write_relays_per_user: "int", hint_relays_per_user: "int", most_used_relays_per_user: "int", nip17_relays: "int"):
        self.read_relays_per_user = read_relays_per_user
        self.write_relays_per_user = write_relays_per_user
        self.hint_relays_per_user = hint_relays_per_user
        self.most_used_relays_per_user = most_used_relays_per_user
        self.nip17_relays = nip17_relays

    def __str__(self):
        return "GossipRelayLimits(read_relays_per_user={}, write_relays_per_user={}, hint_relays_per_user={}, most_used_relays_per_user={}, nip17_relays={})".format(self.read_relays_per_user, self.write_relays_per_user, self.hint_relays_per_user, self.most_used_relays_per_user, self.nip17_relays)

    def __eq__(self, other):
        if self.read_relays_per_user != other.read_relays_per_user:
            return False
        if self.write_relays_per_user != other.write_relays_per_user:
            return False
        if self.hint_relays_per_user != other.hint_relays_per_user:
            return False
        if self.most_used_relays_per_user != other.most_used_relays_per_user:
            return False
        if self.nip17_relays != other.nip17_relays:
            return False
        return True

class _UniffiConverterTypeGossipRelayLimits(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return GossipRelayLimits(
            read_relays_per_user=_UniffiConverterUInt64.read(buf),
            write_relays_per_user=_UniffiConverterUInt64.read(buf),
            hint_relays_per_user=_UniffiConverterUInt64.read(buf),
            most_used_relays_per_user=_UniffiConverterUInt64.read(buf),
            nip17_relays=_UniffiConverterUInt64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterUInt64.check_lower(value.read_relays_per_user)
        _UniffiConverterUInt64.check_lower(value.write_relays_per_user)
        _UniffiConverterUInt64.check_lower(value.hint_relays_per_user)
        _UniffiConverterUInt64.check_lower(value.most_used_relays_per_user)
        _UniffiConverterUInt64.check_lower(value.nip17_relays)

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt64.write(value.read_relays_per_user, buf)
        _UniffiConverterUInt64.write(value.write_relays_per_user, buf)
        _UniffiConverterUInt64.write(value.hint_relays_per_user, buf)
        _UniffiConverterUInt64.write(value.most_used_relays_per_user, buf)
        _UniffiConverterUInt64.write(value.nip17_relays, buf)


class HttpData:
    url: "str"
    method: "HttpMethod"
    payload: "typing.Optional[str]"
    def __init__(self, *, url: "str", method: "HttpMethod", payload: "typing.Optional[str]"):
        self.url = url
        self.method = method
        self.payload = payload

    def __str__(self):
        return "HttpData(url={}, method={}, payload={})".format(self.url, self.method, self.payload)

    def __eq__(self, other):
        if self.url != other.url:
            return False
        if self.method != other.method:
            return False
        if self.payload != other.payload:
            return False
        return True

class _UniffiConverterTypeHttpData(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return HttpData(
            url=_UniffiConverterString.read(buf),
            method=_UniffiConverterTypeHttpMethod.read(buf),
            payload=_UniffiConverterOptionalString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.url)
        _UniffiConverterTypeHttpMethod.check_lower(value.method)
        _UniffiConverterOptionalString.check_lower(value.payload)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.url, buf)
        _UniffiConverterTypeHttpMethod.write(value.method, buf)
        _UniffiConverterOptionalString.write(value.payload, buf)


class Identity:
    """
    External identity

    <https://github.com/nostr-protocol/nips/blob/master/39.md>
    """

    platform: "ExternalIdentity"
    """
    The external identity provider
    """

    ident: "str"
    """
    The user's identity (username) on the provider
    """

    proof: "str"
    """
    The user's proof on the provider
    """

    def __init__(self, *, platform: "ExternalIdentity", ident: "str", proof: "str"):
        self.platform = platform
        self.ident = ident
        self.proof = proof

    def __str__(self):
        return "Identity(platform={}, ident={}, proof={})".format(self.platform, self.ident, self.proof)

    def __eq__(self, other):
        if self.platform != other.platform:
            return False
        if self.ident != other.ident:
            return False
        if self.proof != other.proof:
            return False
        return True

class _UniffiConverterTypeIdentity(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return Identity(
            platform=_UniffiConverterTypeExternalIdentity.read(buf),
            ident=_UniffiConverterString.read(buf),
            proof=_UniffiConverterString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypeExternalIdentity.check_lower(value.platform)
        _UniffiConverterString.check_lower(value.ident)
        _UniffiConverterString.check_lower(value.proof)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeExternalIdentity.write(value.platform, buf)
        _UniffiConverterString.write(value.ident, buf)
        _UniffiConverterString.write(value.proof, buf)


class Image:
    url: "str"
    dimensions: "typing.Optional[ImageDimensions]"
    def __init__(self, *, url: "str", dimensions: "typing.Optional[ImageDimensions]"):
        self.url = url
        self.dimensions = dimensions

    def __str__(self):
        return "Image(url={}, dimensions={})".format(self.url, self.dimensions)

    def __eq__(self, other):
        if self.url != other.url:
            return False
        if self.dimensions != other.dimensions:
            return False
        return True

class _UniffiConverterTypeImage(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return Image(
            url=_UniffiConverterString.read(buf),
            dimensions=_UniffiConverterOptionalTypeImageDimensions.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.url)
        _UniffiConverterOptionalTypeImageDimensions.check_lower(value.dimensions)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.url, buf)
        _UniffiConverterOptionalTypeImageDimensions.write(value.dimensions, buf)


class ImageDimensions:
    width: "int"
    """
    Width
    """

    height: "int"
    """
    Height
    """

    def __init__(self, *, width: "int", height: "int"):
        self.width = width
        self.height = height

    def __str__(self):
        return "ImageDimensions(width={}, height={})".format(self.width, self.height)

    def __eq__(self, other):
        if self.width != other.width:
            return False
        if self.height != other.height:
            return False
        return True

class _UniffiConverterTypeImageDimensions(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ImageDimensions(
            width=_UniffiConverterUInt64.read(buf),
            height=_UniffiConverterUInt64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterUInt64.check_lower(value.width)
        _UniffiConverterUInt64.check_lower(value.height)

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt64.write(value.width, buf)
        _UniffiConverterUInt64.write(value.height, buf)


class Interests:
    """
    Topics a user may be interested in and pointers

    <https://github.com/nostr-protocol/nips/blob/master/51.md>
    """

    hashtags: "typing.List[str]"
    coordinate: "typing.List[Coordinate]"
    def __init__(self, *, hashtags: "typing.List[str]" = _DEFAULT, coordinate: "typing.List[Coordinate]" = _DEFAULT):
        if hashtags is _DEFAULT:
            self.hashtags = []
        else:
            self.hashtags = hashtags
        if coordinate is _DEFAULT:
            self.coordinate = []
        else:
            self.coordinate = coordinate

    def __str__(self):
        return "Interests(hashtags={}, coordinate={})".format(self.hashtags, self.coordinate)

    def __eq__(self, other):
        if self.hashtags != other.hashtags:
            return False
        if self.coordinate != other.coordinate:
            return False
        return True

class _UniffiConverterTypeInterests(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return Interests(
            hashtags=_UniffiConverterSequenceString.read(buf),
            coordinate=_UniffiConverterSequenceTypeCoordinate.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterSequenceString.check_lower(value.hashtags)
        _UniffiConverterSequenceTypeCoordinate.check_lower(value.coordinate)

    @staticmethod
    def write(value, buf):
        _UniffiConverterSequenceString.write(value.hashtags, buf)
        _UniffiConverterSequenceTypeCoordinate.write(value.coordinate, buf)


class KeysendTlvRecord:
    """
    TLVs to be added to the keysend payment
    """

    tlv_type: "int"
    """
    TLV type
    """

    value: "str"
    """
    TLV value
    """

    def __init__(self, *, tlv_type: "int", value: "str"):
        self.tlv_type = tlv_type
        self.value = value

    def __str__(self):
        return "KeysendTlvRecord(tlv_type={}, value={})".format(self.tlv_type, self.value)

    def __eq__(self, other):
        if self.tlv_type != other.tlv_type:
            return False
        if self.value != other.value:
            return False
        return True

class _UniffiConverterTypeKeysendTlvRecord(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return KeysendTlvRecord(
            tlv_type=_UniffiConverterUInt64.read(buf),
            value=_UniffiConverterString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterUInt64.check_lower(value.tlv_type)
        _UniffiConverterString.check_lower(value.value)

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt64.write(value.tlv_type, buf)
        _UniffiConverterString.write(value.value, buf)


class Limitation:
    """
    These are limitations imposed by the relay on clients. Your client should
    expect that requests which exceed these practical limitations are rejected or fail immediately.
    """

    max_message_length: "typing.Optional[int]"
    """
    Maximum number of bytes for incoming JSON that the relay will attempt to decode and act upon
    """

    max_subscriptions: "typing.Optional[int]"
    """
    Total number of subscriptions that may be active on a single websocket connection
    """

    max_filters: "typing.Optional[int]"
    """
    Maximum number of filter values in each subscription
    """

    max_limit: "typing.Optional[int]"
    """
    Relay will clamp each filter's limit value to this number
    """

    max_subid_length: "typing.Optional[int]"
    """
    Maximum length of subscription id as a string
    """

    max_event_tags: "typing.Optional[int]"
    """
    Maximum number of elements in the tags list
    """

    max_content_length: "typing.Optional[int]"
    """
    Maximum number of characters in the content field of any event
    """

    min_pow_difficulty: "typing.Optional[int]"
    """
    New events will require at least this difficulty of PoW,
    """

    auth_required: "typing.Optional[bool]"
    """
    Relay requires NIP42 authentication to happen before a new connection may perform any other action
    """

    payment_required: "typing.Optional[bool]"
    """
    Relay requires payment before a new connection may perform any action
    """

    created_at_lower_limit: "typing.Optional[Timestamp]"
    """
    'created_at' lower limit
    """

    created_at_upper_limit: "typing.Optional[Timestamp]"
    """
    'created_at' upper limit
    """

    def __init__(self, *, max_message_length: "typing.Optional[int]", max_subscriptions: "typing.Optional[int]", max_filters: "typing.Optional[int]", max_limit: "typing.Optional[int]", max_subid_length: "typing.Optional[int]", max_event_tags: "typing.Optional[int]", max_content_length: "typing.Optional[int]", min_pow_difficulty: "typing.Optional[int]", auth_required: "typing.Optional[bool]", payment_required: "typing.Optional[bool]", created_at_lower_limit: "typing.Optional[Timestamp]", created_at_upper_limit: "typing.Optional[Timestamp]"):
        self.max_message_length = max_message_length
        self.max_subscriptions = max_subscriptions
        self.max_filters = max_filters
        self.max_limit = max_limit
        self.max_subid_length = max_subid_length
        self.max_event_tags = max_event_tags
        self.max_content_length = max_content_length
        self.min_pow_difficulty = min_pow_difficulty
        self.auth_required = auth_required
        self.payment_required = payment_required
        self.created_at_lower_limit = created_at_lower_limit
        self.created_at_upper_limit = created_at_upper_limit

    def __str__(self):
        return "Limitation(max_message_length={}, max_subscriptions={}, max_filters={}, max_limit={}, max_subid_length={}, max_event_tags={}, max_content_length={}, min_pow_difficulty={}, auth_required={}, payment_required={}, created_at_lower_limit={}, created_at_upper_limit={})".format(self.max_message_length, self.max_subscriptions, self.max_filters, self.max_limit, self.max_subid_length, self.max_event_tags, self.max_content_length, self.min_pow_difficulty, self.auth_required, self.payment_required, self.created_at_lower_limit, self.created_at_upper_limit)

    def __eq__(self, other):
        if self.max_message_length != other.max_message_length:
            return False
        if self.max_subscriptions != other.max_subscriptions:
            return False
        if self.max_filters != other.max_filters:
            return False
        if self.max_limit != other.max_limit:
            return False
        if self.max_subid_length != other.max_subid_length:
            return False
        if self.max_event_tags != other.max_event_tags:
            return False
        if self.max_content_length != other.max_content_length:
            return False
        if self.min_pow_difficulty != other.min_pow_difficulty:
            return False
        if self.auth_required != other.auth_required:
            return False
        if self.payment_required != other.payment_required:
            return False
        if self.created_at_lower_limit != other.created_at_lower_limit:
            return False
        if self.created_at_upper_limit != other.created_at_upper_limit:
            return False
        return True

class _UniffiConverterTypeLimitation(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return Limitation(
            max_message_length=_UniffiConverterOptionalInt32.read(buf),
            max_subscriptions=_UniffiConverterOptionalInt32.read(buf),
            max_filters=_UniffiConverterOptionalInt32.read(buf),
            max_limit=_UniffiConverterOptionalInt32.read(buf),
            max_subid_length=_UniffiConverterOptionalInt32.read(buf),
            max_event_tags=_UniffiConverterOptionalInt32.read(buf),
            max_content_length=_UniffiConverterOptionalInt32.read(buf),
            min_pow_difficulty=_UniffiConverterOptionalInt32.read(buf),
            auth_required=_UniffiConverterOptionalBool.read(buf),
            payment_required=_UniffiConverterOptionalBool.read(buf),
            created_at_lower_limit=_UniffiConverterOptionalTypeTimestamp.read(buf),
            created_at_upper_limit=_UniffiConverterOptionalTypeTimestamp.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterOptionalInt32.check_lower(value.max_message_length)
        _UniffiConverterOptionalInt32.check_lower(value.max_subscriptions)
        _UniffiConverterOptionalInt32.check_lower(value.max_filters)
        _UniffiConverterOptionalInt32.check_lower(value.max_limit)
        _UniffiConverterOptionalInt32.check_lower(value.max_subid_length)
        _UniffiConverterOptionalInt32.check_lower(value.max_event_tags)
        _UniffiConverterOptionalInt32.check_lower(value.max_content_length)
        _UniffiConverterOptionalInt32.check_lower(value.min_pow_difficulty)
        _UniffiConverterOptionalBool.check_lower(value.auth_required)
        _UniffiConverterOptionalBool.check_lower(value.payment_required)
        _UniffiConverterOptionalTypeTimestamp.check_lower(value.created_at_lower_limit)
        _UniffiConverterOptionalTypeTimestamp.check_lower(value.created_at_upper_limit)

    @staticmethod
    def write(value, buf):
        _UniffiConverterOptionalInt32.write(value.max_message_length, buf)
        _UniffiConverterOptionalInt32.write(value.max_subscriptions, buf)
        _UniffiConverterOptionalInt32.write(value.max_filters, buf)
        _UniffiConverterOptionalInt32.write(value.max_limit, buf)
        _UniffiConverterOptionalInt32.write(value.max_subid_length, buf)
        _UniffiConverterOptionalInt32.write(value.max_event_tags, buf)
        _UniffiConverterOptionalInt32.write(value.max_content_length, buf)
        _UniffiConverterOptionalInt32.write(value.min_pow_difficulty, buf)
        _UniffiConverterOptionalBool.write(value.auth_required, buf)
        _UniffiConverterOptionalBool.write(value.payment_required, buf)
        _UniffiConverterOptionalTypeTimestamp.write(value.created_at_lower_limit, buf)
        _UniffiConverterOptionalTypeTimestamp.write(value.created_at_upper_limit, buf)


class ListTransactionsRequest:
    """
    List Invoice Request
    """

    _from: "typing.Optional[Timestamp]"
    """
    Starting timestamp in seconds since epoch
    """

    until: "typing.Optional[Timestamp]"
    """
    Ending timestamp in seconds since epoch
    """

    limit: "typing.Optional[int]"
    """
    Number of invoices to return
    """

    offset: "typing.Optional[int]"
    """
    Offset of the first invoice to return
    """

    unpaid: "typing.Optional[bool]"
    """
    If true, include unpaid invoices
    """

    transaction_type: "typing.Optional[TransactionType]"
    """
    [`TransactionType::Incoming`] for invoices, [`TransactionType::Outgoing`] for payments, [`None`] for both
    """

    def __init__(self, *, _from: "typing.Optional[Timestamp]", until: "typing.Optional[Timestamp]", limit: "typing.Optional[int]", offset: "typing.Optional[int]", unpaid: "typing.Optional[bool]", transaction_type: "typing.Optional[TransactionType]"):
        self._from = _from
        self.until = until
        self.limit = limit
        self.offset = offset
        self.unpaid = unpaid
        self.transaction_type = transaction_type

    def __str__(self):
        return "ListTransactionsRequest(_from={}, until={}, limit={}, offset={}, unpaid={}, transaction_type={})".format(self._from, self.until, self.limit, self.offset, self.unpaid, self.transaction_type)

    def __eq__(self, other):
        if self._from != other._from:
            return False
        if self.until != other.until:
            return False
        if self.limit != other.limit:
            return False
        if self.offset != other.offset:
            return False
        if self.unpaid != other.unpaid:
            return False
        if self.transaction_type != other.transaction_type:
            return False
        return True

class _UniffiConverterTypeListTransactionsRequest(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ListTransactionsRequest(
            _from=_UniffiConverterOptionalTypeTimestamp.read(buf),
            until=_UniffiConverterOptionalTypeTimestamp.read(buf),
            limit=_UniffiConverterOptionalUInt64.read(buf),
            offset=_UniffiConverterOptionalUInt64.read(buf),
            unpaid=_UniffiConverterOptionalBool.read(buf),
            transaction_type=_UniffiConverterOptionalTypeTransactionType.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterOptionalTypeTimestamp.check_lower(value._from)
        _UniffiConverterOptionalTypeTimestamp.check_lower(value.until)
        _UniffiConverterOptionalUInt64.check_lower(value.limit)
        _UniffiConverterOptionalUInt64.check_lower(value.offset)
        _UniffiConverterOptionalBool.check_lower(value.unpaid)
        _UniffiConverterOptionalTypeTransactionType.check_lower(value.transaction_type)

    @staticmethod
    def write(value, buf):
        _UniffiConverterOptionalTypeTimestamp.write(value._from, buf)
        _UniffiConverterOptionalTypeTimestamp.write(value.until, buf)
        _UniffiConverterOptionalUInt64.write(value.limit, buf)
        _UniffiConverterOptionalUInt64.write(value.offset, buf)
        _UniffiConverterOptionalBool.write(value.unpaid, buf)
        _UniffiConverterOptionalTypeTransactionType.write(value.transaction_type, buf)


class LiveEvent:
    id: "str"
    title: "typing.Optional[str]"
    summary: "typing.Optional[str]"
    image: "typing.Optional[Image]"
    hashtags: "typing.List[str]"
    streaming: "typing.Optional[str]"
    recording: "typing.Optional[str]"
    start: "typing.Optional[Timestamp]"
    ends: "typing.Optional[Timestamp]"
    status: "typing.Optional[LiveEventStatus]"
    current_participants: "typing.Optional[int]"
    total_participants: "typing.Optional[int]"
    relays: "typing.List[RelayUrl]"
    host: "typing.Optional[LiveEventHost]"
    speakers: "typing.List[Person]"
    participants: "typing.List[Person]"
    def __init__(self, *, id: "str", title: "typing.Optional[str]", summary: "typing.Optional[str]", image: "typing.Optional[Image]", hashtags: "typing.List[str]", streaming: "typing.Optional[str]", recording: "typing.Optional[str]", start: "typing.Optional[Timestamp]", ends: "typing.Optional[Timestamp]", status: "typing.Optional[LiveEventStatus]", current_participants: "typing.Optional[int]", total_participants: "typing.Optional[int]", relays: "typing.List[RelayUrl]", host: "typing.Optional[LiveEventHost]", speakers: "typing.List[Person]", participants: "typing.List[Person]"):
        self.id = id
        self.title = title
        self.summary = summary
        self.image = image
        self.hashtags = hashtags
        self.streaming = streaming
        self.recording = recording
        self.start = start
        self.ends = ends
        self.status = status
        self.current_participants = current_participants
        self.total_participants = total_participants
        self.relays = relays
        self.host = host
        self.speakers = speakers
        self.participants = participants

    def __str__(self):
        return "LiveEvent(id={}, title={}, summary={}, image={}, hashtags={}, streaming={}, recording={}, start={}, ends={}, status={}, current_participants={}, total_participants={}, relays={}, host={}, speakers={}, participants={})".format(self.id, self.title, self.summary, self.image, self.hashtags, self.streaming, self.recording, self.start, self.ends, self.status, self.current_participants, self.total_participants, self.relays, self.host, self.speakers, self.participants)

    def __eq__(self, other):
        if self.id != other.id:
            return False
        if self.title != other.title:
            return False
        if self.summary != other.summary:
            return False
        if self.image != other.image:
            return False
        if self.hashtags != other.hashtags:
            return False
        if self.streaming != other.streaming:
            return False
        if self.recording != other.recording:
            return False
        if self.start != other.start:
            return False
        if self.ends != other.ends:
            return False
        if self.status != other.status:
            return False
        if self.current_participants != other.current_participants:
            return False
        if self.total_participants != other.total_participants:
            return False
        if self.relays != other.relays:
            return False
        if self.host != other.host:
            return False
        if self.speakers != other.speakers:
            return False
        if self.participants != other.participants:
            return False
        return True

class _UniffiConverterTypeLiveEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return LiveEvent(
            id=_UniffiConverterString.read(buf),
            title=_UniffiConverterOptionalString.read(buf),
            summary=_UniffiConverterOptionalString.read(buf),
            image=_UniffiConverterOptionalTypeImage.read(buf),
            hashtags=_UniffiConverterSequenceString.read(buf),
            streaming=_UniffiConverterOptionalString.read(buf),
            recording=_UniffiConverterOptionalString.read(buf),
            start=_UniffiConverterOptionalTypeTimestamp.read(buf),
            ends=_UniffiConverterOptionalTypeTimestamp.read(buf),
            status=_UniffiConverterOptionalTypeLiveEventStatus.read(buf),
            current_participants=_UniffiConverterOptionalUInt64.read(buf),
            total_participants=_UniffiConverterOptionalUInt64.read(buf),
            relays=_UniffiConverterSequenceTypeRelayUrl.read(buf),
            host=_UniffiConverterOptionalTypeLiveEventHost.read(buf),
            speakers=_UniffiConverterSequenceTypePerson.read(buf),
            participants=_UniffiConverterSequenceTypePerson.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.id)
        _UniffiConverterOptionalString.check_lower(value.title)
        _UniffiConverterOptionalString.check_lower(value.summary)
        _UniffiConverterOptionalTypeImage.check_lower(value.image)
        _UniffiConverterSequenceString.check_lower(value.hashtags)
        _UniffiConverterOptionalString.check_lower(value.streaming)
        _UniffiConverterOptionalString.check_lower(value.recording)
        _UniffiConverterOptionalTypeTimestamp.check_lower(value.start)
        _UniffiConverterOptionalTypeTimestamp.check_lower(value.ends)
        _UniffiConverterOptionalTypeLiveEventStatus.check_lower(value.status)
        _UniffiConverterOptionalUInt64.check_lower(value.current_participants)
        _UniffiConverterOptionalUInt64.check_lower(value.total_participants)
        _UniffiConverterSequenceTypeRelayUrl.check_lower(value.relays)
        _UniffiConverterOptionalTypeLiveEventHost.check_lower(value.host)
        _UniffiConverterSequenceTypePerson.check_lower(value.speakers)
        _UniffiConverterSequenceTypePerson.check_lower(value.participants)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.id, buf)
        _UniffiConverterOptionalString.write(value.title, buf)
        _UniffiConverterOptionalString.write(value.summary, buf)
        _UniffiConverterOptionalTypeImage.write(value.image, buf)
        _UniffiConverterSequenceString.write(value.hashtags, buf)
        _UniffiConverterOptionalString.write(value.streaming, buf)
        _UniffiConverterOptionalString.write(value.recording, buf)
        _UniffiConverterOptionalTypeTimestamp.write(value.start, buf)
        _UniffiConverterOptionalTypeTimestamp.write(value.ends, buf)
        _UniffiConverterOptionalTypeLiveEventStatus.write(value.status, buf)
        _UniffiConverterOptionalUInt64.write(value.current_participants, buf)
        _UniffiConverterOptionalUInt64.write(value.total_participants, buf)
        _UniffiConverterSequenceTypeRelayUrl.write(value.relays, buf)
        _UniffiConverterOptionalTypeLiveEventHost.write(value.host, buf)
        _UniffiConverterSequenceTypePerson.write(value.speakers, buf)
        _UniffiConverterSequenceTypePerson.write(value.participants, buf)


class LiveEventHost:
    public_key: "PublicKey"
    relay_url: "typing.Optional[RelayUrl]"
    proof: "typing.Optional[str]"
    def __init__(self, *, public_key: "PublicKey", relay_url: "typing.Optional[RelayUrl]", proof: "typing.Optional[str]"):
        self.public_key = public_key
        self.relay_url = relay_url
        self.proof = proof

    def __str__(self):
        return "LiveEventHost(public_key={}, relay_url={}, proof={})".format(self.public_key, self.relay_url, self.proof)

    def __eq__(self, other):
        if self.public_key != other.public_key:
            return False
        if self.relay_url != other.relay_url:
            return False
        if self.proof != other.proof:
            return False
        return True

class _UniffiConverterTypeLiveEventHost(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return LiveEventHost(
            public_key=_UniffiConverterTypePublicKey.read(buf),
            relay_url=_UniffiConverterOptionalTypeRelayUrl.read(buf),
            proof=_UniffiConverterOptionalString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypePublicKey.check_lower(value.public_key)
        _UniffiConverterOptionalTypeRelayUrl.check_lower(value.relay_url)
        _UniffiConverterOptionalString.check_lower(value.proof)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypePublicKey.write(value.public_key, buf)
        _UniffiConverterOptionalTypeRelayUrl.write(value.relay_url, buf)
        _UniffiConverterOptionalString.write(value.proof, buf)


class LookupInvoiceRequest:
    """
    Lookup Invoice Request
    """

    payment_hash: "typing.Optional[str]"
    """
    Payment hash of invoice
    """

    invoice: "typing.Optional[str]"
    """
    Bolt11 invoice
    """

    def __init__(self, *, payment_hash: "typing.Optional[str]", invoice: "typing.Optional[str]"):
        self.payment_hash = payment_hash
        self.invoice = invoice

    def __str__(self):
        return "LookupInvoiceRequest(payment_hash={}, invoice={})".format(self.payment_hash, self.invoice)

    def __eq__(self, other):
        if self.payment_hash != other.payment_hash:
            return False
        if self.invoice != other.invoice:
            return False
        return True

class _UniffiConverterTypeLookupInvoiceRequest(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return LookupInvoiceRequest(
            payment_hash=_UniffiConverterOptionalString.read(buf),
            invoice=_UniffiConverterOptionalString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterOptionalString.check_lower(value.payment_hash)
        _UniffiConverterOptionalString.check_lower(value.invoice)

    @staticmethod
    def write(value, buf):
        _UniffiConverterOptionalString.write(value.payment_hash, buf)
        _UniffiConverterOptionalString.write(value.invoice, buf)


class LookupInvoiceResponse:
    """
    NIP47 Response Result
    """

    transaction_type: "typing.Optional[TransactionType]"
    """
    Transaction type
    """

    state: "typing.Optional[TransactionState]"
    """
    Transaction state.
    """

    invoice: "typing.Optional[str]"
    """
    Bolt11 invoice
    """

    description: "typing.Optional[str]"
    """
    Invoice's description
    """

    description_hash: "typing.Optional[str]"
    """
    Invoice's description hash
    """

    preimage: "typing.Optional[str]"
    """
    Payment preimage
    """

    payment_hash: "str"
    """
    Payment hash
    """

    amount: "int"
    """
    Amount in millisatoshis
    """

    fees_paid: "int"
    """
    Fees paid in millisatoshis
    """

    created_at: "Timestamp"
    """
    Creation timestamp in seconds since epoch
    """

    expires_at: "typing.Optional[Timestamp]"
    """
    Expiration timestamp in seconds since epoch
    """

    settled_at: "typing.Optional[Timestamp]"
    """
    Settled timestamp in seconds since epoch
    """

    metadata: "typing.Optional[JsonValue]"
    """
    Optional metadata about the payment
    """

    def __init__(self, *, transaction_type: "typing.Optional[TransactionType]", state: "typing.Optional[TransactionState]", invoice: "typing.Optional[str]", description: "typing.Optional[str]", description_hash: "typing.Optional[str]", preimage: "typing.Optional[str]", payment_hash: "str", amount: "int", fees_paid: "int", created_at: "Timestamp", expires_at: "typing.Optional[Timestamp]", settled_at: "typing.Optional[Timestamp]", metadata: "typing.Optional[JsonValue]"):
        self.transaction_type = transaction_type
        self.state = state
        self.invoice = invoice
        self.description = description
        self.description_hash = description_hash
        self.preimage = preimage
        self.payment_hash = payment_hash
        self.amount = amount
        self.fees_paid = fees_paid
        self.created_at = created_at
        self.expires_at = expires_at
        self.settled_at = settled_at
        self.metadata = metadata

    def __str__(self):
        return "LookupInvoiceResponse(transaction_type={}, state={}, invoice={}, description={}, description_hash={}, preimage={}, payment_hash={}, amount={}, fees_paid={}, created_at={}, expires_at={}, settled_at={}, metadata={})".format(self.transaction_type, self.state, self.invoice, self.description, self.description_hash, self.preimage, self.payment_hash, self.amount, self.fees_paid, self.created_at, self.expires_at, self.settled_at, self.metadata)

    def __eq__(self, other):
        if self.transaction_type != other.transaction_type:
            return False
        if self.state != other.state:
            return False
        if self.invoice != other.invoice:
            return False
        if self.description != other.description:
            return False
        if self.description_hash != other.description_hash:
            return False
        if self.preimage != other.preimage:
            return False
        if self.payment_hash != other.payment_hash:
            return False
        if self.amount != other.amount:
            return False
        if self.fees_paid != other.fees_paid:
            return False
        if self.created_at != other.created_at:
            return False
        if self.expires_at != other.expires_at:
            return False
        if self.settled_at != other.settled_at:
            return False
        if self.metadata != other.metadata:
            return False
        return True

class _UniffiConverterTypeLookupInvoiceResponse(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return LookupInvoiceResponse(
            transaction_type=_UniffiConverterOptionalTypeTransactionType.read(buf),
            state=_UniffiConverterOptionalTypeTransactionState.read(buf),
            invoice=_UniffiConverterOptionalString.read(buf),
            description=_UniffiConverterOptionalString.read(buf),
            description_hash=_UniffiConverterOptionalString.read(buf),
            preimage=_UniffiConverterOptionalString.read(buf),
            payment_hash=_UniffiConverterString.read(buf),
            amount=_UniffiConverterUInt64.read(buf),
            fees_paid=_UniffiConverterUInt64.read(buf),
            created_at=_UniffiConverterTypeTimestamp.read(buf),
            expires_at=_UniffiConverterOptionalTypeTimestamp.read(buf),
            settled_at=_UniffiConverterOptionalTypeTimestamp.read(buf),
            metadata=_UniffiConverterOptionalTypeJsonValue.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterOptionalTypeTransactionType.check_lower(value.transaction_type)
        _UniffiConverterOptionalTypeTransactionState.check_lower(value.state)
        _UniffiConverterOptionalString.check_lower(value.invoice)
        _UniffiConverterOptionalString.check_lower(value.description)
        _UniffiConverterOptionalString.check_lower(value.description_hash)
        _UniffiConverterOptionalString.check_lower(value.preimage)
        _UniffiConverterString.check_lower(value.payment_hash)
        _UniffiConverterUInt64.check_lower(value.amount)
        _UniffiConverterUInt64.check_lower(value.fees_paid)
        _UniffiConverterTypeTimestamp.check_lower(value.created_at)
        _UniffiConverterOptionalTypeTimestamp.check_lower(value.expires_at)
        _UniffiConverterOptionalTypeTimestamp.check_lower(value.settled_at)
        _UniffiConverterOptionalTypeJsonValue.check_lower(value.metadata)

    @staticmethod
    def write(value, buf):
        _UniffiConverterOptionalTypeTransactionType.write(value.transaction_type, buf)
        _UniffiConverterOptionalTypeTransactionState.write(value.state, buf)
        _UniffiConverterOptionalString.write(value.invoice, buf)
        _UniffiConverterOptionalString.write(value.description, buf)
        _UniffiConverterOptionalString.write(value.description_hash, buf)
        _UniffiConverterOptionalString.write(value.preimage, buf)
        _UniffiConverterString.write(value.payment_hash, buf)
        _UniffiConverterUInt64.write(value.amount, buf)
        _UniffiConverterUInt64.write(value.fees_paid, buf)
        _UniffiConverterTypeTimestamp.write(value.created_at, buf)
        _UniffiConverterOptionalTypeTimestamp.write(value.expires_at, buf)
        _UniffiConverterOptionalTypeTimestamp.write(value.settled_at, buf)
        _UniffiConverterOptionalTypeJsonValue.write(value.metadata, buf)


class MakeHoldInvoiceRequest:
    """
    Make Hold Invoice Request
    """

    amount: "int"
    """
    Amount in millisatoshis
    """

    description: "typing.Optional[str]"
    """
    Invoice description
    """

    description_hash: "typing.Optional[str]"
    """
    Invoice description hash
    """

    expiry: "typing.Optional[int]"
    """
    Invoice expiry in seconds
    """

    payment_hash: "str"
    """
    payment_hash
    """

    cltv_expiry_delta: "typing.Optional[int]"
    """
    The minimum CLTV delta to use for the final hop
    """

    def __init__(self, *, amount: "int", description: "typing.Optional[str]", description_hash: "typing.Optional[str]", expiry: "typing.Optional[int]", payment_hash: "str", cltv_expiry_delta: "typing.Optional[int]"):
        self.amount = amount
        self.description = description
        self.description_hash = description_hash
        self.expiry = expiry
        self.payment_hash = payment_hash
        self.cltv_expiry_delta = cltv_expiry_delta

    def __str__(self):
        return "MakeHoldInvoiceRequest(amount={}, description={}, description_hash={}, expiry={}, payment_hash={}, cltv_expiry_delta={})".format(self.amount, self.description, self.description_hash, self.expiry, self.payment_hash, self.cltv_expiry_delta)

    def __eq__(self, other):
        if self.amount != other.amount:
            return False
        if self.description != other.description:
            return False
        if self.description_hash != other.description_hash:
            return False
        if self.expiry != other.expiry:
            return False
        if self.payment_hash != other.payment_hash:
            return False
        if self.cltv_expiry_delta != other.cltv_expiry_delta:
            return False
        return True

class _UniffiConverterTypeMakeHoldInvoiceRequest(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return MakeHoldInvoiceRequest(
            amount=_UniffiConverterUInt64.read(buf),
            description=_UniffiConverterOptionalString.read(buf),
            description_hash=_UniffiConverterOptionalString.read(buf),
            expiry=_UniffiConverterOptionalUInt64.read(buf),
            payment_hash=_UniffiConverterString.read(buf),
            cltv_expiry_delta=_UniffiConverterOptionalUInt32.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterUInt64.check_lower(value.amount)
        _UniffiConverterOptionalString.check_lower(value.description)
        _UniffiConverterOptionalString.check_lower(value.description_hash)
        _UniffiConverterOptionalUInt64.check_lower(value.expiry)
        _UniffiConverterString.check_lower(value.payment_hash)
        _UniffiConverterOptionalUInt32.check_lower(value.cltv_expiry_delta)

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt64.write(value.amount, buf)
        _UniffiConverterOptionalString.write(value.description, buf)
        _UniffiConverterOptionalString.write(value.description_hash, buf)
        _UniffiConverterOptionalUInt64.write(value.expiry, buf)
        _UniffiConverterString.write(value.payment_hash, buf)
        _UniffiConverterOptionalUInt32.write(value.cltv_expiry_delta, buf)


class MakeHoldInvoiceResponse:
    """
    Make Hold Invoice Response
    """

    transaction_type: "TransactionType"
    """
    Transaction type
    """

    invoice: "typing.Optional[str]"
    """
    Bolt11 invoice
    """

    description: "typing.Optional[str]"
    """
    Description
    """

    description_hash: "typing.Optional[str]"
    """
    Description hash
    """

    payment_hash: "str"
    """
    Payment hash
    """

    amount: "int"
    """
    Amount in millisatoshis
    """

    created_at: "Timestamp"
    """
    Creation timestamp
    """

    expires_at: "Timestamp"
    """
    Expiration timestamp
    """

    metadata: "typing.Optional[JsonValue]"
    """
    Metadata
    """

    def __init__(self, *, transaction_type: "TransactionType", invoice: "typing.Optional[str]", description: "typing.Optional[str]", description_hash: "typing.Optional[str]", payment_hash: "str", amount: "int", created_at: "Timestamp", expires_at: "Timestamp", metadata: "typing.Optional[JsonValue]"):
        self.transaction_type = transaction_type
        self.invoice = invoice
        self.description = description
        self.description_hash = description_hash
        self.payment_hash = payment_hash
        self.amount = amount
        self.created_at = created_at
        self.expires_at = expires_at
        self.metadata = metadata

    def __str__(self):
        return "MakeHoldInvoiceResponse(transaction_type={}, invoice={}, description={}, description_hash={}, payment_hash={}, amount={}, created_at={}, expires_at={}, metadata={})".format(self.transaction_type, self.invoice, self.description, self.description_hash, self.payment_hash, self.amount, self.created_at, self.expires_at, self.metadata)

    def __eq__(self, other):
        if self.transaction_type != other.transaction_type:
            return False
        if self.invoice != other.invoice:
            return False
        if self.description != other.description:
            return False
        if self.description_hash != other.description_hash:
            return False
        if self.payment_hash != other.payment_hash:
            return False
        if self.amount != other.amount:
            return False
        if self.created_at != other.created_at:
            return False
        if self.expires_at != other.expires_at:
            return False
        if self.metadata != other.metadata:
            return False
        return True

class _UniffiConverterTypeMakeHoldInvoiceResponse(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return MakeHoldInvoiceResponse(
            transaction_type=_UniffiConverterTypeTransactionType.read(buf),
            invoice=_UniffiConverterOptionalString.read(buf),
            description=_UniffiConverterOptionalString.read(buf),
            description_hash=_UniffiConverterOptionalString.read(buf),
            payment_hash=_UniffiConverterString.read(buf),
            amount=_UniffiConverterUInt64.read(buf),
            created_at=_UniffiConverterTypeTimestamp.read(buf),
            expires_at=_UniffiConverterTypeTimestamp.read(buf),
            metadata=_UniffiConverterOptionalTypeJsonValue.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypeTransactionType.check_lower(value.transaction_type)
        _UniffiConverterOptionalString.check_lower(value.invoice)
        _UniffiConverterOptionalString.check_lower(value.description)
        _UniffiConverterOptionalString.check_lower(value.description_hash)
        _UniffiConverterString.check_lower(value.payment_hash)
        _UniffiConverterUInt64.check_lower(value.amount)
        _UniffiConverterTypeTimestamp.check_lower(value.created_at)
        _UniffiConverterTypeTimestamp.check_lower(value.expires_at)
        _UniffiConverterOptionalTypeJsonValue.check_lower(value.metadata)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeTransactionType.write(value.transaction_type, buf)
        _UniffiConverterOptionalString.write(value.invoice, buf)
        _UniffiConverterOptionalString.write(value.description, buf)
        _UniffiConverterOptionalString.write(value.description_hash, buf)
        _UniffiConverterString.write(value.payment_hash, buf)
        _UniffiConverterUInt64.write(value.amount, buf)
        _UniffiConverterTypeTimestamp.write(value.created_at, buf)
        _UniffiConverterTypeTimestamp.write(value.expires_at, buf)
        _UniffiConverterOptionalTypeJsonValue.write(value.metadata, buf)


class MakeInvoiceRequest:
    """
    Make Invoice Request
    """

    amount: "int"
    """
    Amount in millisatoshis
    """

    description: "typing.Optional[str]"
    """
    Invoice description
    """

    description_hash: "typing.Optional[str]"
    """
    Invoice description hash
    """

    expiry: "typing.Optional[int]"
    """
    Invoice expiry in seconds
    """

    def __init__(self, *, amount: "int", description: "typing.Optional[str]", description_hash: "typing.Optional[str]", expiry: "typing.Optional[int]"):
        self.amount = amount
        self.description = description
        self.description_hash = description_hash
        self.expiry = expiry

    def __str__(self):
        return "MakeInvoiceRequest(amount={}, description={}, description_hash={}, expiry={})".format(self.amount, self.description, self.description_hash, self.expiry)

    def __eq__(self, other):
        if self.amount != other.amount:
            return False
        if self.description != other.description:
            return False
        if self.description_hash != other.description_hash:
            return False
        if self.expiry != other.expiry:
            return False
        return True

class _UniffiConverterTypeMakeInvoiceRequest(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return MakeInvoiceRequest(
            amount=_UniffiConverterUInt64.read(buf),
            description=_UniffiConverterOptionalString.read(buf),
            description_hash=_UniffiConverterOptionalString.read(buf),
            expiry=_UniffiConverterOptionalUInt64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterUInt64.check_lower(value.amount)
        _UniffiConverterOptionalString.check_lower(value.description)
        _UniffiConverterOptionalString.check_lower(value.description_hash)
        _UniffiConverterOptionalUInt64.check_lower(value.expiry)

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt64.write(value.amount, buf)
        _UniffiConverterOptionalString.write(value.description, buf)
        _UniffiConverterOptionalString.write(value.description_hash, buf)
        _UniffiConverterOptionalUInt64.write(value.expiry, buf)


class MakeInvoiceResponse:
    """
    NIP47 Response Result
    """

    invoice: "str"
    """
    Bolt 11 invoice
    """

    payment_hash: "typing.Optional[str]"
    """
    Invoice's payment hash
    """

    description: "typing.Optional[str]"
    """
    Invoice's description
    """

    description_hash: "typing.Optional[str]"
    """
    Invoice's description hash
    """

    preimage: "typing.Optional[str]"
    """
    Payment preimage
    """

    amount: "typing.Optional[int]"
    """
    Amount in msats.
    """

    created_at: "typing.Optional[Timestamp]"
    """
    Creation timestamp in seconds since epoch
    """

    expires_at: "typing.Optional[Timestamp]"
    """
    Expiration timestamp in seconds since epoch
    """

    def __init__(self, *, invoice: "str", payment_hash: "typing.Optional[str]", description: "typing.Optional[str]", description_hash: "typing.Optional[str]", preimage: "typing.Optional[str]", amount: "typing.Optional[int]", created_at: "typing.Optional[Timestamp]", expires_at: "typing.Optional[Timestamp]"):
        self.invoice = invoice
        self.payment_hash = payment_hash
        self.description = description
        self.description_hash = description_hash
        self.preimage = preimage
        self.amount = amount
        self.created_at = created_at
        self.expires_at = expires_at

    def __str__(self):
        return "MakeInvoiceResponse(invoice={}, payment_hash={}, description={}, description_hash={}, preimage={}, amount={}, created_at={}, expires_at={})".format(self.invoice, self.payment_hash, self.description, self.description_hash, self.preimage, self.amount, self.created_at, self.expires_at)

    def __eq__(self, other):
        if self.invoice != other.invoice:
            return False
        if self.payment_hash != other.payment_hash:
            return False
        if self.description != other.description:
            return False
        if self.description_hash != other.description_hash:
            return False
        if self.preimage != other.preimage:
            return False
        if self.amount != other.amount:
            return False
        if self.created_at != other.created_at:
            return False
        if self.expires_at != other.expires_at:
            return False
        return True

class _UniffiConverterTypeMakeInvoiceResponse(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return MakeInvoiceResponse(
            invoice=_UniffiConverterString.read(buf),
            payment_hash=_UniffiConverterOptionalString.read(buf),
            description=_UniffiConverterOptionalString.read(buf),
            description_hash=_UniffiConverterOptionalString.read(buf),
            preimage=_UniffiConverterOptionalString.read(buf),
            amount=_UniffiConverterOptionalUInt64.read(buf),
            created_at=_UniffiConverterOptionalTypeTimestamp.read(buf),
            expires_at=_UniffiConverterOptionalTypeTimestamp.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.invoice)
        _UniffiConverterOptionalString.check_lower(value.payment_hash)
        _UniffiConverterOptionalString.check_lower(value.description)
        _UniffiConverterOptionalString.check_lower(value.description_hash)
        _UniffiConverterOptionalString.check_lower(value.preimage)
        _UniffiConverterOptionalUInt64.check_lower(value.amount)
        _UniffiConverterOptionalTypeTimestamp.check_lower(value.created_at)
        _UniffiConverterOptionalTypeTimestamp.check_lower(value.expires_at)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.invoice, buf)
        _UniffiConverterOptionalString.write(value.payment_hash, buf)
        _UniffiConverterOptionalString.write(value.description, buf)
        _UniffiConverterOptionalString.write(value.description_hash, buf)
        _UniffiConverterOptionalString.write(value.preimage, buf)
        _UniffiConverterOptionalUInt64.write(value.amount, buf)
        _UniffiConverterOptionalTypeTimestamp.write(value.created_at, buf)
        _UniffiConverterOptionalTypeTimestamp.write(value.expires_at, buf)


class MetadataRecord:
    name: "typing.Optional[str]"
    """
    Name
    """

    display_name: "typing.Optional[str]"
    """
    Display name
    """

    about: "typing.Optional[str]"
    """
    Description
    """

    website: "typing.Optional[str]"
    """
    Website url
    """

    picture: "typing.Optional[str]"
    """
    Picture url
    """

    banner: "typing.Optional[str]"
    """
    Banner url
    """

    nip05: "typing.Optional[str]"
    """
    NIP05 (ex. name@example.com)
    """

    lud06: "typing.Optional[str]"
    """
    LNURL
    """

    lud16: "typing.Optional[str]"
    """
    Lightning Address
    """

    custom: "typing.Optional[dict[str, JsonValue]]"
    """
    Additional custom metadata
    """

    def __init__(self, *, name: "typing.Optional[str]" = _DEFAULT, display_name: "typing.Optional[str]" = _DEFAULT, about: "typing.Optional[str]" = _DEFAULT, website: "typing.Optional[str]" = _DEFAULT, picture: "typing.Optional[str]" = _DEFAULT, banner: "typing.Optional[str]" = _DEFAULT, nip05: "typing.Optional[str]" = _DEFAULT, lud06: "typing.Optional[str]" = _DEFAULT, lud16: "typing.Optional[str]" = _DEFAULT, custom: "typing.Optional[dict[str, JsonValue]]" = _DEFAULT):
        if name is _DEFAULT:
            self.name = None
        else:
            self.name = name
        if display_name is _DEFAULT:
            self.display_name = None
        else:
            self.display_name = display_name
        if about is _DEFAULT:
            self.about = None
        else:
            self.about = about
        if website is _DEFAULT:
            self.website = None
        else:
            self.website = website
        if picture is _DEFAULT:
            self.picture = None
        else:
            self.picture = picture
        if banner is _DEFAULT:
            self.banner = None
        else:
            self.banner = banner
        if nip05 is _DEFAULT:
            self.nip05 = None
        else:
            self.nip05 = nip05
        if lud06 is _DEFAULT:
            self.lud06 = None
        else:
            self.lud06 = lud06
        if lud16 is _DEFAULT:
            self.lud16 = None
        else:
            self.lud16 = lud16
        if custom is _DEFAULT:
            self.custom = None
        else:
            self.custom = custom

    def __str__(self):
        return "MetadataRecord(name={}, display_name={}, about={}, website={}, picture={}, banner={}, nip05={}, lud06={}, lud16={}, custom={})".format(self.name, self.display_name, self.about, self.website, self.picture, self.banner, self.nip05, self.lud06, self.lud16, self.custom)

    def __eq__(self, other):
        if self.name != other.name:
            return False
        if self.display_name != other.display_name:
            return False
        if self.about != other.about:
            return False
        if self.website != other.website:
            return False
        if self.picture != other.picture:
            return False
        if self.banner != other.banner:
            return False
        if self.nip05 != other.nip05:
            return False
        if self.lud06 != other.lud06:
            return False
        if self.lud16 != other.lud16:
            return False
        if self.custom != other.custom:
            return False
        return True

class _UniffiConverterTypeMetadataRecord(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return MetadataRecord(
            name=_UniffiConverterOptionalString.read(buf),
            display_name=_UniffiConverterOptionalString.read(buf),
            about=_UniffiConverterOptionalString.read(buf),
            website=_UniffiConverterOptionalString.read(buf),
            picture=_UniffiConverterOptionalString.read(buf),
            banner=_UniffiConverterOptionalString.read(buf),
            nip05=_UniffiConverterOptionalString.read(buf),
            lud06=_UniffiConverterOptionalString.read(buf),
            lud16=_UniffiConverterOptionalString.read(buf),
            custom=_UniffiConverterOptionalMapStringTypeJsonValue.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterOptionalString.check_lower(value.name)
        _UniffiConverterOptionalString.check_lower(value.display_name)
        _UniffiConverterOptionalString.check_lower(value.about)
        _UniffiConverterOptionalString.check_lower(value.website)
        _UniffiConverterOptionalString.check_lower(value.picture)
        _UniffiConverterOptionalString.check_lower(value.banner)
        _UniffiConverterOptionalString.check_lower(value.nip05)
        _UniffiConverterOptionalString.check_lower(value.lud06)
        _UniffiConverterOptionalString.check_lower(value.lud16)
        _UniffiConverterOptionalMapStringTypeJsonValue.check_lower(value.custom)

    @staticmethod
    def write(value, buf):
        _UniffiConverterOptionalString.write(value.name, buf)
        _UniffiConverterOptionalString.write(value.display_name, buf)
        _UniffiConverterOptionalString.write(value.about, buf)
        _UniffiConverterOptionalString.write(value.website, buf)
        _UniffiConverterOptionalString.write(value.picture, buf)
        _UniffiConverterOptionalString.write(value.banner, buf)
        _UniffiConverterOptionalString.write(value.nip05, buf)
        _UniffiConverterOptionalString.write(value.lud06, buf)
        _UniffiConverterOptionalString.write(value.lud16, buf)
        _UniffiConverterOptionalMapStringTypeJsonValue.write(value.custom, buf)


class MultiPayInvoiceRequest:
    """
    Multi Pay Invoice Request Params
    """

    invoices: "typing.List[PayInvoiceRequest]"
    """
    Invoices to pay
    """

    def __init__(self, *, invoices: "typing.List[PayInvoiceRequest]"):
        self.invoices = invoices

    def __str__(self):
        return "MultiPayInvoiceRequest(invoices={})".format(self.invoices)

    def __eq__(self, other):
        if self.invoices != other.invoices:
            return False
        return True

class _UniffiConverterTypeMultiPayInvoiceRequest(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return MultiPayInvoiceRequest(
            invoices=_UniffiConverterSequenceTypePayInvoiceRequest.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterSequenceTypePayInvoiceRequest.check_lower(value.invoices)

    @staticmethod
    def write(value, buf):
        _UniffiConverterSequenceTypePayInvoiceRequest.write(value.invoices, buf)


class MultiPayKeysendRequest:
    """
    Multi Pay Keysend Request
    """

    keysends: "typing.List[PayKeysendRequest]"
    """
    Keysends
    """

    def __init__(self, *, keysends: "typing.List[PayKeysendRequest]"):
        self.keysends = keysends

    def __str__(self):
        return "MultiPayKeysendRequest(keysends={})".format(self.keysends)

    def __eq__(self, other):
        if self.keysends != other.keysends:
            return False
        return True

class _UniffiConverterTypeMultiPayKeysendRequest(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return MultiPayKeysendRequest(
            keysends=_UniffiConverterSequenceTypePayKeysendRequest.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterSequenceTypePayKeysendRequest.check_lower(value.keysends)

    @staticmethod
    def write(value, buf):
        _UniffiConverterSequenceTypePayKeysendRequest.write(value.keysends, buf)


class MuteList:
    """
    Things the user doesn't want to see in their feeds

    <https://github.com/nostr-protocol/nips/blob/master/51.md>
    """

    public_keys: "typing.List[PublicKey]"
    hashtags: "typing.List[str]"
    event_ids: "typing.List[EventId]"
    words: "typing.List[str]"
    def __init__(self, *, public_keys: "typing.List[PublicKey]" = _DEFAULT, hashtags: "typing.List[str]" = _DEFAULT, event_ids: "typing.List[EventId]" = _DEFAULT, words: "typing.List[str]" = _DEFAULT):
        if public_keys is _DEFAULT:
            self.public_keys = []
        else:
            self.public_keys = public_keys
        if hashtags is _DEFAULT:
            self.hashtags = []
        else:
            self.hashtags = hashtags
        if event_ids is _DEFAULT:
            self.event_ids = []
        else:
            self.event_ids = event_ids
        if words is _DEFAULT:
            self.words = []
        else:
            self.words = words

    def __str__(self):
        return "MuteList(public_keys={}, hashtags={}, event_ids={}, words={})".format(self.public_keys, self.hashtags, self.event_ids, self.words)

    def __eq__(self, other):
        if self.public_keys != other.public_keys:
            return False
        if self.hashtags != other.hashtags:
            return False
        if self.event_ids != other.event_ids:
            return False
        if self.words != other.words:
            return False
        return True

class _UniffiConverterTypeMuteList(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return MuteList(
            public_keys=_UniffiConverterSequenceTypePublicKey.read(buf),
            hashtags=_UniffiConverterSequenceString.read(buf),
            event_ids=_UniffiConverterSequenceTypeEventId.read(buf),
            words=_UniffiConverterSequenceString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterSequenceTypePublicKey.check_lower(value.public_keys)
        _UniffiConverterSequenceString.check_lower(value.hashtags)
        _UniffiConverterSequenceTypeEventId.check_lower(value.event_ids)
        _UniffiConverterSequenceString.check_lower(value.words)

    @staticmethod
    def write(value, buf):
        _UniffiConverterSequenceTypePublicKey.write(value.public_keys, buf)
        _UniffiConverterSequenceString.write(value.hashtags, buf)
        _UniffiConverterSequenceTypeEventId.write(value.event_ids, buf)
        _UniffiConverterSequenceString.write(value.words, buf)


class NegentropyItem:
    id: "EventId"
    timestamp: "Timestamp"
    def __init__(self, *, id: "EventId", timestamp: "Timestamp"):
        self.id = id
        self.timestamp = timestamp

    def __str__(self):
        return "NegentropyItem(id={}, timestamp={})".format(self.id, self.timestamp)

    def __eq__(self, other):
        if self.id != other.id:
            return False
        if self.timestamp != other.timestamp:
            return False
        return True

class _UniffiConverterTypeNegentropyItem(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return NegentropyItem(
            id=_UniffiConverterTypeEventId.read(buf),
            timestamp=_UniffiConverterTypeTimestamp.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypeEventId.check_lower(value.id)
        _UniffiConverterTypeTimestamp.check_lower(value.timestamp)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeEventId.write(value.id, buf)
        _UniffiConverterTypeTimestamp.write(value.timestamp, buf)


class Nip47Error:
    """
    NIP47 Error message
    """

    code: "ErrorCode"
    """
    Error Code
    """

    message: "str"
    """
    Human Readable error message
    """

    def __init__(self, *, code: "ErrorCode", message: "str"):
        self.code = code
        self.message = message

    def __str__(self):
        return "Nip47Error(code={}, message={})".format(self.code, self.message)

    def __eq__(self, other):
        if self.code != other.code:
            return False
        if self.message != other.message:
            return False
        return True

class _UniffiConverterTypeNip47Error(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return Nip47Error(
            code=_UniffiConverterTypeErrorCode.read(buf),
            message=_UniffiConverterString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypeErrorCode.check_lower(value.code)
        _UniffiConverterString.check_lower(value.message)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeErrorCode.write(value.code, buf)
        _UniffiConverterString.write(value.message, buf)


class NostrParserOptions:
    """
    Nostr parser options
    """

    nostr_uris: "bool"
    """
    Parse nostr URIs
    """

    urls: "bool"
    """
    Parse URLs
    """

    hashtags: "bool"
    """
    Parse hashtags
    """

    text: "bool"
    """
    Parse text, line breaks and whitespaces
    """

    def __init__(self, *, nostr_uris: "bool" = _DEFAULT, urls: "bool" = _DEFAULT, hashtags: "bool" = _DEFAULT, text: "bool" = _DEFAULT):
        if nostr_uris is _DEFAULT:
            self.nostr_uris = True
        else:
            self.nostr_uris = nostr_uris
        if urls is _DEFAULT:
            self.urls = True
        else:
            self.urls = urls
        if hashtags is _DEFAULT:
            self.hashtags = True
        else:
            self.hashtags = hashtags
        if text is _DEFAULT:
            self.text = True
        else:
            self.text = text

    def __str__(self):
        return "NostrParserOptions(nostr_uris={}, urls={}, hashtags={}, text={})".format(self.nostr_uris, self.urls, self.hashtags, self.text)

    def __eq__(self, other):
        if self.nostr_uris != other.nostr_uris:
            return False
        if self.urls != other.urls:
            return False
        if self.hashtags != other.hashtags:
            return False
        if self.text != other.text:
            return False
        return True

class _UniffiConverterTypeNostrParserOptions(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return NostrParserOptions(
            nostr_uris=_UniffiConverterBool.read(buf),
            urls=_UniffiConverterBool.read(buf),
            hashtags=_UniffiConverterBool.read(buf),
            text=_UniffiConverterBool.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterBool.check_lower(value.nostr_uris)
        _UniffiConverterBool.check_lower(value.urls)
        _UniffiConverterBool.check_lower(value.hashtags)
        _UniffiConverterBool.check_lower(value.text)

    @staticmethod
    def write(value, buf):
        _UniffiConverterBool.write(value.nostr_uris, buf)
        _UniffiConverterBool.write(value.urls, buf)
        _UniffiConverterBool.write(value.hashtags, buf)
        _UniffiConverterBool.write(value.text, buf)


class Output:
    """
    Output

    Send or negentropy reconciliation output
    """

    success: "typing.List[RelayUrl]"
    """
    Set of relays that success
    """

    failed: "dict[RelayUrl, str]"
    """
    Map of relays that failed, with related errors.
    """

    def __init__(self, *, success: "typing.List[RelayUrl]", failed: "dict[RelayUrl, str]"):
        self.success = success
        self.failed = failed

    def __str__(self):
        return "Output(success={}, failed={})".format(self.success, self.failed)

    def __eq__(self, other):
        if self.success != other.success:
            return False
        if self.failed != other.failed:
            return False
        return True

class _UniffiConverterTypeOutput(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return Output(
            success=_UniffiConverterSequenceTypeRelayUrl.read(buf),
            failed=_UniffiConverterMapTypeRelayUrlString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterSequenceTypeRelayUrl.check_lower(value.success)
        _UniffiConverterMapTypeRelayUrlString.check_lower(value.failed)

    @staticmethod
    def write(value, buf):
        _UniffiConverterSequenceTypeRelayUrl.write(value.success, buf)
        _UniffiConverterMapTypeRelayUrlString.write(value.failed, buf)


class PayInvoiceRequest:
    """
    Pay Invoice Request
    """

    id: "typing.Optional[str]"
    """
    Optional id
    """

    invoice: "str"
    """
    Request invoice
    """

    amount: "typing.Optional[int]"
    """
    Optional amount in millisatoshis
    """

    def __init__(self, *, id: "typing.Optional[str]", invoice: "str", amount: "typing.Optional[int]"):
        self.id = id
        self.invoice = invoice
        self.amount = amount

    def __str__(self):
        return "PayInvoiceRequest(id={}, invoice={}, amount={})".format(self.id, self.invoice, self.amount)

    def __eq__(self, other):
        if self.id != other.id:
            return False
        if self.invoice != other.invoice:
            return False
        if self.amount != other.amount:
            return False
        return True

class _UniffiConverterTypePayInvoiceRequest(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return PayInvoiceRequest(
            id=_UniffiConverterOptionalString.read(buf),
            invoice=_UniffiConverterString.read(buf),
            amount=_UniffiConverterOptionalUInt64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterOptionalString.check_lower(value.id)
        _UniffiConverterString.check_lower(value.invoice)
        _UniffiConverterOptionalUInt64.check_lower(value.amount)

    @staticmethod
    def write(value, buf):
        _UniffiConverterOptionalString.write(value.id, buf)
        _UniffiConverterString.write(value.invoice, buf)
        _UniffiConverterOptionalUInt64.write(value.amount, buf)


class PayInvoiceResponse:
    """
    NIP47 Response Result
    """

    preimage: "str"
    """
    Response preimage
    """

    fees_paid: "typing.Optional[int]"
    """
    Fees paid
    """

    def __init__(self, *, preimage: "str", fees_paid: "typing.Optional[int]"):
        self.preimage = preimage
        self.fees_paid = fees_paid

    def __str__(self):
        return "PayInvoiceResponse(preimage={}, fees_paid={})".format(self.preimage, self.fees_paid)

    def __eq__(self, other):
        if self.preimage != other.preimage:
            return False
        if self.fees_paid != other.fees_paid:
            return False
        return True

class _UniffiConverterTypePayInvoiceResponse(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return PayInvoiceResponse(
            preimage=_UniffiConverterString.read(buf),
            fees_paid=_UniffiConverterOptionalUInt64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.preimage)
        _UniffiConverterOptionalUInt64.check_lower(value.fees_paid)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.preimage, buf)
        _UniffiConverterOptionalUInt64.write(value.fees_paid, buf)


class PayKeysendRequest:
    """
    Pay Invoice Request
    """

    id: "typing.Optional[str]"
    """
    Optional id
    """

    amount: "int"
    """
    Amount in millisatoshis
    """

    pubkey: "str"
    """
    Receiver's node id
    """

    preimage: "typing.Optional[str]"
    """
    Optional preimage
    """

    tlv_records: "typing.List[KeysendTlvRecord]"
    """
    Optional TLVs to be added to the keysend payment
    """

    def __init__(self, *, id: "typing.Optional[str]", amount: "int", pubkey: "str", preimage: "typing.Optional[str]", tlv_records: "typing.List[KeysendTlvRecord]"):
        self.id = id
        self.amount = amount
        self.pubkey = pubkey
        self.preimage = preimage
        self.tlv_records = tlv_records

    def __str__(self):
        return "PayKeysendRequest(id={}, amount={}, pubkey={}, preimage={}, tlv_records={})".format(self.id, self.amount, self.pubkey, self.preimage, self.tlv_records)

    def __eq__(self, other):
        if self.id != other.id:
            return False
        if self.amount != other.amount:
            return False
        if self.pubkey != other.pubkey:
            return False
        if self.preimage != other.preimage:
            return False
        if self.tlv_records != other.tlv_records:
            return False
        return True

class _UniffiConverterTypePayKeysendRequest(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return PayKeysendRequest(
            id=_UniffiConverterOptionalString.read(buf),
            amount=_UniffiConverterUInt64.read(buf),
            pubkey=_UniffiConverterString.read(buf),
            preimage=_UniffiConverterOptionalString.read(buf),
            tlv_records=_UniffiConverterSequenceTypeKeysendTlvRecord.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterOptionalString.check_lower(value.id)
        _UniffiConverterUInt64.check_lower(value.amount)
        _UniffiConverterString.check_lower(value.pubkey)
        _UniffiConverterOptionalString.check_lower(value.preimage)
        _UniffiConverterSequenceTypeKeysendTlvRecord.check_lower(value.tlv_records)

    @staticmethod
    def write(value, buf):
        _UniffiConverterOptionalString.write(value.id, buf)
        _UniffiConverterUInt64.write(value.amount, buf)
        _UniffiConverterString.write(value.pubkey, buf)
        _UniffiConverterOptionalString.write(value.preimage, buf)
        _UniffiConverterSequenceTypeKeysendTlvRecord.write(value.tlv_records, buf)


class PayKeysendResponse:
    """
    NIP47 Response Result
    """

    preimage: "str"
    """
    Response preimage
    """

    fees_paid: "typing.Optional[int]"
    """
    Fees paid
    """

    def __init__(self, *, preimage: "str", fees_paid: "typing.Optional[int]"):
        self.preimage = preimage
        self.fees_paid = fees_paid

    def __str__(self):
        return "PayKeysendResponse(preimage={}, fees_paid={})".format(self.preimage, self.fees_paid)

    def __eq__(self, other):
        if self.preimage != other.preimage:
            return False
        if self.fees_paid != other.fees_paid:
            return False
        return True

class _UniffiConverterTypePayKeysendResponse(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return PayKeysendResponse(
            preimage=_UniffiConverterString.read(buf),
            fees_paid=_UniffiConverterOptionalUInt64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.preimage)
        _UniffiConverterOptionalUInt64.check_lower(value.fees_paid)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.preimage, buf)
        _UniffiConverterOptionalUInt64.write(value.fees_paid, buf)


class Person:
    public_key: "PublicKey"
    relay_url: "typing.Optional[RelayUrl]"
    def __init__(self, *, public_key: "PublicKey", relay_url: "typing.Optional[RelayUrl]"):
        self.public_key = public_key
        self.relay_url = relay_url

    def __str__(self):
        return "Person(public_key={}, relay_url={})".format(self.public_key, self.relay_url)

    def __eq__(self, other):
        if self.public_key != other.public_key:
            return False
        if self.relay_url != other.relay_url:
            return False
        return True

class _UniffiConverterTypePerson(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return Person(
            public_key=_UniffiConverterTypePublicKey.read(buf),
            relay_url=_UniffiConverterOptionalTypeRelayUrl.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypePublicKey.check_lower(value.public_key)
        _UniffiConverterOptionalTypeRelayUrl.check_lower(value.relay_url)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypePublicKey.write(value.public_key, buf)
        _UniffiConverterOptionalTypeRelayUrl.write(value.relay_url, buf)


class PollOption:
    id: "str"
    """
    Option ID
    """

    text: "str"
    """
    Option label
    """

    def __init__(self, *, id: "str", text: "str"):
        self.id = id
        self.text = text

    def __str__(self):
        return "PollOption(id={}, text={})".format(self.id, self.text)

    def __eq__(self, other):
        if self.id != other.id:
            return False
        if self.text != other.text:
            return False
        return True

class _UniffiConverterTypePollOption(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return PollOption(
            id=_UniffiConverterString.read(buf),
            text=_UniffiConverterString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.id)
        _UniffiConverterString.check_lower(value.text)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.id, buf)
        _UniffiConverterString.write(value.text, buf)


class ProductData:
    """
    Payload for creating or updating product
    """

    id: "str"
    """
    UUID of the product generated by merchant
    """

    stall_id: "str"
    """
    Id of the stall that this product belongs to
    """

    name: "str"
    """
    Product name
    """

    description: "typing.Optional[str]"
    """
    Description of the product
    """

    images: "typing.Optional[typing.List[str]]"
    """
    Image urls of the product
    """

    currency: "str"
    """
    Currency used
    """

    price: "float"
    """
    Price of the product
    """

    quantity: "int"
    """
    Available items
    """

    specs: "typing.Optional[typing.List[typing.List[str]]]"
    """
    Specifications of the product
    """

    shipping: "typing.List[ShippingCost]"
    """
    Shipping method costs
    """

    categories: "typing.Optional[typing.List[str]]"
    """
    Categories of the product (will be added to tags)
    """

    def __init__(self, *, id: "str", stall_id: "str", name: "str", description: "typing.Optional[str]", images: "typing.Optional[typing.List[str]]", currency: "str", price: "float", quantity: "int", specs: "typing.Optional[typing.List[typing.List[str]]]", shipping: "typing.List[ShippingCost]", categories: "typing.Optional[typing.List[str]]"):
        self.id = id
        self.stall_id = stall_id
        self.name = name
        self.description = description
        self.images = images
        self.currency = currency
        self.price = price
        self.quantity = quantity
        self.specs = specs
        self.shipping = shipping
        self.categories = categories

    def __str__(self):
        return "ProductData(id={}, stall_id={}, name={}, description={}, images={}, currency={}, price={}, quantity={}, specs={}, shipping={}, categories={})".format(self.id, self.stall_id, self.name, self.description, self.images, self.currency, self.price, self.quantity, self.specs, self.shipping, self.categories)

    def __eq__(self, other):
        if self.id != other.id:
            return False
        if self.stall_id != other.stall_id:
            return False
        if self.name != other.name:
            return False
        if self.description != other.description:
            return False
        if self.images != other.images:
            return False
        if self.currency != other.currency:
            return False
        if self.price != other.price:
            return False
        if self.quantity != other.quantity:
            return False
        if self.specs != other.specs:
            return False
        if self.shipping != other.shipping:
            return False
        if self.categories != other.categories:
            return False
        return True

class _UniffiConverterTypeProductData(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ProductData(
            id=_UniffiConverterString.read(buf),
            stall_id=_UniffiConverterString.read(buf),
            name=_UniffiConverterString.read(buf),
            description=_UniffiConverterOptionalString.read(buf),
            images=_UniffiConverterOptionalSequenceString.read(buf),
            currency=_UniffiConverterString.read(buf),
            price=_UniffiConverterDouble.read(buf),
            quantity=_UniffiConverterUInt64.read(buf),
            specs=_UniffiConverterOptionalSequenceSequenceString.read(buf),
            shipping=_UniffiConverterSequenceTypeShippingCost.read(buf),
            categories=_UniffiConverterOptionalSequenceString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.id)
        _UniffiConverterString.check_lower(value.stall_id)
        _UniffiConverterString.check_lower(value.name)
        _UniffiConverterOptionalString.check_lower(value.description)
        _UniffiConverterOptionalSequenceString.check_lower(value.images)
        _UniffiConverterString.check_lower(value.currency)
        _UniffiConverterDouble.check_lower(value.price)
        _UniffiConverterUInt64.check_lower(value.quantity)
        _UniffiConverterOptionalSequenceSequenceString.check_lower(value.specs)
        _UniffiConverterSequenceTypeShippingCost.check_lower(value.shipping)
        _UniffiConverterOptionalSequenceString.check_lower(value.categories)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.id, buf)
        _UniffiConverterString.write(value.stall_id, buf)
        _UniffiConverterString.write(value.name, buf)
        _UniffiConverterOptionalString.write(value.description, buf)
        _UniffiConverterOptionalSequenceString.write(value.images, buf)
        _UniffiConverterString.write(value.currency, buf)
        _UniffiConverterDouble.write(value.price, buf)
        _UniffiConverterUInt64.write(value.quantity, buf)
        _UniffiConverterOptionalSequenceSequenceString.write(value.specs, buf)
        _UniffiConverterSequenceTypeShippingCost.write(value.shipping, buf)
        _UniffiConverterOptionalSequenceString.write(value.categories, buf)


class RateLimit:
    """
    Rate limit
    """

    max_reqs: "int"
    """
    Max active REQs
    """

    notes_per_minute: "int"
    """
    Max events per minutes
    """

    def __init__(self, *, max_reqs: "int", notes_per_minute: "int"):
        self.max_reqs = max_reqs
        self.notes_per_minute = notes_per_minute

    def __str__(self):
        return "RateLimit(max_reqs={}, notes_per_minute={})".format(self.max_reqs, self.notes_per_minute)

    def __eq__(self, other):
        if self.max_reqs != other.max_reqs:
            return False
        if self.notes_per_minute != other.notes_per_minute:
            return False
        return True

class _UniffiConverterTypeRateLimit(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return RateLimit(
            max_reqs=_UniffiConverterUInt64.read(buf),
            notes_per_minute=_UniffiConverterUInt32.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterUInt64.check_lower(value.max_reqs)
        _UniffiConverterUInt32.check_lower(value.notes_per_minute)

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt64.write(value.max_reqs, buf)
        _UniffiConverterUInt32.write(value.notes_per_minute, buf)


class Reconciliation:
    """
    Reconciliation output
    """

    local: "typing.List[EventId]"
    """
    The IDs that were stored locally
    """

    remote: "typing.List[EventId]"
    """
    The IDs that were missing locally (stored on relay)
    """

    sent: "typing.List[EventId]"
    """
    Events that are **successfully** sent to relays during reconciliation
    """

    received: "typing.List[EventId]"
    """
    Event that are **successfully** received from relay
    """

    send_failures: "dict[RelayUrl, typing.List[ReconciliationSendFailureItem]]"
    """
    Events that failed to send to relays during reconciliation
    """

    def __init__(self, *, local: "typing.List[EventId]", remote: "typing.List[EventId]", sent: "typing.List[EventId]", received: "typing.List[EventId]", send_failures: "dict[RelayUrl, typing.List[ReconciliationSendFailureItem]]"):
        self.local = local
        self.remote = remote
        self.sent = sent
        self.received = received
        self.send_failures = send_failures

    def __str__(self):
        return "Reconciliation(local={}, remote={}, sent={}, received={}, send_failures={})".format(self.local, self.remote, self.sent, self.received, self.send_failures)

    def __eq__(self, other):
        if self.local != other.local:
            return False
        if self.remote != other.remote:
            return False
        if self.sent != other.sent:
            return False
        if self.received != other.received:
            return False
        if self.send_failures != other.send_failures:
            return False
        return True

class _UniffiConverterTypeReconciliation(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return Reconciliation(
            local=_UniffiConverterSequenceTypeEventId.read(buf),
            remote=_UniffiConverterSequenceTypeEventId.read(buf),
            sent=_UniffiConverterSequenceTypeEventId.read(buf),
            received=_UniffiConverterSequenceTypeEventId.read(buf),
            send_failures=_UniffiConverterMapTypeRelayUrlSequenceTypeReconciliationSendFailureItem.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterSequenceTypeEventId.check_lower(value.local)
        _UniffiConverterSequenceTypeEventId.check_lower(value.remote)
        _UniffiConverterSequenceTypeEventId.check_lower(value.sent)
        _UniffiConverterSequenceTypeEventId.check_lower(value.received)
        _UniffiConverterMapTypeRelayUrlSequenceTypeReconciliationSendFailureItem.check_lower(value.send_failures)

    @staticmethod
    def write(value, buf):
        _UniffiConverterSequenceTypeEventId.write(value.local, buf)
        _UniffiConverterSequenceTypeEventId.write(value.remote, buf)
        _UniffiConverterSequenceTypeEventId.write(value.sent, buf)
        _UniffiConverterSequenceTypeEventId.write(value.received, buf)
        _UniffiConverterMapTypeRelayUrlSequenceTypeReconciliationSendFailureItem.write(value.send_failures, buf)


class ReconciliationOutput:
    """
    Reconciliation output
    """

    report: "Reconciliation"
    """
    Reconciliation report
    """

    success: "typing.List[RelayUrl]"
    """
    Set of relays that success
    """

    failed: "dict[RelayUrl, str]"
    """
    Map of relays that failed, with related errors.
    """

    def __init__(self, *, report: "Reconciliation", success: "typing.List[RelayUrl]", failed: "dict[RelayUrl, str]"):
        self.report = report
        self.success = success
        self.failed = failed

    def __str__(self):
        return "ReconciliationOutput(report={}, success={}, failed={})".format(self.report, self.success, self.failed)

    def __eq__(self, other):
        if self.report != other.report:
            return False
        if self.success != other.success:
            return False
        if self.failed != other.failed:
            return False
        return True

class _UniffiConverterTypeReconciliationOutput(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ReconciliationOutput(
            report=_UniffiConverterTypeReconciliation.read(buf),
            success=_UniffiConverterSequenceTypeRelayUrl.read(buf),
            failed=_UniffiConverterMapTypeRelayUrlString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypeReconciliation.check_lower(value.report)
        _UniffiConverterSequenceTypeRelayUrl.check_lower(value.success)
        _UniffiConverterMapTypeRelayUrlString.check_lower(value.failed)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeReconciliation.write(value.report, buf)
        _UniffiConverterSequenceTypeRelayUrl.write(value.success, buf)
        _UniffiConverterMapTypeRelayUrlString.write(value.failed, buf)


class ReconciliationSendFailureItem:
    id: "EventId"
    error: "str"
    def __init__(self, *, id: "EventId", error: "str"):
        self.id = id
        self.error = error

    def __str__(self):
        return "ReconciliationSendFailureItem(id={}, error={})".format(self.id, self.error)

    def __eq__(self, other):
        if self.id != other.id:
            return False
        if self.error != other.error:
            return False
        return True

class _UniffiConverterTypeReconciliationSendFailureItem(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ReconciliationSendFailureItem(
            id=_UniffiConverterTypeEventId.read(buf),
            error=_UniffiConverterString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypeEventId.check_lower(value.id)
        _UniffiConverterString.check_lower(value.error)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeEventId.write(value.id, buf)
        _UniffiConverterString.write(value.error, buf)


class RelayBuilderNip42:
    """
    NIP42 options
    """

    mode: "RelayBuilderNip42Mode"
    """
    Mode
    """

    def __init__(self, *, mode: "RelayBuilderNip42Mode"):
        self.mode = mode

    def __str__(self):
        return "RelayBuilderNip42(mode={})".format(self.mode)

    def __eq__(self, other):
        if self.mode != other.mode:
            return False
        return True

class _UniffiConverterTypeRelayBuilderNip42(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return RelayBuilderNip42(
            mode=_UniffiConverterTypeRelayBuilderNip42Mode.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypeRelayBuilderNip42Mode.check_lower(value.mode)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeRelayBuilderNip42Mode.write(value.mode, buf)


class Retention:
    """
    A retention schedule for the relay
    """

    kinds: "typing.Optional[typing.List[RetentionKind]]"
    """
    The event kinds this retention pertains to
    """

    time: "typing.Optional[int]"
    """
    The amount of time these events are kept
    """

    count: "typing.Optional[int]"
    """
    The max number of events kept before removing older events
    """

    def __init__(self, *, kinds: "typing.Optional[typing.List[RetentionKind]]", time: "typing.Optional[int]", count: "typing.Optional[int]"):
        self.kinds = kinds
        self.time = time
        self.count = count

    def __str__(self):
        return "Retention(kinds={}, time={}, count={})".format(self.kinds, self.time, self.count)

    def __eq__(self, other):
        if self.kinds != other.kinds:
            return False
        if self.time != other.time:
            return False
        if self.count != other.count:
            return False
        return True

class _UniffiConverterTypeRetention(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return Retention(
            kinds=_UniffiConverterOptionalSequenceTypeRetentionKind.read(buf),
            time=_UniffiConverterOptionalUInt64.read(buf),
            count=_UniffiConverterOptionalUInt64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterOptionalSequenceTypeRetentionKind.check_lower(value.kinds)
        _UniffiConverterOptionalUInt64.check_lower(value.time)
        _UniffiConverterOptionalUInt64.check_lower(value.count)

    @staticmethod
    def write(value, buf):
        _UniffiConverterOptionalSequenceTypeRetentionKind.write(value.kinds, buf)
        _UniffiConverterOptionalUInt64.write(value.time, buf)
        _UniffiConverterOptionalUInt64.write(value.count, buf)


class SendEventOutput:
    """
    Send event output
    """

    id: "EventId"
    """
    Event ID
    """

    success: "typing.List[RelayUrl]"
    """
    Set of relays that success
    """

    failed: "dict[RelayUrl, str]"
    """
    Map of relays that failed, with related errors.
    """

    def __init__(self, *, id: "EventId", success: "typing.List[RelayUrl]", failed: "dict[RelayUrl, str]"):
        self.id = id
        self.success = success
        self.failed = failed

    def __str__(self):
        return "SendEventOutput(id={}, success={}, failed={})".format(self.id, self.success, self.failed)

    def __eq__(self, other):
        if self.id != other.id:
            return False
        if self.success != other.success:
            return False
        if self.failed != other.failed:
            return False
        return True

class _UniffiConverterTypeSendEventOutput(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return SendEventOutput(
            id=_UniffiConverterTypeEventId.read(buf),
            success=_UniffiConverterSequenceTypeRelayUrl.read(buf),
            failed=_UniffiConverterMapTypeRelayUrlString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypeEventId.check_lower(value.id)
        _UniffiConverterSequenceTypeRelayUrl.check_lower(value.success)
        _UniffiConverterMapTypeRelayUrlString.check_lower(value.failed)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeEventId.write(value.id, buf)
        _UniffiConverterSequenceTypeRelayUrl.write(value.success, buf)
        _UniffiConverterMapTypeRelayUrlString.write(value.failed, buf)


class SettleHoldInvoiceRequest:
    """
    Settle Hold Invoice Request
    """

    preimage: "str"
    """
    preimage
    """

    def __init__(self, *, preimage: "str"):
        self.preimage = preimage

    def __str__(self):
        return "SettleHoldInvoiceRequest(preimage={})".format(self.preimage)

    def __eq__(self, other):
        if self.preimage != other.preimage:
            return False
        return True

class _UniffiConverterTypeSettleHoldInvoiceRequest(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return SettleHoldInvoiceRequest(
            preimage=_UniffiConverterString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.preimage)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.preimage, buf)


class SettleHoldInvoiceResponse:
    """
    Settle Hold Invoice Response
    """


    def __str__(self):
        return "SettleHoldInvoiceResponse()".format()

    def __eq__(self, other):
        return True

class _UniffiConverterTypeSettleHoldInvoiceResponse(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return SettleHoldInvoiceResponse(
        )

    @staticmethod
    def check_lower(value):
        pass

    @staticmethod
    def write(value, buf):
        pass


class ShippingCost:
    """
    Delivery cost for shipping method as defined by the merchant in the product
    """

    id: "str"
    """
    Id of the shipping method
    """

    cost: "float"
    """
    Cost to use this shipping method
    """

    def __init__(self, *, id: "str", cost: "float"):
        self.id = id
        self.cost = cost

    def __str__(self):
        return "ShippingCost(id={}, cost={})".format(self.id, self.cost)

    def __eq__(self, other):
        if self.id != other.id:
            return False
        if self.cost != other.cost:
            return False
        return True

class _UniffiConverterTypeShippingCost(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ShippingCost(
            id=_UniffiConverterString.read(buf),
            cost=_UniffiConverterDouble.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.id)
        _UniffiConverterDouble.check_lower(value.cost)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.id, buf)
        _UniffiConverterDouble.write(value.cost, buf)


class ShippingMethodRecord:
    id: "str"
    """
    Shipping method unique id by merchant
    """

    name: "typing.Optional[str]"
    """
    Shipping method name
    """

    cost: "float"
    """
    Shipping method cost (currency is the same as the stall)
    """

    regions: "typing.List[str]"
    """
    Covered regions
    """

    def __init__(self, *, id: "str", name: "typing.Optional[str]", cost: "float", regions: "typing.List[str]"):
        self.id = id
        self.name = name
        self.cost = cost
        self.regions = regions

    def __str__(self):
        return "ShippingMethodRecord(id={}, name={}, cost={}, regions={})".format(self.id, self.name, self.cost, self.regions)

    def __eq__(self, other):
        if self.id != other.id:
            return False
        if self.name != other.name:
            return False
        if self.cost != other.cost:
            return False
        if self.regions != other.regions:
            return False
        return True

class _UniffiConverterTypeShippingMethodRecord(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ShippingMethodRecord(
            id=_UniffiConverterString.read(buf),
            name=_UniffiConverterOptionalString.read(buf),
            cost=_UniffiConverterDouble.read(buf),
            regions=_UniffiConverterSequenceString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.id)
        _UniffiConverterOptionalString.check_lower(value.name)
        _UniffiConverterDouble.check_lower(value.cost)
        _UniffiConverterSequenceString.check_lower(value.regions)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.id, buf)
        _UniffiConverterOptionalString.write(value.name, buf)
        _UniffiConverterDouble.write(value.cost, buf)
        _UniffiConverterSequenceString.write(value.regions, buf)


class StallDataRecord:
    """
    Payload for creating or updating stall
    """

    id: "str"
    """
    UUID of the stall generated by merchant
    """

    name: "str"
    """
    Stall name
    """

    description: "typing.Optional[str]"
    """
    Stall description
    """

    currency: "str"
    """
    Currency used
    """

    shipping: "typing.List[ShippingMethodRecord]"
    """
    Available shipping methods
    """

    def __init__(self, *, id: "str", name: "str", description: "typing.Optional[str]", currency: "str", shipping: "typing.List[ShippingMethodRecord]"):
        self.id = id
        self.name = name
        self.description = description
        self.currency = currency
        self.shipping = shipping

    def __str__(self):
        return "StallDataRecord(id={}, name={}, description={}, currency={}, shipping={})".format(self.id, self.name, self.description, self.currency, self.shipping)

    def __eq__(self, other):
        if self.id != other.id:
            return False
        if self.name != other.name:
            return False
        if self.description != other.description:
            return False
        if self.currency != other.currency:
            return False
        if self.shipping != other.shipping:
            return False
        return True

class _UniffiConverterTypeStallDataRecord(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return StallDataRecord(
            id=_UniffiConverterString.read(buf),
            name=_UniffiConverterString.read(buf),
            description=_UniffiConverterOptionalString.read(buf),
            currency=_UniffiConverterString.read(buf),
            shipping=_UniffiConverterSequenceTypeShippingMethodRecord.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.id)
        _UniffiConverterString.check_lower(value.name)
        _UniffiConverterOptionalString.check_lower(value.description)
        _UniffiConverterString.check_lower(value.currency)
        _UniffiConverterSequenceTypeShippingMethodRecord.check_lower(value.shipping)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.id, buf)
        _UniffiConverterString.write(value.name, buf)
        _UniffiConverterOptionalString.write(value.description, buf)
        _UniffiConverterString.write(value.currency, buf)
        _UniffiConverterSequenceTypeShippingMethodRecord.write(value.shipping, buf)


class SubscribeOutput:
    """
    Subscribe output
    """

    id: "str"
    """
    Subscription ID
    """

    success: "typing.List[RelayUrl]"
    """
    Set of relays that success
    """

    failed: "dict[RelayUrl, str]"
    """
    Map of relays that failed, with related errors.
    """

    def __init__(self, *, id: "str", success: "typing.List[RelayUrl]", failed: "dict[RelayUrl, str]"):
        self.id = id
        self.success = success
        self.failed = failed

    def __str__(self):
        return "SubscribeOutput(id={}, success={}, failed={})".format(self.id, self.success, self.failed)

    def __eq__(self, other):
        if self.id != other.id:
            return False
        if self.success != other.success:
            return False
        if self.failed != other.failed:
            return False
        return True

class _UniffiConverterTypeSubscribeOutput(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return SubscribeOutput(
            id=_UniffiConverterString.read(buf),
            success=_UniffiConverterSequenceTypeRelayUrl.read(buf),
            failed=_UniffiConverterMapTypeRelayUrlString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.id)
        _UniffiConverterSequenceTypeRelayUrl.check_lower(value.success)
        _UniffiConverterMapTypeRelayUrlString.check_lower(value.failed)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.id, buf)
        _UniffiConverterSequenceTypeRelayUrl.write(value.success, buf)
        _UniffiConverterMapTypeRelayUrlString.write(value.failed, buf)


class TagClientAddress:
    coordinate: "Coordinate"
    """
    Coordinate
    """

    hint: "typing.Optional[RelayUrl]"
    """
    Relay hint
    """

    def __init__(self, *, coordinate: "Coordinate", hint: "typing.Optional[RelayUrl]"):
        self.coordinate = coordinate
        self.hint = hint

    def __str__(self):
        return "TagClientAddress(coordinate={}, hint={})".format(self.coordinate, self.hint)

    def __eq__(self, other):
        if self.coordinate != other.coordinate:
            return False
        if self.hint != other.hint:
            return False
        return True

class _UniffiConverterTypeTagClientAddress(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return TagClientAddress(
            coordinate=_UniffiConverterTypeCoordinate.read(buf),
            hint=_UniffiConverterOptionalTypeRelayUrl.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypeCoordinate.check_lower(value.coordinate)
        _UniffiConverterOptionalTypeRelayUrl.check_lower(value.hint)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeCoordinate.write(value.coordinate, buf)
        _UniffiConverterOptionalTypeRelayUrl.write(value.hint, buf)


class WebSocketCloseFrame:
    code: "int"
    reason: "str"
    def __init__(self, *, code: "int", reason: "str"):
        self.code = code
        self.reason = reason

    def __str__(self):
        return "WebSocketCloseFrame(code={}, reason={})".format(self.code, self.reason)

    def __eq__(self, other):
        if self.code != other.code:
            return False
        if self.reason != other.reason:
            return False
        return True

class _UniffiConverterTypeWebSocketCloseFrame(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return WebSocketCloseFrame(
            code=_UniffiConverterUInt16.read(buf),
            reason=_UniffiConverterString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterUInt16.check_lower(value.code)
        _UniffiConverterString.check_lower(value.reason)

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt16.write(value.code, buf)
        _UniffiConverterString.write(value.reason, buf)





class Alphabet(enum.Enum):
    A = 0
    
    B = 1
    
    C = 2
    
    D = 3
    
    E = 4
    
    F = 5
    
    G = 6
    
    H = 7
    
    I = 8
    
    J = 9
    
    K = 10
    
    L = 11
    
    M = 12
    
    N = 13
    
    O = 14
    
    P = 15
    
    Q = 16
    
    R = 17
    
    S = 18
    
    T = 19
    
    U = 20
    
    V = 21
    
    W = 22
    
    X = 23
    
    Y = 24
    
    Z = 25
    


class _UniffiConverterTypeAlphabet(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return Alphabet.A
        if variant == 2:
            return Alphabet.B
        if variant == 3:
            return Alphabet.C
        if variant == 4:
            return Alphabet.D
        if variant == 5:
            return Alphabet.E
        if variant == 6:
            return Alphabet.F
        if variant == 7:
            return Alphabet.G
        if variant == 8:
            return Alphabet.H
        if variant == 9:
            return Alphabet.I
        if variant == 10:
            return Alphabet.J
        if variant == 11:
            return Alphabet.K
        if variant == 12:
            return Alphabet.L
        if variant == 13:
            return Alphabet.M
        if variant == 14:
            return Alphabet.N
        if variant == 15:
            return Alphabet.O
        if variant == 16:
            return Alphabet.P
        if variant == 17:
            return Alphabet.Q
        if variant == 18:
            return Alphabet.R
        if variant == 19:
            return Alphabet.S
        if variant == 20:
            return Alphabet.T
        if variant == 21:
            return Alphabet.U
        if variant == 22:
            return Alphabet.V
        if variant == 23:
            return Alphabet.W
        if variant == 24:
            return Alphabet.X
        if variant == 25:
            return Alphabet.Y
        if variant == 26:
            return Alphabet.Z
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == Alphabet.A:
            return
        if value == Alphabet.B:
            return
        if value == Alphabet.C:
            return
        if value == Alphabet.D:
            return
        if value == Alphabet.E:
            return
        if value == Alphabet.F:
            return
        if value == Alphabet.G:
            return
        if value == Alphabet.H:
            return
        if value == Alphabet.I:
            return
        if value == Alphabet.J:
            return
        if value == Alphabet.K:
            return
        if value == Alphabet.L:
            return
        if value == Alphabet.M:
            return
        if value == Alphabet.N:
            return
        if value == Alphabet.O:
            return
        if value == Alphabet.P:
            return
        if value == Alphabet.Q:
            return
        if value == Alphabet.R:
            return
        if value == Alphabet.S:
            return
        if value == Alphabet.T:
            return
        if value == Alphabet.U:
            return
        if value == Alphabet.V:
            return
        if value == Alphabet.W:
            return
        if value == Alphabet.X:
            return
        if value == Alphabet.Y:
            return
        if value == Alphabet.Z:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == Alphabet.A:
            buf.write_i32(1)
        if value == Alphabet.B:
            buf.write_i32(2)
        if value == Alphabet.C:
            buf.write_i32(3)
        if value == Alphabet.D:
            buf.write_i32(4)
        if value == Alphabet.E:
            buf.write_i32(5)
        if value == Alphabet.F:
            buf.write_i32(6)
        if value == Alphabet.G:
            buf.write_i32(7)
        if value == Alphabet.H:
            buf.write_i32(8)
        if value == Alphabet.I:
            buf.write_i32(9)
        if value == Alphabet.J:
            buf.write_i32(10)
        if value == Alphabet.K:
            buf.write_i32(11)
        if value == Alphabet.L:
            buf.write_i32(12)
        if value == Alphabet.M:
            buf.write_i32(13)
        if value == Alphabet.N:
            buf.write_i32(14)
        if value == Alphabet.O:
            buf.write_i32(15)
        if value == Alphabet.P:
            buf.write_i32(16)
        if value == Alphabet.Q:
            buf.write_i32(17)
        if value == Alphabet.R:
            buf.write_i32(18)
        if value == Alphabet.S:
            buf.write_i32(19)
        if value == Alphabet.T:
            buf.write_i32(20)
        if value == Alphabet.U:
            buf.write_i32(21)
        if value == Alphabet.V:
            buf.write_i32(22)
        if value == Alphabet.W:
            buf.write_i32(23)
        if value == Alphabet.X:
            buf.write_i32(24)
        if value == Alphabet.Y:
            buf.write_i32(25)
        if value == Alphabet.Z:
            buf.write_i32(26)







class ClientMessageEnum:
    """
    Messages sent by clients, received by relays
    """

    def __init__(self):
        raise RuntimeError("ClientMessageEnum cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class EVENT_MSG:
        event: "Event"

        def __init__(self,event: "Event"):
            self.event = event

        def __str__(self):
            return "ClientMessageEnum.EVENT_MSG(event={})".format(self.event)

        def __eq__(self, other):
            if not other.is_EVENT_MSG():
                return False
            if self.event != other.event:
                return False
            return True
    
    class REQ:
        subscription_id: "str"
        filters: "typing.List[Filter]"

        def __init__(self,subscription_id: "str", filters: "typing.List[Filter]"):
            self.subscription_id = subscription_id
            self.filters = filters

        def __str__(self):
            return "ClientMessageEnum.REQ(subscription_id={}, filters={})".format(self.subscription_id, self.filters)

        def __eq__(self, other):
            if not other.is_REQ():
                return False
            if self.subscription_id != other.subscription_id:
                return False
            if self.filters != other.filters:
                return False
            return True
    
    class COUNT:
        subscription_id: "str"
        filter: "Filter"

        def __init__(self,subscription_id: "str", filter: "Filter"):
            self.subscription_id = subscription_id
            self.filter = filter

        def __str__(self):
            return "ClientMessageEnum.COUNT(subscription_id={}, filter={})".format(self.subscription_id, self.filter)

        def __eq__(self, other):
            if not other.is_COUNT():
                return False
            if self.subscription_id != other.subscription_id:
                return False
            if self.filter != other.filter:
                return False
            return True
    
    class CLOSE:
        subscription_id: "str"

        def __init__(self,subscription_id: "str"):
            self.subscription_id = subscription_id

        def __str__(self):
            return "ClientMessageEnum.CLOSE(subscription_id={})".format(self.subscription_id)

        def __eq__(self, other):
            if not other.is_CLOSE():
                return False
            if self.subscription_id != other.subscription_id:
                return False
            return True
    
    class AUTH:
        event: "Event"

        def __init__(self,event: "Event"):
            self.event = event

        def __str__(self):
            return "ClientMessageEnum.AUTH(event={})".format(self.event)

        def __eq__(self, other):
            if not other.is_AUTH():
                return False
            if self.event != other.event:
                return False
            return True
    
    class NEG_OPEN:
        """
        Negentropy Open
        """

        subscription_id: "str"
        filter: "Filter"
        id_size: "typing.Optional[int]"
        """
        ID size (deprecated)
        """

        initial_message: "str"

        def __init__(self,subscription_id: "str", filter: "Filter", id_size: "typing.Optional[int]", initial_message: "str"):
            self.subscription_id = subscription_id
            self.filter = filter
            self.id_size = id_size
            self.initial_message = initial_message

        def __str__(self):
            return "ClientMessageEnum.NEG_OPEN(subscription_id={}, filter={}, id_size={}, initial_message={})".format(self.subscription_id, self.filter, self.id_size, self.initial_message)

        def __eq__(self, other):
            if not other.is_NEG_OPEN():
                return False
            if self.subscription_id != other.subscription_id:
                return False
            if self.filter != other.filter:
                return False
            if self.id_size != other.id_size:
                return False
            if self.initial_message != other.initial_message:
                return False
            return True
    
    class NEG_MSG:
        """
        Negentropy Message
        """

        subscription_id: "str"
        message: "str"

        def __init__(self,subscription_id: "str", message: "str"):
            self.subscription_id = subscription_id
            self.message = message

        def __str__(self):
            return "ClientMessageEnum.NEG_MSG(subscription_id={}, message={})".format(self.subscription_id, self.message)

        def __eq__(self, other):
            if not other.is_NEG_MSG():
                return False
            if self.subscription_id != other.subscription_id:
                return False
            if self.message != other.message:
                return False
            return True
    
    class NEG_CLOSE:
        """
        Negentropy Close
        """

        subscription_id: "str"

        def __init__(self,subscription_id: "str"):
            self.subscription_id = subscription_id

        def __str__(self):
            return "ClientMessageEnum.NEG_CLOSE(subscription_id={})".format(self.subscription_id)

        def __eq__(self, other):
            if not other.is_NEG_CLOSE():
                return False
            if self.subscription_id != other.subscription_id:
                return False
            return True
    
    

    # For each variant, we have `is_NAME` and `is_name` methods for easily checking
    # whether an instance is that variant.
    def is_EVENT_MSG(self) -> bool:
        return isinstance(self, ClientMessageEnum.EVENT_MSG)
    def is_event_msg(self) -> bool:
        return isinstance(self, ClientMessageEnum.EVENT_MSG)
    def is_REQ(self) -> bool:
        return isinstance(self, ClientMessageEnum.REQ)
    def is_req(self) -> bool:
        return isinstance(self, ClientMessageEnum.REQ)
    def is_COUNT(self) -> bool:
        return isinstance(self, ClientMessageEnum.COUNT)
    def is_count(self) -> bool:
        return isinstance(self, ClientMessageEnum.COUNT)
    def is_CLOSE(self) -> bool:
        return isinstance(self, ClientMessageEnum.CLOSE)
    def is_close(self) -> bool:
        return isinstance(self, ClientMessageEnum.CLOSE)
    def is_AUTH(self) -> bool:
        return isinstance(self, ClientMessageEnum.AUTH)
    def is_auth(self) -> bool:
        return isinstance(self, ClientMessageEnum.AUTH)
    def is_NEG_OPEN(self) -> bool:
        return isinstance(self, ClientMessageEnum.NEG_OPEN)
    def is_neg_open(self) -> bool:
        return isinstance(self, ClientMessageEnum.NEG_OPEN)
    def is_NEG_MSG(self) -> bool:
        return isinstance(self, ClientMessageEnum.NEG_MSG)
    def is_neg_msg(self) -> bool:
        return isinstance(self, ClientMessageEnum.NEG_MSG)
    def is_NEG_CLOSE(self) -> bool:
        return isinstance(self, ClientMessageEnum.NEG_CLOSE)
    def is_neg_close(self) -> bool:
        return isinstance(self, ClientMessageEnum.NEG_CLOSE)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
ClientMessageEnum.EVENT_MSG = type("ClientMessageEnum.EVENT_MSG", (ClientMessageEnum.EVENT_MSG, ClientMessageEnum,), {})  # type: ignore
ClientMessageEnum.REQ = type("ClientMessageEnum.REQ", (ClientMessageEnum.REQ, ClientMessageEnum,), {})  # type: ignore
ClientMessageEnum.COUNT = type("ClientMessageEnum.COUNT", (ClientMessageEnum.COUNT, ClientMessageEnum,), {})  # type: ignore
ClientMessageEnum.CLOSE = type("ClientMessageEnum.CLOSE", (ClientMessageEnum.CLOSE, ClientMessageEnum,), {})  # type: ignore
ClientMessageEnum.AUTH = type("ClientMessageEnum.AUTH", (ClientMessageEnum.AUTH, ClientMessageEnum,), {})  # type: ignore
ClientMessageEnum.NEG_OPEN = type("ClientMessageEnum.NEG_OPEN", (ClientMessageEnum.NEG_OPEN, ClientMessageEnum,), {})  # type: ignore
ClientMessageEnum.NEG_MSG = type("ClientMessageEnum.NEG_MSG", (ClientMessageEnum.NEG_MSG, ClientMessageEnum,), {})  # type: ignore
ClientMessageEnum.NEG_CLOSE = type("ClientMessageEnum.NEG_CLOSE", (ClientMessageEnum.NEG_CLOSE, ClientMessageEnum,), {})  # type: ignore




class _UniffiConverterTypeClientMessageEnum(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return ClientMessageEnum.EVENT_MSG(
                _UniffiConverterTypeEvent.read(buf),
            )
        if variant == 2:
            return ClientMessageEnum.REQ(
                _UniffiConverterString.read(buf),
                _UniffiConverterSequenceTypeFilter.read(buf),
            )
        if variant == 3:
            return ClientMessageEnum.COUNT(
                _UniffiConverterString.read(buf),
                _UniffiConverterTypeFilter.read(buf),
            )
        if variant == 4:
            return ClientMessageEnum.CLOSE(
                _UniffiConverterString.read(buf),
            )
        if variant == 5:
            return ClientMessageEnum.AUTH(
                _UniffiConverterTypeEvent.read(buf),
            )
        if variant == 6:
            return ClientMessageEnum.NEG_OPEN(
                _UniffiConverterString.read(buf),
                _UniffiConverterTypeFilter.read(buf),
                _UniffiConverterOptionalUInt8.read(buf),
                _UniffiConverterString.read(buf),
            )
        if variant == 7:
            return ClientMessageEnum.NEG_MSG(
                _UniffiConverterString.read(buf),
                _UniffiConverterString.read(buf),
            )
        if variant == 8:
            return ClientMessageEnum.NEG_CLOSE(
                _UniffiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value.is_EVENT_MSG():
            _UniffiConverterTypeEvent.check_lower(value.event)
            return
        if value.is_REQ():
            _UniffiConverterString.check_lower(value.subscription_id)
            _UniffiConverterSequenceTypeFilter.check_lower(value.filters)
            return
        if value.is_COUNT():
            _UniffiConverterString.check_lower(value.subscription_id)
            _UniffiConverterTypeFilter.check_lower(value.filter)
            return
        if value.is_CLOSE():
            _UniffiConverterString.check_lower(value.subscription_id)
            return
        if value.is_AUTH():
            _UniffiConverterTypeEvent.check_lower(value.event)
            return
        if value.is_NEG_OPEN():
            _UniffiConverterString.check_lower(value.subscription_id)
            _UniffiConverterTypeFilter.check_lower(value.filter)
            _UniffiConverterOptionalUInt8.check_lower(value.id_size)
            _UniffiConverterString.check_lower(value.initial_message)
            return
        if value.is_NEG_MSG():
            _UniffiConverterString.check_lower(value.subscription_id)
            _UniffiConverterString.check_lower(value.message)
            return
        if value.is_NEG_CLOSE():
            _UniffiConverterString.check_lower(value.subscription_id)
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value.is_EVENT_MSG():
            buf.write_i32(1)
            _UniffiConverterTypeEvent.write(value.event, buf)
        if value.is_REQ():
            buf.write_i32(2)
            _UniffiConverterString.write(value.subscription_id, buf)
            _UniffiConverterSequenceTypeFilter.write(value.filters, buf)
        if value.is_COUNT():
            buf.write_i32(3)
            _UniffiConverterString.write(value.subscription_id, buf)
            _UniffiConverterTypeFilter.write(value.filter, buf)
        if value.is_CLOSE():
            buf.write_i32(4)
            _UniffiConverterString.write(value.subscription_id, buf)
        if value.is_AUTH():
            buf.write_i32(5)
            _UniffiConverterTypeEvent.write(value.event, buf)
        if value.is_NEG_OPEN():
            buf.write_i32(6)
            _UniffiConverterString.write(value.subscription_id, buf)
            _UniffiConverterTypeFilter.write(value.filter, buf)
            _UniffiConverterOptionalUInt8.write(value.id_size, buf)
            _UniffiConverterString.write(value.initial_message, buf)
        if value.is_NEG_MSG():
            buf.write_i32(7)
            _UniffiConverterString.write(value.subscription_id, buf)
            _UniffiConverterString.write(value.message, buf)
        if value.is_NEG_CLOSE():
            buf.write_i32(8)
            _UniffiConverterString.write(value.subscription_id, buf)







class CommentTarget:
    """
    Comment target

    <https://github.com/nostr-protocol/nips/blob/master/22.md>
    """

    def __init__(self):
        raise RuntimeError("CommentTarget cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class EVENT:
        """
        Event
        """

        id: "EventId"
        """
        Event ID
        """

        relay_hint: "typing.Optional[RelayUrl]"
        """
        Relay hint
        """

        pubkey_hint: "typing.Optional[PublicKey]"
        """
        Public key hint
        """

        kind: "typing.Optional[Kind]"
        """
        Kind
        """


        def __init__(self,id: "EventId", relay_hint: "typing.Optional[RelayUrl]", pubkey_hint: "typing.Optional[PublicKey]", kind: "typing.Optional[Kind]"):
            self.id = id
            self.relay_hint = relay_hint
            self.pubkey_hint = pubkey_hint
            self.kind = kind

        def __str__(self):
            return "CommentTarget.EVENT(id={}, relay_hint={}, pubkey_hint={}, kind={})".format(self.id, self.relay_hint, self.pubkey_hint, self.kind)

        def __eq__(self, other):
            if not other.is_EVENT():
                return False
            if self.id != other.id:
                return False
            if self.relay_hint != other.relay_hint:
                return False
            if self.pubkey_hint != other.pubkey_hint:
                return False
            if self.kind != other.kind:
                return False
            return True
    
    class ADDRESS:
        """
        Coordinate
        """

        address: "Coordinate"
        """
        Coordinate
        """

        relay_hint: "typing.Optional[RelayUrl]"
        """
        Relay hint
        """


        def __init__(self,address: "Coordinate", relay_hint: "typing.Optional[RelayUrl]"):
            self.address = address
            self.relay_hint = relay_hint

        def __str__(self):
            return "CommentTarget.ADDRESS(address={}, relay_hint={})".format(self.address, self.relay_hint)

        def __eq__(self, other):
            if not other.is_ADDRESS():
                return False
            if self.address != other.address:
                return False
            if self.relay_hint != other.relay_hint:
                return False
            return True
    
    class EXTERNAL:
        """
        External content
        """

        content: "ExternalContentId"
        """
        Content
        """

        hint: "typing.Optional[str]"
        """
        Web hint
        """


        def __init__(self,content: "ExternalContentId", hint: "typing.Optional[str]"):
            self.content = content
            self.hint = hint

        def __str__(self):
            return "CommentTarget.EXTERNAL(content={}, hint={})".format(self.content, self.hint)

        def __eq__(self, other):
            if not other.is_EXTERNAL():
                return False
            if self.content != other.content:
                return False
            if self.hint != other.hint:
                return False
            return True
    
    

    # For each variant, we have `is_NAME` and `is_name` methods for easily checking
    # whether an instance is that variant.
    def is_EVENT(self) -> bool:
        return isinstance(self, CommentTarget.EVENT)
    def is_event(self) -> bool:
        return isinstance(self, CommentTarget.EVENT)
    def is_ADDRESS(self) -> bool:
        return isinstance(self, CommentTarget.ADDRESS)
    def is_address(self) -> bool:
        return isinstance(self, CommentTarget.ADDRESS)
    def is_EXTERNAL(self) -> bool:
        return isinstance(self, CommentTarget.EXTERNAL)
    def is_external(self) -> bool:
        return isinstance(self, CommentTarget.EXTERNAL)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
CommentTarget.EVENT = type("CommentTarget.EVENT", (CommentTarget.EVENT, CommentTarget,), {})  # type: ignore
CommentTarget.ADDRESS = type("CommentTarget.ADDRESS", (CommentTarget.ADDRESS, CommentTarget,), {})  # type: ignore
CommentTarget.EXTERNAL = type("CommentTarget.EXTERNAL", (CommentTarget.EXTERNAL, CommentTarget,), {})  # type: ignore




class _UniffiConverterTypeCommentTarget(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return CommentTarget.EVENT(
                _UniffiConverterTypeEventId.read(buf),
                _UniffiConverterOptionalTypeRelayUrl.read(buf),
                _UniffiConverterOptionalTypePublicKey.read(buf),
                _UniffiConverterOptionalTypeKind.read(buf),
            )
        if variant == 2:
            return CommentTarget.ADDRESS(
                _UniffiConverterTypeCoordinate.read(buf),
                _UniffiConverterOptionalTypeRelayUrl.read(buf),
            )
        if variant == 3:
            return CommentTarget.EXTERNAL(
                _UniffiConverterTypeExternalContentId.read(buf),
                _UniffiConverterOptionalString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value.is_EVENT():
            _UniffiConverterTypeEventId.check_lower(value.id)
            _UniffiConverterOptionalTypeRelayUrl.check_lower(value.relay_hint)
            _UniffiConverterOptionalTypePublicKey.check_lower(value.pubkey_hint)
            _UniffiConverterOptionalTypeKind.check_lower(value.kind)
            return
        if value.is_ADDRESS():
            _UniffiConverterTypeCoordinate.check_lower(value.address)
            _UniffiConverterOptionalTypeRelayUrl.check_lower(value.relay_hint)
            return
        if value.is_EXTERNAL():
            _UniffiConverterTypeExternalContentId.check_lower(value.content)
            _UniffiConverterOptionalString.check_lower(value.hint)
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value.is_EVENT():
            buf.write_i32(1)
            _UniffiConverterTypeEventId.write(value.id, buf)
            _UniffiConverterOptionalTypeRelayUrl.write(value.relay_hint, buf)
            _UniffiConverterOptionalTypePublicKey.write(value.pubkey_hint, buf)
            _UniffiConverterOptionalTypeKind.write(value.kind, buf)
        if value.is_ADDRESS():
            buf.write_i32(2)
            _UniffiConverterTypeCoordinate.write(value.address, buf)
            _UniffiConverterOptionalTypeRelayUrl.write(value.relay_hint, buf)
        if value.is_EXTERNAL():
            buf.write_i32(3)
            _UniffiConverterTypeExternalContentId.write(value.content, buf)
            _UniffiConverterOptionalString.write(value.hint, buf)







class ConnectionMode:
    def __init__(self):
        raise RuntimeError("ConnectionMode cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class DIRECT:

        def __init__(self,):
            pass

        def __str__(self):
            return "ConnectionMode.DIRECT()".format()

        def __eq__(self, other):
            if not other.is_DIRECT():
                return False
            return True
    
    class PROXY:
        ip: "str"
        """
        IP
        """

        port: "int"
        """
        Port
        """


        def __init__(self,ip: "str", port: "int"):
            self.ip = ip
            self.port = port

        def __str__(self):
            return "ConnectionMode.PROXY(ip={}, port={})".format(self.ip, self.port)

        def __eq__(self, other):
            if not other.is_PROXY():
                return False
            if self.ip != other.ip:
                return False
            if self.port != other.port:
                return False
            return True
    
    

    # For each variant, we have `is_NAME` and `is_name` methods for easily checking
    # whether an instance is that variant.
    def is_DIRECT(self) -> bool:
        return isinstance(self, ConnectionMode.DIRECT)
    def is_direct(self) -> bool:
        return isinstance(self, ConnectionMode.DIRECT)
    def is_PROXY(self) -> bool:
        return isinstance(self, ConnectionMode.PROXY)
    def is_proxy(self) -> bool:
        return isinstance(self, ConnectionMode.PROXY)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
ConnectionMode.DIRECT = type("ConnectionMode.DIRECT", (ConnectionMode.DIRECT, ConnectionMode,), {})  # type: ignore
ConnectionMode.PROXY = type("ConnectionMode.PROXY", (ConnectionMode.PROXY, ConnectionMode,), {})  # type: ignore




class _UniffiConverterTypeConnectionMode(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return ConnectionMode.DIRECT(
            )
        if variant == 2:
            return ConnectionMode.PROXY(
                _UniffiConverterString.read(buf),
                _UniffiConverterUInt16.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value.is_DIRECT():
            return
        if value.is_PROXY():
            _UniffiConverterString.check_lower(value.ip)
            _UniffiConverterUInt16.check_lower(value.port)
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value.is_DIRECT():
            buf.write_i32(1)
        if value.is_PROXY():
            buf.write_i32(2)
            _UniffiConverterString.write(value.ip, buf)
            _UniffiConverterUInt16.write(value.port, buf)







class ConnectionTarget(enum.Enum):
    """
    Connection target
    """

    ALL = 0
    """
    Use proxy for all relays
    """

    
    ONION = 1
    """
    Use proxy only for `.onion` relays
    """

    


class _UniffiConverterTypeConnectionTarget(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return ConnectionTarget.ALL
        if variant == 2:
            return ConnectionTarget.ONION
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == ConnectionTarget.ALL:
            return
        if value == ConnectionTarget.ONION:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == ConnectionTarget.ALL:
            buf.write_i32(1)
        if value == ConnectionTarget.ONION:
            buf.write_i32(2)







class DataVendingMachineStatus(enum.Enum):
    PAYMENT_REQUIRED = 0
    
    PROCESSING = 1
    
    ERROR = 2
    
    SUCCESS = 3
    
    PARTIAL = 4
    


class _UniffiConverterTypeDataVendingMachineStatus(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return DataVendingMachineStatus.PAYMENT_REQUIRED
        if variant == 2:
            return DataVendingMachineStatus.PROCESSING
        if variant == 3:
            return DataVendingMachineStatus.ERROR
        if variant == 4:
            return DataVendingMachineStatus.SUCCESS
        if variant == 5:
            return DataVendingMachineStatus.PARTIAL
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == DataVendingMachineStatus.PAYMENT_REQUIRED:
            return
        if value == DataVendingMachineStatus.PROCESSING:
            return
        if value == DataVendingMachineStatus.ERROR:
            return
        if value == DataVendingMachineStatus.SUCCESS:
            return
        if value == DataVendingMachineStatus.PARTIAL:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == DataVendingMachineStatus.PAYMENT_REQUIRED:
            buf.write_i32(1)
        if value == DataVendingMachineStatus.PROCESSING:
            buf.write_i32(2)
        if value == DataVendingMachineStatus.ERROR:
            buf.write_i32(3)
        if value == DataVendingMachineStatus.SUCCESS:
            buf.write_i32(4)
        if value == DataVendingMachineStatus.PARTIAL:
            buf.write_i32(5)







class DatabaseEventStatus(enum.Enum):
    SAVED = 0
    
    DELETED = 1
    
    NOT_EXISTENT = 2
    


class _UniffiConverterTypeDatabaseEventStatus(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return DatabaseEventStatus.SAVED
        if variant == 2:
            return DatabaseEventStatus.DELETED
        if variant == 3:
            return DatabaseEventStatus.NOT_EXISTENT
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == DatabaseEventStatus.SAVED:
            return
        if value == DatabaseEventStatus.DELETED:
            return
        if value == DatabaseEventStatus.NOT_EXISTENT:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == DatabaseEventStatus.SAVED:
            buf.write_i32(1)
        if value == DatabaseEventStatus.DELETED:
            buf.write_i32(2)
        if value == DatabaseEventStatus.NOT_EXISTENT:
            buf.write_i32(3)







class EncryptedSecretKeyVersion(enum.Enum):
    """
    Encrypted Secret Key version (NIP49)
    """

    V2 = 0
    


class _UniffiConverterTypeEncryptedSecretKeyVersion(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return EncryptedSecretKeyVersion.V2
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == EncryptedSecretKeyVersion.V2:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == EncryptedSecretKeyVersion.V2:
            buf.write_i32(1)







class ErrorCode(enum.Enum):
    """
    NIP47 Response Error codes
    """

    RATE_LIMITED = 0
    """
    The client is sending commands too fast.
    """

    
    NOT_IMPLEMENTED = 1
    """
    The command is not known of is intentionally not implemented
    """

    
    INSUFFICIENT_BALANCE = 2
    """
    The wallet does not have enough funds to cover a fee reserve or the payment amount
    """

    
    PAYMENT_FAILED = 3
    """
    The payment failed. This may be due to a timeout, exhausting all routes, insufficient capacity or similar.
    """

    
    NOT_FOUND = 4
    """
    The invoice could not be found by the given parameters.
    """

    
    QUOTA_EXCEEDED = 5
    """
    The wallet has exceeded its spending quota
    """

    
    RESTRICTED = 6
    """
    This public key is not allowed to do this operation
    """

    
    UNAUTHORIZED = 7
    """
    This public key has no wallet connected
    """

    
    INTERNAL = 8
    """
    An internal error
    """

    
    OTHER = 9
    """
    Other error
    """

    


class _UniffiConverterTypeErrorCode(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return ErrorCode.RATE_LIMITED
        if variant == 2:
            return ErrorCode.NOT_IMPLEMENTED
        if variant == 3:
            return ErrorCode.INSUFFICIENT_BALANCE
        if variant == 4:
            return ErrorCode.PAYMENT_FAILED
        if variant == 5:
            return ErrorCode.NOT_FOUND
        if variant == 6:
            return ErrorCode.QUOTA_EXCEEDED
        if variant == 7:
            return ErrorCode.RESTRICTED
        if variant == 8:
            return ErrorCode.UNAUTHORIZED
        if variant == 9:
            return ErrorCode.INTERNAL
        if variant == 10:
            return ErrorCode.OTHER
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == ErrorCode.RATE_LIMITED:
            return
        if value == ErrorCode.NOT_IMPLEMENTED:
            return
        if value == ErrorCode.INSUFFICIENT_BALANCE:
            return
        if value == ErrorCode.PAYMENT_FAILED:
            return
        if value == ErrorCode.NOT_FOUND:
            return
        if value == ErrorCode.QUOTA_EXCEEDED:
            return
        if value == ErrorCode.RESTRICTED:
            return
        if value == ErrorCode.UNAUTHORIZED:
            return
        if value == ErrorCode.INTERNAL:
            return
        if value == ErrorCode.OTHER:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == ErrorCode.RATE_LIMITED:
            buf.write_i32(1)
        if value == ErrorCode.NOT_IMPLEMENTED:
            buf.write_i32(2)
        if value == ErrorCode.INSUFFICIENT_BALANCE:
            buf.write_i32(3)
        if value == ErrorCode.PAYMENT_FAILED:
            buf.write_i32(4)
        if value == ErrorCode.NOT_FOUND:
            buf.write_i32(5)
        if value == ErrorCode.QUOTA_EXCEEDED:
            buf.write_i32(6)
        if value == ErrorCode.RESTRICTED:
            buf.write_i32(7)
        if value == ErrorCode.UNAUTHORIZED:
            buf.write_i32(8)
        if value == ErrorCode.INTERNAL:
            buf.write_i32(9)
        if value == ErrorCode.OTHER:
            buf.write_i32(10)







class ExternalContentId:
    """
    External Content ID
    """

    def __init__(self):
        raise RuntimeError("ExternalContentId cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class URL:
        """
        URL
        """

        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __str__(self):
            return f"ExternalContentId.URL{self._values!r}"

        def __eq__(self, other):
            if not other.is_URL():
                return False
            return self._values == other._values
    class HASHTAG:
        """
        Hashtag
        """

        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __str__(self):
            return f"ExternalContentId.HASHTAG{self._values!r}"

        def __eq__(self, other):
            if not other.is_HASHTAG():
                return False
            return self._values == other._values
    class GEOHASH:
        """
        Geohash
        """

        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __str__(self):
            return f"ExternalContentId.GEOHASH{self._values!r}"

        def __eq__(self, other):
            if not other.is_GEOHASH():
                return False
            return self._values == other._values
    class BOOK:
        """
        Book
        """

        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __str__(self):
            return f"ExternalContentId.BOOK{self._values!r}"

        def __eq__(self, other):
            if not other.is_BOOK():
                return False
            return self._values == other._values
    class PODCAST_FEED:
        """
        Podcast Feed
        """

        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __str__(self):
            return f"ExternalContentId.PODCAST_FEED{self._values!r}"

        def __eq__(self, other):
            if not other.is_PODCAST_FEED():
                return False
            return self._values == other._values
    class PODCAST_EPISODE:
        """
        Podcast Episode
        """

        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __str__(self):
            return f"ExternalContentId.PODCAST_EPISODE{self._values!r}"

        def __eq__(self, other):
            if not other.is_PODCAST_EPISODE():
                return False
            return self._values == other._values
    class PODCAST_PUBLISHER:
        """
        Podcast Publisher
        """

        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __str__(self):
            return f"ExternalContentId.PODCAST_PUBLISHER{self._values!r}"

        def __eq__(self, other):
            if not other.is_PODCAST_PUBLISHER():
                return False
            return self._values == other._values
    class MOVIE:
        """
        Movie
        """

        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __str__(self):
            return f"ExternalContentId.MOVIE{self._values!r}"

        def __eq__(self, other):
            if not other.is_MOVIE():
                return False
            return self._values == other._values
    class PAPER:
        """
        Paper
        """

        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __str__(self):
            return f"ExternalContentId.PAPER{self._values!r}"

        def __eq__(self, other):
            if not other.is_PAPER():
                return False
            return self._values == other._values
    class BLOCKCHAIN_TRANSACTION:
        """
        Blockchain Transaction
        """

        chain: "str"
        """
        The blockchain name (e.g., "bitcoin", "ethereum")
        """

        transaction_hash: "str"
        """
        A lower case hex transaction id
        """

        chain_id: "typing.Optional[str]"
        """
        The chain id if one is required
        """


        def __init__(self,chain: "str", transaction_hash: "str", chain_id: "typing.Optional[str]"):
            self.chain = chain
            self.transaction_hash = transaction_hash
            self.chain_id = chain_id

        def __str__(self):
            return "ExternalContentId.BLOCKCHAIN_TRANSACTION(chain={}, transaction_hash={}, chain_id={})".format(self.chain, self.transaction_hash, self.chain_id)

        def __eq__(self, other):
            if not other.is_BLOCKCHAIN_TRANSACTION():
                return False
            if self.chain != other.chain:
                return False
            if self.transaction_hash != other.transaction_hash:
                return False
            if self.chain_id != other.chain_id:
                return False
            return True
    
    class BLOCKCHAIN_ADDRESS:
        """
        Blockchain Address
        """

        chain: "str"
        """
        The blockchain name (e.g., "bitcoin", "ethereum")
        """

        address: "str"
        """
        The on-chain address
        """

        chain_id: "typing.Optional[str]"
        """
        The chain id if one is required
        """


        def __init__(self,chain: "str", address: "str", chain_id: "typing.Optional[str]"):
            self.chain = chain
            self.address = address
            self.chain_id = chain_id

        def __str__(self):
            return "ExternalContentId.BLOCKCHAIN_ADDRESS(chain={}, address={}, chain_id={})".format(self.chain, self.address, self.chain_id)

        def __eq__(self, other):
            if not other.is_BLOCKCHAIN_ADDRESS():
                return False
            if self.chain != other.chain:
                return False
            if self.address != other.address:
                return False
            if self.chain_id != other.chain_id:
                return False
            return True
    
    

    # For each variant, we have `is_NAME` and `is_name` methods for easily checking
    # whether an instance is that variant.
    def is_URL(self) -> bool:
        return isinstance(self, ExternalContentId.URL)
    def is_url(self) -> bool:
        return isinstance(self, ExternalContentId.URL)
    def is_HASHTAG(self) -> bool:
        return isinstance(self, ExternalContentId.HASHTAG)
    def is_hashtag(self) -> bool:
        return isinstance(self, ExternalContentId.HASHTAG)
    def is_GEOHASH(self) -> bool:
        return isinstance(self, ExternalContentId.GEOHASH)
    def is_geohash(self) -> bool:
        return isinstance(self, ExternalContentId.GEOHASH)
    def is_BOOK(self) -> bool:
        return isinstance(self, ExternalContentId.BOOK)
    def is_book(self) -> bool:
        return isinstance(self, ExternalContentId.BOOK)
    def is_PODCAST_FEED(self) -> bool:
        return isinstance(self, ExternalContentId.PODCAST_FEED)
    def is_podcast_feed(self) -> bool:
        return isinstance(self, ExternalContentId.PODCAST_FEED)
    def is_PODCAST_EPISODE(self) -> bool:
        return isinstance(self, ExternalContentId.PODCAST_EPISODE)
    def is_podcast_episode(self) -> bool:
        return isinstance(self, ExternalContentId.PODCAST_EPISODE)
    def is_PODCAST_PUBLISHER(self) -> bool:
        return isinstance(self, ExternalContentId.PODCAST_PUBLISHER)
    def is_podcast_publisher(self) -> bool:
        return isinstance(self, ExternalContentId.PODCAST_PUBLISHER)
    def is_MOVIE(self) -> bool:
        return isinstance(self, ExternalContentId.MOVIE)
    def is_movie(self) -> bool:
        return isinstance(self, ExternalContentId.MOVIE)
    def is_PAPER(self) -> bool:
        return isinstance(self, ExternalContentId.PAPER)
    def is_paper(self) -> bool:
        return isinstance(self, ExternalContentId.PAPER)
    def is_BLOCKCHAIN_TRANSACTION(self) -> bool:
        return isinstance(self, ExternalContentId.BLOCKCHAIN_TRANSACTION)
    def is_blockchain_transaction(self) -> bool:
        return isinstance(self, ExternalContentId.BLOCKCHAIN_TRANSACTION)
    def is_BLOCKCHAIN_ADDRESS(self) -> bool:
        return isinstance(self, ExternalContentId.BLOCKCHAIN_ADDRESS)
    def is_blockchain_address(self) -> bool:
        return isinstance(self, ExternalContentId.BLOCKCHAIN_ADDRESS)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
ExternalContentId.URL = type("ExternalContentId.URL", (ExternalContentId.URL, ExternalContentId,), {})  # type: ignore
ExternalContentId.HASHTAG = type("ExternalContentId.HASHTAG", (ExternalContentId.HASHTAG, ExternalContentId,), {})  # type: ignore
ExternalContentId.GEOHASH = type("ExternalContentId.GEOHASH", (ExternalContentId.GEOHASH, ExternalContentId,), {})  # type: ignore
ExternalContentId.BOOK = type("ExternalContentId.BOOK", (ExternalContentId.BOOK, ExternalContentId,), {})  # type: ignore
ExternalContentId.PODCAST_FEED = type("ExternalContentId.PODCAST_FEED", (ExternalContentId.PODCAST_FEED, ExternalContentId,), {})  # type: ignore
ExternalContentId.PODCAST_EPISODE = type("ExternalContentId.PODCAST_EPISODE", (ExternalContentId.PODCAST_EPISODE, ExternalContentId,), {})  # type: ignore
ExternalContentId.PODCAST_PUBLISHER = type("ExternalContentId.PODCAST_PUBLISHER", (ExternalContentId.PODCAST_PUBLISHER, ExternalContentId,), {})  # type: ignore
ExternalContentId.MOVIE = type("ExternalContentId.MOVIE", (ExternalContentId.MOVIE, ExternalContentId,), {})  # type: ignore
ExternalContentId.PAPER = type("ExternalContentId.PAPER", (ExternalContentId.PAPER, ExternalContentId,), {})  # type: ignore
ExternalContentId.BLOCKCHAIN_TRANSACTION = type("ExternalContentId.BLOCKCHAIN_TRANSACTION", (ExternalContentId.BLOCKCHAIN_TRANSACTION, ExternalContentId,), {})  # type: ignore
ExternalContentId.BLOCKCHAIN_ADDRESS = type("ExternalContentId.BLOCKCHAIN_ADDRESS", (ExternalContentId.BLOCKCHAIN_ADDRESS, ExternalContentId,), {})  # type: ignore




class _UniffiConverterTypeExternalContentId(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return ExternalContentId.URL(
                _UniffiConverterString.read(buf),
            )
        if variant == 2:
            return ExternalContentId.HASHTAG(
                _UniffiConverterString.read(buf),
            )
        if variant == 3:
            return ExternalContentId.GEOHASH(
                _UniffiConverterString.read(buf),
            )
        if variant == 4:
            return ExternalContentId.BOOK(
                _UniffiConverterString.read(buf),
            )
        if variant == 5:
            return ExternalContentId.PODCAST_FEED(
                _UniffiConverterString.read(buf),
            )
        if variant == 6:
            return ExternalContentId.PODCAST_EPISODE(
                _UniffiConverterString.read(buf),
            )
        if variant == 7:
            return ExternalContentId.PODCAST_PUBLISHER(
                _UniffiConverterString.read(buf),
            )
        if variant == 8:
            return ExternalContentId.MOVIE(
                _UniffiConverterString.read(buf),
            )
        if variant == 9:
            return ExternalContentId.PAPER(
                _UniffiConverterString.read(buf),
            )
        if variant == 10:
            return ExternalContentId.BLOCKCHAIN_TRANSACTION(
                _UniffiConverterString.read(buf),
                _UniffiConverterString.read(buf),
                _UniffiConverterOptionalString.read(buf),
            )
        if variant == 11:
            return ExternalContentId.BLOCKCHAIN_ADDRESS(
                _UniffiConverterString.read(buf),
                _UniffiConverterString.read(buf),
                _UniffiConverterOptionalString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value.is_URL():
            _UniffiConverterString.check_lower(value._values[0])
            return
        if value.is_HASHTAG():
            _UniffiConverterString.check_lower(value._values[0])
            return
        if value.is_GEOHASH():
            _UniffiConverterString.check_lower(value._values[0])
            return
        if value.is_BOOK():
            _UniffiConverterString.check_lower(value._values[0])
            return
        if value.is_PODCAST_FEED():
            _UniffiConverterString.check_lower(value._values[0])
            return
        if value.is_PODCAST_EPISODE():
            _UniffiConverterString.check_lower(value._values[0])
            return
        if value.is_PODCAST_PUBLISHER():
            _UniffiConverterString.check_lower(value._values[0])
            return
        if value.is_MOVIE():
            _UniffiConverterString.check_lower(value._values[0])
            return
        if value.is_PAPER():
            _UniffiConverterString.check_lower(value._values[0])
            return
        if value.is_BLOCKCHAIN_TRANSACTION():
            _UniffiConverterString.check_lower(value.chain)
            _UniffiConverterString.check_lower(value.transaction_hash)
            _UniffiConverterOptionalString.check_lower(value.chain_id)
            return
        if value.is_BLOCKCHAIN_ADDRESS():
            _UniffiConverterString.check_lower(value.chain)
            _UniffiConverterString.check_lower(value.address)
            _UniffiConverterOptionalString.check_lower(value.chain_id)
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value.is_URL():
            buf.write_i32(1)
            _UniffiConverterString.write(value._values[0], buf)
        if value.is_HASHTAG():
            buf.write_i32(2)
            _UniffiConverterString.write(value._values[0], buf)
        if value.is_GEOHASH():
            buf.write_i32(3)
            _UniffiConverterString.write(value._values[0], buf)
        if value.is_BOOK():
            buf.write_i32(4)
            _UniffiConverterString.write(value._values[0], buf)
        if value.is_PODCAST_FEED():
            buf.write_i32(5)
            _UniffiConverterString.write(value._values[0], buf)
        if value.is_PODCAST_EPISODE():
            buf.write_i32(6)
            _UniffiConverterString.write(value._values[0], buf)
        if value.is_PODCAST_PUBLISHER():
            buf.write_i32(7)
            _UniffiConverterString.write(value._values[0], buf)
        if value.is_MOVIE():
            buf.write_i32(8)
            _UniffiConverterString.write(value._values[0], buf)
        if value.is_PAPER():
            buf.write_i32(9)
            _UniffiConverterString.write(value._values[0], buf)
        if value.is_BLOCKCHAIN_TRANSACTION():
            buf.write_i32(10)
            _UniffiConverterString.write(value.chain, buf)
            _UniffiConverterString.write(value.transaction_hash, buf)
            _UniffiConverterOptionalString.write(value.chain_id, buf)
        if value.is_BLOCKCHAIN_ADDRESS():
            buf.write_i32(11)
            _UniffiConverterString.write(value.chain, buf)
            _UniffiConverterString.write(value.address, buf)
            _UniffiConverterOptionalString.write(value.chain_id, buf)







class ExternalIdentity(enum.Enum):
    """
    Supported external identity providers

    <https://github.com/nostr-protocol/nips/blob/master/39.md>
    """

    GIT_HUB = 0
    """
    github.com
    """

    
    TWITTER = 1
    """
    twitter.com
    """

    
    MASTODON = 2
    """
    mastodon.social
    """

    
    TELEGRAM = 3
    """
    telegram.org
    """

    


class _UniffiConverterTypeExternalIdentity(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return ExternalIdentity.GIT_HUB
        if variant == 2:
            return ExternalIdentity.TWITTER
        if variant == 3:
            return ExternalIdentity.MASTODON
        if variant == 4:
            return ExternalIdentity.TELEGRAM
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == ExternalIdentity.GIT_HUB:
            return
        if value == ExternalIdentity.TWITTER:
            return
        if value == ExternalIdentity.MASTODON:
            return
        if value == ExternalIdentity.TELEGRAM:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == ExternalIdentity.GIT_HUB:
            buf.write_i32(1)
        if value == ExternalIdentity.TWITTER:
            buf.write_i32(2)
        if value == ExternalIdentity.MASTODON:
            buf.write_i32(3)
        if value == ExternalIdentity.TELEGRAM:
            buf.write_i32(4)







class GitPatchContent:
    """
    Git Patch Content
    """

    def __init__(self):
        raise RuntimeError("GitPatchContent cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class COVER_LETTER:
        """
        Cover letter
        """

        title: "str"
        """
        Title
        """

        description: "str"
        """
        Description
        """

        last_commit: "str"
        """
        Last commit
        """

        commits_len: "int"
        """
        Number of commits
        """


        def __init__(self,title: "str", description: "str", last_commit: "str", commits_len: "int"):
            self.title = title
            self.description = description
            self.last_commit = last_commit
            self.commits_len = commits_len

        def __str__(self):
            return "GitPatchContent.COVER_LETTER(title={}, description={}, last_commit={}, commits_len={})".format(self.title, self.description, self.last_commit, self.commits_len)

        def __eq__(self, other):
            if not other.is_COVER_LETTER():
                return False
            if self.title != other.title:
                return False
            if self.description != other.description:
                return False
            if self.last_commit != other.last_commit:
                return False
            if self.commits_len != other.commits_len:
                return False
            return True
    
    class PATCH:
        """
        Patch
        """

        content: "str"
        """
        Patch content
        """

        commit: "str"
        """
        Commit hash
        """

        parent_commit: "str"
        """
        Parent commit
        """

        commit_pgp_sig: "typing.Optional[str]"
        """
        PGP signature of commit
        """

        committer: "GitPatchCommitter"
        """
        Committer
        """


        def __init__(self,content: "str", commit: "str", parent_commit: "str", commit_pgp_sig: "typing.Optional[str]", committer: "GitPatchCommitter"):
            self.content = content
            self.commit = commit
            self.parent_commit = parent_commit
            self.commit_pgp_sig = commit_pgp_sig
            self.committer = committer

        def __str__(self):
            return "GitPatchContent.PATCH(content={}, commit={}, parent_commit={}, commit_pgp_sig={}, committer={})".format(self.content, self.commit, self.parent_commit, self.commit_pgp_sig, self.committer)

        def __eq__(self, other):
            if not other.is_PATCH():
                return False
            if self.content != other.content:
                return False
            if self.commit != other.commit:
                return False
            if self.parent_commit != other.parent_commit:
                return False
            if self.commit_pgp_sig != other.commit_pgp_sig:
                return False
            if self.committer != other.committer:
                return False
            return True
    
    

    # For each variant, we have `is_NAME` and `is_name` methods for easily checking
    # whether an instance is that variant.
    def is_COVER_LETTER(self) -> bool:
        return isinstance(self, GitPatchContent.COVER_LETTER)
    def is_cover_letter(self) -> bool:
        return isinstance(self, GitPatchContent.COVER_LETTER)
    def is_PATCH(self) -> bool:
        return isinstance(self, GitPatchContent.PATCH)
    def is_patch(self) -> bool:
        return isinstance(self, GitPatchContent.PATCH)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
GitPatchContent.COVER_LETTER = type("GitPatchContent.COVER_LETTER", (GitPatchContent.COVER_LETTER, GitPatchContent,), {})  # type: ignore
GitPatchContent.PATCH = type("GitPatchContent.PATCH", (GitPatchContent.PATCH, GitPatchContent,), {})  # type: ignore




class _UniffiConverterTypeGitPatchContent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return GitPatchContent.COVER_LETTER(
                _UniffiConverterString.read(buf),
                _UniffiConverterString.read(buf),
                _UniffiConverterString.read(buf),
                _UniffiConverterUInt64.read(buf),
            )
        if variant == 2:
            return GitPatchContent.PATCH(
                _UniffiConverterString.read(buf),
                _UniffiConverterString.read(buf),
                _UniffiConverterString.read(buf),
                _UniffiConverterOptionalString.read(buf),
                _UniffiConverterTypeGitPatchCommitter.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value.is_COVER_LETTER():
            _UniffiConverterString.check_lower(value.title)
            _UniffiConverterString.check_lower(value.description)
            _UniffiConverterString.check_lower(value.last_commit)
            _UniffiConverterUInt64.check_lower(value.commits_len)
            return
        if value.is_PATCH():
            _UniffiConverterString.check_lower(value.content)
            _UniffiConverterString.check_lower(value.commit)
            _UniffiConverterString.check_lower(value.parent_commit)
            _UniffiConverterOptionalString.check_lower(value.commit_pgp_sig)
            _UniffiConverterTypeGitPatchCommitter.check_lower(value.committer)
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value.is_COVER_LETTER():
            buf.write_i32(1)
            _UniffiConverterString.write(value.title, buf)
            _UniffiConverterString.write(value.description, buf)
            _UniffiConverterString.write(value.last_commit, buf)
            _UniffiConverterUInt64.write(value.commits_len, buf)
        if value.is_PATCH():
            buf.write_i32(2)
            _UniffiConverterString.write(value.content, buf)
            _UniffiConverterString.write(value.commit, buf)
            _UniffiConverterString.write(value.parent_commit, buf)
            _UniffiConverterOptionalString.write(value.commit_pgp_sig, buf)
            _UniffiConverterTypeGitPatchCommitter.write(value.committer, buf)







class HttpMethod(enum.Enum):
    GET = 0
    
    POST = 1
    
    PUT = 2
    
    PATCH = 3
    


class _UniffiConverterTypeHttpMethod(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return HttpMethod.GET
        if variant == 2:
            return HttpMethod.POST
        if variant == 3:
            return HttpMethod.PUT
        if variant == 4:
            return HttpMethod.PATCH
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == HttpMethod.GET:
            return
        if value == HttpMethod.POST:
            return
        if value == HttpMethod.PUT:
            return
        if value == HttpMethod.PATCH:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == HttpMethod.GET:
            buf.write_i32(1)
        if value == HttpMethod.POST:
            buf.write_i32(2)
        if value == HttpMethod.PUT:
            buf.write_i32(3)
        if value == HttpMethod.PATCH:
            buf.write_i32(4)







class JsonValue:
    def __init__(self):
        raise RuntimeError("JsonValue cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class BOOL:
        bool: "bool"

        def __init__(self,bool: "bool"):
            self.bool = bool

        def __str__(self):
            return "JsonValue.BOOL(bool={})".format(self.bool)

        def __eq__(self, other):
            if not other.is_BOOL():
                return False
            if self.bool != other.bool:
                return False
            return True
    
    class NUMBER_POS_INT:
        number: "int"

        def __init__(self,number: "int"):
            self.number = number

        def __str__(self):
            return "JsonValue.NUMBER_POS_INT(number={})".format(self.number)

        def __eq__(self, other):
            if not other.is_NUMBER_POS_INT():
                return False
            if self.number != other.number:
                return False
            return True
    
    class NUMBER_NEG_INT:
        number: "int"

        def __init__(self,number: "int"):
            self.number = number

        def __str__(self):
            return "JsonValue.NUMBER_NEG_INT(number={})".format(self.number)

        def __eq__(self, other):
            if not other.is_NUMBER_NEG_INT():
                return False
            if self.number != other.number:
                return False
            return True
    
    class NUMBER_FLOAT:
        number: "float"

        def __init__(self,number: "float"):
            self.number = number

        def __str__(self):
            return "JsonValue.NUMBER_FLOAT(number={})".format(self.number)

        def __eq__(self, other):
            if not other.is_NUMBER_FLOAT():
                return False
            if self.number != other.number:
                return False
            return True
    
    class STR:
        s: "str"

        def __init__(self,s: "str"):
            self.s = s

        def __str__(self):
            return "JsonValue.STR(s={})".format(self.s)

        def __eq__(self, other):
            if not other.is_STR():
                return False
            if self.s != other.s:
                return False
            return True
    
    class ARRAY:
        array: "typing.List[JsonValue]"

        def __init__(self,array: "typing.List[JsonValue]"):
            self.array = array

        def __str__(self):
            return "JsonValue.ARRAY(array={})".format(self.array)

        def __eq__(self, other):
            if not other.is_ARRAY():
                return False
            if self.array != other.array:
                return False
            return True
    
    class OBJECT:
        map: "dict[str, JsonValue]"

        def __init__(self,map: "dict[str, JsonValue]"):
            self.map = map

        def __str__(self):
            return "JsonValue.OBJECT(map={})".format(self.map)

        def __eq__(self, other):
            if not other.is_OBJECT():
                return False
            if self.map != other.map:
                return False
            return True
    
    class NULL:

        def __init__(self,):
            pass

        def __str__(self):
            return "JsonValue.NULL()".format()

        def __eq__(self, other):
            if not other.is_NULL():
                return False
            return True
    
    

    # For each variant, we have `is_NAME` and `is_name` methods for easily checking
    # whether an instance is that variant.
    def is_BOOL(self) -> bool:
        return isinstance(self, JsonValue.BOOL)
    def is_bool(self) -> bool:
        return isinstance(self, JsonValue.BOOL)
    def is_NUMBER_POS_INT(self) -> bool:
        return isinstance(self, JsonValue.NUMBER_POS_INT)
    def is_number_pos_int(self) -> bool:
        return isinstance(self, JsonValue.NUMBER_POS_INT)
    def is_NUMBER_NEG_INT(self) -> bool:
        return isinstance(self, JsonValue.NUMBER_NEG_INT)
    def is_number_neg_int(self) -> bool:
        return isinstance(self, JsonValue.NUMBER_NEG_INT)
    def is_NUMBER_FLOAT(self) -> bool:
        return isinstance(self, JsonValue.NUMBER_FLOAT)
    def is_number_float(self) -> bool:
        return isinstance(self, JsonValue.NUMBER_FLOAT)
    def is_STR(self) -> bool:
        return isinstance(self, JsonValue.STR)
    def is_str(self) -> bool:
        return isinstance(self, JsonValue.STR)
    def is_ARRAY(self) -> bool:
        return isinstance(self, JsonValue.ARRAY)
    def is_array(self) -> bool:
        return isinstance(self, JsonValue.ARRAY)
    def is_OBJECT(self) -> bool:
        return isinstance(self, JsonValue.OBJECT)
    def is_object(self) -> bool:
        return isinstance(self, JsonValue.OBJECT)
    def is_NULL(self) -> bool:
        return isinstance(self, JsonValue.NULL)
    def is_null(self) -> bool:
        return isinstance(self, JsonValue.NULL)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
JsonValue.BOOL = type("JsonValue.BOOL", (JsonValue.BOOL, JsonValue,), {})  # type: ignore
JsonValue.NUMBER_POS_INT = type("JsonValue.NUMBER_POS_INT", (JsonValue.NUMBER_POS_INT, JsonValue,), {})  # type: ignore
JsonValue.NUMBER_NEG_INT = type("JsonValue.NUMBER_NEG_INT", (JsonValue.NUMBER_NEG_INT, JsonValue,), {})  # type: ignore
JsonValue.NUMBER_FLOAT = type("JsonValue.NUMBER_FLOAT", (JsonValue.NUMBER_FLOAT, JsonValue,), {})  # type: ignore
JsonValue.STR = type("JsonValue.STR", (JsonValue.STR, JsonValue,), {})  # type: ignore
JsonValue.ARRAY = type("JsonValue.ARRAY", (JsonValue.ARRAY, JsonValue,), {})  # type: ignore
JsonValue.OBJECT = type("JsonValue.OBJECT", (JsonValue.OBJECT, JsonValue,), {})  # type: ignore
JsonValue.NULL = type("JsonValue.NULL", (JsonValue.NULL, JsonValue,), {})  # type: ignore




class _UniffiConverterTypeJsonValue(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return JsonValue.BOOL(
                _UniffiConverterBool.read(buf),
            )
        if variant == 2:
            return JsonValue.NUMBER_POS_INT(
                _UniffiConverterUInt64.read(buf),
            )
        if variant == 3:
            return JsonValue.NUMBER_NEG_INT(
                _UniffiConverterInt64.read(buf),
            )
        if variant == 4:
            return JsonValue.NUMBER_FLOAT(
                _UniffiConverterDouble.read(buf),
            )
        if variant == 5:
            return JsonValue.STR(
                _UniffiConverterString.read(buf),
            )
        if variant == 6:
            return JsonValue.ARRAY(
                _UniffiConverterSequenceTypeJsonValue.read(buf),
            )
        if variant == 7:
            return JsonValue.OBJECT(
                _UniffiConverterMapStringTypeJsonValue.read(buf),
            )
        if variant == 8:
            return JsonValue.NULL(
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value.is_BOOL():
            _UniffiConverterBool.check_lower(value.bool)
            return
        if value.is_NUMBER_POS_INT():
            _UniffiConverterUInt64.check_lower(value.number)
            return
        if value.is_NUMBER_NEG_INT():
            _UniffiConverterInt64.check_lower(value.number)
            return
        if value.is_NUMBER_FLOAT():
            _UniffiConverterDouble.check_lower(value.number)
            return
        if value.is_STR():
            _UniffiConverterString.check_lower(value.s)
            return
        if value.is_ARRAY():
            _UniffiConverterSequenceTypeJsonValue.check_lower(value.array)
            return
        if value.is_OBJECT():
            _UniffiConverterMapStringTypeJsonValue.check_lower(value.map)
            return
        if value.is_NULL():
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value.is_BOOL():
            buf.write_i32(1)
            _UniffiConverterBool.write(value.bool, buf)
        if value.is_NUMBER_POS_INT():
            buf.write_i32(2)
            _UniffiConverterUInt64.write(value.number, buf)
        if value.is_NUMBER_NEG_INT():
            buf.write_i32(3)
            _UniffiConverterInt64.write(value.number, buf)
        if value.is_NUMBER_FLOAT():
            buf.write_i32(4)
            _UniffiConverterDouble.write(value.number, buf)
        if value.is_STR():
            buf.write_i32(5)
            _UniffiConverterString.write(value.s, buf)
        if value.is_ARRAY():
            buf.write_i32(6)
            _UniffiConverterSequenceTypeJsonValue.write(value.array, buf)
        if value.is_OBJECT():
            buf.write_i32(7)
            _UniffiConverterMapStringTypeJsonValue.write(value.map, buf)
        if value.is_NULL():
            buf.write_i32(8)







class KeySecurity(enum.Enum):
    """
    Key security
    """

    WEAK = 0
    """
    The key has been known to have been handled insecurely (stored unencrypted, cut and paste unencrypted, etc)
    """

    
    MEDIUM = 1
    """
    The key has NOT been known to have been handled insecurely (stored encrypted, cut and paste encrypted, etc)
    """

    
    UNKNOWN = 2
    """
    The client does not track this data
    """

    


class _UniffiConverterTypeKeySecurity(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return KeySecurity.WEAK
        if variant == 2:
            return KeySecurity.MEDIUM
        if variant == 3:
            return KeySecurity.UNKNOWN
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == KeySecurity.WEAK:
            return
        if value == KeySecurity.MEDIUM:
            return
        if value == KeySecurity.UNKNOWN:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == KeySecurity.WEAK:
            buf.write_i32(1)
        if value == KeySecurity.MEDIUM:
            buf.write_i32(2)
        if value == KeySecurity.UNKNOWN:
            buf.write_i32(3)







class KindStandard(enum.Enum):
    """
    Standardized kind
    """

    METADATA = 0
    """
    Metadata (NIP01 and NIP05)
    """

    
    TEXT_NOTE = 1
    """
    Short Text Note (NIP01)
    """

    
    CONTACT_LIST = 2
    """
    Contacts (NIP02)
    """

    
    OPEN_TIMESTAMPS = 3
    """
    OpenTimestamps Attestations (NIP03)
    """

    
    EVENT_DELETION = 4
    """
    Event Deletion (NIP09)
    """

    
    REPOST = 5
    """
    Repost (NIP18)
    """

    
    GENERIC_REPOST = 6
    """
    Generic Repost (NIP18)
    """

    
    COMMENT = 7
    """
    Comment (NIP22)
    """

    
    REACTION = 8
    """
    Reaction (NIP25)
    """

    
    BADGE_AWARD = 9
    """
    Badge Award (NIP58)
    """

    
    BLOSSOM_AUTH = 10
    """
    Blossom Authorization
    """

    
    CHANNEL_CREATION = 11
    """
    Channel Creation (NIP28)
    """

    
    CHANNEL_METADATA = 12
    """
    Channel Metadata (NIP28)
    """

    
    CHANNEL_MESSAGE = 13
    """
    Channel Message (NIP28)
    """

    
    CHANNEL_HIDE_MESSAGE = 14
    """
    Channel Hide Message (NIP28)
    """

    
    CHANNEL_MUTE_USER = 15
    """
    Channel Mute User (NIP28)
    """

    
    GIT_PATCH = 16
    """
    Git Patch

    <https://github.com/nostr-protocol/nips/blob/master/34.md>
    """

    
    GIT_ISSUE = 17
    """
    Git Issue

    <https://github.com/nostr-protocol/nips/blob/master/34.md>
    """

    
    GIT_REPLY = 18
    """
    Git Reply

    <https://github.com/nostr-protocol/nips/blob/master/34.md>
    """

    
    GIT_STATUS_OPEN = 19
    """
    Open Status of Git Patch or Issue

    <https://github.com/nostr-protocol/nips/blob/master/34.md>
    """

    
    GIT_STATUS_APPLIED = 20
    """
    Applied / Merged Status of Git Patch or Resolved Status of Git Issue

    <https://github.com/nostr-protocol/nips/blob/master/34.md>
    """

    
    GIT_STATUS_CLOSED = 21
    """
    Closed Status of Git Patch or Issue

    <https://github.com/nostr-protocol/nips/blob/master/34.md>
    """

    
    GIT_STATUS_DRAFT = 22
    """
    Draft Status of Git Patch or Issue

    <https://github.com/nostr-protocol/nips/blob/master/34.md>
    """

    
    TORRENT = 23
    """
    Torrent

    <https://github.com/nostr-protocol/nips/blob/master/35.md>
    """

    
    TORRENT_COMMENT = 24
    """
    Torrent comment

    <https://github.com/nostr-protocol/nips/blob/master/35.md>
    """

    
    LABEL = 25
    """
    Label

    <https://github.com/nostr-protocol/nips/blob/master/32.md>
    """

    
    WALLET_CONNECT_INFO = 26
    """
    Wallet Service Info (NIP47)
    """

    
    WALLET_CONNECT_NOTIFICATION = 27
    """
    Wallet Connect notification (NIP47)
    """

    
    REPORTING = 28
    """
    Reporting (NIP56)
    """

    
    ZAP_PRIVATE_MESSAGE = 29
    """
    Zap Private Message (NIP57)
    """

    
    ZAP_REQUEST = 30
    """
    Zap Request (NIP57)
    """

    
    ZAP_RECEIPT = 31
    """
    Zap Receipt (NIP57)
    """

    
    MUTE_LIST = 32
    """
    Mute List

    <https://github.com/nostr-protocol/nips/blob/master/51.md>
    """

    
    PIN_LIST = 33
    """
    Pin List

    <https://github.com/nostr-protocol/nips/blob/master/51.md>
    """

    
    BOOKMARKS = 34
    """
    Bookmarks

    <https://github.com/nostr-protocol/nips/blob/master/51.md>
    """

    
    COMMUNITIES = 35
    """
    Communities

    <https://github.com/nostr-protocol/nips/blob/master/51.md>
    """

    
    PUBLIC_CHATS = 36
    """
    Public Chats

    <https://github.com/nostr-protocol/nips/blob/master/51.md>
    """

    
    BLOCKED_RELAYS = 37
    """
    Blocked Relays

    <https://github.com/nostr-protocol/nips/blob/master/51.md>
    """

    
    SEARCH_RELAYS = 38
    """
    Search Relays

    <https://github.com/nostr-protocol/nips/blob/master/51.md>
    """

    
    SIMPLE_GROUPS = 39
    """
    Simple Groups

    <https://github.com/nostr-protocol/nips/blob/master/51.md>
    """

    
    INTERESTS = 40
    """
    Interests

    <https://github.com/nostr-protocol/nips/blob/master/51.md>
    """

    
    EMOJIS = 41
    """
    Emojis

    <https://github.com/nostr-protocol/nips/blob/master/51.md>
    """

    
    FOLLOW_SET = 42
    """
    Follow Set

    <https://github.com/nostr-protocol/nips/blob/master/51.md>
    """

    
    RELAY_SET = 43
    """
    Relay Set

    <https://github.com/nostr-protocol/nips/blob/master/51.md>
    """

    
    BOOKMARK_SET = 44
    """
    Bookmark Set

    <https://github.com/nostr-protocol/nips/blob/master/51.md>
    """

    
    ARTICLES_CURATION_SET = 45
    """
    Articles Curation Set

    <https://github.com/nostr-protocol/nips/blob/master/51.md>
    """

    
    VIDEOS_CURATION_SET = 46
    """
    Videos Curation Set

    <https://github.com/nostr-protocol/nips/blob/master/51.md>
    """

    
    INTEREST_SET = 47
    """
    Interest Set

    <https://github.com/nostr-protocol/nips/blob/master/51.md>
    """

    
    EMOJI_SET = 48
    """
    Emoji Set

    <https://github.com/nostr-protocol/nips/blob/master/51.md>
    """

    
    RELEASE_ARTIFACT_SET = 49
    """
    Release Artifact Set

    <https://github.com/nostr-protocol/nips/blob/master/51.md>
    """

    
    RELAY_LIST = 50
    """
    Relay List Metadata (NIP65)
    """

    
    PEER_TO_PEER_ORDER = 51
    """
    Peer-to-peer Order events

    <https://github.com/nostr-protocol/nips/blob/master/69.md>
    """

    
    REQUEST_TO_VANISH = 52
    """
    Request to Vanish (NIP62)

    <https://github.com/nostr-protocol/nips/blob/master/62.md>
    """

    
    AUTHENTICATION = 53
    """
    Client Authentication (NIP42)
    """

    
    WALLET_CONNECT_REQUEST = 54
    """
    Wallet Connect Request (NIP47)
    """

    
    WALLET_CONNECT_RESPONSE = 55
    """
    Wallet Connect Response (NIP47)
    """

    
    NOSTR_CONNECT = 56
    """
    Nostr Connect (NIP46)
    """

    
    LIVE_EVENT = 57
    """
    Live Event (NIP53)
    """

    
    LIVE_EVENT_MESSAGE = 58
    """
    Live Event Message (NIP53)
    """

    
    PROFILE_BADGES = 59
    """
    Profile Badges (NIP58)
    """

    
    BADGE_DEFINITION = 60
    """
    Badge Definition (NIP58)
    """

    
    SEAL = 61
    """
    Seal (NIP59)
    """

    
    GIFT_WRAP = 62
    """
    Gift Wrap (NIP59)
    """

    
    PRIVATE_DIRECT_MESSAGE = 63
    """
    Private Direct message

    <https://github.com/nostr-protocol/nips/blob/master/17.md>
    """

    
    INBOX_RELAYS = 64
    """
    Inbox Relays (NIP17)
    """

    
    MLS_KEY_PACKAGE_RELAYS = 65
    """
    MLS Key Package Relays (NIP104)
    """

    
    MLS_KEY_PACKAGE = 66
    """
    MLS Key Package (NIP104)
    """

    
    MLS_WELCOME = 67
    """
    MLS Welcome (NIP104)
    """

    
    MLS_GROUP_MESSAGE = 68
    """
    MLS Group Message (NIP104)
    """

    
    LONG_FORM_TEXT_NOTE = 69
    """
    Long-form Text Note (NIP23)
    """

    
    GIT_REPO_ANNOUNCEMENT = 70
    """
    Git Repository Announcement

    <https://github.com/nostr-protocol/nips/blob/master/34.md>
    """

    
    APPLICATION_SPECIFIC_DATA = 71
    """
    Application-specific Data (NIP78)
    """

    
    FILE_METADATA = 72
    """
    File Metadata (NIP94)
    """

    
    HTTP_AUTH = 73
    """
    HTTP Auth (NIP98)
    """

    
    SET_STALL = 74
    """
    Set stall (NIP15)
    """

    
    SET_PRODUCT = 75
    """
    Set product (NIP15)
    """

    
    JOB_FEEDBACK = 76
    """
    Job Feedback (NIP90)
    """

    
    USER_STATUS = 77
    """
    User Status

    <https://github.com/nostr-protocol/nips/blob/master/38.md>
    """

    
    CASHU_WALLET = 78
    """
    Cashu Wallet

    <https://github.com/nostr-protocol/nips/blob/master/60.md>
    """

    
    CASHU_WALLET_UNSPENT_PROOF = 79
    """
    Cashu Wallet Unspent Proof

    <https://github.com/nostr-protocol/nips/blob/master/60.md>
    """

    
    CASHU_WALLET_SPENDING_HISTORY = 80
    """
    Cashu Wallet Spending History

    <https://github.com/nostr-protocol/nips/blob/master/60.md>
    """

    
    CASHU_WALLET_QUOTE = 81
    """
    Cashu Wallet Redeeming a quote
    """

    
    CASHU_NUT_ZAP_INFO = 82
    """
    Cashu Nut Zap informational event
    """

    
    CASHU_NUT_ZAP = 83
    """
    Cashu Nut Zap
    """

    
    CODE_SNIPPET = 84
    """
    Code Snippet

    <https://github.com/nostr-protocol/nips/blob/master/C0.md>
    """

    
    POLL = 85
    """
    Poll

    <https://github.com/nostr-protocol/nips/blob/master/88.md>
    """

    
    POLL_RESPONSE = 86
    """
    Poll response

    <https://github.com/nostr-protocol/nips/blob/master/88.md>
    """

    
    REPO_STATE = 87
    
    VOICE_MESSAGE = 88
    
    VOICE_MESSAGE_REPLY = 89
    
    THREAD = 90
    
    WEB_BOOKMARK = 91
    
    CHAT_MESSAGE = 92
    


class _UniffiConverterTypeKindStandard(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return KindStandard.METADATA
        if variant == 2:
            return KindStandard.TEXT_NOTE
        if variant == 3:
            return KindStandard.CONTACT_LIST
        if variant == 4:
            return KindStandard.OPEN_TIMESTAMPS
        if variant == 5:
            return KindStandard.EVENT_DELETION
        if variant == 6:
            return KindStandard.REPOST
        if variant == 7:
            return KindStandard.GENERIC_REPOST
        if variant == 8:
            return KindStandard.COMMENT
        if variant == 9:
            return KindStandard.REACTION
        if variant == 10:
            return KindStandard.BADGE_AWARD
        if variant == 11:
            return KindStandard.BLOSSOM_AUTH
        if variant == 12:
            return KindStandard.CHANNEL_CREATION
        if variant == 13:
            return KindStandard.CHANNEL_METADATA
        if variant == 14:
            return KindStandard.CHANNEL_MESSAGE
        if variant == 15:
            return KindStandard.CHANNEL_HIDE_MESSAGE
        if variant == 16:
            return KindStandard.CHANNEL_MUTE_USER
        if variant == 17:
            return KindStandard.GIT_PATCH
        if variant == 18:
            return KindStandard.GIT_ISSUE
        if variant == 19:
            return KindStandard.GIT_REPLY
        if variant == 20:
            return KindStandard.GIT_STATUS_OPEN
        if variant == 21:
            return KindStandard.GIT_STATUS_APPLIED
        if variant == 22:
            return KindStandard.GIT_STATUS_CLOSED
        if variant == 23:
            return KindStandard.GIT_STATUS_DRAFT
        if variant == 24:
            return KindStandard.TORRENT
        if variant == 25:
            return KindStandard.TORRENT_COMMENT
        if variant == 26:
            return KindStandard.LABEL
        if variant == 27:
            return KindStandard.WALLET_CONNECT_INFO
        if variant == 28:
            return KindStandard.WALLET_CONNECT_NOTIFICATION
        if variant == 29:
            return KindStandard.REPORTING
        if variant == 30:
            return KindStandard.ZAP_PRIVATE_MESSAGE
        if variant == 31:
            return KindStandard.ZAP_REQUEST
        if variant == 32:
            return KindStandard.ZAP_RECEIPT
        if variant == 33:
            return KindStandard.MUTE_LIST
        if variant == 34:
            return KindStandard.PIN_LIST
        if variant == 35:
            return KindStandard.BOOKMARKS
        if variant == 36:
            return KindStandard.COMMUNITIES
        if variant == 37:
            return KindStandard.PUBLIC_CHATS
        if variant == 38:
            return KindStandard.BLOCKED_RELAYS
        if variant == 39:
            return KindStandard.SEARCH_RELAYS
        if variant == 40:
            return KindStandard.SIMPLE_GROUPS
        if variant == 41:
            return KindStandard.INTERESTS
        if variant == 42:
            return KindStandard.EMOJIS
        if variant == 43:
            return KindStandard.FOLLOW_SET
        if variant == 44:
            return KindStandard.RELAY_SET
        if variant == 45:
            return KindStandard.BOOKMARK_SET
        if variant == 46:
            return KindStandard.ARTICLES_CURATION_SET
        if variant == 47:
            return KindStandard.VIDEOS_CURATION_SET
        if variant == 48:
            return KindStandard.INTEREST_SET
        if variant == 49:
            return KindStandard.EMOJI_SET
        if variant == 50:
            return KindStandard.RELEASE_ARTIFACT_SET
        if variant == 51:
            return KindStandard.RELAY_LIST
        if variant == 52:
            return KindStandard.PEER_TO_PEER_ORDER
        if variant == 53:
            return KindStandard.REQUEST_TO_VANISH
        if variant == 54:
            return KindStandard.AUTHENTICATION
        if variant == 55:
            return KindStandard.WALLET_CONNECT_REQUEST
        if variant == 56:
            return KindStandard.WALLET_CONNECT_RESPONSE
        if variant == 57:
            return KindStandard.NOSTR_CONNECT
        if variant == 58:
            return KindStandard.LIVE_EVENT
        if variant == 59:
            return KindStandard.LIVE_EVENT_MESSAGE
        if variant == 60:
            return KindStandard.PROFILE_BADGES
        if variant == 61:
            return KindStandard.BADGE_DEFINITION
        if variant == 62:
            return KindStandard.SEAL
        if variant == 63:
            return KindStandard.GIFT_WRAP
        if variant == 64:
            return KindStandard.PRIVATE_DIRECT_MESSAGE
        if variant == 65:
            return KindStandard.INBOX_RELAYS
        if variant == 66:
            return KindStandard.MLS_KEY_PACKAGE_RELAYS
        if variant == 67:
            return KindStandard.MLS_KEY_PACKAGE
        if variant == 68:
            return KindStandard.MLS_WELCOME
        if variant == 69:
            return KindStandard.MLS_GROUP_MESSAGE
        if variant == 70:
            return KindStandard.LONG_FORM_TEXT_NOTE
        if variant == 71:
            return KindStandard.GIT_REPO_ANNOUNCEMENT
        if variant == 72:
            return KindStandard.APPLICATION_SPECIFIC_DATA
        if variant == 73:
            return KindStandard.FILE_METADATA
        if variant == 74:
            return KindStandard.HTTP_AUTH
        if variant == 75:
            return KindStandard.SET_STALL
        if variant == 76:
            return KindStandard.SET_PRODUCT
        if variant == 77:
            return KindStandard.JOB_FEEDBACK
        if variant == 78:
            return KindStandard.USER_STATUS
        if variant == 79:
            return KindStandard.CASHU_WALLET
        if variant == 80:
            return KindStandard.CASHU_WALLET_UNSPENT_PROOF
        if variant == 81:
            return KindStandard.CASHU_WALLET_SPENDING_HISTORY
        if variant == 82:
            return KindStandard.CASHU_WALLET_QUOTE
        if variant == 83:
            return KindStandard.CASHU_NUT_ZAP_INFO
        if variant == 84:
            return KindStandard.CASHU_NUT_ZAP
        if variant == 85:
            return KindStandard.CODE_SNIPPET
        if variant == 86:
            return KindStandard.POLL
        if variant == 87:
            return KindStandard.POLL_RESPONSE
        if variant == 88:
            return KindStandard.REPO_STATE
        if variant == 89:
            return KindStandard.VOICE_MESSAGE
        if variant == 90:
            return KindStandard.VOICE_MESSAGE_REPLY
        if variant == 91:
            return KindStandard.THREAD
        if variant == 92:
            return KindStandard.WEB_BOOKMARK
        if variant == 93:
            return KindStandard.CHAT_MESSAGE
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == KindStandard.METADATA:
            return
        if value == KindStandard.TEXT_NOTE:
            return
        if value == KindStandard.CONTACT_LIST:
            return
        if value == KindStandard.OPEN_TIMESTAMPS:
            return
        if value == KindStandard.EVENT_DELETION:
            return
        if value == KindStandard.REPOST:
            return
        if value == KindStandard.GENERIC_REPOST:
            return
        if value == KindStandard.COMMENT:
            return
        if value == KindStandard.REACTION:
            return
        if value == KindStandard.BADGE_AWARD:
            return
        if value == KindStandard.BLOSSOM_AUTH:
            return
        if value == KindStandard.CHANNEL_CREATION:
            return
        if value == KindStandard.CHANNEL_METADATA:
            return
        if value == KindStandard.CHANNEL_MESSAGE:
            return
        if value == KindStandard.CHANNEL_HIDE_MESSAGE:
            return
        if value == KindStandard.CHANNEL_MUTE_USER:
            return
        if value == KindStandard.GIT_PATCH:
            return
        if value == KindStandard.GIT_ISSUE:
            return
        if value == KindStandard.GIT_REPLY:
            return
        if value == KindStandard.GIT_STATUS_OPEN:
            return
        if value == KindStandard.GIT_STATUS_APPLIED:
            return
        if value == KindStandard.GIT_STATUS_CLOSED:
            return
        if value == KindStandard.GIT_STATUS_DRAFT:
            return
        if value == KindStandard.TORRENT:
            return
        if value == KindStandard.TORRENT_COMMENT:
            return
        if value == KindStandard.LABEL:
            return
        if value == KindStandard.WALLET_CONNECT_INFO:
            return
        if value == KindStandard.WALLET_CONNECT_NOTIFICATION:
            return
        if value == KindStandard.REPORTING:
            return
        if value == KindStandard.ZAP_PRIVATE_MESSAGE:
            return
        if value == KindStandard.ZAP_REQUEST:
            return
        if value == KindStandard.ZAP_RECEIPT:
            return
        if value == KindStandard.MUTE_LIST:
            return
        if value == KindStandard.PIN_LIST:
            return
        if value == KindStandard.BOOKMARKS:
            return
        if value == KindStandard.COMMUNITIES:
            return
        if value == KindStandard.PUBLIC_CHATS:
            return
        if value == KindStandard.BLOCKED_RELAYS:
            return
        if value == KindStandard.SEARCH_RELAYS:
            return
        if value == KindStandard.SIMPLE_GROUPS:
            return
        if value == KindStandard.INTERESTS:
            return
        if value == KindStandard.EMOJIS:
            return
        if value == KindStandard.FOLLOW_SET:
            return
        if value == KindStandard.RELAY_SET:
            return
        if value == KindStandard.BOOKMARK_SET:
            return
        if value == KindStandard.ARTICLES_CURATION_SET:
            return
        if value == KindStandard.VIDEOS_CURATION_SET:
            return
        if value == KindStandard.INTEREST_SET:
            return
        if value == KindStandard.EMOJI_SET:
            return
        if value == KindStandard.RELEASE_ARTIFACT_SET:
            return
        if value == KindStandard.RELAY_LIST:
            return
        if value == KindStandard.PEER_TO_PEER_ORDER:
            return
        if value == KindStandard.REQUEST_TO_VANISH:
            return
        if value == KindStandard.AUTHENTICATION:
            return
        if value == KindStandard.WALLET_CONNECT_REQUEST:
            return
        if value == KindStandard.WALLET_CONNECT_RESPONSE:
            return
        if value == KindStandard.NOSTR_CONNECT:
            return
        if value == KindStandard.LIVE_EVENT:
            return
        if value == KindStandard.LIVE_EVENT_MESSAGE:
            return
        if value == KindStandard.PROFILE_BADGES:
            return
        if value == KindStandard.BADGE_DEFINITION:
            return
        if value == KindStandard.SEAL:
            return
        if value == KindStandard.GIFT_WRAP:
            return
        if value == KindStandard.PRIVATE_DIRECT_MESSAGE:
            return
        if value == KindStandard.INBOX_RELAYS:
            return
        if value == KindStandard.MLS_KEY_PACKAGE_RELAYS:
            return
        if value == KindStandard.MLS_KEY_PACKAGE:
            return
        if value == KindStandard.MLS_WELCOME:
            return
        if value == KindStandard.MLS_GROUP_MESSAGE:
            return
        if value == KindStandard.LONG_FORM_TEXT_NOTE:
            return
        if value == KindStandard.GIT_REPO_ANNOUNCEMENT:
            return
        if value == KindStandard.APPLICATION_SPECIFIC_DATA:
            return
        if value == KindStandard.FILE_METADATA:
            return
        if value == KindStandard.HTTP_AUTH:
            return
        if value == KindStandard.SET_STALL:
            return
        if value == KindStandard.SET_PRODUCT:
            return
        if value == KindStandard.JOB_FEEDBACK:
            return
        if value == KindStandard.USER_STATUS:
            return
        if value == KindStandard.CASHU_WALLET:
            return
        if value == KindStandard.CASHU_WALLET_UNSPENT_PROOF:
            return
        if value == KindStandard.CASHU_WALLET_SPENDING_HISTORY:
            return
        if value == KindStandard.CASHU_WALLET_QUOTE:
            return
        if value == KindStandard.CASHU_NUT_ZAP_INFO:
            return
        if value == KindStandard.CASHU_NUT_ZAP:
            return
        if value == KindStandard.CODE_SNIPPET:
            return
        if value == KindStandard.POLL:
            return
        if value == KindStandard.POLL_RESPONSE:
            return
        if value == KindStandard.REPO_STATE:
            return
        if value == KindStandard.VOICE_MESSAGE:
            return
        if value == KindStandard.VOICE_MESSAGE_REPLY:
            return
        if value == KindStandard.THREAD:
            return
        if value == KindStandard.WEB_BOOKMARK:
            return
        if value == KindStandard.CHAT_MESSAGE:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == KindStandard.METADATA:
            buf.write_i32(1)
        if value == KindStandard.TEXT_NOTE:
            buf.write_i32(2)
        if value == KindStandard.CONTACT_LIST:
            buf.write_i32(3)
        if value == KindStandard.OPEN_TIMESTAMPS:
            buf.write_i32(4)
        if value == KindStandard.EVENT_DELETION:
            buf.write_i32(5)
        if value == KindStandard.REPOST:
            buf.write_i32(6)
        if value == KindStandard.GENERIC_REPOST:
            buf.write_i32(7)
        if value == KindStandard.COMMENT:
            buf.write_i32(8)
        if value == KindStandard.REACTION:
            buf.write_i32(9)
        if value == KindStandard.BADGE_AWARD:
            buf.write_i32(10)
        if value == KindStandard.BLOSSOM_AUTH:
            buf.write_i32(11)
        if value == KindStandard.CHANNEL_CREATION:
            buf.write_i32(12)
        if value == KindStandard.CHANNEL_METADATA:
            buf.write_i32(13)
        if value == KindStandard.CHANNEL_MESSAGE:
            buf.write_i32(14)
        if value == KindStandard.CHANNEL_HIDE_MESSAGE:
            buf.write_i32(15)
        if value == KindStandard.CHANNEL_MUTE_USER:
            buf.write_i32(16)
        if value == KindStandard.GIT_PATCH:
            buf.write_i32(17)
        if value == KindStandard.GIT_ISSUE:
            buf.write_i32(18)
        if value == KindStandard.GIT_REPLY:
            buf.write_i32(19)
        if value == KindStandard.GIT_STATUS_OPEN:
            buf.write_i32(20)
        if value == KindStandard.GIT_STATUS_APPLIED:
            buf.write_i32(21)
        if value == KindStandard.GIT_STATUS_CLOSED:
            buf.write_i32(22)
        if value == KindStandard.GIT_STATUS_DRAFT:
            buf.write_i32(23)
        if value == KindStandard.TORRENT:
            buf.write_i32(24)
        if value == KindStandard.TORRENT_COMMENT:
            buf.write_i32(25)
        if value == KindStandard.LABEL:
            buf.write_i32(26)
        if value == KindStandard.WALLET_CONNECT_INFO:
            buf.write_i32(27)
        if value == KindStandard.WALLET_CONNECT_NOTIFICATION:
            buf.write_i32(28)
        if value == KindStandard.REPORTING:
            buf.write_i32(29)
        if value == KindStandard.ZAP_PRIVATE_MESSAGE:
            buf.write_i32(30)
        if value == KindStandard.ZAP_REQUEST:
            buf.write_i32(31)
        if value == KindStandard.ZAP_RECEIPT:
            buf.write_i32(32)
        if value == KindStandard.MUTE_LIST:
            buf.write_i32(33)
        if value == KindStandard.PIN_LIST:
            buf.write_i32(34)
        if value == KindStandard.BOOKMARKS:
            buf.write_i32(35)
        if value == KindStandard.COMMUNITIES:
            buf.write_i32(36)
        if value == KindStandard.PUBLIC_CHATS:
            buf.write_i32(37)
        if value == KindStandard.BLOCKED_RELAYS:
            buf.write_i32(38)
        if value == KindStandard.SEARCH_RELAYS:
            buf.write_i32(39)
        if value == KindStandard.SIMPLE_GROUPS:
            buf.write_i32(40)
        if value == KindStandard.INTERESTS:
            buf.write_i32(41)
        if value == KindStandard.EMOJIS:
            buf.write_i32(42)
        if value == KindStandard.FOLLOW_SET:
            buf.write_i32(43)
        if value == KindStandard.RELAY_SET:
            buf.write_i32(44)
        if value == KindStandard.BOOKMARK_SET:
            buf.write_i32(45)
        if value == KindStandard.ARTICLES_CURATION_SET:
            buf.write_i32(46)
        if value == KindStandard.VIDEOS_CURATION_SET:
            buf.write_i32(47)
        if value == KindStandard.INTEREST_SET:
            buf.write_i32(48)
        if value == KindStandard.EMOJI_SET:
            buf.write_i32(49)
        if value == KindStandard.RELEASE_ARTIFACT_SET:
            buf.write_i32(50)
        if value == KindStandard.RELAY_LIST:
            buf.write_i32(51)
        if value == KindStandard.PEER_TO_PEER_ORDER:
            buf.write_i32(52)
        if value == KindStandard.REQUEST_TO_VANISH:
            buf.write_i32(53)
        if value == KindStandard.AUTHENTICATION:
            buf.write_i32(54)
        if value == KindStandard.WALLET_CONNECT_REQUEST:
            buf.write_i32(55)
        if value == KindStandard.WALLET_CONNECT_RESPONSE:
            buf.write_i32(56)
        if value == KindStandard.NOSTR_CONNECT:
            buf.write_i32(57)
        if value == KindStandard.LIVE_EVENT:
            buf.write_i32(58)
        if value == KindStandard.LIVE_EVENT_MESSAGE:
            buf.write_i32(59)
        if value == KindStandard.PROFILE_BADGES:
            buf.write_i32(60)
        if value == KindStandard.BADGE_DEFINITION:
            buf.write_i32(61)
        if value == KindStandard.SEAL:
            buf.write_i32(62)
        if value == KindStandard.GIFT_WRAP:
            buf.write_i32(63)
        if value == KindStandard.PRIVATE_DIRECT_MESSAGE:
            buf.write_i32(64)
        if value == KindStandard.INBOX_RELAYS:
            buf.write_i32(65)
        if value == KindStandard.MLS_KEY_PACKAGE_RELAYS:
            buf.write_i32(66)
        if value == KindStandard.MLS_KEY_PACKAGE:
            buf.write_i32(67)
        if value == KindStandard.MLS_WELCOME:
            buf.write_i32(68)
        if value == KindStandard.MLS_GROUP_MESSAGE:
            buf.write_i32(69)
        if value == KindStandard.LONG_FORM_TEXT_NOTE:
            buf.write_i32(70)
        if value == KindStandard.GIT_REPO_ANNOUNCEMENT:
            buf.write_i32(71)
        if value == KindStandard.APPLICATION_SPECIFIC_DATA:
            buf.write_i32(72)
        if value == KindStandard.FILE_METADATA:
            buf.write_i32(73)
        if value == KindStandard.HTTP_AUTH:
            buf.write_i32(74)
        if value == KindStandard.SET_STALL:
            buf.write_i32(75)
        if value == KindStandard.SET_PRODUCT:
            buf.write_i32(76)
        if value == KindStandard.JOB_FEEDBACK:
            buf.write_i32(77)
        if value == KindStandard.USER_STATUS:
            buf.write_i32(78)
        if value == KindStandard.CASHU_WALLET:
            buf.write_i32(79)
        if value == KindStandard.CASHU_WALLET_UNSPENT_PROOF:
            buf.write_i32(80)
        if value == KindStandard.CASHU_WALLET_SPENDING_HISTORY:
            buf.write_i32(81)
        if value == KindStandard.CASHU_WALLET_QUOTE:
            buf.write_i32(82)
        if value == KindStandard.CASHU_NUT_ZAP_INFO:
            buf.write_i32(83)
        if value == KindStandard.CASHU_NUT_ZAP:
            buf.write_i32(84)
        if value == KindStandard.CODE_SNIPPET:
            buf.write_i32(85)
        if value == KindStandard.POLL:
            buf.write_i32(86)
        if value == KindStandard.POLL_RESPONSE:
            buf.write_i32(87)
        if value == KindStandard.REPO_STATE:
            buf.write_i32(88)
        if value == KindStandard.VOICE_MESSAGE:
            buf.write_i32(89)
        if value == KindStandard.VOICE_MESSAGE_REPLY:
            buf.write_i32(90)
        if value == KindStandard.THREAD:
            buf.write_i32(91)
        if value == KindStandard.WEB_BOOKMARK:
            buf.write_i32(92)
        if value == KindStandard.CHAT_MESSAGE:
            buf.write_i32(93)







class LiveEventMarker(enum.Enum):
    """
    Live Event Marker
    """

    HOST = 0
    """
    Host
    """

    
    SPEAKER = 1
    """
    Speaker
    """

    
    PARTICIPANT = 2
    """
    Participant
    """

    


class _UniffiConverterTypeLiveEventMarker(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return LiveEventMarker.HOST
        if variant == 2:
            return LiveEventMarker.SPEAKER
        if variant == 3:
            return LiveEventMarker.PARTICIPANT
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == LiveEventMarker.HOST:
            return
        if value == LiveEventMarker.SPEAKER:
            return
        if value == LiveEventMarker.PARTICIPANT:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == LiveEventMarker.HOST:
            buf.write_i32(1)
        if value == LiveEventMarker.SPEAKER:
            buf.write_i32(2)
        if value == LiveEventMarker.PARTICIPANT:
            buf.write_i32(3)







class LiveEventStatus:
    def __init__(self):
        raise RuntimeError("LiveEventStatus cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class PLANNED:

        def __init__(self,):
            pass

        def __str__(self):
            return "LiveEventStatus.PLANNED()".format()

        def __eq__(self, other):
            if not other.is_PLANNED():
                return False
            return True
    
    class LIVE:

        def __init__(self,):
            pass

        def __str__(self):
            return "LiveEventStatus.LIVE()".format()

        def __eq__(self, other):
            if not other.is_LIVE():
                return False
            return True
    
    class ENDED:

        def __init__(self,):
            pass

        def __str__(self):
            return "LiveEventStatus.ENDED()".format()

        def __eq__(self, other):
            if not other.is_ENDED():
                return False
            return True
    
    class CUSTOM:
        custom: "str"

        def __init__(self,custom: "str"):
            self.custom = custom

        def __str__(self):
            return "LiveEventStatus.CUSTOM(custom={})".format(self.custom)

        def __eq__(self, other):
            if not other.is_CUSTOM():
                return False
            if self.custom != other.custom:
                return False
            return True
    
    

    # For each variant, we have `is_NAME` and `is_name` methods for easily checking
    # whether an instance is that variant.
    def is_PLANNED(self) -> bool:
        return isinstance(self, LiveEventStatus.PLANNED)
    def is_planned(self) -> bool:
        return isinstance(self, LiveEventStatus.PLANNED)
    def is_LIVE(self) -> bool:
        return isinstance(self, LiveEventStatus.LIVE)
    def is_live(self) -> bool:
        return isinstance(self, LiveEventStatus.LIVE)
    def is_ENDED(self) -> bool:
        return isinstance(self, LiveEventStatus.ENDED)
    def is_ended(self) -> bool:
        return isinstance(self, LiveEventStatus.ENDED)
    def is_CUSTOM(self) -> bool:
        return isinstance(self, LiveEventStatus.CUSTOM)
    def is_custom(self) -> bool:
        return isinstance(self, LiveEventStatus.CUSTOM)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
LiveEventStatus.PLANNED = type("LiveEventStatus.PLANNED", (LiveEventStatus.PLANNED, LiveEventStatus,), {})  # type: ignore
LiveEventStatus.LIVE = type("LiveEventStatus.LIVE", (LiveEventStatus.LIVE, LiveEventStatus,), {})  # type: ignore
LiveEventStatus.ENDED = type("LiveEventStatus.ENDED", (LiveEventStatus.ENDED, LiveEventStatus,), {})  # type: ignore
LiveEventStatus.CUSTOM = type("LiveEventStatus.CUSTOM", (LiveEventStatus.CUSTOM, LiveEventStatus,), {})  # type: ignore




class _UniffiConverterTypeLiveEventStatus(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return LiveEventStatus.PLANNED(
            )
        if variant == 2:
            return LiveEventStatus.LIVE(
            )
        if variant == 3:
            return LiveEventStatus.ENDED(
            )
        if variant == 4:
            return LiveEventStatus.CUSTOM(
                _UniffiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value.is_PLANNED():
            return
        if value.is_LIVE():
            return
        if value.is_ENDED():
            return
        if value.is_CUSTOM():
            _UniffiConverterString.check_lower(value.custom)
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value.is_PLANNED():
            buf.write_i32(1)
        if value.is_LIVE():
            buf.write_i32(2)
        if value.is_ENDED():
            buf.write_i32(3)
        if value.is_CUSTOM():
            buf.write_i32(4)
            _UniffiConverterString.write(value.custom, buf)







class LogLevel(enum.Enum):
    ERROR = 0
    
    WARN = 1
    
    INFO = 2
    
    DEBUG = 3
    
    TRACE = 4
    


class _UniffiConverterTypeLogLevel(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return LogLevel.ERROR
        if variant == 2:
            return LogLevel.WARN
        if variant == 3:
            return LogLevel.INFO
        if variant == 4:
            return LogLevel.DEBUG
        if variant == 5:
            return LogLevel.TRACE
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == LogLevel.ERROR:
            return
        if value == LogLevel.WARN:
            return
        if value == LogLevel.INFO:
            return
        if value == LogLevel.DEBUG:
            return
        if value == LogLevel.TRACE:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == LogLevel.ERROR:
            buf.write_i32(1)
        if value == LogLevel.WARN:
            buf.write_i32(2)
        if value == LogLevel.INFO:
            buf.write_i32(3)
        if value == LogLevel.DEBUG:
            buf.write_i32(4)
        if value == LogLevel.TRACE:
            buf.write_i32(5)







class Marker(enum.Enum):
    """
    Marker
    """

    ROOT = 0
    """
    Root
    """

    
    REPLY = 1
    """
    Reply
    """

    


class _UniffiConverterTypeMarker(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return Marker.ROOT
        if variant == 2:
            return Marker.REPLY
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == Marker.ROOT:
            return
        if value == Marker.REPLY:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == Marker.ROOT:
            buf.write_i32(1)
        if value == Marker.REPLY:
            buf.write_i32(2)







class Method(enum.Enum):
    """
    Method
    """

    PAY_INVOICE = 0
    """
    Pay Invoice
    """

    
    MULTI_PAY_INVOICE = 1
    """
    Multi Pay Invoice
    """

    
    PAY_KEYSEND = 2
    """
    Pay Keysend
    """

    
    MULTI_PAY_KEYSEND = 3
    """
    Multi Pay Keysend
    """

    
    MAKE_INVOICE = 4
    """
    Make Invoice
    """

    
    LOOKUP_INVOICE = 5
    """
    Lookup Invoice
    """

    
    LIST_TRANSACTIONS = 6
    """
    List transactions
    """

    
    GET_BALANCE = 7
    """
    Get Balance
    """

    
    GET_INFO = 8
    """
    Get Info
    """

    
    MAKE_HOLD_INVOICE = 9
    """
    Make Hold Invoice
    """

    
    CANCEL_HOLD_INVOICE = 10
    """
    Cancel Hold Invoice
    """

    
    SETTLE_HOLD_INVOICE = 11
    """
    Settle Hold Invoice
    """

    


class _UniffiConverterTypeMethod(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return Method.PAY_INVOICE
        if variant == 2:
            return Method.MULTI_PAY_INVOICE
        if variant == 3:
            return Method.PAY_KEYSEND
        if variant == 4:
            return Method.MULTI_PAY_KEYSEND
        if variant == 5:
            return Method.MAKE_INVOICE
        if variant == 6:
            return Method.LOOKUP_INVOICE
        if variant == 7:
            return Method.LIST_TRANSACTIONS
        if variant == 8:
            return Method.GET_BALANCE
        if variant == 9:
            return Method.GET_INFO
        if variant == 10:
            return Method.MAKE_HOLD_INVOICE
        if variant == 11:
            return Method.CANCEL_HOLD_INVOICE
        if variant == 12:
            return Method.SETTLE_HOLD_INVOICE
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == Method.PAY_INVOICE:
            return
        if value == Method.MULTI_PAY_INVOICE:
            return
        if value == Method.PAY_KEYSEND:
            return
        if value == Method.MULTI_PAY_KEYSEND:
            return
        if value == Method.MAKE_INVOICE:
            return
        if value == Method.LOOKUP_INVOICE:
            return
        if value == Method.LIST_TRANSACTIONS:
            return
        if value == Method.GET_BALANCE:
            return
        if value == Method.GET_INFO:
            return
        if value == Method.MAKE_HOLD_INVOICE:
            return
        if value == Method.CANCEL_HOLD_INVOICE:
            return
        if value == Method.SETTLE_HOLD_INVOICE:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == Method.PAY_INVOICE:
            buf.write_i32(1)
        if value == Method.MULTI_PAY_INVOICE:
            buf.write_i32(2)
        if value == Method.PAY_KEYSEND:
            buf.write_i32(3)
        if value == Method.MULTI_PAY_KEYSEND:
            buf.write_i32(4)
        if value == Method.MAKE_INVOICE:
            buf.write_i32(5)
        if value == Method.LOOKUP_INVOICE:
            buf.write_i32(6)
        if value == Method.LIST_TRANSACTIONS:
            buf.write_i32(7)
        if value == Method.GET_BALANCE:
            buf.write_i32(8)
        if value == Method.GET_INFO:
            buf.write_i32(9)
        if value == Method.MAKE_HOLD_INVOICE:
            buf.write_i32(10)
        if value == Method.CANCEL_HOLD_INVOICE:
            buf.write_i32(11)
        if value == Method.SETTLE_HOLD_INVOICE:
            buf.write_i32(12)







class Nip19Enum:
    """
    A representation any `NIP19` bech32 nostr object. Useful for decoding
    `NIP19` bech32 strings without necessarily knowing what you're decoding
    ahead of time.
    """

    def __init__(self):
        raise RuntimeError("Nip19Enum cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class SECRET:
        """
        nsec
        """

        nsec: "SecretKey"

        def __init__(self,nsec: "SecretKey"):
            self.nsec = nsec

        def __str__(self):
            return "Nip19Enum.SECRET(nsec={})".format(self.nsec)

        def __eq__(self, other):
            if not other.is_SECRET():
                return False
            if self.nsec != other.nsec:
                return False
            return True
    
    class ENCRYPTED_SECRET:
        """
        Encrypted Secret Key
        """

        val: "EncryptedSecretKey"

        def __init__(self,val: "EncryptedSecretKey"):
            self.val = val

        def __str__(self):
            return "Nip19Enum.ENCRYPTED_SECRET(val={})".format(self.val)

        def __eq__(self, other):
            if not other.is_ENCRYPTED_SECRET():
                return False
            if self.val != other.val:
                return False
            return True
    
    class PUBKEY:
        """
        npub
        """

        npub: "PublicKey"

        def __init__(self,npub: "PublicKey"):
            self.npub = npub

        def __str__(self):
            return "Nip19Enum.PUBKEY(npub={})".format(self.npub)

        def __eq__(self, other):
            if not other.is_PUBKEY():
                return False
            if self.npub != other.npub:
                return False
            return True
    
    class PROFILE:
        """
        nprofile
        """

        nprofile: "Nip19Profile"

        def __init__(self,nprofile: "Nip19Profile"):
            self.nprofile = nprofile

        def __str__(self):
            return "Nip19Enum.PROFILE(nprofile={})".format(self.nprofile)

        def __eq__(self, other):
            if not other.is_PROFILE():
                return False
            if self.nprofile != other.nprofile:
                return False
            return True
    
    class NOTE:
        """
        note
        """

        event_id: "EventId"

        def __init__(self,event_id: "EventId"):
            self.event_id = event_id

        def __str__(self):
            return "Nip19Enum.NOTE(event_id={})".format(self.event_id)

        def __eq__(self, other):
            if not other.is_NOTE():
                return False
            if self.event_id != other.event_id:
                return False
            return True
    
    class EVENT:
        """
        nevent
        """

        event: "Nip19Event"

        def __init__(self,event: "Nip19Event"):
            self.event = event

        def __str__(self):
            return "Nip19Enum.EVENT(event={})".format(self.event)

        def __eq__(self, other):
            if not other.is_EVENT():
                return False
            if self.event != other.event:
                return False
            return True
    
    class ADDR:
        """
        naddr
        """

        coordinate: "Nip19Coordinate"

        def __init__(self,coordinate: "Nip19Coordinate"):
            self.coordinate = coordinate

        def __str__(self):
            return "Nip19Enum.ADDR(coordinate={})".format(self.coordinate)

        def __eq__(self, other):
            if not other.is_ADDR():
                return False
            if self.coordinate != other.coordinate:
                return False
            return True
    
    

    # For each variant, we have `is_NAME` and `is_name` methods for easily checking
    # whether an instance is that variant.
    def is_SECRET(self) -> bool:
        return isinstance(self, Nip19Enum.SECRET)
    def is_secret(self) -> bool:
        return isinstance(self, Nip19Enum.SECRET)
    def is_ENCRYPTED_SECRET(self) -> bool:
        return isinstance(self, Nip19Enum.ENCRYPTED_SECRET)
    def is_encrypted_secret(self) -> bool:
        return isinstance(self, Nip19Enum.ENCRYPTED_SECRET)
    def is_PUBKEY(self) -> bool:
        return isinstance(self, Nip19Enum.PUBKEY)
    def is_pubkey(self) -> bool:
        return isinstance(self, Nip19Enum.PUBKEY)
    def is_PROFILE(self) -> bool:
        return isinstance(self, Nip19Enum.PROFILE)
    def is_profile(self) -> bool:
        return isinstance(self, Nip19Enum.PROFILE)
    def is_NOTE(self) -> bool:
        return isinstance(self, Nip19Enum.NOTE)
    def is_note(self) -> bool:
        return isinstance(self, Nip19Enum.NOTE)
    def is_EVENT(self) -> bool:
        return isinstance(self, Nip19Enum.EVENT)
    def is_event(self) -> bool:
        return isinstance(self, Nip19Enum.EVENT)
    def is_ADDR(self) -> bool:
        return isinstance(self, Nip19Enum.ADDR)
    def is_addr(self) -> bool:
        return isinstance(self, Nip19Enum.ADDR)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
Nip19Enum.SECRET = type("Nip19Enum.SECRET", (Nip19Enum.SECRET, Nip19Enum,), {})  # type: ignore
Nip19Enum.ENCRYPTED_SECRET = type("Nip19Enum.ENCRYPTED_SECRET", (Nip19Enum.ENCRYPTED_SECRET, Nip19Enum,), {})  # type: ignore
Nip19Enum.PUBKEY = type("Nip19Enum.PUBKEY", (Nip19Enum.PUBKEY, Nip19Enum,), {})  # type: ignore
Nip19Enum.PROFILE = type("Nip19Enum.PROFILE", (Nip19Enum.PROFILE, Nip19Enum,), {})  # type: ignore
Nip19Enum.NOTE = type("Nip19Enum.NOTE", (Nip19Enum.NOTE, Nip19Enum,), {})  # type: ignore
Nip19Enum.EVENT = type("Nip19Enum.EVENT", (Nip19Enum.EVENT, Nip19Enum,), {})  # type: ignore
Nip19Enum.ADDR = type("Nip19Enum.ADDR", (Nip19Enum.ADDR, Nip19Enum,), {})  # type: ignore




class _UniffiConverterTypeNip19Enum(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return Nip19Enum.SECRET(
                _UniffiConverterTypeSecretKey.read(buf),
            )
        if variant == 2:
            return Nip19Enum.ENCRYPTED_SECRET(
                _UniffiConverterTypeEncryptedSecretKey.read(buf),
            )
        if variant == 3:
            return Nip19Enum.PUBKEY(
                _UniffiConverterTypePublicKey.read(buf),
            )
        if variant == 4:
            return Nip19Enum.PROFILE(
                _UniffiConverterTypeNip19Profile.read(buf),
            )
        if variant == 5:
            return Nip19Enum.NOTE(
                _UniffiConverterTypeEventId.read(buf),
            )
        if variant == 6:
            return Nip19Enum.EVENT(
                _UniffiConverterTypeNip19Event.read(buf),
            )
        if variant == 7:
            return Nip19Enum.ADDR(
                _UniffiConverterTypeNip19Coordinate.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value.is_SECRET():
            _UniffiConverterTypeSecretKey.check_lower(value.nsec)
            return
        if value.is_ENCRYPTED_SECRET():
            _UniffiConverterTypeEncryptedSecretKey.check_lower(value.val)
            return
        if value.is_PUBKEY():
            _UniffiConverterTypePublicKey.check_lower(value.npub)
            return
        if value.is_PROFILE():
            _UniffiConverterTypeNip19Profile.check_lower(value.nprofile)
            return
        if value.is_NOTE():
            _UniffiConverterTypeEventId.check_lower(value.event_id)
            return
        if value.is_EVENT():
            _UniffiConverterTypeNip19Event.check_lower(value.event)
            return
        if value.is_ADDR():
            _UniffiConverterTypeNip19Coordinate.check_lower(value.coordinate)
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value.is_SECRET():
            buf.write_i32(1)
            _UniffiConverterTypeSecretKey.write(value.nsec, buf)
        if value.is_ENCRYPTED_SECRET():
            buf.write_i32(2)
            _UniffiConverterTypeEncryptedSecretKey.write(value.val, buf)
        if value.is_PUBKEY():
            buf.write_i32(3)
            _UniffiConverterTypePublicKey.write(value.npub, buf)
        if value.is_PROFILE():
            buf.write_i32(4)
            _UniffiConverterTypeNip19Profile.write(value.nprofile, buf)
        if value.is_NOTE():
            buf.write_i32(5)
            _UniffiConverterTypeEventId.write(value.event_id, buf)
        if value.is_EVENT():
            buf.write_i32(6)
            _UniffiConverterTypeNip19Event.write(value.event, buf)
        if value.is_ADDR():
            buf.write_i32(7)
            _UniffiConverterTypeNip19Coordinate.write(value.coordinate, buf)







class Nip21Enum:
    """
    A representation any `NIP21` object. Useful for decoding
    `NIP21` strings without necessarily knowing what you're decoding
    ahead of time.
    """

    def __init__(self):
        raise RuntimeError("Nip21Enum cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class PUBKEY:
        """
        nostr::npub
        """

        public_key: "PublicKey"

        def __init__(self,public_key: "PublicKey"):
            self.public_key = public_key

        def __str__(self):
            return "Nip21Enum.PUBKEY(public_key={})".format(self.public_key)

        def __eq__(self, other):
            if not other.is_PUBKEY():
                return False
            if self.public_key != other.public_key:
                return False
            return True
    
    class PROFILE:
        """
        nostr::nprofile
        """

        profile: "Nip19Profile"

        def __init__(self,profile: "Nip19Profile"):
            self.profile = profile

        def __str__(self):
            return "Nip21Enum.PROFILE(profile={})".format(self.profile)

        def __eq__(self, other):
            if not other.is_PROFILE():
                return False
            if self.profile != other.profile:
                return False
            return True
    
    class NOTE:
        """
        nostr::note (EventId)
        """

        event_id: "EventId"

        def __init__(self,event_id: "EventId"):
            self.event_id = event_id

        def __str__(self):
            return "Nip21Enum.NOTE(event_id={})".format(self.event_id)

        def __eq__(self, other):
            if not other.is_NOTE():
                return False
            if self.event_id != other.event_id:
                return False
            return True
    
    class EVENT:
        """
        nostr::nevent
        """

        event: "Nip19Event"

        def __init__(self,event: "Nip19Event"):
            self.event = event

        def __str__(self):
            return "Nip21Enum.EVENT(event={})".format(self.event)

        def __eq__(self, other):
            if not other.is_EVENT():
                return False
            if self.event != other.event:
                return False
            return True
    
    class ADDR:
        """
        nostr::naddr
        """

        coordinate: "Nip19Coordinate"

        def __init__(self,coordinate: "Nip19Coordinate"):
            self.coordinate = coordinate

        def __str__(self):
            return "Nip21Enum.ADDR(coordinate={})".format(self.coordinate)

        def __eq__(self, other):
            if not other.is_ADDR():
                return False
            if self.coordinate != other.coordinate:
                return False
            return True
    
    

    # For each variant, we have `is_NAME` and `is_name` methods for easily checking
    # whether an instance is that variant.
    def is_PUBKEY(self) -> bool:
        return isinstance(self, Nip21Enum.PUBKEY)
    def is_pubkey(self) -> bool:
        return isinstance(self, Nip21Enum.PUBKEY)
    def is_PROFILE(self) -> bool:
        return isinstance(self, Nip21Enum.PROFILE)
    def is_profile(self) -> bool:
        return isinstance(self, Nip21Enum.PROFILE)
    def is_NOTE(self) -> bool:
        return isinstance(self, Nip21Enum.NOTE)
    def is_note(self) -> bool:
        return isinstance(self, Nip21Enum.NOTE)
    def is_EVENT(self) -> bool:
        return isinstance(self, Nip21Enum.EVENT)
    def is_event(self) -> bool:
        return isinstance(self, Nip21Enum.EVENT)
    def is_ADDR(self) -> bool:
        return isinstance(self, Nip21Enum.ADDR)
    def is_addr(self) -> bool:
        return isinstance(self, Nip21Enum.ADDR)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
Nip21Enum.PUBKEY = type("Nip21Enum.PUBKEY", (Nip21Enum.PUBKEY, Nip21Enum,), {})  # type: ignore
Nip21Enum.PROFILE = type("Nip21Enum.PROFILE", (Nip21Enum.PROFILE, Nip21Enum,), {})  # type: ignore
Nip21Enum.NOTE = type("Nip21Enum.NOTE", (Nip21Enum.NOTE, Nip21Enum,), {})  # type: ignore
Nip21Enum.EVENT = type("Nip21Enum.EVENT", (Nip21Enum.EVENT, Nip21Enum,), {})  # type: ignore
Nip21Enum.ADDR = type("Nip21Enum.ADDR", (Nip21Enum.ADDR, Nip21Enum,), {})  # type: ignore




class _UniffiConverterTypeNip21Enum(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return Nip21Enum.PUBKEY(
                _UniffiConverterTypePublicKey.read(buf),
            )
        if variant == 2:
            return Nip21Enum.PROFILE(
                _UniffiConverterTypeNip19Profile.read(buf),
            )
        if variant == 3:
            return Nip21Enum.NOTE(
                _UniffiConverterTypeEventId.read(buf),
            )
        if variant == 4:
            return Nip21Enum.EVENT(
                _UniffiConverterTypeNip19Event.read(buf),
            )
        if variant == 5:
            return Nip21Enum.ADDR(
                _UniffiConverterTypeNip19Coordinate.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value.is_PUBKEY():
            _UniffiConverterTypePublicKey.check_lower(value.public_key)
            return
        if value.is_PROFILE():
            _UniffiConverterTypeNip19Profile.check_lower(value.profile)
            return
        if value.is_NOTE():
            _UniffiConverterTypeEventId.check_lower(value.event_id)
            return
        if value.is_EVENT():
            _UniffiConverterTypeNip19Event.check_lower(value.event)
            return
        if value.is_ADDR():
            _UniffiConverterTypeNip19Coordinate.check_lower(value.coordinate)
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value.is_PUBKEY():
            buf.write_i32(1)
            _UniffiConverterTypePublicKey.write(value.public_key, buf)
        if value.is_PROFILE():
            buf.write_i32(2)
            _UniffiConverterTypeNip19Profile.write(value.profile, buf)
        if value.is_NOTE():
            buf.write_i32(3)
            _UniffiConverterTypeEventId.write(value.event_id, buf)
        if value.is_EVENT():
            buf.write_i32(4)
            _UniffiConverterTypeNip19Event.write(value.event, buf)
        if value.is_ADDR():
            buf.write_i32(5)
            _UniffiConverterTypeNip19Coordinate.write(value.coordinate, buf)







class Nip44Version(enum.Enum):
    """
    NIP44 Version
    """

    V2 = 0
    """
    V2 - Secp256k1 ECDH, HKDF, padding, ChaCha20, HMAC-SHA256 and base64
    """

    


class _UniffiConverterTypeNip44Version(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return Nip44Version.V2
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == Nip44Version.V2:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == Nip44Version.V2:
            buf.write_i32(1)







class Nip73Kind:
    """
    NIP-73 kinds
    """

    def __init__(self):
        raise RuntimeError("Nip73Kind cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class URL:
        """
        URLs kind "web"
        """


        def __init__(self,):
            pass

        def __str__(self):
            return "Nip73Kind.URL()".format()

        def __eq__(self, other):
            if not other.is_URL():
                return False
            return True
    
    class BOOK:
        """
        Books kind "isbn"
        """


        def __init__(self,):
            pass

        def __str__(self):
            return "Nip73Kind.BOOK()".format()

        def __eq__(self, other):
            if not other.is_BOOK():
                return False
            return True
    
    class GEOHASH:
        """
        Geohashes kind "geo"
        """


        def __init__(self,):
            pass

        def __str__(self):
            return "Nip73Kind.GEOHASH()".format()

        def __eq__(self, other):
            if not other.is_GEOHASH():
                return False
            return True
    
    class MOVIE:
        """
        Movies kind "isan"
        """


        def __init__(self,):
            pass

        def __str__(self):
            return "Nip73Kind.MOVIE()".format()

        def __eq__(self, other):
            if not other.is_MOVIE():
                return False
            return True
    
    class PAPER:
        """
        Papers kind "doi"
        """


        def __init__(self,):
            pass

        def __str__(self):
            return "Nip73Kind.PAPER()".format()

        def __eq__(self, other):
            if not other.is_PAPER():
                return False
            return True
    
    class HASHTAG:
        """
        Hashtags kind "#"
        """


        def __init__(self,):
            pass

        def __str__(self):
            return "Nip73Kind.HASHTAG()".format()

        def __eq__(self, other):
            if not other.is_HASHTAG():
                return False
            return True
    
    class PODCAST_FEED:
        """
        Podcast feeds kind "podcast:guid"
        """


        def __init__(self,):
            pass

        def __str__(self):
            return "Nip73Kind.PODCAST_FEED()".format()

        def __eq__(self, other):
            if not other.is_PODCAST_FEED():
                return False
            return True
    
    class PODCAST_EPISODE:
        """
        Podcast episodes kind "podcast:item:guid"
        """


        def __init__(self,):
            pass

        def __str__(self):
            return "Nip73Kind.PODCAST_EPISODE()".format()

        def __eq__(self, other):
            if not other.is_PODCAST_EPISODE():
                return False
            return True
    
    class PODCAST_PUBLISHER:
        """
        Podcast publishers kind "podcast:publisher:guid"
        """


        def __init__(self,):
            pass

        def __str__(self):
            return "Nip73Kind.PODCAST_PUBLISHER()".format()

        def __eq__(self, other):
            if not other.is_PODCAST_PUBLISHER():
                return False
            return True
    
    class BLOCKCHAIN_TRANSACTION:
        """
        Blockchain transaction kind "<blockchain>:tx"
        """

        tx: "str"

        def __init__(self,tx: "str"):
            self.tx = tx

        def __str__(self):
            return "Nip73Kind.BLOCKCHAIN_TRANSACTION(tx={})".format(self.tx)

        def __eq__(self, other):
            if not other.is_BLOCKCHAIN_TRANSACTION():
                return False
            if self.tx != other.tx:
                return False
            return True
    
    class BLOCKCHAIN_ADDRESS:
        """
        Blockchain address kind "<blockchain>:address"
        """

        address: "str"

        def __init__(self,address: "str"):
            self.address = address

        def __str__(self):
            return "Nip73Kind.BLOCKCHAIN_ADDRESS(address={})".format(self.address)

        def __eq__(self, other):
            if not other.is_BLOCKCHAIN_ADDRESS():
                return False
            if self.address != other.address:
                return False
            return True
    
    

    # For each variant, we have `is_NAME` and `is_name` methods for easily checking
    # whether an instance is that variant.
    def is_URL(self) -> bool:
        return isinstance(self, Nip73Kind.URL)
    def is_url(self) -> bool:
        return isinstance(self, Nip73Kind.URL)
    def is_BOOK(self) -> bool:
        return isinstance(self, Nip73Kind.BOOK)
    def is_book(self) -> bool:
        return isinstance(self, Nip73Kind.BOOK)
    def is_GEOHASH(self) -> bool:
        return isinstance(self, Nip73Kind.GEOHASH)
    def is_geohash(self) -> bool:
        return isinstance(self, Nip73Kind.GEOHASH)
    def is_MOVIE(self) -> bool:
        return isinstance(self, Nip73Kind.MOVIE)
    def is_movie(self) -> bool:
        return isinstance(self, Nip73Kind.MOVIE)
    def is_PAPER(self) -> bool:
        return isinstance(self, Nip73Kind.PAPER)
    def is_paper(self) -> bool:
        return isinstance(self, Nip73Kind.PAPER)
    def is_HASHTAG(self) -> bool:
        return isinstance(self, Nip73Kind.HASHTAG)
    def is_hashtag(self) -> bool:
        return isinstance(self, Nip73Kind.HASHTAG)
    def is_PODCAST_FEED(self) -> bool:
        return isinstance(self, Nip73Kind.PODCAST_FEED)
    def is_podcast_feed(self) -> bool:
        return isinstance(self, Nip73Kind.PODCAST_FEED)
    def is_PODCAST_EPISODE(self) -> bool:
        return isinstance(self, Nip73Kind.PODCAST_EPISODE)
    def is_podcast_episode(self) -> bool:
        return isinstance(self, Nip73Kind.PODCAST_EPISODE)
    def is_PODCAST_PUBLISHER(self) -> bool:
        return isinstance(self, Nip73Kind.PODCAST_PUBLISHER)
    def is_podcast_publisher(self) -> bool:
        return isinstance(self, Nip73Kind.PODCAST_PUBLISHER)
    def is_BLOCKCHAIN_TRANSACTION(self) -> bool:
        return isinstance(self, Nip73Kind.BLOCKCHAIN_TRANSACTION)
    def is_blockchain_transaction(self) -> bool:
        return isinstance(self, Nip73Kind.BLOCKCHAIN_TRANSACTION)
    def is_BLOCKCHAIN_ADDRESS(self) -> bool:
        return isinstance(self, Nip73Kind.BLOCKCHAIN_ADDRESS)
    def is_blockchain_address(self) -> bool:
        return isinstance(self, Nip73Kind.BLOCKCHAIN_ADDRESS)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
Nip73Kind.URL = type("Nip73Kind.URL", (Nip73Kind.URL, Nip73Kind,), {})  # type: ignore
Nip73Kind.BOOK = type("Nip73Kind.BOOK", (Nip73Kind.BOOK, Nip73Kind,), {})  # type: ignore
Nip73Kind.GEOHASH = type("Nip73Kind.GEOHASH", (Nip73Kind.GEOHASH, Nip73Kind,), {})  # type: ignore
Nip73Kind.MOVIE = type("Nip73Kind.MOVIE", (Nip73Kind.MOVIE, Nip73Kind,), {})  # type: ignore
Nip73Kind.PAPER = type("Nip73Kind.PAPER", (Nip73Kind.PAPER, Nip73Kind,), {})  # type: ignore
Nip73Kind.HASHTAG = type("Nip73Kind.HASHTAG", (Nip73Kind.HASHTAG, Nip73Kind,), {})  # type: ignore
Nip73Kind.PODCAST_FEED = type("Nip73Kind.PODCAST_FEED", (Nip73Kind.PODCAST_FEED, Nip73Kind,), {})  # type: ignore
Nip73Kind.PODCAST_EPISODE = type("Nip73Kind.PODCAST_EPISODE", (Nip73Kind.PODCAST_EPISODE, Nip73Kind,), {})  # type: ignore
Nip73Kind.PODCAST_PUBLISHER = type("Nip73Kind.PODCAST_PUBLISHER", (Nip73Kind.PODCAST_PUBLISHER, Nip73Kind,), {})  # type: ignore
Nip73Kind.BLOCKCHAIN_TRANSACTION = type("Nip73Kind.BLOCKCHAIN_TRANSACTION", (Nip73Kind.BLOCKCHAIN_TRANSACTION, Nip73Kind,), {})  # type: ignore
Nip73Kind.BLOCKCHAIN_ADDRESS = type("Nip73Kind.BLOCKCHAIN_ADDRESS", (Nip73Kind.BLOCKCHAIN_ADDRESS, Nip73Kind,), {})  # type: ignore




class _UniffiConverterTypeNip73Kind(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return Nip73Kind.URL(
            )
        if variant == 2:
            return Nip73Kind.BOOK(
            )
        if variant == 3:
            return Nip73Kind.GEOHASH(
            )
        if variant == 4:
            return Nip73Kind.MOVIE(
            )
        if variant == 5:
            return Nip73Kind.PAPER(
            )
        if variant == 6:
            return Nip73Kind.HASHTAG(
            )
        if variant == 7:
            return Nip73Kind.PODCAST_FEED(
            )
        if variant == 8:
            return Nip73Kind.PODCAST_EPISODE(
            )
        if variant == 9:
            return Nip73Kind.PODCAST_PUBLISHER(
            )
        if variant == 10:
            return Nip73Kind.BLOCKCHAIN_TRANSACTION(
                _UniffiConverterString.read(buf),
            )
        if variant == 11:
            return Nip73Kind.BLOCKCHAIN_ADDRESS(
                _UniffiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value.is_URL():
            return
        if value.is_BOOK():
            return
        if value.is_GEOHASH():
            return
        if value.is_MOVIE():
            return
        if value.is_PAPER():
            return
        if value.is_HASHTAG():
            return
        if value.is_PODCAST_FEED():
            return
        if value.is_PODCAST_EPISODE():
            return
        if value.is_PODCAST_PUBLISHER():
            return
        if value.is_BLOCKCHAIN_TRANSACTION():
            _UniffiConverterString.check_lower(value.tx)
            return
        if value.is_BLOCKCHAIN_ADDRESS():
            _UniffiConverterString.check_lower(value.address)
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value.is_URL():
            buf.write_i32(1)
        if value.is_BOOK():
            buf.write_i32(2)
        if value.is_GEOHASH():
            buf.write_i32(3)
        if value.is_MOVIE():
            buf.write_i32(4)
        if value.is_PAPER():
            buf.write_i32(5)
        if value.is_HASHTAG():
            buf.write_i32(6)
        if value.is_PODCAST_FEED():
            buf.write_i32(7)
        if value.is_PODCAST_EPISODE():
            buf.write_i32(8)
        if value.is_PODCAST_PUBLISHER():
            buf.write_i32(9)
        if value.is_BLOCKCHAIN_TRANSACTION():
            buf.write_i32(10)
            _UniffiConverterString.write(value.tx, buf)
        if value.is_BLOCKCHAIN_ADDRESS():
            buf.write_i32(11)
            _UniffiConverterString.write(value.address, buf)







class NostrConnectMessage:
    def __init__(self):
        raise RuntimeError("NostrConnectMessage cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class REQUEST:
        id: "str"
        method: "str"
        params: "typing.List[str]"

        def __init__(self,id: "str", method: "str", params: "typing.List[str]"):
            self.id = id
            self.method = method
            self.params = params

        def __str__(self):
            return "NostrConnectMessage.REQUEST(id={}, method={}, params={})".format(self.id, self.method, self.params)

        def __eq__(self, other):
            if not other.is_REQUEST():
                return False
            if self.id != other.id:
                return False
            if self.method != other.method:
                return False
            if self.params != other.params:
                return False
            return True
    
    class RESPONSE:
        id: "str"
        result: "typing.Optional[str]"
        error: "typing.Optional[str]"

        def __init__(self,id: "str", result: "typing.Optional[str]", error: "typing.Optional[str]"):
            self.id = id
            self.result = result
            self.error = error

        def __str__(self):
            return "NostrConnectMessage.RESPONSE(id={}, result={}, error={})".format(self.id, self.result, self.error)

        def __eq__(self, other):
            if not other.is_RESPONSE():
                return False
            if self.id != other.id:
                return False
            if self.result != other.result:
                return False
            if self.error != other.error:
                return False
            return True
    
    

    # For each variant, we have `is_NAME` and `is_name` methods for easily checking
    # whether an instance is that variant.
    def is_REQUEST(self) -> bool:
        return isinstance(self, NostrConnectMessage.REQUEST)
    def is_request(self) -> bool:
        return isinstance(self, NostrConnectMessage.REQUEST)
    def is_RESPONSE(self) -> bool:
        return isinstance(self, NostrConnectMessage.RESPONSE)
    def is_response(self) -> bool:
        return isinstance(self, NostrConnectMessage.RESPONSE)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
NostrConnectMessage.REQUEST = type("NostrConnectMessage.REQUEST", (NostrConnectMessage.REQUEST, NostrConnectMessage,), {})  # type: ignore
NostrConnectMessage.RESPONSE = type("NostrConnectMessage.RESPONSE", (NostrConnectMessage.RESPONSE, NostrConnectMessage,), {})  # type: ignore




class _UniffiConverterTypeNostrConnectMessage(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return NostrConnectMessage.REQUEST(
                _UniffiConverterString.read(buf),
                _UniffiConverterString.read(buf),
                _UniffiConverterSequenceString.read(buf),
            )
        if variant == 2:
            return NostrConnectMessage.RESPONSE(
                _UniffiConverterString.read(buf),
                _UniffiConverterOptionalString.read(buf),
                _UniffiConverterOptionalString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value.is_REQUEST():
            _UniffiConverterString.check_lower(value.id)
            _UniffiConverterString.check_lower(value.method)
            _UniffiConverterSequenceString.check_lower(value.params)
            return
        if value.is_RESPONSE():
            _UniffiConverterString.check_lower(value.id)
            _UniffiConverterOptionalString.check_lower(value.result)
            _UniffiConverterOptionalString.check_lower(value.error)
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value.is_REQUEST():
            buf.write_i32(1)
            _UniffiConverterString.write(value.id, buf)
            _UniffiConverterString.write(value.method, buf)
            _UniffiConverterSequenceString.write(value.params, buf)
        if value.is_RESPONSE():
            buf.write_i32(2)
            _UniffiConverterString.write(value.id, buf)
            _UniffiConverterOptionalString.write(value.result, buf)
            _UniffiConverterOptionalString.write(value.error, buf)







class NostrConnectRequest:
    """
    Nostr Connect Request (NIP46)
    """

    def __init__(self):
        raise RuntimeError("NostrConnectRequest cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class CONNECT:
        """
        Connect
        """

        remote_signer_public_key: "PublicKey"
        """
        Remote public key
        """

        secret: "typing.Optional[str]"
        """
        Optional secret
        """


        def __init__(self,remote_signer_public_key: "PublicKey", secret: "typing.Optional[str]"):
            self.remote_signer_public_key = remote_signer_public_key
            self.secret = secret

        def __str__(self):
            return "NostrConnectRequest.CONNECT(remote_signer_public_key={}, secret={})".format(self.remote_signer_public_key, self.secret)

        def __eq__(self, other):
            if not other.is_CONNECT():
                return False
            if self.remote_signer_public_key != other.remote_signer_public_key:
                return False
            if self.secret != other.secret:
                return False
            return True
    
    class GET_PUBLIC_KEY:
        """
        Get public key
        """


        def __init__(self,):
            pass

        def __str__(self):
            return "NostrConnectRequest.GET_PUBLIC_KEY()".format()

        def __eq__(self, other):
            if not other.is_GET_PUBLIC_KEY():
                return False
            return True
    
    class SIGN_EVENT:
        """
        Sign [`UnsignedEvent`]
        """

        unsigned_event: "UnsignedEvent"

        def __init__(self,unsigned_event: "UnsignedEvent"):
            self.unsigned_event = unsigned_event

        def __str__(self):
            return "NostrConnectRequest.SIGN_EVENT(unsigned_event={})".format(self.unsigned_event)

        def __eq__(self, other):
            if not other.is_SIGN_EVENT():
                return False
            if self.unsigned_event != other.unsigned_event:
                return False
            return True
    
    class NIP04_ENCRYPT:
        """
        Encrypt text (NIP04)
        """

        public_key: "PublicKey"
        """
        Pubkey
        """

        text: "str"
        """
        Plain text
        """


        def __init__(self,public_key: "PublicKey", text: "str"):
            self.public_key = public_key
            self.text = text

        def __str__(self):
            return "NostrConnectRequest.NIP04_ENCRYPT(public_key={}, text={})".format(self.public_key, self.text)

        def __eq__(self, other):
            if not other.is_NIP04_ENCRYPT():
                return False
            if self.public_key != other.public_key:
                return False
            if self.text != other.text:
                return False
            return True
    
    class NIP04_DECRYPT:
        """
        Decrypt (NIP04)
        """

        public_key: "PublicKey"
        """
        Pubkey
        """

        ciphertext: "str"
        """
        Ciphertext
        """


        def __init__(self,public_key: "PublicKey", ciphertext: "str"):
            self.public_key = public_key
            self.ciphertext = ciphertext

        def __str__(self):
            return "NostrConnectRequest.NIP04_DECRYPT(public_key={}, ciphertext={})".format(self.public_key, self.ciphertext)

        def __eq__(self, other):
            if not other.is_NIP04_DECRYPT():
                return False
            if self.public_key != other.public_key:
                return False
            if self.ciphertext != other.ciphertext:
                return False
            return True
    
    class NIP44_ENCRYPT:
        """
        Encrypt text (NIP44)
        """

        public_key: "PublicKey"
        """
        Pubkey
        """

        text: "str"
        """
        Plain text
        """


        def __init__(self,public_key: "PublicKey", text: "str"):
            self.public_key = public_key
            self.text = text

        def __str__(self):
            return "NostrConnectRequest.NIP44_ENCRYPT(public_key={}, text={})".format(self.public_key, self.text)

        def __eq__(self, other):
            if not other.is_NIP44_ENCRYPT():
                return False
            if self.public_key != other.public_key:
                return False
            if self.text != other.text:
                return False
            return True
    
    class NIP44_DECRYPT:
        """
        Decrypt (NIP44)
        """

        public_key: "PublicKey"
        """
        Pubkey
        """

        ciphertext: "str"
        """
        Ciphertext
        """


        def __init__(self,public_key: "PublicKey", ciphertext: "str"):
            self.public_key = public_key
            self.ciphertext = ciphertext

        def __str__(self):
            return "NostrConnectRequest.NIP44_DECRYPT(public_key={}, ciphertext={})".format(self.public_key, self.ciphertext)

        def __eq__(self, other):
            if not other.is_NIP44_DECRYPT():
                return False
            if self.public_key != other.public_key:
                return False
            if self.ciphertext != other.ciphertext:
                return False
            return True
    
    class PING:
        """
        Ping
        """


        def __init__(self,):
            pass

        def __str__(self):
            return "NostrConnectRequest.PING()".format()

        def __eq__(self, other):
            if not other.is_PING():
                return False
            return True
    
    

    # For each variant, we have `is_NAME` and `is_name` methods for easily checking
    # whether an instance is that variant.
    def is_CONNECT(self) -> bool:
        return isinstance(self, NostrConnectRequest.CONNECT)
    def is_connect(self) -> bool:
        return isinstance(self, NostrConnectRequest.CONNECT)
    def is_GET_PUBLIC_KEY(self) -> bool:
        return isinstance(self, NostrConnectRequest.GET_PUBLIC_KEY)
    def is_get_public_key(self) -> bool:
        return isinstance(self, NostrConnectRequest.GET_PUBLIC_KEY)
    def is_SIGN_EVENT(self) -> bool:
        return isinstance(self, NostrConnectRequest.SIGN_EVENT)
    def is_sign_event(self) -> bool:
        return isinstance(self, NostrConnectRequest.SIGN_EVENT)
    def is_NIP04_ENCRYPT(self) -> bool:
        return isinstance(self, NostrConnectRequest.NIP04_ENCRYPT)
    def is_nip04_encrypt(self) -> bool:
        return isinstance(self, NostrConnectRequest.NIP04_ENCRYPT)
    def is_NIP04_DECRYPT(self) -> bool:
        return isinstance(self, NostrConnectRequest.NIP04_DECRYPT)
    def is_nip04_decrypt(self) -> bool:
        return isinstance(self, NostrConnectRequest.NIP04_DECRYPT)
    def is_NIP44_ENCRYPT(self) -> bool:
        return isinstance(self, NostrConnectRequest.NIP44_ENCRYPT)
    def is_nip44_encrypt(self) -> bool:
        return isinstance(self, NostrConnectRequest.NIP44_ENCRYPT)
    def is_NIP44_DECRYPT(self) -> bool:
        return isinstance(self, NostrConnectRequest.NIP44_DECRYPT)
    def is_nip44_decrypt(self) -> bool:
        return isinstance(self, NostrConnectRequest.NIP44_DECRYPT)
    def is_PING(self) -> bool:
        return isinstance(self, NostrConnectRequest.PING)
    def is_ping(self) -> bool:
        return isinstance(self, NostrConnectRequest.PING)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
NostrConnectRequest.CONNECT = type("NostrConnectRequest.CONNECT", (NostrConnectRequest.CONNECT, NostrConnectRequest,), {})  # type: ignore
NostrConnectRequest.GET_PUBLIC_KEY = type("NostrConnectRequest.GET_PUBLIC_KEY", (NostrConnectRequest.GET_PUBLIC_KEY, NostrConnectRequest,), {})  # type: ignore
NostrConnectRequest.SIGN_EVENT = type("NostrConnectRequest.SIGN_EVENT", (NostrConnectRequest.SIGN_EVENT, NostrConnectRequest,), {})  # type: ignore
NostrConnectRequest.NIP04_ENCRYPT = type("NostrConnectRequest.NIP04_ENCRYPT", (NostrConnectRequest.NIP04_ENCRYPT, NostrConnectRequest,), {})  # type: ignore
NostrConnectRequest.NIP04_DECRYPT = type("NostrConnectRequest.NIP04_DECRYPT", (NostrConnectRequest.NIP04_DECRYPT, NostrConnectRequest,), {})  # type: ignore
NostrConnectRequest.NIP44_ENCRYPT = type("NostrConnectRequest.NIP44_ENCRYPT", (NostrConnectRequest.NIP44_ENCRYPT, NostrConnectRequest,), {})  # type: ignore
NostrConnectRequest.NIP44_DECRYPT = type("NostrConnectRequest.NIP44_DECRYPT", (NostrConnectRequest.NIP44_DECRYPT, NostrConnectRequest,), {})  # type: ignore
NostrConnectRequest.PING = type("NostrConnectRequest.PING", (NostrConnectRequest.PING, NostrConnectRequest,), {})  # type: ignore




class _UniffiConverterTypeNostrConnectRequest(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return NostrConnectRequest.CONNECT(
                _UniffiConverterTypePublicKey.read(buf),
                _UniffiConverterOptionalString.read(buf),
            )
        if variant == 2:
            return NostrConnectRequest.GET_PUBLIC_KEY(
            )
        if variant == 3:
            return NostrConnectRequest.SIGN_EVENT(
                _UniffiConverterTypeUnsignedEvent.read(buf),
            )
        if variant == 4:
            return NostrConnectRequest.NIP04_ENCRYPT(
                _UniffiConverterTypePublicKey.read(buf),
                _UniffiConverterString.read(buf),
            )
        if variant == 5:
            return NostrConnectRequest.NIP04_DECRYPT(
                _UniffiConverterTypePublicKey.read(buf),
                _UniffiConverterString.read(buf),
            )
        if variant == 6:
            return NostrConnectRequest.NIP44_ENCRYPT(
                _UniffiConverterTypePublicKey.read(buf),
                _UniffiConverterString.read(buf),
            )
        if variant == 7:
            return NostrConnectRequest.NIP44_DECRYPT(
                _UniffiConverterTypePublicKey.read(buf),
                _UniffiConverterString.read(buf),
            )
        if variant == 8:
            return NostrConnectRequest.PING(
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value.is_CONNECT():
            _UniffiConverterTypePublicKey.check_lower(value.remote_signer_public_key)
            _UniffiConverterOptionalString.check_lower(value.secret)
            return
        if value.is_GET_PUBLIC_KEY():
            return
        if value.is_SIGN_EVENT():
            _UniffiConverterTypeUnsignedEvent.check_lower(value.unsigned_event)
            return
        if value.is_NIP04_ENCRYPT():
            _UniffiConverterTypePublicKey.check_lower(value.public_key)
            _UniffiConverterString.check_lower(value.text)
            return
        if value.is_NIP04_DECRYPT():
            _UniffiConverterTypePublicKey.check_lower(value.public_key)
            _UniffiConverterString.check_lower(value.ciphertext)
            return
        if value.is_NIP44_ENCRYPT():
            _UniffiConverterTypePublicKey.check_lower(value.public_key)
            _UniffiConverterString.check_lower(value.text)
            return
        if value.is_NIP44_DECRYPT():
            _UniffiConverterTypePublicKey.check_lower(value.public_key)
            _UniffiConverterString.check_lower(value.ciphertext)
            return
        if value.is_PING():
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value.is_CONNECT():
            buf.write_i32(1)
            _UniffiConverterTypePublicKey.write(value.remote_signer_public_key, buf)
            _UniffiConverterOptionalString.write(value.secret, buf)
        if value.is_GET_PUBLIC_KEY():
            buf.write_i32(2)
        if value.is_SIGN_EVENT():
            buf.write_i32(3)
            _UniffiConverterTypeUnsignedEvent.write(value.unsigned_event, buf)
        if value.is_NIP04_ENCRYPT():
            buf.write_i32(4)
            _UniffiConverterTypePublicKey.write(value.public_key, buf)
            _UniffiConverterString.write(value.text, buf)
        if value.is_NIP04_DECRYPT():
            buf.write_i32(5)
            _UniffiConverterTypePublicKey.write(value.public_key, buf)
            _UniffiConverterString.write(value.ciphertext, buf)
        if value.is_NIP44_ENCRYPT():
            buf.write_i32(6)
            _UniffiConverterTypePublicKey.write(value.public_key, buf)
            _UniffiConverterString.write(value.text, buf)
        if value.is_NIP44_DECRYPT():
            buf.write_i32(7)
            _UniffiConverterTypePublicKey.write(value.public_key, buf)
            _UniffiConverterString.write(value.ciphertext, buf)
        if value.is_PING():
            buf.write_i32(8)







class NostrParserToken:
    def __init__(self):
        raise RuntimeError("NostrParserToken cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class NOSTR:
        """
        Nostr URI

        <https://github.com/nostr-protocol/nips/blob/master/21.md>
        """

        uri: "Nip21Enum"

        def __init__(self,uri: "Nip21Enum"):
            self.uri = uri

        def __str__(self):
            return "NostrParserToken.NOSTR(uri={})".format(self.uri)

        def __eq__(self, other):
            if not other.is_NOSTR():
                return False
            if self.uri != other.uri:
                return False
            return True
    
    class URL:
        """
        Url
        """

        url: "str"

        def __init__(self,url: "str"):
            self.url = url

        def __str__(self):
            return "NostrParserToken.URL(url={})".format(self.url)

        def __eq__(self, other):
            if not other.is_URL():
                return False
            if self.url != other.url:
                return False
            return True
    
    class HASHTAG:
        """
        Hashtag
        """

        hashtag: "str"

        def __init__(self,hashtag: "str"):
            self.hashtag = hashtag

        def __str__(self):
            return "NostrParserToken.HASHTAG(hashtag={})".format(self.hashtag)

        def __eq__(self, other):
            if not other.is_HASHTAG():
                return False
            if self.hashtag != other.hashtag:
                return False
            return True
    
    class TEXT:
        """
        Other text

        Spaces at the beginning or end of a text are parsed as [`Token::Whitespace`].
        """

        text: "str"

        def __init__(self,text: "str"):
            self.text = text

        def __str__(self):
            return "NostrParserToken.TEXT(text={})".format(self.text)

        def __eq__(self, other):
            if not other.is_TEXT():
                return False
            if self.text != other.text:
                return False
            return True
    
    class LINE_BREAK:
        """
        Line break
        """


        def __init__(self,):
            pass

        def __str__(self):
            return "NostrParserToken.LINE_BREAK()".format()

        def __eq__(self, other):
            if not other.is_LINE_BREAK():
                return False
            return True
    
    class WHITESPACE:
        """
        A whitespace
        """


        def __init__(self,):
            pass

        def __str__(self):
            return "NostrParserToken.WHITESPACE()".format()

        def __eq__(self, other):
            if not other.is_WHITESPACE():
                return False
            return True
    
    

    # For each variant, we have `is_NAME` and `is_name` methods for easily checking
    # whether an instance is that variant.
    def is_NOSTR(self) -> bool:
        return isinstance(self, NostrParserToken.NOSTR)
    def is_nostr(self) -> bool:
        return isinstance(self, NostrParserToken.NOSTR)
    def is_URL(self) -> bool:
        return isinstance(self, NostrParserToken.URL)
    def is_url(self) -> bool:
        return isinstance(self, NostrParserToken.URL)
    def is_HASHTAG(self) -> bool:
        return isinstance(self, NostrParserToken.HASHTAG)
    def is_hashtag(self) -> bool:
        return isinstance(self, NostrParserToken.HASHTAG)
    def is_TEXT(self) -> bool:
        return isinstance(self, NostrParserToken.TEXT)
    def is_text(self) -> bool:
        return isinstance(self, NostrParserToken.TEXT)
    def is_LINE_BREAK(self) -> bool:
        return isinstance(self, NostrParserToken.LINE_BREAK)
    def is_line_break(self) -> bool:
        return isinstance(self, NostrParserToken.LINE_BREAK)
    def is_WHITESPACE(self) -> bool:
        return isinstance(self, NostrParserToken.WHITESPACE)
    def is_whitespace(self) -> bool:
        return isinstance(self, NostrParserToken.WHITESPACE)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
NostrParserToken.NOSTR = type("NostrParserToken.NOSTR", (NostrParserToken.NOSTR, NostrParserToken,), {})  # type: ignore
NostrParserToken.URL = type("NostrParserToken.URL", (NostrParserToken.URL, NostrParserToken,), {})  # type: ignore
NostrParserToken.HASHTAG = type("NostrParserToken.HASHTAG", (NostrParserToken.HASHTAG, NostrParserToken,), {})  # type: ignore
NostrParserToken.TEXT = type("NostrParserToken.TEXT", (NostrParserToken.TEXT, NostrParserToken,), {})  # type: ignore
NostrParserToken.LINE_BREAK = type("NostrParserToken.LINE_BREAK", (NostrParserToken.LINE_BREAK, NostrParserToken,), {})  # type: ignore
NostrParserToken.WHITESPACE = type("NostrParserToken.WHITESPACE", (NostrParserToken.WHITESPACE, NostrParserToken,), {})  # type: ignore




class _UniffiConverterTypeNostrParserToken(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return NostrParserToken.NOSTR(
                _UniffiConverterTypeNip21Enum.read(buf),
            )
        if variant == 2:
            return NostrParserToken.URL(
                _UniffiConverterString.read(buf),
            )
        if variant == 3:
            return NostrParserToken.HASHTAG(
                _UniffiConverterString.read(buf),
            )
        if variant == 4:
            return NostrParserToken.TEXT(
                _UniffiConverterString.read(buf),
            )
        if variant == 5:
            return NostrParserToken.LINE_BREAK(
            )
        if variant == 6:
            return NostrParserToken.WHITESPACE(
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value.is_NOSTR():
            _UniffiConverterTypeNip21Enum.check_lower(value.uri)
            return
        if value.is_URL():
            _UniffiConverterString.check_lower(value.url)
            return
        if value.is_HASHTAG():
            _UniffiConverterString.check_lower(value.hashtag)
            return
        if value.is_TEXT():
            _UniffiConverterString.check_lower(value.text)
            return
        if value.is_LINE_BREAK():
            return
        if value.is_WHITESPACE():
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value.is_NOSTR():
            buf.write_i32(1)
            _UniffiConverterTypeNip21Enum.write(value.uri, buf)
        if value.is_URL():
            buf.write_i32(2)
            _UniffiConverterString.write(value.url, buf)
        if value.is_HASHTAG():
            buf.write_i32(3)
            _UniffiConverterString.write(value.hashtag, buf)
        if value.is_TEXT():
            buf.write_i32(4)
            _UniffiConverterString.write(value.text, buf)
        if value.is_LINE_BREAK():
            buf.write_i32(5)
        if value.is_WHITESPACE():
            buf.write_i32(6)




# NostrSdkError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class NostrSdkError(Exception):
    pass

_UniffiTempNostrSdkError = NostrSdkError

class NostrSdkError:  # type: ignore
    class Generic(_UniffiTempNostrSdkError):

        def __repr__(self):
            return "NostrSdkError.Generic({})".format(repr(str(self)))
    _UniffiTempNostrSdkError.Generic = Generic # type: ignore

NostrSdkError = _UniffiTempNostrSdkError # type: ignore
del _UniffiTempNostrSdkError


class _UniffiConverterTypeNostrSdkError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return NostrSdkError.Generic(
                _UniffiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if isinstance(value, NostrSdkError.Generic):
            return

    @staticmethod
    def write(value, buf):
        if isinstance(value, NostrSdkError.Generic):
            buf.write_i32(1)





class PolicyResult:
    """
    Generic plugin policy response
    """

    def __init__(self):
        raise RuntimeError("PolicyResult cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class ACCEPT:
        """
        Policy enforces that the event/query should be accepted
        """


        def __init__(self,):
            pass

        def __str__(self):
            return "PolicyResult.ACCEPT()".format()

        def __eq__(self, other):
            if not other.is_ACCEPT():
                return False
            return True
    
    class REJECT:
        """
        Policy enforces that the event/query should be rejected
        """

        reason: "str"
        """
        Rejection reason
        """


        def __init__(self,reason: "str"):
            self.reason = reason

        def __str__(self):
            return "PolicyResult.REJECT(reason={})".format(self.reason)

        def __eq__(self, other):
            if not other.is_REJECT():
                return False
            if self.reason != other.reason:
                return False
            return True
    
    

    # For each variant, we have `is_NAME` and `is_name` methods for easily checking
    # whether an instance is that variant.
    def is_ACCEPT(self) -> bool:
        return isinstance(self, PolicyResult.ACCEPT)
    def is_accept(self) -> bool:
        return isinstance(self, PolicyResult.ACCEPT)
    def is_REJECT(self) -> bool:
        return isinstance(self, PolicyResult.REJECT)
    def is_reject(self) -> bool:
        return isinstance(self, PolicyResult.REJECT)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
PolicyResult.ACCEPT = type("PolicyResult.ACCEPT", (PolicyResult.ACCEPT, PolicyResult,), {})  # type: ignore
PolicyResult.REJECT = type("PolicyResult.REJECT", (PolicyResult.REJECT, PolicyResult,), {})  # type: ignore




class _UniffiConverterTypePolicyResult(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return PolicyResult.ACCEPT(
            )
        if variant == 2:
            return PolicyResult.REJECT(
                _UniffiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value.is_ACCEPT():
            return
        if value.is_REJECT():
            _UniffiConverterString.check_lower(value.reason)
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value.is_ACCEPT():
            buf.write_i32(1)
        if value.is_REJECT():
            buf.write_i32(2)
            _UniffiConverterString.write(value.reason, buf)







class PollType(enum.Enum):
    SINGLE_CHOICE = 0
    """
    Single choice
    """

    
    MULTIPLE_CHOICE = 1
    """
    Multiple choice
    """

    


class _UniffiConverterTypePollType(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return PollType.SINGLE_CHOICE
        if variant == 2:
            return PollType.MULTIPLE_CHOICE
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == PollType.SINGLE_CHOICE:
            return
        if value == PollType.MULTIPLE_CHOICE:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == PollType.SINGLE_CHOICE:
            buf.write_i32(1)
        if value == PollType.MULTIPLE_CHOICE:
            buf.write_i32(2)







class Protocol:
    """
    NIP48 Proxy Protocol
    """

    def __init__(self):
        raise RuntimeError("Protocol cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class ACTIVITY_PUB:
        """
        ActivityPub
        """


        def __init__(self,):
            pass

        def __str__(self):
            return "Protocol.ACTIVITY_PUB()".format()

        def __eq__(self, other):
            if not other.is_ACTIVITY_PUB():
                return False
            return True
    
    class AT_PROTO:
        """
        AT Protocol
        """


        def __init__(self,):
            pass

        def __str__(self):
            return "Protocol.AT_PROTO()".format()

        def __eq__(self, other):
            if not other.is_AT_PROTO():
                return False
            return True
    
    class RSS:
        """
        Rss
        """


        def __init__(self,):
            pass

        def __str__(self):
            return "Protocol.RSS()".format()

        def __eq__(self, other):
            if not other.is_RSS():
                return False
            return True
    
    class WEB:
        """
        Web
        """


        def __init__(self,):
            pass

        def __str__(self):
            return "Protocol.WEB()".format()

        def __eq__(self, other):
            if not other.is_WEB():
                return False
            return True
    
    class CUSTOM:
        """
        Custom
        """

        custom: "str"

        def __init__(self,custom: "str"):
            self.custom = custom

        def __str__(self):
            return "Protocol.CUSTOM(custom={})".format(self.custom)

        def __eq__(self, other):
            if not other.is_CUSTOM():
                return False
            if self.custom != other.custom:
                return False
            return True
    
    

    # For each variant, we have `is_NAME` and `is_name` methods for easily checking
    # whether an instance is that variant.
    def is_ACTIVITY_PUB(self) -> bool:
        return isinstance(self, Protocol.ACTIVITY_PUB)
    def is_activity_pub(self) -> bool:
        return isinstance(self, Protocol.ACTIVITY_PUB)
    def is_AT_PROTO(self) -> bool:
        return isinstance(self, Protocol.AT_PROTO)
    def is_at_proto(self) -> bool:
        return isinstance(self, Protocol.AT_PROTO)
    def is_RSS(self) -> bool:
        return isinstance(self, Protocol.RSS)
    def is_rss(self) -> bool:
        return isinstance(self, Protocol.RSS)
    def is_WEB(self) -> bool:
        return isinstance(self, Protocol.WEB)
    def is_web(self) -> bool:
        return isinstance(self, Protocol.WEB)
    def is_CUSTOM(self) -> bool:
        return isinstance(self, Protocol.CUSTOM)
    def is_custom(self) -> bool:
        return isinstance(self, Protocol.CUSTOM)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
Protocol.ACTIVITY_PUB = type("Protocol.ACTIVITY_PUB", (Protocol.ACTIVITY_PUB, Protocol,), {})  # type: ignore
Protocol.AT_PROTO = type("Protocol.AT_PROTO", (Protocol.AT_PROTO, Protocol,), {})  # type: ignore
Protocol.RSS = type("Protocol.RSS", (Protocol.RSS, Protocol,), {})  # type: ignore
Protocol.WEB = type("Protocol.WEB", (Protocol.WEB, Protocol,), {})  # type: ignore
Protocol.CUSTOM = type("Protocol.CUSTOM", (Protocol.CUSTOM, Protocol,), {})  # type: ignore




class _UniffiConverterTypeProtocol(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return Protocol.ACTIVITY_PUB(
            )
        if variant == 2:
            return Protocol.AT_PROTO(
            )
        if variant == 3:
            return Protocol.RSS(
            )
        if variant == 4:
            return Protocol.WEB(
            )
        if variant == 5:
            return Protocol.CUSTOM(
                _UniffiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value.is_ACTIVITY_PUB():
            return
        if value.is_AT_PROTO():
            return
        if value.is_RSS():
            return
        if value.is_WEB():
            return
        if value.is_CUSTOM():
            _UniffiConverterString.check_lower(value.custom)
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value.is_ACTIVITY_PUB():
            buf.write_i32(1)
        if value.is_AT_PROTO():
            buf.write_i32(2)
        if value.is_RSS():
            buf.write_i32(3)
        if value.is_WEB():
            buf.write_i32(4)
        if value.is_CUSTOM():
            buf.write_i32(5)
            _UniffiConverterString.write(value.custom, buf)







class RejectedReason(enum.Enum):
    """
    Reason why event wasn't stored into the database
    """

    EPHEMERAL = 0
    """
    Ephemeral events aren't expected to be stored
    """

    
    DUPLICATE = 1
    """
    The event already exists
    """

    
    DELETED = 2
    """
    The event was deleted
    """

    
    EXPIRED = 3
    """
    The event is expired
    """

    
    REPLACED = 4
    """
    The event was replaced
    """

    
    INVALID_DELETE = 5
    """
    Attempt to delete a non-owned event
    """

    
    OTHER = 6
    """
    Other reason
    """

    


class _UniffiConverterTypeRejectedReason(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return RejectedReason.EPHEMERAL
        if variant == 2:
            return RejectedReason.DUPLICATE
        if variant == 3:
            return RejectedReason.DELETED
        if variant == 4:
            return RejectedReason.EXPIRED
        if variant == 5:
            return RejectedReason.REPLACED
        if variant == 6:
            return RejectedReason.INVALID_DELETE
        if variant == 7:
            return RejectedReason.OTHER
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == RejectedReason.EPHEMERAL:
            return
        if value == RejectedReason.DUPLICATE:
            return
        if value == RejectedReason.DELETED:
            return
        if value == RejectedReason.EXPIRED:
            return
        if value == RejectedReason.REPLACED:
            return
        if value == RejectedReason.INVALID_DELETE:
            return
        if value == RejectedReason.OTHER:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == RejectedReason.EPHEMERAL:
            buf.write_i32(1)
        if value == RejectedReason.DUPLICATE:
            buf.write_i32(2)
        if value == RejectedReason.DELETED:
            buf.write_i32(3)
        if value == RejectedReason.EXPIRED:
            buf.write_i32(4)
        if value == RejectedReason.REPLACED:
            buf.write_i32(5)
        if value == RejectedReason.INVALID_DELETE:
            buf.write_i32(6)
        if value == RejectedReason.OTHER:
            buf.write_i32(7)







class RelayBuilderNip42Mode(enum.Enum):
    """
    NIP42 mode
    """

    WRITE = 0
    """
    Require authentication for writing
    """

    
    READ = 1
    """
    Require authentication for reading
    """

    
    BOTH = 2
    """
    Always require authentication
    """

    


class _UniffiConverterTypeRelayBuilderNip42Mode(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return RelayBuilderNip42Mode.WRITE
        if variant == 2:
            return RelayBuilderNip42Mode.READ
        if variant == 3:
            return RelayBuilderNip42Mode.BOTH
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == RelayBuilderNip42Mode.WRITE:
            return
        if value == RelayBuilderNip42Mode.READ:
            return
        if value == RelayBuilderNip42Mode.BOTH:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == RelayBuilderNip42Mode.WRITE:
            buf.write_i32(1)
        if value == RelayBuilderNip42Mode.READ:
            buf.write_i32(2)
        if value == RelayBuilderNip42Mode.BOTH:
            buf.write_i32(3)







class RelayMessageEnum:
    def __init__(self):
        raise RuntimeError("RelayMessageEnum cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class EVENT_MSG:
        subscription_id: "str"
        event: "Event"

        def __init__(self,subscription_id: "str", event: "Event"):
            self.subscription_id = subscription_id
            self.event = event

        def __str__(self):
            return "RelayMessageEnum.EVENT_MSG(subscription_id={}, event={})".format(self.subscription_id, self.event)

        def __eq__(self, other):
            if not other.is_EVENT_MSG():
                return False
            if self.subscription_id != other.subscription_id:
                return False
            if self.event != other.event:
                return False
            return True
    
    class OK:
        event_id: "EventId"
        status: "bool"
        message: "str"

        def __init__(self,event_id: "EventId", status: "bool", message: "str"):
            self.event_id = event_id
            self.status = status
            self.message = message

        def __str__(self):
            return "RelayMessageEnum.OK(event_id={}, status={}, message={})".format(self.event_id, self.status, self.message)

        def __eq__(self, other):
            if not other.is_OK():
                return False
            if self.event_id != other.event_id:
                return False
            if self.status != other.status:
                return False
            if self.message != other.message:
                return False
            return True
    
    class END_OF_STORED_EVENTS:
        subscription_id: "str"

        def __init__(self,subscription_id: "str"):
            self.subscription_id = subscription_id

        def __str__(self):
            return "RelayMessageEnum.END_OF_STORED_EVENTS(subscription_id={})".format(self.subscription_id)

        def __eq__(self, other):
            if not other.is_END_OF_STORED_EVENTS():
                return False
            if self.subscription_id != other.subscription_id:
                return False
            return True
    
    class NOTICE:
        message: "str"

        def __init__(self,message: "str"):
            self.message = message

        def __str__(self):
            return "RelayMessageEnum.NOTICE(message={})".format(self.message)

        def __eq__(self, other):
            if not other.is_NOTICE():
                return False
            if self.message != other.message:
                return False
            return True
    
    class CLOSED:
        subscription_id: "str"
        message: "str"

        def __init__(self,subscription_id: "str", message: "str"):
            self.subscription_id = subscription_id
            self.message = message

        def __str__(self):
            return "RelayMessageEnum.CLOSED(subscription_id={}, message={})".format(self.subscription_id, self.message)

        def __eq__(self, other):
            if not other.is_CLOSED():
                return False
            if self.subscription_id != other.subscription_id:
                return False
            if self.message != other.message:
                return False
            return True
    
    class AUTH:
        challenge: "str"

        def __init__(self,challenge: "str"):
            self.challenge = challenge

        def __str__(self):
            return "RelayMessageEnum.AUTH(challenge={})".format(self.challenge)

        def __eq__(self, other):
            if not other.is_AUTH():
                return False
            if self.challenge != other.challenge:
                return False
            return True
    
    class COUNT:
        subscription_id: "str"
        count: "int"

        def __init__(self,subscription_id: "str", count: "int"):
            self.subscription_id = subscription_id
            self.count = count

        def __str__(self):
            return "RelayMessageEnum.COUNT(subscription_id={}, count={})".format(self.subscription_id, self.count)

        def __eq__(self, other):
            if not other.is_COUNT():
                return False
            if self.subscription_id != other.subscription_id:
                return False
            if self.count != other.count:
                return False
            return True
    
    class NEG_MSG:
        subscription_id: "str"
        message: "str"

        def __init__(self,subscription_id: "str", message: "str"):
            self.subscription_id = subscription_id
            self.message = message

        def __str__(self):
            return "RelayMessageEnum.NEG_MSG(subscription_id={}, message={})".format(self.subscription_id, self.message)

        def __eq__(self, other):
            if not other.is_NEG_MSG():
                return False
            if self.subscription_id != other.subscription_id:
                return False
            if self.message != other.message:
                return False
            return True
    
    class NEG_ERR:
        subscription_id: "str"
        message: "str"

        def __init__(self,subscription_id: "str", message: "str"):
            self.subscription_id = subscription_id
            self.message = message

        def __str__(self):
            return "RelayMessageEnum.NEG_ERR(subscription_id={}, message={})".format(self.subscription_id, self.message)

        def __eq__(self, other):
            if not other.is_NEG_ERR():
                return False
            if self.subscription_id != other.subscription_id:
                return False
            if self.message != other.message:
                return False
            return True
    
    

    # For each variant, we have `is_NAME` and `is_name` methods for easily checking
    # whether an instance is that variant.
    def is_EVENT_MSG(self) -> bool:
        return isinstance(self, RelayMessageEnum.EVENT_MSG)
    def is_event_msg(self) -> bool:
        return isinstance(self, RelayMessageEnum.EVENT_MSG)
    def is_OK(self) -> bool:
        return isinstance(self, RelayMessageEnum.OK)
    def is_ok(self) -> bool:
        return isinstance(self, RelayMessageEnum.OK)
    def is_END_OF_STORED_EVENTS(self) -> bool:
        return isinstance(self, RelayMessageEnum.END_OF_STORED_EVENTS)
    def is_end_of_stored_events(self) -> bool:
        return isinstance(self, RelayMessageEnum.END_OF_STORED_EVENTS)
    def is_NOTICE(self) -> bool:
        return isinstance(self, RelayMessageEnum.NOTICE)
    def is_notice(self) -> bool:
        return isinstance(self, RelayMessageEnum.NOTICE)
    def is_CLOSED(self) -> bool:
        return isinstance(self, RelayMessageEnum.CLOSED)
    def is_closed(self) -> bool:
        return isinstance(self, RelayMessageEnum.CLOSED)
    def is_AUTH(self) -> bool:
        return isinstance(self, RelayMessageEnum.AUTH)
    def is_auth(self) -> bool:
        return isinstance(self, RelayMessageEnum.AUTH)
    def is_COUNT(self) -> bool:
        return isinstance(self, RelayMessageEnum.COUNT)
    def is_count(self) -> bool:
        return isinstance(self, RelayMessageEnum.COUNT)
    def is_NEG_MSG(self) -> bool:
        return isinstance(self, RelayMessageEnum.NEG_MSG)
    def is_neg_msg(self) -> bool:
        return isinstance(self, RelayMessageEnum.NEG_MSG)
    def is_NEG_ERR(self) -> bool:
        return isinstance(self, RelayMessageEnum.NEG_ERR)
    def is_neg_err(self) -> bool:
        return isinstance(self, RelayMessageEnum.NEG_ERR)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
RelayMessageEnum.EVENT_MSG = type("RelayMessageEnum.EVENT_MSG", (RelayMessageEnum.EVENT_MSG, RelayMessageEnum,), {})  # type: ignore
RelayMessageEnum.OK = type("RelayMessageEnum.OK", (RelayMessageEnum.OK, RelayMessageEnum,), {})  # type: ignore
RelayMessageEnum.END_OF_STORED_EVENTS = type("RelayMessageEnum.END_OF_STORED_EVENTS", (RelayMessageEnum.END_OF_STORED_EVENTS, RelayMessageEnum,), {})  # type: ignore
RelayMessageEnum.NOTICE = type("RelayMessageEnum.NOTICE", (RelayMessageEnum.NOTICE, RelayMessageEnum,), {})  # type: ignore
RelayMessageEnum.CLOSED = type("RelayMessageEnum.CLOSED", (RelayMessageEnum.CLOSED, RelayMessageEnum,), {})  # type: ignore
RelayMessageEnum.AUTH = type("RelayMessageEnum.AUTH", (RelayMessageEnum.AUTH, RelayMessageEnum,), {})  # type: ignore
RelayMessageEnum.COUNT = type("RelayMessageEnum.COUNT", (RelayMessageEnum.COUNT, RelayMessageEnum,), {})  # type: ignore
RelayMessageEnum.NEG_MSG = type("RelayMessageEnum.NEG_MSG", (RelayMessageEnum.NEG_MSG, RelayMessageEnum,), {})  # type: ignore
RelayMessageEnum.NEG_ERR = type("RelayMessageEnum.NEG_ERR", (RelayMessageEnum.NEG_ERR, RelayMessageEnum,), {})  # type: ignore




class _UniffiConverterTypeRelayMessageEnum(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return RelayMessageEnum.EVENT_MSG(
                _UniffiConverterString.read(buf),
                _UniffiConverterTypeEvent.read(buf),
            )
        if variant == 2:
            return RelayMessageEnum.OK(
                _UniffiConverterTypeEventId.read(buf),
                _UniffiConverterBool.read(buf),
                _UniffiConverterString.read(buf),
            )
        if variant == 3:
            return RelayMessageEnum.END_OF_STORED_EVENTS(
                _UniffiConverterString.read(buf),
            )
        if variant == 4:
            return RelayMessageEnum.NOTICE(
                _UniffiConverterString.read(buf),
            )
        if variant == 5:
            return RelayMessageEnum.CLOSED(
                _UniffiConverterString.read(buf),
                _UniffiConverterString.read(buf),
            )
        if variant == 6:
            return RelayMessageEnum.AUTH(
                _UniffiConverterString.read(buf),
            )
        if variant == 7:
            return RelayMessageEnum.COUNT(
                _UniffiConverterString.read(buf),
                _UniffiConverterUInt64.read(buf),
            )
        if variant == 8:
            return RelayMessageEnum.NEG_MSG(
                _UniffiConverterString.read(buf),
                _UniffiConverterString.read(buf),
            )
        if variant == 9:
            return RelayMessageEnum.NEG_ERR(
                _UniffiConverterString.read(buf),
                _UniffiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value.is_EVENT_MSG():
            _UniffiConverterString.check_lower(value.subscription_id)
            _UniffiConverterTypeEvent.check_lower(value.event)
            return
        if value.is_OK():
            _UniffiConverterTypeEventId.check_lower(value.event_id)
            _UniffiConverterBool.check_lower(value.status)
            _UniffiConverterString.check_lower(value.message)
            return
        if value.is_END_OF_STORED_EVENTS():
            _UniffiConverterString.check_lower(value.subscription_id)
            return
        if value.is_NOTICE():
            _UniffiConverterString.check_lower(value.message)
            return
        if value.is_CLOSED():
            _UniffiConverterString.check_lower(value.subscription_id)
            _UniffiConverterString.check_lower(value.message)
            return
        if value.is_AUTH():
            _UniffiConverterString.check_lower(value.challenge)
            return
        if value.is_COUNT():
            _UniffiConverterString.check_lower(value.subscription_id)
            _UniffiConverterUInt64.check_lower(value.count)
            return
        if value.is_NEG_MSG():
            _UniffiConverterString.check_lower(value.subscription_id)
            _UniffiConverterString.check_lower(value.message)
            return
        if value.is_NEG_ERR():
            _UniffiConverterString.check_lower(value.subscription_id)
            _UniffiConverterString.check_lower(value.message)
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value.is_EVENT_MSG():
            buf.write_i32(1)
            _UniffiConverterString.write(value.subscription_id, buf)
            _UniffiConverterTypeEvent.write(value.event, buf)
        if value.is_OK():
            buf.write_i32(2)
            _UniffiConverterTypeEventId.write(value.event_id, buf)
            _UniffiConverterBool.write(value.status, buf)
            _UniffiConverterString.write(value.message, buf)
        if value.is_END_OF_STORED_EVENTS():
            buf.write_i32(3)
            _UniffiConverterString.write(value.subscription_id, buf)
        if value.is_NOTICE():
            buf.write_i32(4)
            _UniffiConverterString.write(value.message, buf)
        if value.is_CLOSED():
            buf.write_i32(5)
            _UniffiConverterString.write(value.subscription_id, buf)
            _UniffiConverterString.write(value.message, buf)
        if value.is_AUTH():
            buf.write_i32(6)
            _UniffiConverterString.write(value.challenge, buf)
        if value.is_COUNT():
            buf.write_i32(7)
            _UniffiConverterString.write(value.subscription_id, buf)
            _UniffiConverterUInt64.write(value.count, buf)
        if value.is_NEG_MSG():
            buf.write_i32(8)
            _UniffiConverterString.write(value.subscription_id, buf)
            _UniffiConverterString.write(value.message, buf)
        if value.is_NEG_ERR():
            buf.write_i32(9)
            _UniffiConverterString.write(value.subscription_id, buf)
            _UniffiConverterString.write(value.message, buf)







class RelayMetadata(enum.Enum):
    READ = 0
    """
    Read
    """

    
    WRITE = 1
    """
    Write
    """

    


class _UniffiConverterTypeRelayMetadata(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return RelayMetadata.READ
        if variant == 2:
            return RelayMetadata.WRITE
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == RelayMetadata.READ:
            return
        if value == RelayMetadata.WRITE:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == RelayMetadata.READ:
            buf.write_i32(1)
        if value == RelayMetadata.WRITE:
            buf.write_i32(2)







class RelayStatus(enum.Enum):
    INITIALIZED = 0
    """
    Initialized
    """

    
    PENDING = 1
    """
    Pending
    """

    
    CONNECTING = 2
    """
    Connecting
    """

    
    CONNECTED = 3
    """
    Connected
    """

    
    DISCONNECTED = 4
    """
    Disconnected, will retry to connect again
    """

    
    TERMINATED = 5
    """
    Completely disconnected
    """

    
    BANNED = 6
    """
    The relay has been banned.
    """

    
    SLEEPING = 7
    """
    Relay is sleeping
    """

    


class _UniffiConverterTypeRelayStatus(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return RelayStatus.INITIALIZED
        if variant == 2:
            return RelayStatus.PENDING
        if variant == 3:
            return RelayStatus.CONNECTING
        if variant == 4:
            return RelayStatus.CONNECTED
        if variant == 5:
            return RelayStatus.DISCONNECTED
        if variant == 6:
            return RelayStatus.TERMINATED
        if variant == 7:
            return RelayStatus.BANNED
        if variant == 8:
            return RelayStatus.SLEEPING
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == RelayStatus.INITIALIZED:
            return
        if value == RelayStatus.PENDING:
            return
        if value == RelayStatus.CONNECTING:
            return
        if value == RelayStatus.CONNECTED:
            return
        if value == RelayStatus.DISCONNECTED:
            return
        if value == RelayStatus.TERMINATED:
            return
        if value == RelayStatus.BANNED:
            return
        if value == RelayStatus.SLEEPING:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == RelayStatus.INITIALIZED:
            buf.write_i32(1)
        if value == RelayStatus.PENDING:
            buf.write_i32(2)
        if value == RelayStatus.CONNECTING:
            buf.write_i32(3)
        if value == RelayStatus.CONNECTED:
            buf.write_i32(4)
        if value == RelayStatus.DISCONNECTED:
            buf.write_i32(5)
        if value == RelayStatus.TERMINATED:
            buf.write_i32(6)
        if value == RelayStatus.BANNED:
            buf.write_i32(7)
        if value == RelayStatus.SLEEPING:
            buf.write_i32(8)







class Report(enum.Enum):
    """
    Report

    <https://github.com/nostr-protocol/nips/blob/master/56.md>
    """

    NUDITY = 0
    """
    Depictions of nudity, porn, etc
    """

    
    MALWARE = 1
    """
    Virus, trojan horse, worm, robot, spyware, adware, back door, ransomware, rootkit, kidnapper, etc.
    """

    
    PROFANITY = 2
    """
    Profanity, hateful speech, etc.
    """

    
    ILLEGAL = 3
    """
    Something which may be illegal in some jurisdiction

    Remember: there is what is right and there is the law.
    """

    
    SPAM = 4
    """
    Spam
    """

    
    IMPERSONATION = 5
    """
    Someone pretending to be someone else
    """

    
    OTHER = 6
    """
    Reports that don't fit in the above categories
    """

    


class _UniffiConverterTypeReport(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return Report.NUDITY
        if variant == 2:
            return Report.MALWARE
        if variant == 3:
            return Report.PROFANITY
        if variant == 4:
            return Report.ILLEGAL
        if variant == 5:
            return Report.SPAM
        if variant == 6:
            return Report.IMPERSONATION
        if variant == 7:
            return Report.OTHER
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == Report.NUDITY:
            return
        if value == Report.MALWARE:
            return
        if value == Report.PROFANITY:
            return
        if value == Report.ILLEGAL:
            return
        if value == Report.SPAM:
            return
        if value == Report.IMPERSONATION:
            return
        if value == Report.OTHER:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == Report.NUDITY:
            buf.write_i32(1)
        if value == Report.MALWARE:
            buf.write_i32(2)
        if value == Report.PROFANITY:
            buf.write_i32(3)
        if value == Report.ILLEGAL:
            buf.write_i32(4)
        if value == Report.SPAM:
            buf.write_i32(5)
        if value == Report.IMPERSONATION:
            buf.write_i32(6)
        if value == Report.OTHER:
            buf.write_i32(7)







class ReqExitPolicy:
    """
    Request (REQ) exit policy
    """

    def __init__(self):
        raise RuntimeError("ReqExitPolicy cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class EXIT_ON_EOSE:
        """
        Exit on EOSE
        """


        def __init__(self,):
            pass

        def __str__(self):
            return "ReqExitPolicy.EXIT_ON_EOSE()".format()

        def __eq__(self, other):
            if not other.is_EXIT_ON_EOSE():
                return False
            return True
    
    class WAIT_FOR_EVENTS:
        """
        Wait to receive N events and then exit.
        """

        num: "int"

        def __init__(self,num: "int"):
            self.num = num

        def __str__(self):
            return "ReqExitPolicy.WAIT_FOR_EVENTS(num={})".format(self.num)

        def __eq__(self, other):
            if not other.is_WAIT_FOR_EVENTS():
                return False
            if self.num != other.num:
                return False
            return True
    
    class WAIT_FOR_EVENTS_AFTER_EOSE:
        """
        After EOSE is received, keep listening for N more events that match the filter.
        """

        num: "int"

        def __init__(self,num: "int"):
            self.num = num

        def __str__(self):
            return "ReqExitPolicy.WAIT_FOR_EVENTS_AFTER_EOSE(num={})".format(self.num)

        def __eq__(self, other):
            if not other.is_WAIT_FOR_EVENTS_AFTER_EOSE():
                return False
            if self.num != other.num:
                return False
            return True
    
    class WAIT_DURATION_AFTER_EOSE:
        """
        After EOSE is received, keep listening for matching events for `Duration` more time.
        """

        duration: "Duration"

        def __init__(self,duration: "Duration"):
            self.duration = duration

        def __str__(self):
            return "ReqExitPolicy.WAIT_DURATION_AFTER_EOSE(duration={})".format(self.duration)

        def __eq__(self, other):
            if not other.is_WAIT_DURATION_AFTER_EOSE():
                return False
            if self.duration != other.duration:
                return False
            return True
    
    

    # For each variant, we have `is_NAME` and `is_name` methods for easily checking
    # whether an instance is that variant.
    def is_EXIT_ON_EOSE(self) -> bool:
        return isinstance(self, ReqExitPolicy.EXIT_ON_EOSE)
    def is_exit_on_eose(self) -> bool:
        return isinstance(self, ReqExitPolicy.EXIT_ON_EOSE)
    def is_WAIT_FOR_EVENTS(self) -> bool:
        return isinstance(self, ReqExitPolicy.WAIT_FOR_EVENTS)
    def is_wait_for_events(self) -> bool:
        return isinstance(self, ReqExitPolicy.WAIT_FOR_EVENTS)
    def is_WAIT_FOR_EVENTS_AFTER_EOSE(self) -> bool:
        return isinstance(self, ReqExitPolicy.WAIT_FOR_EVENTS_AFTER_EOSE)
    def is_wait_for_events_after_eose(self) -> bool:
        return isinstance(self, ReqExitPolicy.WAIT_FOR_EVENTS_AFTER_EOSE)
    def is_WAIT_DURATION_AFTER_EOSE(self) -> bool:
        return isinstance(self, ReqExitPolicy.WAIT_DURATION_AFTER_EOSE)
    def is_wait_duration_after_eose(self) -> bool:
        return isinstance(self, ReqExitPolicy.WAIT_DURATION_AFTER_EOSE)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
ReqExitPolicy.EXIT_ON_EOSE = type("ReqExitPolicy.EXIT_ON_EOSE", (ReqExitPolicy.EXIT_ON_EOSE, ReqExitPolicy,), {})  # type: ignore
ReqExitPolicy.WAIT_FOR_EVENTS = type("ReqExitPolicy.WAIT_FOR_EVENTS", (ReqExitPolicy.WAIT_FOR_EVENTS, ReqExitPolicy,), {})  # type: ignore
ReqExitPolicy.WAIT_FOR_EVENTS_AFTER_EOSE = type("ReqExitPolicy.WAIT_FOR_EVENTS_AFTER_EOSE", (ReqExitPolicy.WAIT_FOR_EVENTS_AFTER_EOSE, ReqExitPolicy,), {})  # type: ignore
ReqExitPolicy.WAIT_DURATION_AFTER_EOSE = type("ReqExitPolicy.WAIT_DURATION_AFTER_EOSE", (ReqExitPolicy.WAIT_DURATION_AFTER_EOSE, ReqExitPolicy,), {})  # type: ignore




class _UniffiConverterTypeReqExitPolicy(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return ReqExitPolicy.EXIT_ON_EOSE(
            )
        if variant == 2:
            return ReqExitPolicy.WAIT_FOR_EVENTS(
                _UniffiConverterUInt16.read(buf),
            )
        if variant == 3:
            return ReqExitPolicy.WAIT_FOR_EVENTS_AFTER_EOSE(
                _UniffiConverterUInt16.read(buf),
            )
        if variant == 4:
            return ReqExitPolicy.WAIT_DURATION_AFTER_EOSE(
                _UniffiConverterDuration.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value.is_EXIT_ON_EOSE():
            return
        if value.is_WAIT_FOR_EVENTS():
            _UniffiConverterUInt16.check_lower(value.num)
            return
        if value.is_WAIT_FOR_EVENTS_AFTER_EOSE():
            _UniffiConverterUInt16.check_lower(value.num)
            return
        if value.is_WAIT_DURATION_AFTER_EOSE():
            _UniffiConverterDuration.check_lower(value.duration)
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value.is_EXIT_ON_EOSE():
            buf.write_i32(1)
        if value.is_WAIT_FOR_EVENTS():
            buf.write_i32(2)
            _UniffiConverterUInt16.write(value.num, buf)
        if value.is_WAIT_FOR_EVENTS_AFTER_EOSE():
            buf.write_i32(3)
            _UniffiConverterUInt16.write(value.num, buf)
        if value.is_WAIT_DURATION_AFTER_EOSE():
            buf.write_i32(4)
            _UniffiConverterDuration.write(value.duration, buf)







class RequestParams:
    """
    Nostr Wallet Connect Request Params
    """

    def __init__(self):
        raise RuntimeError("RequestParams cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class PAY_INVOICE:
        """
        Pay Invoice
        """

        pay_invoice: "PayInvoiceRequest"

        def __init__(self,pay_invoice: "PayInvoiceRequest"):
            self.pay_invoice = pay_invoice

        def __str__(self):
            return "RequestParams.PAY_INVOICE(pay_invoice={})".format(self.pay_invoice)

        def __eq__(self, other):
            if not other.is_PAY_INVOICE():
                return False
            if self.pay_invoice != other.pay_invoice:
                return False
            return True
    
    class MULTI_PAY_INVOICE:
        """
        Multi Pay Invoice
        """

        multi_pay_invoice: "MultiPayInvoiceRequest"

        def __init__(self,multi_pay_invoice: "MultiPayInvoiceRequest"):
            self.multi_pay_invoice = multi_pay_invoice

        def __str__(self):
            return "RequestParams.MULTI_PAY_INVOICE(multi_pay_invoice={})".format(self.multi_pay_invoice)

        def __eq__(self, other):
            if not other.is_MULTI_PAY_INVOICE():
                return False
            if self.multi_pay_invoice != other.multi_pay_invoice:
                return False
            return True
    
    class PAY_KEYSEND:
        """
        Pay Keysend
        """

        pay_keysend: "PayKeysendRequest"

        def __init__(self,pay_keysend: "PayKeysendRequest"):
            self.pay_keysend = pay_keysend

        def __str__(self):
            return "RequestParams.PAY_KEYSEND(pay_keysend={})".format(self.pay_keysend)

        def __eq__(self, other):
            if not other.is_PAY_KEYSEND():
                return False
            if self.pay_keysend != other.pay_keysend:
                return False
            return True
    
    class MULTI_PAY_KEYSEND:
        """
        Multi Pay Keysend
        """

        multi_pay_keysend: "MultiPayKeysendRequest"

        def __init__(self,multi_pay_keysend: "MultiPayKeysendRequest"):
            self.multi_pay_keysend = multi_pay_keysend

        def __str__(self):
            return "RequestParams.MULTI_PAY_KEYSEND(multi_pay_keysend={})".format(self.multi_pay_keysend)

        def __eq__(self, other):
            if not other.is_MULTI_PAY_KEYSEND():
                return False
            if self.multi_pay_keysend != other.multi_pay_keysend:
                return False
            return True
    
    class MAKE_INVOICE:
        """
        Make Invoice
        """

        make_invoice: "MakeInvoiceRequest"

        def __init__(self,make_invoice: "MakeInvoiceRequest"):
            self.make_invoice = make_invoice

        def __str__(self):
            return "RequestParams.MAKE_INVOICE(make_invoice={})".format(self.make_invoice)

        def __eq__(self, other):
            if not other.is_MAKE_INVOICE():
                return False
            if self.make_invoice != other.make_invoice:
                return False
            return True
    
    class LOOKUP_INVOICE:
        """
        Lookup Invoice
        """

        lookup_invoice: "LookupInvoiceRequest"

        def __init__(self,lookup_invoice: "LookupInvoiceRequest"):
            self.lookup_invoice = lookup_invoice

        def __str__(self):
            return "RequestParams.LOOKUP_INVOICE(lookup_invoice={})".format(self.lookup_invoice)

        def __eq__(self, other):
            if not other.is_LOOKUP_INVOICE():
                return False
            if self.lookup_invoice != other.lookup_invoice:
                return False
            return True
    
    class LIST_TRANSACTIONS:
        """
        List Transactions
        """

        list_transactions: "ListTransactionsRequest"

        def __init__(self,list_transactions: "ListTransactionsRequest"):
            self.list_transactions = list_transactions

        def __str__(self):
            return "RequestParams.LIST_TRANSACTIONS(list_transactions={})".format(self.list_transactions)

        def __eq__(self, other):
            if not other.is_LIST_TRANSACTIONS():
                return False
            if self.list_transactions != other.list_transactions:
                return False
            return True
    
    class GET_BALANCE:
        """
        Get Balance
        """


        def __init__(self,):
            pass

        def __str__(self):
            return "RequestParams.GET_BALANCE()".format()

        def __eq__(self, other):
            if not other.is_GET_BALANCE():
                return False
            return True
    
    class GET_INFO:
        """
        Get Info
        """


        def __init__(self,):
            pass

        def __str__(self):
            return "RequestParams.GET_INFO()".format()

        def __eq__(self, other):
            if not other.is_GET_INFO():
                return False
            return True
    
    class MAKE_HOLD_INVOICE:
        """
        Make Hold Invoice
        """

        req: "MakeHoldInvoiceRequest"

        def __init__(self,req: "MakeHoldInvoiceRequest"):
            self.req = req

        def __str__(self):
            return "RequestParams.MAKE_HOLD_INVOICE(req={})".format(self.req)

        def __eq__(self, other):
            if not other.is_MAKE_HOLD_INVOICE():
                return False
            if self.req != other.req:
                return False
            return True
    
    class CANCEL_HOLD_INVOICE:
        """
        Cancel Hold Invoice
        """

        req: "CancelHoldInvoiceRequest"

        def __init__(self,req: "CancelHoldInvoiceRequest"):
            self.req = req

        def __str__(self):
            return "RequestParams.CANCEL_HOLD_INVOICE(req={})".format(self.req)

        def __eq__(self, other):
            if not other.is_CANCEL_HOLD_INVOICE():
                return False
            if self.req != other.req:
                return False
            return True
    
    class SETTLE_HOLD_INVOICE:
        """
        Settle Hold Invoice
        """

        req: "SettleHoldInvoiceRequest"

        def __init__(self,req: "SettleHoldInvoiceRequest"):
            self.req = req

        def __str__(self):
            return "RequestParams.SETTLE_HOLD_INVOICE(req={})".format(self.req)

        def __eq__(self, other):
            if not other.is_SETTLE_HOLD_INVOICE():
                return False
            if self.req != other.req:
                return False
            return True
    
    

    # For each variant, we have `is_NAME` and `is_name` methods for easily checking
    # whether an instance is that variant.
    def is_PAY_INVOICE(self) -> bool:
        return isinstance(self, RequestParams.PAY_INVOICE)
    def is_pay_invoice(self) -> bool:
        return isinstance(self, RequestParams.PAY_INVOICE)
    def is_MULTI_PAY_INVOICE(self) -> bool:
        return isinstance(self, RequestParams.MULTI_PAY_INVOICE)
    def is_multi_pay_invoice(self) -> bool:
        return isinstance(self, RequestParams.MULTI_PAY_INVOICE)
    def is_PAY_KEYSEND(self) -> bool:
        return isinstance(self, RequestParams.PAY_KEYSEND)
    def is_pay_keysend(self) -> bool:
        return isinstance(self, RequestParams.PAY_KEYSEND)
    def is_MULTI_PAY_KEYSEND(self) -> bool:
        return isinstance(self, RequestParams.MULTI_PAY_KEYSEND)
    def is_multi_pay_keysend(self) -> bool:
        return isinstance(self, RequestParams.MULTI_PAY_KEYSEND)
    def is_MAKE_INVOICE(self) -> bool:
        return isinstance(self, RequestParams.MAKE_INVOICE)
    def is_make_invoice(self) -> bool:
        return isinstance(self, RequestParams.MAKE_INVOICE)
    def is_LOOKUP_INVOICE(self) -> bool:
        return isinstance(self, RequestParams.LOOKUP_INVOICE)
    def is_lookup_invoice(self) -> bool:
        return isinstance(self, RequestParams.LOOKUP_INVOICE)
    def is_LIST_TRANSACTIONS(self) -> bool:
        return isinstance(self, RequestParams.LIST_TRANSACTIONS)
    def is_list_transactions(self) -> bool:
        return isinstance(self, RequestParams.LIST_TRANSACTIONS)
    def is_GET_BALANCE(self) -> bool:
        return isinstance(self, RequestParams.GET_BALANCE)
    def is_get_balance(self) -> bool:
        return isinstance(self, RequestParams.GET_BALANCE)
    def is_GET_INFO(self) -> bool:
        return isinstance(self, RequestParams.GET_INFO)
    def is_get_info(self) -> bool:
        return isinstance(self, RequestParams.GET_INFO)
    def is_MAKE_HOLD_INVOICE(self) -> bool:
        return isinstance(self, RequestParams.MAKE_HOLD_INVOICE)
    def is_make_hold_invoice(self) -> bool:
        return isinstance(self, RequestParams.MAKE_HOLD_INVOICE)
    def is_CANCEL_HOLD_INVOICE(self) -> bool:
        return isinstance(self, RequestParams.CANCEL_HOLD_INVOICE)
    def is_cancel_hold_invoice(self) -> bool:
        return isinstance(self, RequestParams.CANCEL_HOLD_INVOICE)
    def is_SETTLE_HOLD_INVOICE(self) -> bool:
        return isinstance(self, RequestParams.SETTLE_HOLD_INVOICE)
    def is_settle_hold_invoice(self) -> bool:
        return isinstance(self, RequestParams.SETTLE_HOLD_INVOICE)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
RequestParams.PAY_INVOICE = type("RequestParams.PAY_INVOICE", (RequestParams.PAY_INVOICE, RequestParams,), {})  # type: ignore
RequestParams.MULTI_PAY_INVOICE = type("RequestParams.MULTI_PAY_INVOICE", (RequestParams.MULTI_PAY_INVOICE, RequestParams,), {})  # type: ignore
RequestParams.PAY_KEYSEND = type("RequestParams.PAY_KEYSEND", (RequestParams.PAY_KEYSEND, RequestParams,), {})  # type: ignore
RequestParams.MULTI_PAY_KEYSEND = type("RequestParams.MULTI_PAY_KEYSEND", (RequestParams.MULTI_PAY_KEYSEND, RequestParams,), {})  # type: ignore
RequestParams.MAKE_INVOICE = type("RequestParams.MAKE_INVOICE", (RequestParams.MAKE_INVOICE, RequestParams,), {})  # type: ignore
RequestParams.LOOKUP_INVOICE = type("RequestParams.LOOKUP_INVOICE", (RequestParams.LOOKUP_INVOICE, RequestParams,), {})  # type: ignore
RequestParams.LIST_TRANSACTIONS = type("RequestParams.LIST_TRANSACTIONS", (RequestParams.LIST_TRANSACTIONS, RequestParams,), {})  # type: ignore
RequestParams.GET_BALANCE = type("RequestParams.GET_BALANCE", (RequestParams.GET_BALANCE, RequestParams,), {})  # type: ignore
RequestParams.GET_INFO = type("RequestParams.GET_INFO", (RequestParams.GET_INFO, RequestParams,), {})  # type: ignore
RequestParams.MAKE_HOLD_INVOICE = type("RequestParams.MAKE_HOLD_INVOICE", (RequestParams.MAKE_HOLD_INVOICE, RequestParams,), {})  # type: ignore
RequestParams.CANCEL_HOLD_INVOICE = type("RequestParams.CANCEL_HOLD_INVOICE", (RequestParams.CANCEL_HOLD_INVOICE, RequestParams,), {})  # type: ignore
RequestParams.SETTLE_HOLD_INVOICE = type("RequestParams.SETTLE_HOLD_INVOICE", (RequestParams.SETTLE_HOLD_INVOICE, RequestParams,), {})  # type: ignore




class _UniffiConverterTypeRequestParams(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return RequestParams.PAY_INVOICE(
                _UniffiConverterTypePayInvoiceRequest.read(buf),
            )
        if variant == 2:
            return RequestParams.MULTI_PAY_INVOICE(
                _UniffiConverterTypeMultiPayInvoiceRequest.read(buf),
            )
        if variant == 3:
            return RequestParams.PAY_KEYSEND(
                _UniffiConverterTypePayKeysendRequest.read(buf),
            )
        if variant == 4:
            return RequestParams.MULTI_PAY_KEYSEND(
                _UniffiConverterTypeMultiPayKeysendRequest.read(buf),
            )
        if variant == 5:
            return RequestParams.MAKE_INVOICE(
                _UniffiConverterTypeMakeInvoiceRequest.read(buf),
            )
        if variant == 6:
            return RequestParams.LOOKUP_INVOICE(
                _UniffiConverterTypeLookupInvoiceRequest.read(buf),
            )
        if variant == 7:
            return RequestParams.LIST_TRANSACTIONS(
                _UniffiConverterTypeListTransactionsRequest.read(buf),
            )
        if variant == 8:
            return RequestParams.GET_BALANCE(
            )
        if variant == 9:
            return RequestParams.GET_INFO(
            )
        if variant == 10:
            return RequestParams.MAKE_HOLD_INVOICE(
                _UniffiConverterTypeMakeHoldInvoiceRequest.read(buf),
            )
        if variant == 11:
            return RequestParams.CANCEL_HOLD_INVOICE(
                _UniffiConverterTypeCancelHoldInvoiceRequest.read(buf),
            )
        if variant == 12:
            return RequestParams.SETTLE_HOLD_INVOICE(
                _UniffiConverterTypeSettleHoldInvoiceRequest.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value.is_PAY_INVOICE():
            _UniffiConverterTypePayInvoiceRequest.check_lower(value.pay_invoice)
            return
        if value.is_MULTI_PAY_INVOICE():
            _UniffiConverterTypeMultiPayInvoiceRequest.check_lower(value.multi_pay_invoice)
            return
        if value.is_PAY_KEYSEND():
            _UniffiConverterTypePayKeysendRequest.check_lower(value.pay_keysend)
            return
        if value.is_MULTI_PAY_KEYSEND():
            _UniffiConverterTypeMultiPayKeysendRequest.check_lower(value.multi_pay_keysend)
            return
        if value.is_MAKE_INVOICE():
            _UniffiConverterTypeMakeInvoiceRequest.check_lower(value.make_invoice)
            return
        if value.is_LOOKUP_INVOICE():
            _UniffiConverterTypeLookupInvoiceRequest.check_lower(value.lookup_invoice)
            return
        if value.is_LIST_TRANSACTIONS():
            _UniffiConverterTypeListTransactionsRequest.check_lower(value.list_transactions)
            return
        if value.is_GET_BALANCE():
            return
        if value.is_GET_INFO():
            return
        if value.is_MAKE_HOLD_INVOICE():
            _UniffiConverterTypeMakeHoldInvoiceRequest.check_lower(value.req)
            return
        if value.is_CANCEL_HOLD_INVOICE():
            _UniffiConverterTypeCancelHoldInvoiceRequest.check_lower(value.req)
            return
        if value.is_SETTLE_HOLD_INVOICE():
            _UniffiConverterTypeSettleHoldInvoiceRequest.check_lower(value.req)
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value.is_PAY_INVOICE():
            buf.write_i32(1)
            _UniffiConverterTypePayInvoiceRequest.write(value.pay_invoice, buf)
        if value.is_MULTI_PAY_INVOICE():
            buf.write_i32(2)
            _UniffiConverterTypeMultiPayInvoiceRequest.write(value.multi_pay_invoice, buf)
        if value.is_PAY_KEYSEND():
            buf.write_i32(3)
            _UniffiConverterTypePayKeysendRequest.write(value.pay_keysend, buf)
        if value.is_MULTI_PAY_KEYSEND():
            buf.write_i32(4)
            _UniffiConverterTypeMultiPayKeysendRequest.write(value.multi_pay_keysend, buf)
        if value.is_MAKE_INVOICE():
            buf.write_i32(5)
            _UniffiConverterTypeMakeInvoiceRequest.write(value.make_invoice, buf)
        if value.is_LOOKUP_INVOICE():
            buf.write_i32(6)
            _UniffiConverterTypeLookupInvoiceRequest.write(value.lookup_invoice, buf)
        if value.is_LIST_TRANSACTIONS():
            buf.write_i32(7)
            _UniffiConverterTypeListTransactionsRequest.write(value.list_transactions, buf)
        if value.is_GET_BALANCE():
            buf.write_i32(8)
        if value.is_GET_INFO():
            buf.write_i32(9)
        if value.is_MAKE_HOLD_INVOICE():
            buf.write_i32(10)
            _UniffiConverterTypeMakeHoldInvoiceRequest.write(value.req, buf)
        if value.is_CANCEL_HOLD_INVOICE():
            buf.write_i32(11)
            _UniffiConverterTypeCancelHoldInvoiceRequest.write(value.req, buf)
        if value.is_SETTLE_HOLD_INVOICE():
            buf.write_i32(12)
            _UniffiConverterTypeSettleHoldInvoiceRequest.write(value.req, buf)







class ResponseResult:
    """
    NIP47 Response Result
    """

    def __init__(self):
        raise RuntimeError("ResponseResult cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class PAY_INVOICE:
        """
        Pay Invoice
        """

        pay_invoice: "PayInvoiceResponse"

        def __init__(self,pay_invoice: "PayInvoiceResponse"):
            self.pay_invoice = pay_invoice

        def __str__(self):
            return "ResponseResult.PAY_INVOICE(pay_invoice={})".format(self.pay_invoice)

        def __eq__(self, other):
            if not other.is_PAY_INVOICE():
                return False
            if self.pay_invoice != other.pay_invoice:
                return False
            return True
    
    class MULTI_PAY_INVOICE:
        """
        Multi Pay Invoice
        """

        pay_invoice: "PayInvoiceResponse"

        def __init__(self,pay_invoice: "PayInvoiceResponse"):
            self.pay_invoice = pay_invoice

        def __str__(self):
            return "ResponseResult.MULTI_PAY_INVOICE(pay_invoice={})".format(self.pay_invoice)

        def __eq__(self, other):
            if not other.is_MULTI_PAY_INVOICE():
                return False
            if self.pay_invoice != other.pay_invoice:
                return False
            return True
    
    class PAY_KEYSEND:
        """
        Pay Keysend
        """

        pay_keysend: "PayKeysendResponse"

        def __init__(self,pay_keysend: "PayKeysendResponse"):
            self.pay_keysend = pay_keysend

        def __str__(self):
            return "ResponseResult.PAY_KEYSEND(pay_keysend={})".format(self.pay_keysend)

        def __eq__(self, other):
            if not other.is_PAY_KEYSEND():
                return False
            if self.pay_keysend != other.pay_keysend:
                return False
            return True
    
    class MULTI_PAY_KEYSEND:
        """
        Multi Pay Keysend
        """

        pay_keysend: "PayKeysendResponse"

        def __init__(self,pay_keysend: "PayKeysendResponse"):
            self.pay_keysend = pay_keysend

        def __str__(self):
            return "ResponseResult.MULTI_PAY_KEYSEND(pay_keysend={})".format(self.pay_keysend)

        def __eq__(self, other):
            if not other.is_MULTI_PAY_KEYSEND():
                return False
            if self.pay_keysend != other.pay_keysend:
                return False
            return True
    
    class MAKE_INVOICE:
        """
        Make Invoice
        """

        make_invoice: "MakeInvoiceResponse"

        def __init__(self,make_invoice: "MakeInvoiceResponse"):
            self.make_invoice = make_invoice

        def __str__(self):
            return "ResponseResult.MAKE_INVOICE(make_invoice={})".format(self.make_invoice)

        def __eq__(self, other):
            if not other.is_MAKE_INVOICE():
                return False
            if self.make_invoice != other.make_invoice:
                return False
            return True
    
    class LOOKUP_INVOICE:
        """
        Lookup Invoice
        """

        lookup_invoice: "LookupInvoiceResponse"

        def __init__(self,lookup_invoice: "LookupInvoiceResponse"):
            self.lookup_invoice = lookup_invoice

        def __str__(self):
            return "ResponseResult.LOOKUP_INVOICE(lookup_invoice={})".format(self.lookup_invoice)

        def __eq__(self, other):
            if not other.is_LOOKUP_INVOICE():
                return False
            if self.lookup_invoice != other.lookup_invoice:
                return False
            return True
    
    class LIST_TRANSACTIONS:
        """
        List Transactions
        """

        list_transactions: "typing.List[LookupInvoiceResponse]"

        def __init__(self,list_transactions: "typing.List[LookupInvoiceResponse]"):
            self.list_transactions = list_transactions

        def __str__(self):
            return "ResponseResult.LIST_TRANSACTIONS(list_transactions={})".format(self.list_transactions)

        def __eq__(self, other):
            if not other.is_LIST_TRANSACTIONS():
                return False
            if self.list_transactions != other.list_transactions:
                return False
            return True
    
    class GET_BALANCE:
        """
        Get Balance
        """

        get_balance: "GetBalanceResponse"

        def __init__(self,get_balance: "GetBalanceResponse"):
            self.get_balance = get_balance

        def __str__(self):
            return "ResponseResult.GET_BALANCE(get_balance={})".format(self.get_balance)

        def __eq__(self, other):
            if not other.is_GET_BALANCE():
                return False
            if self.get_balance != other.get_balance:
                return False
            return True
    
    class GET_INFO:
        """
        Get Info
        """

        get_info: "GetInfoResponse"

        def __init__(self,get_info: "GetInfoResponse"):
            self.get_info = get_info

        def __str__(self):
            return "ResponseResult.GET_INFO(get_info={})".format(self.get_info)

        def __eq__(self, other):
            if not other.is_GET_INFO():
                return False
            if self.get_info != other.get_info:
                return False
            return True
    
    class MAKE_HOLD_INVOICE:
        """
        Make Hold Invoice
        """

        res: "MakeHoldInvoiceResponse"

        def __init__(self,res: "MakeHoldInvoiceResponse"):
            self.res = res

        def __str__(self):
            return "ResponseResult.MAKE_HOLD_INVOICE(res={})".format(self.res)

        def __eq__(self, other):
            if not other.is_MAKE_HOLD_INVOICE():
                return False
            if self.res != other.res:
                return False
            return True
    
    class CANCEL_HOLD_INVOICE:
        """
        Cancel Hold Invoice
        """

        res: "CancelHoldInvoiceResponse"

        def __init__(self,res: "CancelHoldInvoiceResponse"):
            self.res = res

        def __str__(self):
            return "ResponseResult.CANCEL_HOLD_INVOICE(res={})".format(self.res)

        def __eq__(self, other):
            if not other.is_CANCEL_HOLD_INVOICE():
                return False
            if self.res != other.res:
                return False
            return True
    
    class SETTLE_HOLD_INVOICE:
        """
        Settle Hold Invoice
        """

        res: "SettleHoldInvoiceResponse"

        def __init__(self,res: "SettleHoldInvoiceResponse"):
            self.res = res

        def __str__(self):
            return "ResponseResult.SETTLE_HOLD_INVOICE(res={})".format(self.res)

        def __eq__(self, other):
            if not other.is_SETTLE_HOLD_INVOICE():
                return False
            if self.res != other.res:
                return False
            return True
    
    

    # For each variant, we have `is_NAME` and `is_name` methods for easily checking
    # whether an instance is that variant.
    def is_PAY_INVOICE(self) -> bool:
        return isinstance(self, ResponseResult.PAY_INVOICE)
    def is_pay_invoice(self) -> bool:
        return isinstance(self, ResponseResult.PAY_INVOICE)
    def is_MULTI_PAY_INVOICE(self) -> bool:
        return isinstance(self, ResponseResult.MULTI_PAY_INVOICE)
    def is_multi_pay_invoice(self) -> bool:
        return isinstance(self, ResponseResult.MULTI_PAY_INVOICE)
    def is_PAY_KEYSEND(self) -> bool:
        return isinstance(self, ResponseResult.PAY_KEYSEND)
    def is_pay_keysend(self) -> bool:
        return isinstance(self, ResponseResult.PAY_KEYSEND)
    def is_MULTI_PAY_KEYSEND(self) -> bool:
        return isinstance(self, ResponseResult.MULTI_PAY_KEYSEND)
    def is_multi_pay_keysend(self) -> bool:
        return isinstance(self, ResponseResult.MULTI_PAY_KEYSEND)
    def is_MAKE_INVOICE(self) -> bool:
        return isinstance(self, ResponseResult.MAKE_INVOICE)
    def is_make_invoice(self) -> bool:
        return isinstance(self, ResponseResult.MAKE_INVOICE)
    def is_LOOKUP_INVOICE(self) -> bool:
        return isinstance(self, ResponseResult.LOOKUP_INVOICE)
    def is_lookup_invoice(self) -> bool:
        return isinstance(self, ResponseResult.LOOKUP_INVOICE)
    def is_LIST_TRANSACTIONS(self) -> bool:
        return isinstance(self, ResponseResult.LIST_TRANSACTIONS)
    def is_list_transactions(self) -> bool:
        return isinstance(self, ResponseResult.LIST_TRANSACTIONS)
    def is_GET_BALANCE(self) -> bool:
        return isinstance(self, ResponseResult.GET_BALANCE)
    def is_get_balance(self) -> bool:
        return isinstance(self, ResponseResult.GET_BALANCE)
    def is_GET_INFO(self) -> bool:
        return isinstance(self, ResponseResult.GET_INFO)
    def is_get_info(self) -> bool:
        return isinstance(self, ResponseResult.GET_INFO)
    def is_MAKE_HOLD_INVOICE(self) -> bool:
        return isinstance(self, ResponseResult.MAKE_HOLD_INVOICE)
    def is_make_hold_invoice(self) -> bool:
        return isinstance(self, ResponseResult.MAKE_HOLD_INVOICE)
    def is_CANCEL_HOLD_INVOICE(self) -> bool:
        return isinstance(self, ResponseResult.CANCEL_HOLD_INVOICE)
    def is_cancel_hold_invoice(self) -> bool:
        return isinstance(self, ResponseResult.CANCEL_HOLD_INVOICE)
    def is_SETTLE_HOLD_INVOICE(self) -> bool:
        return isinstance(self, ResponseResult.SETTLE_HOLD_INVOICE)
    def is_settle_hold_invoice(self) -> bool:
        return isinstance(self, ResponseResult.SETTLE_HOLD_INVOICE)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
ResponseResult.PAY_INVOICE = type("ResponseResult.PAY_INVOICE", (ResponseResult.PAY_INVOICE, ResponseResult,), {})  # type: ignore
ResponseResult.MULTI_PAY_INVOICE = type("ResponseResult.MULTI_PAY_INVOICE", (ResponseResult.MULTI_PAY_INVOICE, ResponseResult,), {})  # type: ignore
ResponseResult.PAY_KEYSEND = type("ResponseResult.PAY_KEYSEND", (ResponseResult.PAY_KEYSEND, ResponseResult,), {})  # type: ignore
ResponseResult.MULTI_PAY_KEYSEND = type("ResponseResult.MULTI_PAY_KEYSEND", (ResponseResult.MULTI_PAY_KEYSEND, ResponseResult,), {})  # type: ignore
ResponseResult.MAKE_INVOICE = type("ResponseResult.MAKE_INVOICE", (ResponseResult.MAKE_INVOICE, ResponseResult,), {})  # type: ignore
ResponseResult.LOOKUP_INVOICE = type("ResponseResult.LOOKUP_INVOICE", (ResponseResult.LOOKUP_INVOICE, ResponseResult,), {})  # type: ignore
ResponseResult.LIST_TRANSACTIONS = type("ResponseResult.LIST_TRANSACTIONS", (ResponseResult.LIST_TRANSACTIONS, ResponseResult,), {})  # type: ignore
ResponseResult.GET_BALANCE = type("ResponseResult.GET_BALANCE", (ResponseResult.GET_BALANCE, ResponseResult,), {})  # type: ignore
ResponseResult.GET_INFO = type("ResponseResult.GET_INFO", (ResponseResult.GET_INFO, ResponseResult,), {})  # type: ignore
ResponseResult.MAKE_HOLD_INVOICE = type("ResponseResult.MAKE_HOLD_INVOICE", (ResponseResult.MAKE_HOLD_INVOICE, ResponseResult,), {})  # type: ignore
ResponseResult.CANCEL_HOLD_INVOICE = type("ResponseResult.CANCEL_HOLD_INVOICE", (ResponseResult.CANCEL_HOLD_INVOICE, ResponseResult,), {})  # type: ignore
ResponseResult.SETTLE_HOLD_INVOICE = type("ResponseResult.SETTLE_HOLD_INVOICE", (ResponseResult.SETTLE_HOLD_INVOICE, ResponseResult,), {})  # type: ignore




class _UniffiConverterTypeResponseResult(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return ResponseResult.PAY_INVOICE(
                _UniffiConverterTypePayInvoiceResponse.read(buf),
            )
        if variant == 2:
            return ResponseResult.MULTI_PAY_INVOICE(
                _UniffiConverterTypePayInvoiceResponse.read(buf),
            )
        if variant == 3:
            return ResponseResult.PAY_KEYSEND(
                _UniffiConverterTypePayKeysendResponse.read(buf),
            )
        if variant == 4:
            return ResponseResult.MULTI_PAY_KEYSEND(
                _UniffiConverterTypePayKeysendResponse.read(buf),
            )
        if variant == 5:
            return ResponseResult.MAKE_INVOICE(
                _UniffiConverterTypeMakeInvoiceResponse.read(buf),
            )
        if variant == 6:
            return ResponseResult.LOOKUP_INVOICE(
                _UniffiConverterTypeLookupInvoiceResponse.read(buf),
            )
        if variant == 7:
            return ResponseResult.LIST_TRANSACTIONS(
                _UniffiConverterSequenceTypeLookupInvoiceResponse.read(buf),
            )
        if variant == 8:
            return ResponseResult.GET_BALANCE(
                _UniffiConverterTypeGetBalanceResponse.read(buf),
            )
        if variant == 9:
            return ResponseResult.GET_INFO(
                _UniffiConverterTypeGetInfoResponse.read(buf),
            )
        if variant == 10:
            return ResponseResult.MAKE_HOLD_INVOICE(
                _UniffiConverterTypeMakeHoldInvoiceResponse.read(buf),
            )
        if variant == 11:
            return ResponseResult.CANCEL_HOLD_INVOICE(
                _UniffiConverterTypeCancelHoldInvoiceResponse.read(buf),
            )
        if variant == 12:
            return ResponseResult.SETTLE_HOLD_INVOICE(
                _UniffiConverterTypeSettleHoldInvoiceResponse.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value.is_PAY_INVOICE():
            _UniffiConverterTypePayInvoiceResponse.check_lower(value.pay_invoice)
            return
        if value.is_MULTI_PAY_INVOICE():
            _UniffiConverterTypePayInvoiceResponse.check_lower(value.pay_invoice)
            return
        if value.is_PAY_KEYSEND():
            _UniffiConverterTypePayKeysendResponse.check_lower(value.pay_keysend)
            return
        if value.is_MULTI_PAY_KEYSEND():
            _UniffiConverterTypePayKeysendResponse.check_lower(value.pay_keysend)
            return
        if value.is_MAKE_INVOICE():
            _UniffiConverterTypeMakeInvoiceResponse.check_lower(value.make_invoice)
            return
        if value.is_LOOKUP_INVOICE():
            _UniffiConverterTypeLookupInvoiceResponse.check_lower(value.lookup_invoice)
            return
        if value.is_LIST_TRANSACTIONS():
            _UniffiConverterSequenceTypeLookupInvoiceResponse.check_lower(value.list_transactions)
            return
        if value.is_GET_BALANCE():
            _UniffiConverterTypeGetBalanceResponse.check_lower(value.get_balance)
            return
        if value.is_GET_INFO():
            _UniffiConverterTypeGetInfoResponse.check_lower(value.get_info)
            return
        if value.is_MAKE_HOLD_INVOICE():
            _UniffiConverterTypeMakeHoldInvoiceResponse.check_lower(value.res)
            return
        if value.is_CANCEL_HOLD_INVOICE():
            _UniffiConverterTypeCancelHoldInvoiceResponse.check_lower(value.res)
            return
        if value.is_SETTLE_HOLD_INVOICE():
            _UniffiConverterTypeSettleHoldInvoiceResponse.check_lower(value.res)
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value.is_PAY_INVOICE():
            buf.write_i32(1)
            _UniffiConverterTypePayInvoiceResponse.write(value.pay_invoice, buf)
        if value.is_MULTI_PAY_INVOICE():
            buf.write_i32(2)
            _UniffiConverterTypePayInvoiceResponse.write(value.pay_invoice, buf)
        if value.is_PAY_KEYSEND():
            buf.write_i32(3)
            _UniffiConverterTypePayKeysendResponse.write(value.pay_keysend, buf)
        if value.is_MULTI_PAY_KEYSEND():
            buf.write_i32(4)
            _UniffiConverterTypePayKeysendResponse.write(value.pay_keysend, buf)
        if value.is_MAKE_INVOICE():
            buf.write_i32(5)
            _UniffiConverterTypeMakeInvoiceResponse.write(value.make_invoice, buf)
        if value.is_LOOKUP_INVOICE():
            buf.write_i32(6)
            _UniffiConverterTypeLookupInvoiceResponse.write(value.lookup_invoice, buf)
        if value.is_LIST_TRANSACTIONS():
            buf.write_i32(7)
            _UniffiConverterSequenceTypeLookupInvoiceResponse.write(value.list_transactions, buf)
        if value.is_GET_BALANCE():
            buf.write_i32(8)
            _UniffiConverterTypeGetBalanceResponse.write(value.get_balance, buf)
        if value.is_GET_INFO():
            buf.write_i32(9)
            _UniffiConverterTypeGetInfoResponse.write(value.get_info, buf)
        if value.is_MAKE_HOLD_INVOICE():
            buf.write_i32(10)
            _UniffiConverterTypeMakeHoldInvoiceResponse.write(value.res, buf)
        if value.is_CANCEL_HOLD_INVOICE():
            buf.write_i32(11)
            _UniffiConverterTypeCancelHoldInvoiceResponse.write(value.res, buf)
        if value.is_SETTLE_HOLD_INVOICE():
            buf.write_i32(12)
            _UniffiConverterTypeSettleHoldInvoiceResponse.write(value.res, buf)







class RetentionKind:
    def __init__(self):
        raise RuntimeError("RetentionKind cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class SINGLE:
        single: "int"

        def __init__(self,single: "int"):
            self.single = single

        def __str__(self):
            return "RetentionKind.SINGLE(single={})".format(self.single)

        def __eq__(self, other):
            if not other.is_SINGLE():
                return False
            if self.single != other.single:
                return False
            return True
    
    class RANGE:
        start: "int"
        end: "int"

        def __init__(self,start: "int", end: "int"):
            self.start = start
            self.end = end

        def __str__(self):
            return "RetentionKind.RANGE(start={}, end={})".format(self.start, self.end)

        def __eq__(self, other):
            if not other.is_RANGE():
                return False
            if self.start != other.start:
                return False
            if self.end != other.end:
                return False
            return True
    
    

    # For each variant, we have `is_NAME` and `is_name` methods for easily checking
    # whether an instance is that variant.
    def is_SINGLE(self) -> bool:
        return isinstance(self, RetentionKind.SINGLE)
    def is_single(self) -> bool:
        return isinstance(self, RetentionKind.SINGLE)
    def is_RANGE(self) -> bool:
        return isinstance(self, RetentionKind.RANGE)
    def is_range(self) -> bool:
        return isinstance(self, RetentionKind.RANGE)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
RetentionKind.SINGLE = type("RetentionKind.SINGLE", (RetentionKind.SINGLE, RetentionKind,), {})  # type: ignore
RetentionKind.RANGE = type("RetentionKind.RANGE", (RetentionKind.RANGE, RetentionKind,), {})  # type: ignore




class _UniffiConverterTypeRetentionKind(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return RetentionKind.SINGLE(
                _UniffiConverterUInt64.read(buf),
            )
        if variant == 2:
            return RetentionKind.RANGE(
                _UniffiConverterUInt64.read(buf),
                _UniffiConverterUInt64.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value.is_SINGLE():
            _UniffiConverterUInt64.check_lower(value.single)
            return
        if value.is_RANGE():
            _UniffiConverterUInt64.check_lower(value.start)
            _UniffiConverterUInt64.check_lower(value.end)
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value.is_SINGLE():
            buf.write_i32(1)
            _UniffiConverterUInt64.write(value.single, buf)
        if value.is_RANGE():
            buf.write_i32(2)
            _UniffiConverterUInt64.write(value.start, buf)
            _UniffiConverterUInt64.write(value.end, buf)







class SignerBackend:
    def __init__(self):
        raise RuntimeError("SignerBackend cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class KEYS:
        """
        Secret key
        """


        def __init__(self,):
            pass

        def __str__(self):
            return "SignerBackend.KEYS()".format()

        def __eq__(self, other):
            if not other.is_KEYS():
                return False
            return True
    
    class BROWSER_EXTENSION:
        """
        Browser extension (NIP07)

        <https://github.com/nostr-protocol/nips/blob/master/07.md>
        """


        def __init__(self,):
            pass

        def __str__(self):
            return "SignerBackend.BROWSER_EXTENSION()".format()

        def __eq__(self, other):
            if not other.is_BROWSER_EXTENSION():
                return False
            return True
    
    class NOSTR_CONNECT:
        """
        Nostr Connect (NIP46)

        <https://github.com/nostr-protocol/nips/blob/master/46.md>
        """


        def __init__(self,):
            pass

        def __str__(self):
            return "SignerBackend.NOSTR_CONNECT()".format()

        def __eq__(self, other):
            if not other.is_NOSTR_CONNECT():
                return False
            return True
    
    class CUSTOM:
        """
        Custom
        """

        backend: "str"

        def __init__(self,backend: "str"):
            self.backend = backend

        def __str__(self):
            return "SignerBackend.CUSTOM(backend={})".format(self.backend)

        def __eq__(self, other):
            if not other.is_CUSTOM():
                return False
            if self.backend != other.backend:
                return False
            return True
    
    

    # For each variant, we have `is_NAME` and `is_name` methods for easily checking
    # whether an instance is that variant.
    def is_KEYS(self) -> bool:
        return isinstance(self, SignerBackend.KEYS)
    def is_keys(self) -> bool:
        return isinstance(self, SignerBackend.KEYS)
    def is_BROWSER_EXTENSION(self) -> bool:
        return isinstance(self, SignerBackend.BROWSER_EXTENSION)
    def is_browser_extension(self) -> bool:
        return isinstance(self, SignerBackend.BROWSER_EXTENSION)
    def is_NOSTR_CONNECT(self) -> bool:
        return isinstance(self, SignerBackend.NOSTR_CONNECT)
    def is_nostr_connect(self) -> bool:
        return isinstance(self, SignerBackend.NOSTR_CONNECT)
    def is_CUSTOM(self) -> bool:
        return isinstance(self, SignerBackend.CUSTOM)
    def is_custom(self) -> bool:
        return isinstance(self, SignerBackend.CUSTOM)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
SignerBackend.KEYS = type("SignerBackend.KEYS", (SignerBackend.KEYS, SignerBackend,), {})  # type: ignore
SignerBackend.BROWSER_EXTENSION = type("SignerBackend.BROWSER_EXTENSION", (SignerBackend.BROWSER_EXTENSION, SignerBackend,), {})  # type: ignore
SignerBackend.NOSTR_CONNECT = type("SignerBackend.NOSTR_CONNECT", (SignerBackend.NOSTR_CONNECT, SignerBackend,), {})  # type: ignore
SignerBackend.CUSTOM = type("SignerBackend.CUSTOM", (SignerBackend.CUSTOM, SignerBackend,), {})  # type: ignore




class _UniffiConverterTypeSignerBackend(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return SignerBackend.KEYS(
            )
        if variant == 2:
            return SignerBackend.BROWSER_EXTENSION(
            )
        if variant == 3:
            return SignerBackend.NOSTR_CONNECT(
            )
        if variant == 4:
            return SignerBackend.CUSTOM(
                _UniffiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value.is_KEYS():
            return
        if value.is_BROWSER_EXTENSION():
            return
        if value.is_NOSTR_CONNECT():
            return
        if value.is_CUSTOM():
            _UniffiConverterString.check_lower(value.backend)
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value.is_KEYS():
            buf.write_i32(1)
        if value.is_BROWSER_EXTENSION():
            buf.write_i32(2)
        if value.is_NOSTR_CONNECT():
            buf.write_i32(3)
        if value.is_CUSTOM():
            buf.write_i32(4)
            _UniffiConverterString.write(value.backend, buf)







class SyncDirection(enum.Enum):
    UP = 0
    
    DOWN = 1
    
    BOTH = 2
    


class _UniffiConverterTypeSyncDirection(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return SyncDirection.UP
        if variant == 2:
            return SyncDirection.DOWN
        if variant == 3:
            return SyncDirection.BOTH
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == SyncDirection.UP:
            return
        if value == SyncDirection.DOWN:
            return
        if value == SyncDirection.BOTH:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == SyncDirection.UP:
            buf.write_i32(1)
        if value == SyncDirection.DOWN:
            buf.write_i32(2)
        if value == SyncDirection.BOTH:
            buf.write_i32(3)







class TagKind:
    def __init__(self):
        raise RuntimeError("TagKind cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class ALT:
        """
        Human-readable plaintext summary of what that event is about

        <https://github.com/nostr-protocol/nips/blob/master/31.md>
        """


        def __init__(self,):
            pass

        def __str__(self):
            return "TagKind.ALT()".format()

        def __eq__(self, other):
            if not other.is_ALT():
                return False
            return True
    
    class CLIENT:
        """
        Client

        <https://github.com/nostr-protocol/nips/blob/master/89.md>
        """


        def __init__(self,):
            pass

        def __str__(self):
            return "TagKind.CLIENT()".format()

        def __eq__(self, other):
            if not other.is_CLIENT():
                return False
            return True
    
    class COMMIT:
        """
        Commit

        <https://github.com/nostr-protocol/nips/blob/master/34.md>
        """


        def __init__(self,):
            pass

        def __str__(self):
            return "TagKind.COMMIT()".format()

        def __eq__(self, other):
            if not other.is_COMMIT():
                return False
            return True
    
    class DEPENDENCY:
        """
        Required dependency

        <https://github.com/nostr-protocol/nips/blob/master/C0.md>
        """


        def __init__(self,):
            pass

        def __str__(self):
            return "TagKind.DEPENDENCY()".format()

        def __eq__(self, other):
            if not other.is_DEPENDENCY():
                return False
            return True
    
    class EXTENSION:
        """
        File extension

        <https://github.com/nostr-protocol/nips/blob/master/C0.md>
        """


        def __init__(self,):
            pass

        def __str__(self):
            return "TagKind.EXTENSION()".format()

        def __eq__(self, other):
            if not other.is_EXTENSION():
                return False
            return True
    
    class LICENSE:
        """
        License of the shared content

        <https://github.com/nostr-protocol/nips/blob/master/C0.md>
        """


        def __init__(self,):
            pass

        def __str__(self):
            return "TagKind.LICENSE()".format()

        def __eq__(self, other):
            if not other.is_LICENSE():
                return False
            return True
    
    class MAINTAINERS:
        """
        Maintainers
        """


        def __init__(self,):
            pass

        def __str__(self):
            return "TagKind.MAINTAINERS()".format()

        def __eq__(self, other):
            if not other.is_MAINTAINERS():
                return False
            return True
    
    class PROTECTED:
        """
        Protected event

        <https://github.com/nostr-protocol/nips/blob/master/70.md>
        """


        def __init__(self,):
            pass

        def __str__(self):
            return "TagKind.PROTECTED()".format()

        def __eq__(self, other):
            if not other.is_PROTECTED():
                return False
            return True
    
    class RELAY_URL:
        """
        Relay
        """


        def __init__(self,):
            pass

        def __str__(self):
            return "TagKind.RELAY_URL()".format()

        def __eq__(self, other):
            if not other.is_RELAY_URL():
                return False
            return True
    
    class NONCE:
        """
        Nonce
        """


        def __init__(self,):
            pass

        def __str__(self):
            return "TagKind.NONCE()".format()

        def __eq__(self, other):
            if not other.is_NONCE():
                return False
            return True
    
    class CONTENT_WARNING:
        """
        Content warning
        """


        def __init__(self,):
            pass

        def __str__(self):
            return "TagKind.CONTENT_WARNING()".format()

        def __eq__(self, other):
            if not other.is_CONTENT_WARNING():
                return False
            return True
    
    class EXPIRATION:
        """
        Expiration
        """


        def __init__(self,):
            pass

        def __str__(self):
            return "TagKind.EXPIRATION()".format()

        def __eq__(self, other):
            if not other.is_EXPIRATION():
                return False
            return True
    
    class SUBJECT:
        """
        Subject
        """


        def __init__(self,):
            pass

        def __str__(self):
            return "TagKind.SUBJECT()".format()

        def __eq__(self, other):
            if not other.is_SUBJECT():
                return False
            return True
    
    class CHALLENGE:
        """
        Auth challenge
        """


        def __init__(self,):
            pass

        def __str__(self):
            return "TagKind.CHALLENGE()".format()

        def __eq__(self, other):
            if not other.is_CHALLENGE():
                return False
            return True
    
    class TITLE:
        """
        Title (NIP23)
        """


        def __init__(self,):
            pass

        def __str__(self):
            return "TagKind.TITLE()".format()

        def __eq__(self, other):
            if not other.is_TITLE():
                return False
            return True
    
    class IMAGE:
        """
        Image (NIP23)
        """


        def __init__(self,):
            pass

        def __str__(self):
            return "TagKind.IMAGE()".format()

        def __eq__(self, other):
            if not other.is_IMAGE():
                return False
            return True
    
    class THUMB:
        """
        Thumbnail
        """


        def __init__(self,):
            pass

        def __str__(self):
            return "TagKind.THUMB()".format()

        def __eq__(self, other):
            if not other.is_THUMB():
                return False
            return True
    
    class SUMMARY:
        """
        Summary (NIP23)
        """


        def __init__(self,):
            pass

        def __str__(self):
            return "TagKind.SUMMARY()".format()

        def __eq__(self, other):
            if not other.is_SUMMARY():
                return False
            return True
    
    class PUBLISHED_AT:
        """
        PublishedAt (NIP23)
        """


        def __init__(self,):
            pass

        def __str__(self):
            return "TagKind.PUBLISHED_AT()".format()

        def __eq__(self, other):
            if not other.is_PUBLISHED_AT():
                return False
            return True
    
    class DESCRIPTION:
        """
        Description (NIP57)
        """


        def __init__(self,):
            pass

        def __str__(self):
            return "TagKind.DESCRIPTION()".format()

        def __eq__(self, other):
            if not other.is_DESCRIPTION():
                return False
            return True
    
    class BOLT11:
        """
        Bolt11 Invoice (NIP57)
        """


        def __init__(self,):
            pass

        def __str__(self):
            return "TagKind.BOLT11()".format()

        def __eq__(self, other):
            if not other.is_BOLT11():
                return False
            return True
    
    class PREIMAGE:
        """
        Preimage (NIP57)
        """


        def __init__(self,):
            pass

        def __str__(self):
            return "TagKind.PREIMAGE()".format()

        def __eq__(self, other):
            if not other.is_PREIMAGE():
                return False
            return True
    
    class RELAYS:
        """
        Relays (NIP57)
        """


        def __init__(self,):
            pass

        def __str__(self):
            return "TagKind.RELAYS()".format()

        def __eq__(self, other):
            if not other.is_RELAYS():
                return False
            return True
    
    class AMOUNT:
        """
        Amount (NIP57)
        """


        def __init__(self,):
            pass

        def __str__(self):
            return "TagKind.AMOUNT()".format()

        def __eq__(self, other):
            if not other.is_AMOUNT():
                return False
            return True
    
    class LNURL:
        """
        Lnurl (NIP57)
        """


        def __init__(self,):
            pass

        def __str__(self):
            return "TagKind.LNURL()".format()

        def __eq__(self, other):
            if not other.is_LNURL():
                return False
            return True
    
    class MLS_PROTOCOL_VERSION:
        """
        MLS Protocol Version (NIP104)
        """


        def __init__(self,):
            pass

        def __str__(self):
            return "TagKind.MLS_PROTOCOL_VERSION()".format()

        def __eq__(self, other):
            if not other.is_MLS_PROTOCOL_VERSION():
                return False
            return True
    
    class MLS_CIPHERSUITE:
        """
        MLS Cipher Suite (NIP104)
        """


        def __init__(self,):
            pass

        def __str__(self):
            return "TagKind.MLS_CIPHERSUITE()".format()

        def __eq__(self, other):
            if not other.is_MLS_CIPHERSUITE():
                return False
            return True
    
    class MLS_EXTENSIONS:
        """
        MLS Extensions (NIP104)
        """


        def __init__(self,):
            pass

        def __str__(self):
            return "TagKind.MLS_EXTENSIONS()".format()

        def __eq__(self, other):
            if not other.is_MLS_EXTENSIONS():
                return False
            return True
    
    class NAME:
        """
        Name tag
        """


        def __init__(self,):
            pass

        def __str__(self):
            return "TagKind.NAME()".format()

        def __eq__(self, other):
            if not other.is_NAME():
                return False
            return True
    
    class OPTION:
        """
        Option
        """


        def __init__(self,):
            pass

        def __str__(self):
            return "TagKind.OPTION()".format()

        def __eq__(self, other):
            if not other.is_OPTION():
                return False
            return True
    
    class URL:
        """
        Url
        """


        def __init__(self,):
            pass

        def __str__(self):
            return "TagKind.URL()".format()

        def __eq__(self, other):
            if not other.is_URL():
                return False
            return True
    
    class AES256_GCM:
        """
        AES 256 GCM
        """


        def __init__(self,):
            pass

        def __str__(self):
            return "TagKind.AES256_GCM()".format()

        def __eq__(self, other):
            if not other.is_AES256_GCM():
                return False
            return True
    
    class SIZE:
        """
        Size of file in bytes
        """


        def __init__(self,):
            pass

        def __str__(self):
            return "TagKind.SIZE()".format()

        def __eq__(self, other):
            if not other.is_SIZE():
                return False
            return True
    
    class DIM:
        """
        Size of file in pixels
        """


        def __init__(self,):
            pass

        def __str__(self):
            return "TagKind.DIM()".format()

        def __eq__(self, other):
            if not other.is_DIM():
                return False
            return True
    
    class FILE:

        def __init__(self,):
            pass

        def __str__(self):
            return "TagKind.FILE()".format()

        def __eq__(self, other):
            if not other.is_FILE():
                return False
            return True
    
    class MAGNET:
        """
        Magnet
        """


        def __init__(self,):
            pass

        def __str__(self):
            return "TagKind.MAGNET()".format()

        def __eq__(self, other):
            if not other.is_MAGNET():
                return False
            return True
    
    class BLURHASH:
        """
        Blurhash
        """


        def __init__(self,):
            pass

        def __str__(self):
            return "TagKind.BLURHASH()".format()

        def __eq__(self, other):
            if not other.is_BLURHASH():
                return False
            return True
    
    class STREAMING:
        """
        Streaming
        """


        def __init__(self,):
            pass

        def __str__(self):
            return "TagKind.STREAMING()".format()

        def __eq__(self, other):
            if not other.is_STREAMING():
                return False
            return True
    
    class RECORDING:
        """
        Recording
        """


        def __init__(self,):
            pass

        def __str__(self):
            return "TagKind.RECORDING()".format()

        def __eq__(self, other):
            if not other.is_RECORDING():
                return False
            return True
    
    class SERVER:
        """
        Server
        """


        def __init__(self,):
            pass

        def __str__(self):
            return "TagKind.SERVER()".format()

        def __eq__(self, other):
            if not other.is_SERVER():
                return False
            return True
    
    class STARTS:
        """
        Starts
        """


        def __init__(self,):
            pass

        def __str__(self):
            return "TagKind.STARTS()".format()

        def __eq__(self, other):
            if not other.is_STARTS():
                return False
            return True
    
    class ENDS:
        """
        Ends
        """


        def __init__(self,):
            pass

        def __str__(self):
            return "TagKind.ENDS()".format()

        def __eq__(self, other):
            if not other.is_ENDS():
                return False
            return True
    
    class STATUS:
        """
        Status
        """


        def __init__(self,):
            pass

        def __str__(self):
            return "TagKind.STATUS()".format()

        def __eq__(self, other):
            if not other.is_STATUS():
                return False
            return True
    
    class CURRENT_PARTICIPANTS:
        """
        Current participants
        """


        def __init__(self,):
            pass

        def __str__(self):
            return "TagKind.CURRENT_PARTICIPANTS()".format()

        def __eq__(self, other):
            if not other.is_CURRENT_PARTICIPANTS():
                return False
            return True
    
    class TOTAL_PARTICIPANTS:
        """
        Total participants
        """


        def __init__(self,):
            pass

        def __str__(self):
            return "TagKind.TOTAL_PARTICIPANTS()".format()

        def __eq__(self, other):
            if not other.is_TOTAL_PARTICIPANTS():
                return False
            return True
    
    class TRACKER:

        def __init__(self,):
            pass

        def __str__(self):
            return "TagKind.TRACKER()".format()

        def __eq__(self, other):
            if not other.is_TRACKER():
                return False
            return True
    
    class METHOD:
        """
        HTTP Method Request
        """


        def __init__(self,):
            pass

        def __str__(self):
            return "TagKind.METHOD()".format()

        def __eq__(self, other):
            if not other.is_METHOD():
                return False
            return True
    
    class PAYLOAD:
        """
        Payload HASH
        """


        def __init__(self,):
            pass

        def __str__(self):
            return "TagKind.PAYLOAD()".format()

        def __eq__(self, other):
            if not other.is_PAYLOAD():
                return False
            return True
    
    class ANON:

        def __init__(self,):
            pass

        def __str__(self):
            return "TagKind.ANON()".format()

        def __eq__(self, other):
            if not other.is_ANON():
                return False
            return True
    
    class PROXY:

        def __init__(self,):
            pass

        def __str__(self):
            return "TagKind.PROXY()".format()

        def __eq__(self, other):
            if not other.is_PROXY():
                return False
            return True
    
    class EMOJI:

        def __init__(self,):
            pass

        def __str__(self):
            return "TagKind.EMOJI()".format()

        def __eq__(self, other):
            if not other.is_EMOJI():
                return False
            return True
    
    class ENCRYPTED:
        """
        Encrypted
        """


        def __init__(self,):
            pass

        def __str__(self):
            return "TagKind.ENCRYPTED()".format()

        def __eq__(self, other):
            if not other.is_ENCRYPTED():
                return False
            return True
    
    class REPOSITORY:
        """
        Reference to the origin repository

        <https://github.com/nostr-protocol/nips/blob/master/C0.md>
        """


        def __init__(self,):
            pass

        def __str__(self):
            return "TagKind.REPOSITORY()".format()

        def __eq__(self, other):
            if not other.is_REPOSITORY():
                return False
            return True
    
    class REQUEST:
        """
        Request
        """


        def __init__(self,):
            pass

        def __str__(self):
            return "TagKind.REQUEST()".format()

        def __eq__(self, other):
            if not other.is_REQUEST():
                return False
            return True
    
    class RUNTIME:
        """
        Runtime or environment specification

        <https://github.com/nostr-protocol/nips/blob/master/C0.md>
        """


        def __init__(self,):
            pass

        def __str__(self):
            return "TagKind.RUNTIME()".format()

        def __eq__(self, other):
            if not other.is_RUNTIME():
                return False
            return True
    
    class POLL_TYPE:

        def __init__(self,):
            pass

        def __str__(self):
            return "TagKind.POLL_TYPE()".format()

        def __eq__(self, other):
            if not other.is_POLL_TYPE():
                return False
            return True
    
    class RESPONSE:

        def __init__(self,):
            pass

        def __str__(self):
            return "TagKind.RESPONSE()".format()

        def __eq__(self, other):
            if not other.is_RESPONSE():
                return False
            return True
    
    class WEB:

        def __init__(self,):
            pass

        def __str__(self):
            return "TagKind.WEB()".format()

        def __eq__(self, other):
            if not other.is_WEB():
                return False
            return True
    
    class WORD:

        def __init__(self,):
            pass

        def __str__(self):
            return "TagKind.WORD()".format()

        def __eq__(self, other):
            if not other.is_WORD():
                return False
            return True
    
    class HEAD:

        def __init__(self,):
            pass

        def __str__(self):
            return "TagKind.HEAD()".format()

        def __eq__(self, other):
            if not other.is_HEAD():
                return False
            return True
    
    class SINGLE_LETTER:
        single_letter: "SingleLetterTag"

        def __init__(self,single_letter: "SingleLetterTag"):
            self.single_letter = single_letter

        def __str__(self):
            return "TagKind.SINGLE_LETTER(single_letter={})".format(self.single_letter)

        def __eq__(self, other):
            if not other.is_SINGLE_LETTER():
                return False
            if self.single_letter != other.single_letter:
                return False
            return True
    
    class UNKNOWN:
        unknown: "str"

        def __init__(self,unknown: "str"):
            self.unknown = unknown

        def __str__(self):
            return "TagKind.UNKNOWN(unknown={})".format(self.unknown)

        def __eq__(self, other):
            if not other.is_UNKNOWN():
                return False
            if self.unknown != other.unknown:
                return False
            return True
    
    

    # For each variant, we have `is_NAME` and `is_name` methods for easily checking
    # whether an instance is that variant.
    def is_ALT(self) -> bool:
        return isinstance(self, TagKind.ALT)
    def is_alt(self) -> bool:
        return isinstance(self, TagKind.ALT)
    def is_CLIENT(self) -> bool:
        return isinstance(self, TagKind.CLIENT)
    def is_client(self) -> bool:
        return isinstance(self, TagKind.CLIENT)
    def is_COMMIT(self) -> bool:
        return isinstance(self, TagKind.COMMIT)
    def is_commit(self) -> bool:
        return isinstance(self, TagKind.COMMIT)
    def is_DEPENDENCY(self) -> bool:
        return isinstance(self, TagKind.DEPENDENCY)
    def is_dependency(self) -> bool:
        return isinstance(self, TagKind.DEPENDENCY)
    def is_EXTENSION(self) -> bool:
        return isinstance(self, TagKind.EXTENSION)
    def is_extension(self) -> bool:
        return isinstance(self, TagKind.EXTENSION)
    def is_LICENSE(self) -> bool:
        return isinstance(self, TagKind.LICENSE)
    def is_license(self) -> bool:
        return isinstance(self, TagKind.LICENSE)
    def is_MAINTAINERS(self) -> bool:
        return isinstance(self, TagKind.MAINTAINERS)
    def is_maintainers(self) -> bool:
        return isinstance(self, TagKind.MAINTAINERS)
    def is_PROTECTED(self) -> bool:
        return isinstance(self, TagKind.PROTECTED)
    def is_protected(self) -> bool:
        return isinstance(self, TagKind.PROTECTED)
    def is_RELAY_URL(self) -> bool:
        return isinstance(self, TagKind.RELAY_URL)
    def is_relay_url(self) -> bool:
        return isinstance(self, TagKind.RELAY_URL)
    def is_NONCE(self) -> bool:
        return isinstance(self, TagKind.NONCE)
    def is_nonce(self) -> bool:
        return isinstance(self, TagKind.NONCE)
    def is_CONTENT_WARNING(self) -> bool:
        return isinstance(self, TagKind.CONTENT_WARNING)
    def is_content_warning(self) -> bool:
        return isinstance(self, TagKind.CONTENT_WARNING)
    def is_EXPIRATION(self) -> bool:
        return isinstance(self, TagKind.EXPIRATION)
    def is_expiration(self) -> bool:
        return isinstance(self, TagKind.EXPIRATION)
    def is_SUBJECT(self) -> bool:
        return isinstance(self, TagKind.SUBJECT)
    def is_subject(self) -> bool:
        return isinstance(self, TagKind.SUBJECT)
    def is_CHALLENGE(self) -> bool:
        return isinstance(self, TagKind.CHALLENGE)
    def is_challenge(self) -> bool:
        return isinstance(self, TagKind.CHALLENGE)
    def is_TITLE(self) -> bool:
        return isinstance(self, TagKind.TITLE)
    def is_title(self) -> bool:
        return isinstance(self, TagKind.TITLE)
    def is_IMAGE(self) -> bool:
        return isinstance(self, TagKind.IMAGE)
    def is_image(self) -> bool:
        return isinstance(self, TagKind.IMAGE)
    def is_THUMB(self) -> bool:
        return isinstance(self, TagKind.THUMB)
    def is_thumb(self) -> bool:
        return isinstance(self, TagKind.THUMB)
    def is_SUMMARY(self) -> bool:
        return isinstance(self, TagKind.SUMMARY)
    def is_summary(self) -> bool:
        return isinstance(self, TagKind.SUMMARY)
    def is_PUBLISHED_AT(self) -> bool:
        return isinstance(self, TagKind.PUBLISHED_AT)
    def is_published_at(self) -> bool:
        return isinstance(self, TagKind.PUBLISHED_AT)
    def is_DESCRIPTION(self) -> bool:
        return isinstance(self, TagKind.DESCRIPTION)
    def is_description(self) -> bool:
        return isinstance(self, TagKind.DESCRIPTION)
    def is_BOLT11(self) -> bool:
        return isinstance(self, TagKind.BOLT11)
    def is_bolt11(self) -> bool:
        return isinstance(self, TagKind.BOLT11)
    def is_PREIMAGE(self) -> bool:
        return isinstance(self, TagKind.PREIMAGE)
    def is_preimage(self) -> bool:
        return isinstance(self, TagKind.PREIMAGE)
    def is_RELAYS(self) -> bool:
        return isinstance(self, TagKind.RELAYS)
    def is_relays(self) -> bool:
        return isinstance(self, TagKind.RELAYS)
    def is_AMOUNT(self) -> bool:
        return isinstance(self, TagKind.AMOUNT)
    def is_amount(self) -> bool:
        return isinstance(self, TagKind.AMOUNT)
    def is_LNURL(self) -> bool:
        return isinstance(self, TagKind.LNURL)
    def is_lnurl(self) -> bool:
        return isinstance(self, TagKind.LNURL)
    def is_MLS_PROTOCOL_VERSION(self) -> bool:
        return isinstance(self, TagKind.MLS_PROTOCOL_VERSION)
    def is_mls_protocol_version(self) -> bool:
        return isinstance(self, TagKind.MLS_PROTOCOL_VERSION)
    def is_MLS_CIPHERSUITE(self) -> bool:
        return isinstance(self, TagKind.MLS_CIPHERSUITE)
    def is_mls_ciphersuite(self) -> bool:
        return isinstance(self, TagKind.MLS_CIPHERSUITE)
    def is_MLS_EXTENSIONS(self) -> bool:
        return isinstance(self, TagKind.MLS_EXTENSIONS)
    def is_mls_extensions(self) -> bool:
        return isinstance(self, TagKind.MLS_EXTENSIONS)
    def is_NAME(self) -> bool:
        return isinstance(self, TagKind.NAME)
    def is_name(self) -> bool:
        return isinstance(self, TagKind.NAME)
    def is_OPTION(self) -> bool:
        return isinstance(self, TagKind.OPTION)
    def is_option(self) -> bool:
        return isinstance(self, TagKind.OPTION)
    def is_URL(self) -> bool:
        return isinstance(self, TagKind.URL)
    def is_url(self) -> bool:
        return isinstance(self, TagKind.URL)
    def is_AES256_GCM(self) -> bool:
        return isinstance(self, TagKind.AES256_GCM)
    def is_aes256_gcm(self) -> bool:
        return isinstance(self, TagKind.AES256_GCM)
    def is_SIZE(self) -> bool:
        return isinstance(self, TagKind.SIZE)
    def is_size(self) -> bool:
        return isinstance(self, TagKind.SIZE)
    def is_DIM(self) -> bool:
        return isinstance(self, TagKind.DIM)
    def is_dim(self) -> bool:
        return isinstance(self, TagKind.DIM)
    def is_FILE(self) -> bool:
        return isinstance(self, TagKind.FILE)
    def is_file(self) -> bool:
        return isinstance(self, TagKind.FILE)
    def is_MAGNET(self) -> bool:
        return isinstance(self, TagKind.MAGNET)
    def is_magnet(self) -> bool:
        return isinstance(self, TagKind.MAGNET)
    def is_BLURHASH(self) -> bool:
        return isinstance(self, TagKind.BLURHASH)
    def is_blurhash(self) -> bool:
        return isinstance(self, TagKind.BLURHASH)
    def is_STREAMING(self) -> bool:
        return isinstance(self, TagKind.STREAMING)
    def is_streaming(self) -> bool:
        return isinstance(self, TagKind.STREAMING)
    def is_RECORDING(self) -> bool:
        return isinstance(self, TagKind.RECORDING)
    def is_recording(self) -> bool:
        return isinstance(self, TagKind.RECORDING)
    def is_SERVER(self) -> bool:
        return isinstance(self, TagKind.SERVER)
    def is_server(self) -> bool:
        return isinstance(self, TagKind.SERVER)
    def is_STARTS(self) -> bool:
        return isinstance(self, TagKind.STARTS)
    def is_starts(self) -> bool:
        return isinstance(self, TagKind.STARTS)
    def is_ENDS(self) -> bool:
        return isinstance(self, TagKind.ENDS)
    def is_ends(self) -> bool:
        return isinstance(self, TagKind.ENDS)
    def is_STATUS(self) -> bool:
        return isinstance(self, TagKind.STATUS)
    def is_status(self) -> bool:
        return isinstance(self, TagKind.STATUS)
    def is_CURRENT_PARTICIPANTS(self) -> bool:
        return isinstance(self, TagKind.CURRENT_PARTICIPANTS)
    def is_current_participants(self) -> bool:
        return isinstance(self, TagKind.CURRENT_PARTICIPANTS)
    def is_TOTAL_PARTICIPANTS(self) -> bool:
        return isinstance(self, TagKind.TOTAL_PARTICIPANTS)
    def is_total_participants(self) -> bool:
        return isinstance(self, TagKind.TOTAL_PARTICIPANTS)
    def is_TRACKER(self) -> bool:
        return isinstance(self, TagKind.TRACKER)
    def is_tracker(self) -> bool:
        return isinstance(self, TagKind.TRACKER)
    def is_METHOD(self) -> bool:
        return isinstance(self, TagKind.METHOD)
    def is_method(self) -> bool:
        return isinstance(self, TagKind.METHOD)
    def is_PAYLOAD(self) -> bool:
        return isinstance(self, TagKind.PAYLOAD)
    def is_payload(self) -> bool:
        return isinstance(self, TagKind.PAYLOAD)
    def is_ANON(self) -> bool:
        return isinstance(self, TagKind.ANON)
    def is_anon(self) -> bool:
        return isinstance(self, TagKind.ANON)
    def is_PROXY(self) -> bool:
        return isinstance(self, TagKind.PROXY)
    def is_proxy(self) -> bool:
        return isinstance(self, TagKind.PROXY)
    def is_EMOJI(self) -> bool:
        return isinstance(self, TagKind.EMOJI)
    def is_emoji(self) -> bool:
        return isinstance(self, TagKind.EMOJI)
    def is_ENCRYPTED(self) -> bool:
        return isinstance(self, TagKind.ENCRYPTED)
    def is_encrypted(self) -> bool:
        return isinstance(self, TagKind.ENCRYPTED)
    def is_REPOSITORY(self) -> bool:
        return isinstance(self, TagKind.REPOSITORY)
    def is_repository(self) -> bool:
        return isinstance(self, TagKind.REPOSITORY)
    def is_REQUEST(self) -> bool:
        return isinstance(self, TagKind.REQUEST)
    def is_request(self) -> bool:
        return isinstance(self, TagKind.REQUEST)
    def is_RUNTIME(self) -> bool:
        return isinstance(self, TagKind.RUNTIME)
    def is_runtime(self) -> bool:
        return isinstance(self, TagKind.RUNTIME)
    def is_POLL_TYPE(self) -> bool:
        return isinstance(self, TagKind.POLL_TYPE)
    def is_poll_type(self) -> bool:
        return isinstance(self, TagKind.POLL_TYPE)
    def is_RESPONSE(self) -> bool:
        return isinstance(self, TagKind.RESPONSE)
    def is_response(self) -> bool:
        return isinstance(self, TagKind.RESPONSE)
    def is_WEB(self) -> bool:
        return isinstance(self, TagKind.WEB)
    def is_web(self) -> bool:
        return isinstance(self, TagKind.WEB)
    def is_WORD(self) -> bool:
        return isinstance(self, TagKind.WORD)
    def is_word(self) -> bool:
        return isinstance(self, TagKind.WORD)
    def is_HEAD(self) -> bool:
        return isinstance(self, TagKind.HEAD)
    def is_head(self) -> bool:
        return isinstance(self, TagKind.HEAD)
    def is_SINGLE_LETTER(self) -> bool:
        return isinstance(self, TagKind.SINGLE_LETTER)
    def is_single_letter(self) -> bool:
        return isinstance(self, TagKind.SINGLE_LETTER)
    def is_UNKNOWN(self) -> bool:
        return isinstance(self, TagKind.UNKNOWN)
    def is_unknown(self) -> bool:
        return isinstance(self, TagKind.UNKNOWN)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
TagKind.ALT = type("TagKind.ALT", (TagKind.ALT, TagKind,), {})  # type: ignore
TagKind.CLIENT = type("TagKind.CLIENT", (TagKind.CLIENT, TagKind,), {})  # type: ignore
TagKind.COMMIT = type("TagKind.COMMIT", (TagKind.COMMIT, TagKind,), {})  # type: ignore
TagKind.DEPENDENCY = type("TagKind.DEPENDENCY", (TagKind.DEPENDENCY, TagKind,), {})  # type: ignore
TagKind.EXTENSION = type("TagKind.EXTENSION", (TagKind.EXTENSION, TagKind,), {})  # type: ignore
TagKind.LICENSE = type("TagKind.LICENSE", (TagKind.LICENSE, TagKind,), {})  # type: ignore
TagKind.MAINTAINERS = type("TagKind.MAINTAINERS", (TagKind.MAINTAINERS, TagKind,), {})  # type: ignore
TagKind.PROTECTED = type("TagKind.PROTECTED", (TagKind.PROTECTED, TagKind,), {})  # type: ignore
TagKind.RELAY_URL = type("TagKind.RELAY_URL", (TagKind.RELAY_URL, TagKind,), {})  # type: ignore
TagKind.NONCE = type("TagKind.NONCE", (TagKind.NONCE, TagKind,), {})  # type: ignore
TagKind.CONTENT_WARNING = type("TagKind.CONTENT_WARNING", (TagKind.CONTENT_WARNING, TagKind,), {})  # type: ignore
TagKind.EXPIRATION = type("TagKind.EXPIRATION", (TagKind.EXPIRATION, TagKind,), {})  # type: ignore
TagKind.SUBJECT = type("TagKind.SUBJECT", (TagKind.SUBJECT, TagKind,), {})  # type: ignore
TagKind.CHALLENGE = type("TagKind.CHALLENGE", (TagKind.CHALLENGE, TagKind,), {})  # type: ignore
TagKind.TITLE = type("TagKind.TITLE", (TagKind.TITLE, TagKind,), {})  # type: ignore
TagKind.IMAGE = type("TagKind.IMAGE", (TagKind.IMAGE, TagKind,), {})  # type: ignore
TagKind.THUMB = type("TagKind.THUMB", (TagKind.THUMB, TagKind,), {})  # type: ignore
TagKind.SUMMARY = type("TagKind.SUMMARY", (TagKind.SUMMARY, TagKind,), {})  # type: ignore
TagKind.PUBLISHED_AT = type("TagKind.PUBLISHED_AT", (TagKind.PUBLISHED_AT, TagKind,), {})  # type: ignore
TagKind.DESCRIPTION = type("TagKind.DESCRIPTION", (TagKind.DESCRIPTION, TagKind,), {})  # type: ignore
TagKind.BOLT11 = type("TagKind.BOLT11", (TagKind.BOLT11, TagKind,), {})  # type: ignore
TagKind.PREIMAGE = type("TagKind.PREIMAGE", (TagKind.PREIMAGE, TagKind,), {})  # type: ignore
TagKind.RELAYS = type("TagKind.RELAYS", (TagKind.RELAYS, TagKind,), {})  # type: ignore
TagKind.AMOUNT = type("TagKind.AMOUNT", (TagKind.AMOUNT, TagKind,), {})  # type: ignore
TagKind.LNURL = type("TagKind.LNURL", (TagKind.LNURL, TagKind,), {})  # type: ignore
TagKind.MLS_PROTOCOL_VERSION = type("TagKind.MLS_PROTOCOL_VERSION", (TagKind.MLS_PROTOCOL_VERSION, TagKind,), {})  # type: ignore
TagKind.MLS_CIPHERSUITE = type("TagKind.MLS_CIPHERSUITE", (TagKind.MLS_CIPHERSUITE, TagKind,), {})  # type: ignore
TagKind.MLS_EXTENSIONS = type("TagKind.MLS_EXTENSIONS", (TagKind.MLS_EXTENSIONS, TagKind,), {})  # type: ignore
TagKind.NAME = type("TagKind.NAME", (TagKind.NAME, TagKind,), {})  # type: ignore
TagKind.OPTION = type("TagKind.OPTION", (TagKind.OPTION, TagKind,), {})  # type: ignore
TagKind.URL = type("TagKind.URL", (TagKind.URL, TagKind,), {})  # type: ignore
TagKind.AES256_GCM = type("TagKind.AES256_GCM", (TagKind.AES256_GCM, TagKind,), {})  # type: ignore
TagKind.SIZE = type("TagKind.SIZE", (TagKind.SIZE, TagKind,), {})  # type: ignore
TagKind.DIM = type("TagKind.DIM", (TagKind.DIM, TagKind,), {})  # type: ignore
TagKind.FILE = type("TagKind.FILE", (TagKind.FILE, TagKind,), {})  # type: ignore
TagKind.MAGNET = type("TagKind.MAGNET", (TagKind.MAGNET, TagKind,), {})  # type: ignore
TagKind.BLURHASH = type("TagKind.BLURHASH", (TagKind.BLURHASH, TagKind,), {})  # type: ignore
TagKind.STREAMING = type("TagKind.STREAMING", (TagKind.STREAMING, TagKind,), {})  # type: ignore
TagKind.RECORDING = type("TagKind.RECORDING", (TagKind.RECORDING, TagKind,), {})  # type: ignore
TagKind.SERVER = type("TagKind.SERVER", (TagKind.SERVER, TagKind,), {})  # type: ignore
TagKind.STARTS = type("TagKind.STARTS", (TagKind.STARTS, TagKind,), {})  # type: ignore
TagKind.ENDS = type("TagKind.ENDS", (TagKind.ENDS, TagKind,), {})  # type: ignore
TagKind.STATUS = type("TagKind.STATUS", (TagKind.STATUS, TagKind,), {})  # type: ignore
TagKind.CURRENT_PARTICIPANTS = type("TagKind.CURRENT_PARTICIPANTS", (TagKind.CURRENT_PARTICIPANTS, TagKind,), {})  # type: ignore
TagKind.TOTAL_PARTICIPANTS = type("TagKind.TOTAL_PARTICIPANTS", (TagKind.TOTAL_PARTICIPANTS, TagKind,), {})  # type: ignore
TagKind.TRACKER = type("TagKind.TRACKER", (TagKind.TRACKER, TagKind,), {})  # type: ignore
TagKind.METHOD = type("TagKind.METHOD", (TagKind.METHOD, TagKind,), {})  # type: ignore
TagKind.PAYLOAD = type("TagKind.PAYLOAD", (TagKind.PAYLOAD, TagKind,), {})  # type: ignore
TagKind.ANON = type("TagKind.ANON", (TagKind.ANON, TagKind,), {})  # type: ignore
TagKind.PROXY = type("TagKind.PROXY", (TagKind.PROXY, TagKind,), {})  # type: ignore
TagKind.EMOJI = type("TagKind.EMOJI", (TagKind.EMOJI, TagKind,), {})  # type: ignore
TagKind.ENCRYPTED = type("TagKind.ENCRYPTED", (TagKind.ENCRYPTED, TagKind,), {})  # type: ignore
TagKind.REPOSITORY = type("TagKind.REPOSITORY", (TagKind.REPOSITORY, TagKind,), {})  # type: ignore
TagKind.REQUEST = type("TagKind.REQUEST", (TagKind.REQUEST, TagKind,), {})  # type: ignore
TagKind.RUNTIME = type("TagKind.RUNTIME", (TagKind.RUNTIME, TagKind,), {})  # type: ignore
TagKind.POLL_TYPE = type("TagKind.POLL_TYPE", (TagKind.POLL_TYPE, TagKind,), {})  # type: ignore
TagKind.RESPONSE = type("TagKind.RESPONSE", (TagKind.RESPONSE, TagKind,), {})  # type: ignore
TagKind.WEB = type("TagKind.WEB", (TagKind.WEB, TagKind,), {})  # type: ignore
TagKind.WORD = type("TagKind.WORD", (TagKind.WORD, TagKind,), {})  # type: ignore
TagKind.HEAD = type("TagKind.HEAD", (TagKind.HEAD, TagKind,), {})  # type: ignore
TagKind.SINGLE_LETTER = type("TagKind.SINGLE_LETTER", (TagKind.SINGLE_LETTER, TagKind,), {})  # type: ignore
TagKind.UNKNOWN = type("TagKind.UNKNOWN", (TagKind.UNKNOWN, TagKind,), {})  # type: ignore




class _UniffiConverterTypeTagKind(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return TagKind.ALT(
            )
        if variant == 2:
            return TagKind.CLIENT(
            )
        if variant == 3:
            return TagKind.COMMIT(
            )
        if variant == 4:
            return TagKind.DEPENDENCY(
            )
        if variant == 5:
            return TagKind.EXTENSION(
            )
        if variant == 6:
            return TagKind.LICENSE(
            )
        if variant == 7:
            return TagKind.MAINTAINERS(
            )
        if variant == 8:
            return TagKind.PROTECTED(
            )
        if variant == 9:
            return TagKind.RELAY_URL(
            )
        if variant == 10:
            return TagKind.NONCE(
            )
        if variant == 11:
            return TagKind.CONTENT_WARNING(
            )
        if variant == 12:
            return TagKind.EXPIRATION(
            )
        if variant == 13:
            return TagKind.SUBJECT(
            )
        if variant == 14:
            return TagKind.CHALLENGE(
            )
        if variant == 15:
            return TagKind.TITLE(
            )
        if variant == 16:
            return TagKind.IMAGE(
            )
        if variant == 17:
            return TagKind.THUMB(
            )
        if variant == 18:
            return TagKind.SUMMARY(
            )
        if variant == 19:
            return TagKind.PUBLISHED_AT(
            )
        if variant == 20:
            return TagKind.DESCRIPTION(
            )
        if variant == 21:
            return TagKind.BOLT11(
            )
        if variant == 22:
            return TagKind.PREIMAGE(
            )
        if variant == 23:
            return TagKind.RELAYS(
            )
        if variant == 24:
            return TagKind.AMOUNT(
            )
        if variant == 25:
            return TagKind.LNURL(
            )
        if variant == 26:
            return TagKind.MLS_PROTOCOL_VERSION(
            )
        if variant == 27:
            return TagKind.MLS_CIPHERSUITE(
            )
        if variant == 28:
            return TagKind.MLS_EXTENSIONS(
            )
        if variant == 29:
            return TagKind.NAME(
            )
        if variant == 30:
            return TagKind.OPTION(
            )
        if variant == 31:
            return TagKind.URL(
            )
        if variant == 32:
            return TagKind.AES256_GCM(
            )
        if variant == 33:
            return TagKind.SIZE(
            )
        if variant == 34:
            return TagKind.DIM(
            )
        if variant == 35:
            return TagKind.FILE(
            )
        if variant == 36:
            return TagKind.MAGNET(
            )
        if variant == 37:
            return TagKind.BLURHASH(
            )
        if variant == 38:
            return TagKind.STREAMING(
            )
        if variant == 39:
            return TagKind.RECORDING(
            )
        if variant == 40:
            return TagKind.SERVER(
            )
        if variant == 41:
            return TagKind.STARTS(
            )
        if variant == 42:
            return TagKind.ENDS(
            )
        if variant == 43:
            return TagKind.STATUS(
            )
        if variant == 44:
            return TagKind.CURRENT_PARTICIPANTS(
            )
        if variant == 45:
            return TagKind.TOTAL_PARTICIPANTS(
            )
        if variant == 46:
            return TagKind.TRACKER(
            )
        if variant == 47:
            return TagKind.METHOD(
            )
        if variant == 48:
            return TagKind.PAYLOAD(
            )
        if variant == 49:
            return TagKind.ANON(
            )
        if variant == 50:
            return TagKind.PROXY(
            )
        if variant == 51:
            return TagKind.EMOJI(
            )
        if variant == 52:
            return TagKind.ENCRYPTED(
            )
        if variant == 53:
            return TagKind.REPOSITORY(
            )
        if variant == 54:
            return TagKind.REQUEST(
            )
        if variant == 55:
            return TagKind.RUNTIME(
            )
        if variant == 56:
            return TagKind.POLL_TYPE(
            )
        if variant == 57:
            return TagKind.RESPONSE(
            )
        if variant == 58:
            return TagKind.WEB(
            )
        if variant == 59:
            return TagKind.WORD(
            )
        if variant == 60:
            return TagKind.HEAD(
            )
        if variant == 61:
            return TagKind.SINGLE_LETTER(
                _UniffiConverterTypeSingleLetterTag.read(buf),
            )
        if variant == 62:
            return TagKind.UNKNOWN(
                _UniffiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value.is_ALT():
            return
        if value.is_CLIENT():
            return
        if value.is_COMMIT():
            return
        if value.is_DEPENDENCY():
            return
        if value.is_EXTENSION():
            return
        if value.is_LICENSE():
            return
        if value.is_MAINTAINERS():
            return
        if value.is_PROTECTED():
            return
        if value.is_RELAY_URL():
            return
        if value.is_NONCE():
            return
        if value.is_CONTENT_WARNING():
            return
        if value.is_EXPIRATION():
            return
        if value.is_SUBJECT():
            return
        if value.is_CHALLENGE():
            return
        if value.is_TITLE():
            return
        if value.is_IMAGE():
            return
        if value.is_THUMB():
            return
        if value.is_SUMMARY():
            return
        if value.is_PUBLISHED_AT():
            return
        if value.is_DESCRIPTION():
            return
        if value.is_BOLT11():
            return
        if value.is_PREIMAGE():
            return
        if value.is_RELAYS():
            return
        if value.is_AMOUNT():
            return
        if value.is_LNURL():
            return
        if value.is_MLS_PROTOCOL_VERSION():
            return
        if value.is_MLS_CIPHERSUITE():
            return
        if value.is_MLS_EXTENSIONS():
            return
        if value.is_NAME():
            return
        if value.is_OPTION():
            return
        if value.is_URL():
            return
        if value.is_AES256_GCM():
            return
        if value.is_SIZE():
            return
        if value.is_DIM():
            return
        if value.is_FILE():
            return
        if value.is_MAGNET():
            return
        if value.is_BLURHASH():
            return
        if value.is_STREAMING():
            return
        if value.is_RECORDING():
            return
        if value.is_SERVER():
            return
        if value.is_STARTS():
            return
        if value.is_ENDS():
            return
        if value.is_STATUS():
            return
        if value.is_CURRENT_PARTICIPANTS():
            return
        if value.is_TOTAL_PARTICIPANTS():
            return
        if value.is_TRACKER():
            return
        if value.is_METHOD():
            return
        if value.is_PAYLOAD():
            return
        if value.is_ANON():
            return
        if value.is_PROXY():
            return
        if value.is_EMOJI():
            return
        if value.is_ENCRYPTED():
            return
        if value.is_REPOSITORY():
            return
        if value.is_REQUEST():
            return
        if value.is_RUNTIME():
            return
        if value.is_POLL_TYPE():
            return
        if value.is_RESPONSE():
            return
        if value.is_WEB():
            return
        if value.is_WORD():
            return
        if value.is_HEAD():
            return
        if value.is_SINGLE_LETTER():
            _UniffiConverterTypeSingleLetterTag.check_lower(value.single_letter)
            return
        if value.is_UNKNOWN():
            _UniffiConverterString.check_lower(value.unknown)
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value.is_ALT():
            buf.write_i32(1)
        if value.is_CLIENT():
            buf.write_i32(2)
        if value.is_COMMIT():
            buf.write_i32(3)
        if value.is_DEPENDENCY():
            buf.write_i32(4)
        if value.is_EXTENSION():
            buf.write_i32(5)
        if value.is_LICENSE():
            buf.write_i32(6)
        if value.is_MAINTAINERS():
            buf.write_i32(7)
        if value.is_PROTECTED():
            buf.write_i32(8)
        if value.is_RELAY_URL():
            buf.write_i32(9)
        if value.is_NONCE():
            buf.write_i32(10)
        if value.is_CONTENT_WARNING():
            buf.write_i32(11)
        if value.is_EXPIRATION():
            buf.write_i32(12)
        if value.is_SUBJECT():
            buf.write_i32(13)
        if value.is_CHALLENGE():
            buf.write_i32(14)
        if value.is_TITLE():
            buf.write_i32(15)
        if value.is_IMAGE():
            buf.write_i32(16)
        if value.is_THUMB():
            buf.write_i32(17)
        if value.is_SUMMARY():
            buf.write_i32(18)
        if value.is_PUBLISHED_AT():
            buf.write_i32(19)
        if value.is_DESCRIPTION():
            buf.write_i32(20)
        if value.is_BOLT11():
            buf.write_i32(21)
        if value.is_PREIMAGE():
            buf.write_i32(22)
        if value.is_RELAYS():
            buf.write_i32(23)
        if value.is_AMOUNT():
            buf.write_i32(24)
        if value.is_LNURL():
            buf.write_i32(25)
        if value.is_MLS_PROTOCOL_VERSION():
            buf.write_i32(26)
        if value.is_MLS_CIPHERSUITE():
            buf.write_i32(27)
        if value.is_MLS_EXTENSIONS():
            buf.write_i32(28)
        if value.is_NAME():
            buf.write_i32(29)
        if value.is_OPTION():
            buf.write_i32(30)
        if value.is_URL():
            buf.write_i32(31)
        if value.is_AES256_GCM():
            buf.write_i32(32)
        if value.is_SIZE():
            buf.write_i32(33)
        if value.is_DIM():
            buf.write_i32(34)
        if value.is_FILE():
            buf.write_i32(35)
        if value.is_MAGNET():
            buf.write_i32(36)
        if value.is_BLURHASH():
            buf.write_i32(37)
        if value.is_STREAMING():
            buf.write_i32(38)
        if value.is_RECORDING():
            buf.write_i32(39)
        if value.is_SERVER():
            buf.write_i32(40)
        if value.is_STARTS():
            buf.write_i32(41)
        if value.is_ENDS():
            buf.write_i32(42)
        if value.is_STATUS():
            buf.write_i32(43)
        if value.is_CURRENT_PARTICIPANTS():
            buf.write_i32(44)
        if value.is_TOTAL_PARTICIPANTS():
            buf.write_i32(45)
        if value.is_TRACKER():
            buf.write_i32(46)
        if value.is_METHOD():
            buf.write_i32(47)
        if value.is_PAYLOAD():
            buf.write_i32(48)
        if value.is_ANON():
            buf.write_i32(49)
        if value.is_PROXY():
            buf.write_i32(50)
        if value.is_EMOJI():
            buf.write_i32(51)
        if value.is_ENCRYPTED():
            buf.write_i32(52)
        if value.is_REPOSITORY():
            buf.write_i32(53)
        if value.is_REQUEST():
            buf.write_i32(54)
        if value.is_RUNTIME():
            buf.write_i32(55)
        if value.is_POLL_TYPE():
            buf.write_i32(56)
        if value.is_RESPONSE():
            buf.write_i32(57)
        if value.is_WEB():
            buf.write_i32(58)
        if value.is_WORD():
            buf.write_i32(59)
        if value.is_HEAD():
            buf.write_i32(60)
        if value.is_SINGLE_LETTER():
            buf.write_i32(61)
            _UniffiConverterTypeSingleLetterTag.write(value.single_letter, buf)
        if value.is_UNKNOWN():
            buf.write_i32(62)
            _UniffiConverterString.write(value.unknown, buf)







class TagStandard:
    """
    Standardized tag
    """

    def __init__(self):
        raise RuntimeError("TagStandard cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class EVENT_TAG:
        event_id: "EventId"
        relay_url: "typing.Optional[RelayUrl]"
        marker: "typing.Optional[Marker]"
        public_key: "typing.Optional[PublicKey]"
        """
        Should be the public key of the author of the referenced event
        """

        uppercase: "bool"
        """
        Whether the e tag is an uppercase E or not
        """


        def __init__(self,event_id: "EventId", relay_url: "typing.Optional[RelayUrl]", marker: "typing.Optional[Marker]", public_key: "typing.Optional[PublicKey]", uppercase: "bool"):
            self.event_id = event_id
            self.relay_url = relay_url
            self.marker = marker
            self.public_key = public_key
            self.uppercase = uppercase

        def __str__(self):
            return "TagStandard.EVENT_TAG(event_id={}, relay_url={}, marker={}, public_key={}, uppercase={})".format(self.event_id, self.relay_url, self.marker, self.public_key, self.uppercase)

        def __eq__(self, other):
            if not other.is_EVENT_TAG():
                return False
            if self.event_id != other.event_id:
                return False
            if self.relay_url != other.relay_url:
                return False
            if self.marker != other.marker:
                return False
            if self.public_key != other.public_key:
                return False
            if self.uppercase != other.uppercase:
                return False
            return True
    
    class QUOTE:
        event_id: "EventId"
        relay_url: "typing.Optional[RelayUrl]"
        public_key: "typing.Optional[PublicKey]"
        """
        Should be the public key of the author of the referenced event
        """


        def __init__(self,event_id: "EventId", relay_url: "typing.Optional[RelayUrl]", public_key: "typing.Optional[PublicKey]"):
            self.event_id = event_id
            self.relay_url = relay_url
            self.public_key = public_key

        def __str__(self):
            return "TagStandard.QUOTE(event_id={}, relay_url={}, public_key={})".format(self.event_id, self.relay_url, self.public_key)

        def __eq__(self, other):
            if not other.is_QUOTE():
                return False
            if self.event_id != other.event_id:
                return False
            if self.relay_url != other.relay_url:
                return False
            if self.public_key != other.public_key:
                return False
            return True
    
    class QUOTE_ADDRESS:
        coordinate: "Coordinate"
        relay_url: "typing.Optional[RelayUrl]"

        def __init__(self,coordinate: "Coordinate", relay_url: "typing.Optional[RelayUrl]"):
            self.coordinate = coordinate
            self.relay_url = relay_url

        def __str__(self):
            return "TagStandard.QUOTE_ADDRESS(coordinate={}, relay_url={})".format(self.coordinate, self.relay_url)

        def __eq__(self, other):
            if not other.is_QUOTE_ADDRESS():
                return False
            if self.coordinate != other.coordinate:
                return False
            if self.relay_url != other.relay_url:
                return False
            return True
    
    class GIT_CLONE:
        """
        Git clone (`clone` tag)

        <https://github.com/nostr-protocol/nips/blob/master/34.md>
        """

        urls: "typing.List[str]"

        def __init__(self,urls: "typing.List[str]"):
            self.urls = urls

        def __str__(self):
            return "TagStandard.GIT_CLONE(urls={})".format(self.urls)

        def __eq__(self, other):
            if not other.is_GIT_CLONE():
                return False
            if self.urls != other.urls:
                return False
            return True
    
    class GIT_COMMIT:
        """
        Git commit

        <https://github.com/nostr-protocol/nips/blob/master/34.md>
        """

        hash: "str"

        def __init__(self,hash: "str"):
            self.hash = hash

        def __str__(self):
            return "TagStandard.GIT_COMMIT(hash={})".format(self.hash)

        def __eq__(self, other):
            if not other.is_GIT_COMMIT():
                return False
            if self.hash != other.hash:
                return False
            return True
    
    class GIT_EARLIEST_UNIQUE_COMMIT_ID:
        """
        Git earliest unique commit ID

        <https://github.com/nostr-protocol/nips/blob/master/34.md>
        """

        commit: "str"

        def __init__(self,commit: "str"):
            self.commit = commit

        def __str__(self):
            return "TagStandard.GIT_EARLIEST_UNIQUE_COMMIT_ID(commit={})".format(self.commit)

        def __eq__(self, other):
            if not other.is_GIT_EARLIEST_UNIQUE_COMMIT_ID():
                return False
            if self.commit != other.commit:
                return False
            return True
    
    class GIT_MAINTAINERS:
        """
        Git repo maintainers

        <https://github.com/nostr-protocol/nips/blob/master/34.md>
        """

        public_keys: "typing.List[PublicKey]"

        def __init__(self,public_keys: "typing.List[PublicKey]"):
            self.public_keys = public_keys

        def __str__(self):
            return "TagStandard.GIT_MAINTAINERS(public_keys={})".format(self.public_keys)

        def __eq__(self, other):
            if not other.is_GIT_MAINTAINERS():
                return False
            if self.public_keys != other.public_keys:
                return False
            return True
    
    class GIT_HEAD:
        head: "str"

        def __init__(self,head: "str"):
            self.head = head

        def __str__(self):
            return "TagStandard.GIT_HEAD(head={})".format(self.head)

        def __eq__(self, other):
            if not other.is_GIT_HEAD():
                return False
            if self.head != other.head:
                return False
            return True
    
    class PUBLIC_KEY_TAG:
        public_key: "PublicKey"
        relay_url: "typing.Optional[RelayUrl]"
        alias: "typing.Optional[str]"
        uppercase: "bool"
        """
        Whether the p tag is an uppercase P or not
        """


        def __init__(self,public_key: "PublicKey", relay_url: "typing.Optional[RelayUrl]", alias: "typing.Optional[str]", uppercase: "bool"):
            self.public_key = public_key
            self.relay_url = relay_url
            self.alias = alias
            self.uppercase = uppercase

        def __str__(self):
            return "TagStandard.PUBLIC_KEY_TAG(public_key={}, relay_url={}, alias={}, uppercase={})".format(self.public_key, self.relay_url, self.alias, self.uppercase)

        def __eq__(self, other):
            if not other.is_PUBLIC_KEY_TAG():
                return False
            if self.public_key != other.public_key:
                return False
            if self.relay_url != other.relay_url:
                return False
            if self.alias != other.alias:
                return False
            if self.uppercase != other.uppercase:
                return False
            return True
    
    class EVENT_REPORT:
        event_id: "EventId"
        report: "Report"

        def __init__(self,event_id: "EventId", report: "Report"):
            self.event_id = event_id
            self.report = report

        def __str__(self):
            return "TagStandard.EVENT_REPORT(event_id={}, report={})".format(self.event_id, self.report)

        def __eq__(self, other):
            if not other.is_EVENT_REPORT():
                return False
            if self.event_id != other.event_id:
                return False
            if self.report != other.report:
                return False
            return True
    
    class PUB_KEY_REPORT:
        public_key: "PublicKey"
        report: "Report"

        def __init__(self,public_key: "PublicKey", report: "Report"):
            self.public_key = public_key
            self.report = report

        def __str__(self):
            return "TagStandard.PUB_KEY_REPORT(public_key={}, report={})".format(self.public_key, self.report)

        def __eq__(self, other):
            if not other.is_PUB_KEY_REPORT():
                return False
            if self.public_key != other.public_key:
                return False
            if self.report != other.report:
                return False
            return True
    
    class PUBLIC_KEY_LIVE_EVENT:
        public_key: "PublicKey"
        relay_url: "typing.Optional[RelayUrl]"
        marker: "LiveEventMarker"
        proof: "typing.Optional[str]"

        def __init__(self,public_key: "PublicKey", relay_url: "typing.Optional[RelayUrl]", marker: "LiveEventMarker", proof: "typing.Optional[str]"):
            self.public_key = public_key
            self.relay_url = relay_url
            self.marker = marker
            self.proof = proof

        def __str__(self):
            return "TagStandard.PUBLIC_KEY_LIVE_EVENT(public_key={}, relay_url={}, marker={}, proof={})".format(self.public_key, self.relay_url, self.marker, self.proof)

        def __eq__(self, other):
            if not other.is_PUBLIC_KEY_LIVE_EVENT():
                return False
            if self.public_key != other.public_key:
                return False
            if self.relay_url != other.relay_url:
                return False
            if self.marker != other.marker:
                return False
            if self.proof != other.proof:
                return False
            return True
    
    class REFERENCE:
        reference: "str"

        def __init__(self,reference: "str"):
            self.reference = reference

        def __str__(self):
            return "TagStandard.REFERENCE(reference={})".format(self.reference)

        def __eq__(self, other):
            if not other.is_REFERENCE():
                return False
            if self.reference != other.reference:
                return False
            return True
    
    class RELAY_METADATA_TAG:
        relay_url: "RelayUrl"
        rw: "typing.Optional[RelayMetadata]"

        def __init__(self,relay_url: "RelayUrl", rw: "typing.Optional[RelayMetadata]"):
            self.relay_url = relay_url
            self.rw = rw

        def __str__(self):
            return "TagStandard.RELAY_METADATA_TAG(relay_url={}, rw={})".format(self.relay_url, self.rw)

        def __eq__(self, other):
            if not other.is_RELAY_METADATA_TAG():
                return False
            if self.relay_url != other.relay_url:
                return False
            if self.rw != other.rw:
                return False
            return True
    
    class HASHTAG:
        hashtag: "str"

        def __init__(self,hashtag: "str"):
            self.hashtag = hashtag

        def __str__(self):
            return "TagStandard.HASHTAG(hashtag={})".format(self.hashtag)

        def __eq__(self, other):
            if not other.is_HASHTAG():
                return False
            if self.hashtag != other.hashtag:
                return False
            return True
    
    class GEOHASH:
        geohash: "str"

        def __init__(self,geohash: "str"):
            self.geohash = geohash

        def __str__(self):
            return "TagStandard.GEOHASH(geohash={})".format(self.geohash)

        def __eq__(self, other):
            if not other.is_GEOHASH():
                return False
            if self.geohash != other.geohash:
                return False
            return True
    
    class IDENTIFIER:
        identifier: "str"

        def __init__(self,identifier: "str"):
            self.identifier = identifier

        def __str__(self):
            return "TagStandard.IDENTIFIER(identifier={})".format(self.identifier)

        def __eq__(self, other):
            if not other.is_IDENTIFIER():
                return False
            if self.identifier != other.identifier:
                return False
            return True
    
    class EXTERNAL_CONTENT:
        content: "ExternalContentId"
        hint: "typing.Optional[str]"
        """
        Hint URL
        """

        uppercase: "bool"

        def __init__(self,content: "ExternalContentId", hint: "typing.Optional[str]", uppercase: "bool"):
            self.content = content
            self.hint = hint
            self.uppercase = uppercase

        def __str__(self):
            return "TagStandard.EXTERNAL_CONTENT(content={}, hint={}, uppercase={})".format(self.content, self.hint, self.uppercase)

        def __eq__(self, other):
            if not other.is_EXTERNAL_CONTENT():
                return False
            if self.content != other.content:
                return False
            if self.hint != other.hint:
                return False
            if self.uppercase != other.uppercase:
                return False
            return True
    
    class EXTERNAL_IDENTITY:
        identity: "Identity"

        def __init__(self,identity: "Identity"):
            self.identity = identity

        def __str__(self):
            return "TagStandard.EXTERNAL_IDENTITY(identity={})".format(self.identity)

        def __eq__(self, other):
            if not other.is_EXTERNAL_IDENTITY():
                return False
            if self.identity != other.identity:
                return False
            return True
    
    class COORDINATE_TAG:
        coordinate: "Coordinate"
        relay_url: "typing.Optional[RelayUrl]"
        uppercase: "bool"
        """
        Whether the a tag is an uppercase A or not
        """


        def __init__(self,coordinate: "Coordinate", relay_url: "typing.Optional[RelayUrl]", uppercase: "bool"):
            self.coordinate = coordinate
            self.relay_url = relay_url
            self.uppercase = uppercase

        def __str__(self):
            return "TagStandard.COORDINATE_TAG(coordinate={}, relay_url={}, uppercase={})".format(self.coordinate, self.relay_url, self.uppercase)

        def __eq__(self, other):
            if not other.is_COORDINATE_TAG():
                return False
            if self.coordinate != other.coordinate:
                return False
            if self.relay_url != other.relay_url:
                return False
            if self.uppercase != other.uppercase:
                return False
            return True
    
    class KIND_TAG:
        kind: "Kind"
        uppercase: "bool"
        """
        Whether the k tag is an uppercase K or not
        """


        def __init__(self,kind: "Kind", uppercase: "bool"):
            self.kind = kind
            self.uppercase = uppercase

        def __str__(self):
            return "TagStandard.KIND_TAG(kind={}, uppercase={})".format(self.kind, self.uppercase)

        def __eq__(self, other):
            if not other.is_KIND_TAG():
                return False
            if self.kind != other.kind:
                return False
            if self.uppercase != other.uppercase:
                return False
            return True
    
    class NIP73_KIND_TAG:
        kind: "Nip73Kind"
        uppercase: "bool"
        """
        Whether the tag is an uppercase or not
        """


        def __init__(self,kind: "Nip73Kind", uppercase: "bool"):
            self.kind = kind
            self.uppercase = uppercase

        def __str__(self):
            return "TagStandard.NIP73_KIND_TAG(kind={}, uppercase={})".format(self.kind, self.uppercase)

        def __eq__(self, other):
            if not other.is_NIP73_KIND_TAG():
                return False
            if self.kind != other.kind:
                return False
            if self.uppercase != other.uppercase:
                return False
            return True
    
    class RELAY:
        url: "RelayUrl"

        def __init__(self,url: "RelayUrl"):
            self.url = url

        def __str__(self):
            return "TagStandard.RELAY(url={})".format(self.url)

        def __eq__(self, other):
            if not other.is_RELAY():
                return False
            if self.url != other.url:
                return False
            return True
    
    class ALL_RELAYS:
        """
        All relays tag

        <https://github.com/nostr-protocol/nips/blob/master/62.md>
        """


        def __init__(self,):
            pass

        def __str__(self):
            return "TagStandard.ALL_RELAYS()".format()

        def __eq__(self, other):
            if not other.is_ALL_RELAYS():
                return False
            return True
    
    class POW:
        nonce: "str"
        difficulty: "int"

        def __init__(self,nonce: "str", difficulty: "int"):
            self.nonce = nonce
            self.difficulty = difficulty

        def __str__(self):
            return "TagStandard.POW(nonce={}, difficulty={})".format(self.nonce, self.difficulty)

        def __eq__(self, other):
            if not other.is_POW():
                return False
            if self.nonce != other.nonce:
                return False
            if self.difficulty != other.difficulty:
                return False
            return True
    
    class CLIENT:
        name: "str"
        address: "typing.Optional[TagClientAddress]"

        def __init__(self,name: "str", address: "typing.Optional[TagClientAddress]"):
            self.name = name
            self.address = address

        def __str__(self):
            return "TagStandard.CLIENT(name={}, address={})".format(self.name, self.address)

        def __eq__(self, other):
            if not other.is_CLIENT():
                return False
            if self.name != other.name:
                return False
            if self.address != other.address:
                return False
            return True
    
    class CONTENT_WARNING:
        reason: "typing.Optional[str]"

        def __init__(self,reason: "typing.Optional[str]"):
            self.reason = reason

        def __str__(self):
            return "TagStandard.CONTENT_WARNING(reason={})".format(self.reason)

        def __eq__(self, other):
            if not other.is_CONTENT_WARNING():
                return False
            if self.reason != other.reason:
                return False
            return True
    
    class EXPIRATION:
        timestamp: "Timestamp"

        def __init__(self,timestamp: "Timestamp"):
            self.timestamp = timestamp

        def __str__(self):
            return "TagStandard.EXPIRATION(timestamp={})".format(self.timestamp)

        def __eq__(self, other):
            if not other.is_EXPIRATION():
                return False
            if self.timestamp != other.timestamp:
                return False
            return True
    
    class SUBJECT:
        subject: "str"

        def __init__(self,subject: "str"):
            self.subject = subject

        def __str__(self):
            return "TagStandard.SUBJECT(subject={})".format(self.subject)

        def __eq__(self, other):
            if not other.is_SUBJECT():
                return False
            if self.subject != other.subject:
                return False
            return True
    
    class CHALLENGE:
        challenge: "str"

        def __init__(self,challenge: "str"):
            self.challenge = challenge

        def __str__(self):
            return "TagStandard.CHALLENGE(challenge={})".format(self.challenge)

        def __eq__(self, other):
            if not other.is_CHALLENGE():
                return False
            if self.challenge != other.challenge:
                return False
            return True
    
    class TITLE:
        title: "str"

        def __init__(self,title: "str"):
            self.title = title

        def __str__(self):
            return "TagStandard.TITLE(title={})".format(self.title)

        def __eq__(self, other):
            if not other.is_TITLE():
                return False
            if self.title != other.title:
                return False
            return True
    
    class IMAGE:
        url: "str"
        dimensions: "typing.Optional[ImageDimensions]"

        def __init__(self,url: "str", dimensions: "typing.Optional[ImageDimensions]"):
            self.url = url
            self.dimensions = dimensions

        def __str__(self):
            return "TagStandard.IMAGE(url={}, dimensions={})".format(self.url, self.dimensions)

        def __eq__(self, other):
            if not other.is_IMAGE():
                return False
            if self.url != other.url:
                return False
            if self.dimensions != other.dimensions:
                return False
            return True
    
    class THUMB:
        url: "str"
        dimensions: "typing.Optional[ImageDimensions]"

        def __init__(self,url: "str", dimensions: "typing.Optional[ImageDimensions]"):
            self.url = url
            self.dimensions = dimensions

        def __str__(self):
            return "TagStandard.THUMB(url={}, dimensions={})".format(self.url, self.dimensions)

        def __eq__(self, other):
            if not other.is_THUMB():
                return False
            if self.url != other.url:
                return False
            if self.dimensions != other.dimensions:
                return False
            return True
    
    class SUMMARY:
        summary: "str"

        def __init__(self,summary: "str"):
            self.summary = summary

        def __str__(self):
            return "TagStandard.SUMMARY(summary={})".format(self.summary)

        def __eq__(self, other):
            if not other.is_SUMMARY():
                return False
            if self.summary != other.summary:
                return False
            return True
    
    class DESCRIPTION:
        desc: "str"

        def __init__(self,desc: "str"):
            self.desc = desc

        def __str__(self):
            return "TagStandard.DESCRIPTION(desc={})".format(self.desc)

        def __eq__(self, other):
            if not other.is_DESCRIPTION():
                return False
            if self.desc != other.desc:
                return False
            return True
    
    class BOLT11:
        bolt11: "str"

        def __init__(self,bolt11: "str"):
            self.bolt11 = bolt11

        def __str__(self):
            return "TagStandard.BOLT11(bolt11={})".format(self.bolt11)

        def __eq__(self, other):
            if not other.is_BOLT11():
                return False
            if self.bolt11 != other.bolt11:
                return False
            return True
    
    class PREIMAGE:
        preimage: "str"

        def __init__(self,preimage: "str"):
            self.preimage = preimage

        def __str__(self):
            return "TagStandard.PREIMAGE(preimage={})".format(self.preimage)

        def __eq__(self, other):
            if not other.is_PREIMAGE():
                return False
            if self.preimage != other.preimage:
                return False
            return True
    
    class RELAYS:
        urls: "typing.List[RelayUrl]"

        def __init__(self,urls: "typing.List[RelayUrl]"):
            self.urls = urls

        def __str__(self):
            return "TagStandard.RELAYS(urls={})".format(self.urls)

        def __eq__(self, other):
            if not other.is_RELAYS():
                return False
            if self.urls != other.urls:
                return False
            return True
    
    class AMOUNT:
        millisats: "int"
        bolt11: "typing.Optional[str]"

        def __init__(self,millisats: "int", bolt11: "typing.Optional[str]"):
            self.millisats = millisats
            self.bolt11 = bolt11

        def __str__(self):
            return "TagStandard.AMOUNT(millisats={}, bolt11={})".format(self.millisats, self.bolt11)

        def __eq__(self, other):
            if not other.is_AMOUNT():
                return False
            if self.millisats != other.millisats:
                return False
            if self.bolt11 != other.bolt11:
                return False
            return True
    
    class LNURL:
        lnurl: "str"

        def __init__(self,lnurl: "str"):
            self.lnurl = lnurl

        def __str__(self):
            return "TagStandard.LNURL(lnurl={})".format(self.lnurl)

        def __eq__(self, other):
            if not other.is_LNURL():
                return False
            if self.lnurl != other.lnurl:
                return False
            return True
    
    class NAME:
        name: "str"

        def __init__(self,name: "str"):
            self.name = name

        def __str__(self):
            return "TagStandard.NAME(name={})".format(self.name)

        def __eq__(self, other):
            if not other.is_NAME():
                return False
            if self.name != other.name:
                return False
            return True
    
    class PUBLISHED_AT:
        timestamp: "Timestamp"

        def __init__(self,timestamp: "Timestamp"):
            self.timestamp = timestamp

        def __str__(self):
            return "TagStandard.PUBLISHED_AT(timestamp={})".format(self.timestamp)

        def __eq__(self, other):
            if not other.is_PUBLISHED_AT():
                return False
            if self.timestamp != other.timestamp:
                return False
            return True
    
    class URL_TAG:
        url: "str"

        def __init__(self,url: "str"):
            self.url = url

        def __str__(self):
            return "TagStandard.URL_TAG(url={})".format(self.url)

        def __eq__(self, other):
            if not other.is_URL_TAG():
                return False
            if self.url != other.url:
                return False
            return True
    
    class MIME_TYPE:
        mime: "str"

        def __init__(self,mime: "str"):
            self.mime = mime

        def __str__(self):
            return "TagStandard.MIME_TYPE(mime={})".format(self.mime)

        def __eq__(self, other):
            if not other.is_MIME_TYPE():
                return False
            if self.mime != other.mime:
                return False
            return True
    
    class AES256_GCM:
        key: "str"
        iv: "str"

        def __init__(self,key: "str", iv: "str"):
            self.key = key
            self.iv = iv

        def __str__(self):
            return "TagStandard.AES256_GCM(key={}, iv={})".format(self.key, self.iv)

        def __eq__(self, other):
            if not other.is_AES256_GCM():
                return False
            if self.key != other.key:
                return False
            if self.iv != other.iv:
                return False
            return True
    
    class SERVER:
        url: "str"

        def __init__(self,url: "str"):
            self.url = url

        def __str__(self):
            return "TagStandard.SERVER(url={})".format(self.url)

        def __eq__(self, other):
            if not other.is_SERVER():
                return False
            if self.url != other.url:
                return False
            return True
    
    class SHA256:
        hash: "str"

        def __init__(self,hash: "str"):
            self.hash = hash

        def __str__(self):
            return "TagStandard.SHA256(hash={})".format(self.hash)

        def __eq__(self, other):
            if not other.is_SHA256():
                return False
            if self.hash != other.hash:
                return False
            return True
    
    class SIZE:
        size: "int"

        def __init__(self,size: "int"):
            self.size = size

        def __str__(self):
            return "TagStandard.SIZE(size={})".format(self.size)

        def __eq__(self, other):
            if not other.is_SIZE():
                return False
            if self.size != other.size:
                return False
            return True
    
    class DIM:
        """
        Size of file in pixels
        """

        dimensions: "ImageDimensions"

        def __init__(self,dimensions: "ImageDimensions"):
            self.dimensions = dimensions

        def __str__(self):
            return "TagStandard.DIM(dimensions={})".format(self.dimensions)

        def __eq__(self, other):
            if not other.is_DIM():
                return False
            if self.dimensions != other.dimensions:
                return False
            return True
    
    class MAGNET:
        uri: "str"

        def __init__(self,uri: "str"):
            self.uri = uri

        def __str__(self):
            return "TagStandard.MAGNET(uri={})".format(self.uri)

        def __eq__(self, other):
            if not other.is_MAGNET():
                return False
            if self.uri != other.uri:
                return False
            return True
    
    class BLURHASH:
        blurhash: "str"

        def __init__(self,blurhash: "str"):
            self.blurhash = blurhash

        def __str__(self):
            return "TagStandard.BLURHASH(blurhash={})".format(self.blurhash)

        def __eq__(self, other):
            if not other.is_BLURHASH():
                return False
            if self.blurhash != other.blurhash:
                return False
            return True
    
    class STREAMING:
        url: "str"

        def __init__(self,url: "str"):
            self.url = url

        def __str__(self):
            return "TagStandard.STREAMING(url={})".format(self.url)

        def __eq__(self, other):
            if not other.is_STREAMING():
                return False
            if self.url != other.url:
                return False
            return True
    
    class RECORDING:
        url: "str"

        def __init__(self,url: "str"):
            self.url = url

        def __str__(self):
            return "TagStandard.RECORDING(url={})".format(self.url)

        def __eq__(self, other):
            if not other.is_RECORDING():
                return False
            if self.url != other.url:
                return False
            return True
    
    class STARTS:
        timestamp: "Timestamp"

        def __init__(self,timestamp: "Timestamp"):
            self.timestamp = timestamp

        def __str__(self):
            return "TagStandard.STARTS(timestamp={})".format(self.timestamp)

        def __eq__(self, other):
            if not other.is_STARTS():
                return False
            if self.timestamp != other.timestamp:
                return False
            return True
    
    class ENDS:
        timestamp: "Timestamp"

        def __init__(self,timestamp: "Timestamp"):
            self.timestamp = timestamp

        def __str__(self):
            return "TagStandard.ENDS(timestamp={})".format(self.timestamp)

        def __eq__(self, other):
            if not other.is_ENDS():
                return False
            if self.timestamp != other.timestamp:
                return False
            return True
    
    class LIVE_EVENT_STATUS_TAG:
        status: "LiveEventStatus"

        def __init__(self,status: "LiveEventStatus"):
            self.status = status

        def __str__(self):
            return "TagStandard.LIVE_EVENT_STATUS_TAG(status={})".format(self.status)

        def __eq__(self, other):
            if not other.is_LIVE_EVENT_STATUS_TAG():
                return False
            if self.status != other.status:
                return False
            return True
    
    class CURRENT_PARTICIPANTS:
        num: "int"

        def __init__(self,num: "int"):
            self.num = num

        def __str__(self):
            return "TagStandard.CURRENT_PARTICIPANTS(num={})".format(self.num)

        def __eq__(self, other):
            if not other.is_CURRENT_PARTICIPANTS():
                return False
            if self.num != other.num:
                return False
            return True
    
    class TOTAL_PARTICIPANTS:
        num: "int"

        def __init__(self,num: "int"):
            self.num = num

        def __str__(self):
            return "TagStandard.TOTAL_PARTICIPANTS(num={})".format(self.num)

        def __eq__(self, other):
            if not other.is_TOTAL_PARTICIPANTS():
                return False
            if self.num != other.num:
                return False
            return True
    
    class ABSOLUTE_URL:
        url: "str"

        def __init__(self,url: "str"):
            self.url = url

        def __str__(self):
            return "TagStandard.ABSOLUTE_URL(url={})".format(self.url)

        def __eq__(self, other):
            if not other.is_ABSOLUTE_URL():
                return False
            if self.url != other.url:
                return False
            return True
    
    class METHOD:
        method: "HttpMethod"

        def __init__(self,method: "HttpMethod"):
            self.method = method

        def __str__(self):
            return "TagStandard.METHOD(method={})".format(self.method)

        def __eq__(self, other):
            if not other.is_METHOD():
                return False
            if self.method != other.method:
                return False
            return True
    
    class PAYLOAD:
        hash: "str"

        def __init__(self,hash: "str"):
            self.hash = hash

        def __str__(self):
            return "TagStandard.PAYLOAD(hash={})".format(self.hash)

        def __eq__(self, other):
            if not other.is_PAYLOAD():
                return False
            if self.hash != other.hash:
                return False
            return True
    
    class ANON:
        msg: "typing.Optional[str]"

        def __init__(self,msg: "typing.Optional[str]"):
            self.msg = msg

        def __str__(self):
            return "TagStandard.ANON(msg={})".format(self.msg)

        def __eq__(self, other):
            if not other.is_ANON():
                return False
            if self.msg != other.msg:
                return False
            return True
    
    class PROXY:
        id: "str"
        protocol: "Protocol"

        def __init__(self,id: "str", protocol: "Protocol"):
            self.id = id
            self.protocol = protocol

        def __str__(self):
            return "TagStandard.PROXY(id={}, protocol={})".format(self.id, self.protocol)

        def __eq__(self, other):
            if not other.is_PROXY():
                return False
            if self.id != other.id:
                return False
            if self.protocol != other.protocol:
                return False
            return True
    
    class EMOJI:
        shortcode: "str"
        url: "str"

        def __init__(self,shortcode: "str", url: "str"):
            self.shortcode = shortcode
            self.url = url

        def __str__(self):
            return "TagStandard.EMOJI(shortcode={}, url={})".format(self.shortcode, self.url)

        def __eq__(self, other):
            if not other.is_EMOJI():
                return False
            if self.shortcode != other.shortcode:
                return False
            if self.url != other.url:
                return False
            return True
    
    class ENCRYPTED:

        def __init__(self,):
            pass

        def __str__(self):
            return "TagStandard.ENCRYPTED()".format()

        def __eq__(self, other):
            if not other.is_ENCRYPTED():
                return False
            return True
    
    class REQUEST:
        event: "Event"

        def __init__(self,event: "Event"):
            self.event = event

        def __str__(self):
            return "TagStandard.REQUEST(event={})".format(self.event)

        def __eq__(self, other):
            if not other.is_REQUEST():
                return False
            if self.event != other.event:
                return False
            return True
    
    class DATA_VENDING_MACHINE_STATUS_TAG:
        status: "DataVendingMachineStatus"
        extra_info: "typing.Optional[str]"

        def __init__(self,status: "DataVendingMachineStatus", extra_info: "typing.Optional[str]"):
            self.status = status
            self.extra_info = extra_info

        def __str__(self):
            return "TagStandard.DATA_VENDING_MACHINE_STATUS_TAG(status={}, extra_info={})".format(self.status, self.extra_info)

        def __eq__(self, other):
            if not other.is_DATA_VENDING_MACHINE_STATUS_TAG():
                return False
            if self.status != other.status:
                return False
            if self.extra_info != other.extra_info:
                return False
            return True
    
    class LABEL_NAMESPACE:
        namespace: "str"

        def __init__(self,namespace: "str"):
            self.namespace = namespace

        def __str__(self):
            return "TagStandard.LABEL_NAMESPACE(namespace={})".format(self.namespace)

        def __eq__(self, other):
            if not other.is_LABEL_NAMESPACE():
                return False
            if self.namespace != other.namespace:
                return False
            return True
    
    class LABEL:
        value: "str"
        namespace: "typing.Optional[str]"

        def __init__(self,value: "str", namespace: "typing.Optional[str]"):
            self.value = value
            self.namespace = namespace

        def __str__(self):
            return "TagStandard.LABEL(value={}, namespace={})".format(self.value, self.namespace)

        def __eq__(self, other):
            if not other.is_LABEL():
                return False
            if self.value != other.value:
                return False
            if self.namespace != other.namespace:
                return False
            return True
    
    class PROTECTED:
        """
        Protected event

        <https://github.com/nostr-protocol/nips/blob/master/70.md>
        """


        def __init__(self,):
            pass

        def __str__(self):
            return "TagStandard.PROTECTED()".format()

        def __eq__(self, other):
            if not other.is_PROTECTED():
                return False
            return True
    
    class ALT:
        """
        A short human-readable plaintext summary of what that event is about

        <https://github.com/nostr-protocol/nips/blob/master/31.md>
        """

        summary: "str"

        def __init__(self,summary: "str"):
            self.summary = summary

        def __str__(self):
            return "TagStandard.ALT(summary={})".format(self.summary)

        def __eq__(self, other):
            if not other.is_ALT():
                return False
            if self.summary != other.summary:
                return False
            return True
    
    class WORD:
        word: "str"

        def __init__(self,word: "str"):
            self.word = word

        def __str__(self):
            return "TagStandard.WORD(word={})".format(self.word)

        def __eq__(self, other):
            if not other.is_WORD():
                return False
            if self.word != other.word:
                return False
            return True
    
    class WEB:
        urls: "typing.List[str]"

        def __init__(self,urls: "typing.List[str]"):
            self.urls = urls

        def __str__(self):
            return "TagStandard.WEB(urls={})".format(self.urls)

        def __eq__(self, other):
            if not other.is_WEB():
                return False
            if self.urls != other.urls:
                return False
            return True
    
    class DEPENDENCY:
        """
        Required dependency

        <https://github.com/nostr-protocol/nips/blob/master/C0.md>
        """

        dep: "str"

        def __init__(self,dep: "str"):
            self.dep = dep

        def __str__(self):
            return "TagStandard.DEPENDENCY(dep={})".format(self.dep)

        def __eq__(self, other):
            if not other.is_DEPENDENCY():
                return False
            if self.dep != other.dep:
                return False
            return True
    
    class EXTENSION:
        """
        File extension

        <https://github.com/nostr-protocol/nips/blob/master/C0.md>
        """

        ext: "str"

        def __init__(self,ext: "str"):
            self.ext = ext

        def __str__(self):
            return "TagStandard.EXTENSION(ext={})".format(self.ext)

        def __eq__(self, other):
            if not other.is_EXTENSION():
                return False
            if self.ext != other.ext:
                return False
            return True
    
    class LICENSE:
        """
        License of the shared content

        <https://github.com/nostr-protocol/nips/blob/master/C0.md>
        """

        license: "str"

        def __init__(self,license: "str"):
            self.license = license

        def __str__(self):
            return "TagStandard.LICENSE(license={})".format(self.license)

        def __eq__(self, other):
            if not other.is_LICENSE():
                return False
            if self.license != other.license:
                return False
            return True
    
    class RUNTIME:
        """
        Runtime or environment specification

        <https://github.com/nostr-protocol/nips/blob/master/C0.md>
        """

        runtime: "str"

        def __init__(self,runtime: "str"):
            self.runtime = runtime

        def __str__(self):
            return "TagStandard.RUNTIME(runtime={})".format(self.runtime)

        def __eq__(self, other):
            if not other.is_RUNTIME():
                return False
            if self.runtime != other.runtime:
                return False
            return True
    
    class REPOSITORY:
        """
        Reference to the origin repository

        <https://github.com/nostr-protocol/nips/blob/master/C0.md>
        """

        url: "str"

        def __init__(self,url: "str"):
            self.url = url

        def __str__(self):
            return "TagStandard.REPOSITORY(url={})".format(self.url)

        def __eq__(self, other):
            if not other.is_REPOSITORY():
                return False
            if self.url != other.url:
                return False
            return True
    
    class NIP88_POLL_ENDS_AT:
        timestamp: "Timestamp"

        def __init__(self,timestamp: "Timestamp"):
            self.timestamp = timestamp

        def __str__(self):
            return "TagStandard.NIP88_POLL_ENDS_AT(timestamp={})".format(self.timestamp)

        def __eq__(self, other):
            if not other.is_NIP88_POLL_ENDS_AT():
                return False
            if self.timestamp != other.timestamp:
                return False
            return True
    
    class NIP88_POLL_OPTION:
        option: "PollOption"

        def __init__(self,option: "PollOption"):
            self.option = option

        def __str__(self):
            return "TagStandard.NIP88_POLL_OPTION(option={})".format(self.option)

        def __eq__(self, other):
            if not other.is_NIP88_POLL_OPTION():
                return False
            if self.option != other.option:
                return False
            return True
    
    class NIP88_POLL_RESPONSE:
        response: "str"

        def __init__(self,response: "str"):
            self.response = response

        def __str__(self):
            return "TagStandard.NIP88_POLL_RESPONSE(response={})".format(self.response)

        def __eq__(self, other):
            if not other.is_NIP88_POLL_RESPONSE():
                return False
            if self.response != other.response:
                return False
            return True
    
    class NIP88_POLL_TYPE:
        poll_type: "PollType"

        def __init__(self,poll_type: "PollType"):
            self.poll_type = poll_type

        def __str__(self):
            return "TagStandard.NIP88_POLL_TYPE(poll_type={})".format(self.poll_type)

        def __eq__(self, other):
            if not other.is_NIP88_POLL_TYPE():
                return False
            if self.poll_type != other.poll_type:
                return False
            return True
    
    

    # For each variant, we have `is_NAME` and `is_name` methods for easily checking
    # whether an instance is that variant.
    def is_EVENT_TAG(self) -> bool:
        return isinstance(self, TagStandard.EVENT_TAG)
    def is_event_tag(self) -> bool:
        return isinstance(self, TagStandard.EVENT_TAG)
    def is_QUOTE(self) -> bool:
        return isinstance(self, TagStandard.QUOTE)
    def is_quote(self) -> bool:
        return isinstance(self, TagStandard.QUOTE)
    def is_QUOTE_ADDRESS(self) -> bool:
        return isinstance(self, TagStandard.QUOTE_ADDRESS)
    def is_quote_address(self) -> bool:
        return isinstance(self, TagStandard.QUOTE_ADDRESS)
    def is_GIT_CLONE(self) -> bool:
        return isinstance(self, TagStandard.GIT_CLONE)
    def is_git_clone(self) -> bool:
        return isinstance(self, TagStandard.GIT_CLONE)
    def is_GIT_COMMIT(self) -> bool:
        return isinstance(self, TagStandard.GIT_COMMIT)
    def is_git_commit(self) -> bool:
        return isinstance(self, TagStandard.GIT_COMMIT)
    def is_GIT_EARLIEST_UNIQUE_COMMIT_ID(self) -> bool:
        return isinstance(self, TagStandard.GIT_EARLIEST_UNIQUE_COMMIT_ID)
    def is_git_earliest_unique_commit_id(self) -> bool:
        return isinstance(self, TagStandard.GIT_EARLIEST_UNIQUE_COMMIT_ID)
    def is_GIT_MAINTAINERS(self) -> bool:
        return isinstance(self, TagStandard.GIT_MAINTAINERS)
    def is_git_maintainers(self) -> bool:
        return isinstance(self, TagStandard.GIT_MAINTAINERS)
    def is_GIT_HEAD(self) -> bool:
        return isinstance(self, TagStandard.GIT_HEAD)
    def is_git_head(self) -> bool:
        return isinstance(self, TagStandard.GIT_HEAD)
    def is_PUBLIC_KEY_TAG(self) -> bool:
        return isinstance(self, TagStandard.PUBLIC_KEY_TAG)
    def is_public_key_tag(self) -> bool:
        return isinstance(self, TagStandard.PUBLIC_KEY_TAG)
    def is_EVENT_REPORT(self) -> bool:
        return isinstance(self, TagStandard.EVENT_REPORT)
    def is_event_report(self) -> bool:
        return isinstance(self, TagStandard.EVENT_REPORT)
    def is_PUB_KEY_REPORT(self) -> bool:
        return isinstance(self, TagStandard.PUB_KEY_REPORT)
    def is_pub_key_report(self) -> bool:
        return isinstance(self, TagStandard.PUB_KEY_REPORT)
    def is_PUBLIC_KEY_LIVE_EVENT(self) -> bool:
        return isinstance(self, TagStandard.PUBLIC_KEY_LIVE_EVENT)
    def is_public_key_live_event(self) -> bool:
        return isinstance(self, TagStandard.PUBLIC_KEY_LIVE_EVENT)
    def is_REFERENCE(self) -> bool:
        return isinstance(self, TagStandard.REFERENCE)
    def is_reference(self) -> bool:
        return isinstance(self, TagStandard.REFERENCE)
    def is_RELAY_METADATA_TAG(self) -> bool:
        return isinstance(self, TagStandard.RELAY_METADATA_TAG)
    def is_relay_metadata_tag(self) -> bool:
        return isinstance(self, TagStandard.RELAY_METADATA_TAG)
    def is_HASHTAG(self) -> bool:
        return isinstance(self, TagStandard.HASHTAG)
    def is_hashtag(self) -> bool:
        return isinstance(self, TagStandard.HASHTAG)
    def is_GEOHASH(self) -> bool:
        return isinstance(self, TagStandard.GEOHASH)
    def is_geohash(self) -> bool:
        return isinstance(self, TagStandard.GEOHASH)
    def is_IDENTIFIER(self) -> bool:
        return isinstance(self, TagStandard.IDENTIFIER)
    def is_identifier(self) -> bool:
        return isinstance(self, TagStandard.IDENTIFIER)
    def is_EXTERNAL_CONTENT(self) -> bool:
        return isinstance(self, TagStandard.EXTERNAL_CONTENT)
    def is_external_content(self) -> bool:
        return isinstance(self, TagStandard.EXTERNAL_CONTENT)
    def is_EXTERNAL_IDENTITY(self) -> bool:
        return isinstance(self, TagStandard.EXTERNAL_IDENTITY)
    def is_external_identity(self) -> bool:
        return isinstance(self, TagStandard.EXTERNAL_IDENTITY)
    def is_COORDINATE_TAG(self) -> bool:
        return isinstance(self, TagStandard.COORDINATE_TAG)
    def is_coordinate_tag(self) -> bool:
        return isinstance(self, TagStandard.COORDINATE_TAG)
    def is_KIND_TAG(self) -> bool:
        return isinstance(self, TagStandard.KIND_TAG)
    def is_kind_tag(self) -> bool:
        return isinstance(self, TagStandard.KIND_TAG)
    def is_NIP73_KIND_TAG(self) -> bool:
        return isinstance(self, TagStandard.NIP73_KIND_TAG)
    def is_nip73_kind_tag(self) -> bool:
        return isinstance(self, TagStandard.NIP73_KIND_TAG)
    def is_RELAY(self) -> bool:
        return isinstance(self, TagStandard.RELAY)
    def is_relay(self) -> bool:
        return isinstance(self, TagStandard.RELAY)
    def is_ALL_RELAYS(self) -> bool:
        return isinstance(self, TagStandard.ALL_RELAYS)
    def is_all_relays(self) -> bool:
        return isinstance(self, TagStandard.ALL_RELAYS)
    def is_POW(self) -> bool:
        return isinstance(self, TagStandard.POW)
    def is_pow(self) -> bool:
        return isinstance(self, TagStandard.POW)
    def is_CLIENT(self) -> bool:
        return isinstance(self, TagStandard.CLIENT)
    def is_client(self) -> bool:
        return isinstance(self, TagStandard.CLIENT)
    def is_CONTENT_WARNING(self) -> bool:
        return isinstance(self, TagStandard.CONTENT_WARNING)
    def is_content_warning(self) -> bool:
        return isinstance(self, TagStandard.CONTENT_WARNING)
    def is_EXPIRATION(self) -> bool:
        return isinstance(self, TagStandard.EXPIRATION)
    def is_expiration(self) -> bool:
        return isinstance(self, TagStandard.EXPIRATION)
    def is_SUBJECT(self) -> bool:
        return isinstance(self, TagStandard.SUBJECT)
    def is_subject(self) -> bool:
        return isinstance(self, TagStandard.SUBJECT)
    def is_CHALLENGE(self) -> bool:
        return isinstance(self, TagStandard.CHALLENGE)
    def is_challenge(self) -> bool:
        return isinstance(self, TagStandard.CHALLENGE)
    def is_TITLE(self) -> bool:
        return isinstance(self, TagStandard.TITLE)
    def is_title(self) -> bool:
        return isinstance(self, TagStandard.TITLE)
    def is_IMAGE(self) -> bool:
        return isinstance(self, TagStandard.IMAGE)
    def is_image(self) -> bool:
        return isinstance(self, TagStandard.IMAGE)
    def is_THUMB(self) -> bool:
        return isinstance(self, TagStandard.THUMB)
    def is_thumb(self) -> bool:
        return isinstance(self, TagStandard.THUMB)
    def is_SUMMARY(self) -> bool:
        return isinstance(self, TagStandard.SUMMARY)
    def is_summary(self) -> bool:
        return isinstance(self, TagStandard.SUMMARY)
    def is_DESCRIPTION(self) -> bool:
        return isinstance(self, TagStandard.DESCRIPTION)
    def is_description(self) -> bool:
        return isinstance(self, TagStandard.DESCRIPTION)
    def is_BOLT11(self) -> bool:
        return isinstance(self, TagStandard.BOLT11)
    def is_bolt11(self) -> bool:
        return isinstance(self, TagStandard.BOLT11)
    def is_PREIMAGE(self) -> bool:
        return isinstance(self, TagStandard.PREIMAGE)
    def is_preimage(self) -> bool:
        return isinstance(self, TagStandard.PREIMAGE)
    def is_RELAYS(self) -> bool:
        return isinstance(self, TagStandard.RELAYS)
    def is_relays(self) -> bool:
        return isinstance(self, TagStandard.RELAYS)
    def is_AMOUNT(self) -> bool:
        return isinstance(self, TagStandard.AMOUNT)
    def is_amount(self) -> bool:
        return isinstance(self, TagStandard.AMOUNT)
    def is_LNURL(self) -> bool:
        return isinstance(self, TagStandard.LNURL)
    def is_lnurl(self) -> bool:
        return isinstance(self, TagStandard.LNURL)
    def is_NAME(self) -> bool:
        return isinstance(self, TagStandard.NAME)
    def is_name(self) -> bool:
        return isinstance(self, TagStandard.NAME)
    def is_PUBLISHED_AT(self) -> bool:
        return isinstance(self, TagStandard.PUBLISHED_AT)
    def is_published_at(self) -> bool:
        return isinstance(self, TagStandard.PUBLISHED_AT)
    def is_URL_TAG(self) -> bool:
        return isinstance(self, TagStandard.URL_TAG)
    def is_url_tag(self) -> bool:
        return isinstance(self, TagStandard.URL_TAG)
    def is_MIME_TYPE(self) -> bool:
        return isinstance(self, TagStandard.MIME_TYPE)
    def is_mime_type(self) -> bool:
        return isinstance(self, TagStandard.MIME_TYPE)
    def is_AES256_GCM(self) -> bool:
        return isinstance(self, TagStandard.AES256_GCM)
    def is_aes256_gcm(self) -> bool:
        return isinstance(self, TagStandard.AES256_GCM)
    def is_SERVER(self) -> bool:
        return isinstance(self, TagStandard.SERVER)
    def is_server(self) -> bool:
        return isinstance(self, TagStandard.SERVER)
    def is_SHA256(self) -> bool:
        return isinstance(self, TagStandard.SHA256)
    def is_sha256(self) -> bool:
        return isinstance(self, TagStandard.SHA256)
    def is_SIZE(self) -> bool:
        return isinstance(self, TagStandard.SIZE)
    def is_size(self) -> bool:
        return isinstance(self, TagStandard.SIZE)
    def is_DIM(self) -> bool:
        return isinstance(self, TagStandard.DIM)
    def is_dim(self) -> bool:
        return isinstance(self, TagStandard.DIM)
    def is_MAGNET(self) -> bool:
        return isinstance(self, TagStandard.MAGNET)
    def is_magnet(self) -> bool:
        return isinstance(self, TagStandard.MAGNET)
    def is_BLURHASH(self) -> bool:
        return isinstance(self, TagStandard.BLURHASH)
    def is_blurhash(self) -> bool:
        return isinstance(self, TagStandard.BLURHASH)
    def is_STREAMING(self) -> bool:
        return isinstance(self, TagStandard.STREAMING)
    def is_streaming(self) -> bool:
        return isinstance(self, TagStandard.STREAMING)
    def is_RECORDING(self) -> bool:
        return isinstance(self, TagStandard.RECORDING)
    def is_recording(self) -> bool:
        return isinstance(self, TagStandard.RECORDING)
    def is_STARTS(self) -> bool:
        return isinstance(self, TagStandard.STARTS)
    def is_starts(self) -> bool:
        return isinstance(self, TagStandard.STARTS)
    def is_ENDS(self) -> bool:
        return isinstance(self, TagStandard.ENDS)
    def is_ends(self) -> bool:
        return isinstance(self, TagStandard.ENDS)
    def is_LIVE_EVENT_STATUS_TAG(self) -> bool:
        return isinstance(self, TagStandard.LIVE_EVENT_STATUS_TAG)
    def is_live_event_status_tag(self) -> bool:
        return isinstance(self, TagStandard.LIVE_EVENT_STATUS_TAG)
    def is_CURRENT_PARTICIPANTS(self) -> bool:
        return isinstance(self, TagStandard.CURRENT_PARTICIPANTS)
    def is_current_participants(self) -> bool:
        return isinstance(self, TagStandard.CURRENT_PARTICIPANTS)
    def is_TOTAL_PARTICIPANTS(self) -> bool:
        return isinstance(self, TagStandard.TOTAL_PARTICIPANTS)
    def is_total_participants(self) -> bool:
        return isinstance(self, TagStandard.TOTAL_PARTICIPANTS)
    def is_ABSOLUTE_URL(self) -> bool:
        return isinstance(self, TagStandard.ABSOLUTE_URL)
    def is_absolute_url(self) -> bool:
        return isinstance(self, TagStandard.ABSOLUTE_URL)
    def is_METHOD(self) -> bool:
        return isinstance(self, TagStandard.METHOD)
    def is_method(self) -> bool:
        return isinstance(self, TagStandard.METHOD)
    def is_PAYLOAD(self) -> bool:
        return isinstance(self, TagStandard.PAYLOAD)
    def is_payload(self) -> bool:
        return isinstance(self, TagStandard.PAYLOAD)
    def is_ANON(self) -> bool:
        return isinstance(self, TagStandard.ANON)
    def is_anon(self) -> bool:
        return isinstance(self, TagStandard.ANON)
    def is_PROXY(self) -> bool:
        return isinstance(self, TagStandard.PROXY)
    def is_proxy(self) -> bool:
        return isinstance(self, TagStandard.PROXY)
    def is_EMOJI(self) -> bool:
        return isinstance(self, TagStandard.EMOJI)
    def is_emoji(self) -> bool:
        return isinstance(self, TagStandard.EMOJI)
    def is_ENCRYPTED(self) -> bool:
        return isinstance(self, TagStandard.ENCRYPTED)
    def is_encrypted(self) -> bool:
        return isinstance(self, TagStandard.ENCRYPTED)
    def is_REQUEST(self) -> bool:
        return isinstance(self, TagStandard.REQUEST)
    def is_request(self) -> bool:
        return isinstance(self, TagStandard.REQUEST)
    def is_DATA_VENDING_MACHINE_STATUS_TAG(self) -> bool:
        return isinstance(self, TagStandard.DATA_VENDING_MACHINE_STATUS_TAG)
    def is_data_vending_machine_status_tag(self) -> bool:
        return isinstance(self, TagStandard.DATA_VENDING_MACHINE_STATUS_TAG)
    def is_LABEL_NAMESPACE(self) -> bool:
        return isinstance(self, TagStandard.LABEL_NAMESPACE)
    def is_label_namespace(self) -> bool:
        return isinstance(self, TagStandard.LABEL_NAMESPACE)
    def is_LABEL(self) -> bool:
        return isinstance(self, TagStandard.LABEL)
    def is_label(self) -> bool:
        return isinstance(self, TagStandard.LABEL)
    def is_PROTECTED(self) -> bool:
        return isinstance(self, TagStandard.PROTECTED)
    def is_protected(self) -> bool:
        return isinstance(self, TagStandard.PROTECTED)
    def is_ALT(self) -> bool:
        return isinstance(self, TagStandard.ALT)
    def is_alt(self) -> bool:
        return isinstance(self, TagStandard.ALT)
    def is_WORD(self) -> bool:
        return isinstance(self, TagStandard.WORD)
    def is_word(self) -> bool:
        return isinstance(self, TagStandard.WORD)
    def is_WEB(self) -> bool:
        return isinstance(self, TagStandard.WEB)
    def is_web(self) -> bool:
        return isinstance(self, TagStandard.WEB)
    def is_DEPENDENCY(self) -> bool:
        return isinstance(self, TagStandard.DEPENDENCY)
    def is_dependency(self) -> bool:
        return isinstance(self, TagStandard.DEPENDENCY)
    def is_EXTENSION(self) -> bool:
        return isinstance(self, TagStandard.EXTENSION)
    def is_extension(self) -> bool:
        return isinstance(self, TagStandard.EXTENSION)
    def is_LICENSE(self) -> bool:
        return isinstance(self, TagStandard.LICENSE)
    def is_license(self) -> bool:
        return isinstance(self, TagStandard.LICENSE)
    def is_RUNTIME(self) -> bool:
        return isinstance(self, TagStandard.RUNTIME)
    def is_runtime(self) -> bool:
        return isinstance(self, TagStandard.RUNTIME)
    def is_REPOSITORY(self) -> bool:
        return isinstance(self, TagStandard.REPOSITORY)
    def is_repository(self) -> bool:
        return isinstance(self, TagStandard.REPOSITORY)
    def is_NIP88_POLL_ENDS_AT(self) -> bool:
        return isinstance(self, TagStandard.NIP88_POLL_ENDS_AT)
    def is_nip88_poll_ends_at(self) -> bool:
        return isinstance(self, TagStandard.NIP88_POLL_ENDS_AT)
    def is_NIP88_POLL_OPTION(self) -> bool:
        return isinstance(self, TagStandard.NIP88_POLL_OPTION)
    def is_nip88_poll_option(self) -> bool:
        return isinstance(self, TagStandard.NIP88_POLL_OPTION)
    def is_NIP88_POLL_RESPONSE(self) -> bool:
        return isinstance(self, TagStandard.NIP88_POLL_RESPONSE)
    def is_nip88_poll_response(self) -> bool:
        return isinstance(self, TagStandard.NIP88_POLL_RESPONSE)
    def is_NIP88_POLL_TYPE(self) -> bool:
        return isinstance(self, TagStandard.NIP88_POLL_TYPE)
    def is_nip88_poll_type(self) -> bool:
        return isinstance(self, TagStandard.NIP88_POLL_TYPE)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
TagStandard.EVENT_TAG = type("TagStandard.EVENT_TAG", (TagStandard.EVENT_TAG, TagStandard,), {})  # type: ignore
TagStandard.QUOTE = type("TagStandard.QUOTE", (TagStandard.QUOTE, TagStandard,), {})  # type: ignore
TagStandard.QUOTE_ADDRESS = type("TagStandard.QUOTE_ADDRESS", (TagStandard.QUOTE_ADDRESS, TagStandard,), {})  # type: ignore
TagStandard.GIT_CLONE = type("TagStandard.GIT_CLONE", (TagStandard.GIT_CLONE, TagStandard,), {})  # type: ignore
TagStandard.GIT_COMMIT = type("TagStandard.GIT_COMMIT", (TagStandard.GIT_COMMIT, TagStandard,), {})  # type: ignore
TagStandard.GIT_EARLIEST_UNIQUE_COMMIT_ID = type("TagStandard.GIT_EARLIEST_UNIQUE_COMMIT_ID", (TagStandard.GIT_EARLIEST_UNIQUE_COMMIT_ID, TagStandard,), {})  # type: ignore
TagStandard.GIT_MAINTAINERS = type("TagStandard.GIT_MAINTAINERS", (TagStandard.GIT_MAINTAINERS, TagStandard,), {})  # type: ignore
TagStandard.GIT_HEAD = type("TagStandard.GIT_HEAD", (TagStandard.GIT_HEAD, TagStandard,), {})  # type: ignore
TagStandard.PUBLIC_KEY_TAG = type("TagStandard.PUBLIC_KEY_TAG", (TagStandard.PUBLIC_KEY_TAG, TagStandard,), {})  # type: ignore
TagStandard.EVENT_REPORT = type("TagStandard.EVENT_REPORT", (TagStandard.EVENT_REPORT, TagStandard,), {})  # type: ignore
TagStandard.PUB_KEY_REPORT = type("TagStandard.PUB_KEY_REPORT", (TagStandard.PUB_KEY_REPORT, TagStandard,), {})  # type: ignore
TagStandard.PUBLIC_KEY_LIVE_EVENT = type("TagStandard.PUBLIC_KEY_LIVE_EVENT", (TagStandard.PUBLIC_KEY_LIVE_EVENT, TagStandard,), {})  # type: ignore
TagStandard.REFERENCE = type("TagStandard.REFERENCE", (TagStandard.REFERENCE, TagStandard,), {})  # type: ignore
TagStandard.RELAY_METADATA_TAG = type("TagStandard.RELAY_METADATA_TAG", (TagStandard.RELAY_METADATA_TAG, TagStandard,), {})  # type: ignore
TagStandard.HASHTAG = type("TagStandard.HASHTAG", (TagStandard.HASHTAG, TagStandard,), {})  # type: ignore
TagStandard.GEOHASH = type("TagStandard.GEOHASH", (TagStandard.GEOHASH, TagStandard,), {})  # type: ignore
TagStandard.IDENTIFIER = type("TagStandard.IDENTIFIER", (TagStandard.IDENTIFIER, TagStandard,), {})  # type: ignore
TagStandard.EXTERNAL_CONTENT = type("TagStandard.EXTERNAL_CONTENT", (TagStandard.EXTERNAL_CONTENT, TagStandard,), {})  # type: ignore
TagStandard.EXTERNAL_IDENTITY = type("TagStandard.EXTERNAL_IDENTITY", (TagStandard.EXTERNAL_IDENTITY, TagStandard,), {})  # type: ignore
TagStandard.COORDINATE_TAG = type("TagStandard.COORDINATE_TAG", (TagStandard.COORDINATE_TAG, TagStandard,), {})  # type: ignore
TagStandard.KIND_TAG = type("TagStandard.KIND_TAG", (TagStandard.KIND_TAG, TagStandard,), {})  # type: ignore
TagStandard.NIP73_KIND_TAG = type("TagStandard.NIP73_KIND_TAG", (TagStandard.NIP73_KIND_TAG, TagStandard,), {})  # type: ignore
TagStandard.RELAY = type("TagStandard.RELAY", (TagStandard.RELAY, TagStandard,), {})  # type: ignore
TagStandard.ALL_RELAYS = type("TagStandard.ALL_RELAYS", (TagStandard.ALL_RELAYS, TagStandard,), {})  # type: ignore
TagStandard.POW = type("TagStandard.POW", (TagStandard.POW, TagStandard,), {})  # type: ignore
TagStandard.CLIENT = type("TagStandard.CLIENT", (TagStandard.CLIENT, TagStandard,), {})  # type: ignore
TagStandard.CONTENT_WARNING = type("TagStandard.CONTENT_WARNING", (TagStandard.CONTENT_WARNING, TagStandard,), {})  # type: ignore
TagStandard.EXPIRATION = type("TagStandard.EXPIRATION", (TagStandard.EXPIRATION, TagStandard,), {})  # type: ignore
TagStandard.SUBJECT = type("TagStandard.SUBJECT", (TagStandard.SUBJECT, TagStandard,), {})  # type: ignore
TagStandard.CHALLENGE = type("TagStandard.CHALLENGE", (TagStandard.CHALLENGE, TagStandard,), {})  # type: ignore
TagStandard.TITLE = type("TagStandard.TITLE", (TagStandard.TITLE, TagStandard,), {})  # type: ignore
TagStandard.IMAGE = type("TagStandard.IMAGE", (TagStandard.IMAGE, TagStandard,), {})  # type: ignore
TagStandard.THUMB = type("TagStandard.THUMB", (TagStandard.THUMB, TagStandard,), {})  # type: ignore
TagStandard.SUMMARY = type("TagStandard.SUMMARY", (TagStandard.SUMMARY, TagStandard,), {})  # type: ignore
TagStandard.DESCRIPTION = type("TagStandard.DESCRIPTION", (TagStandard.DESCRIPTION, TagStandard,), {})  # type: ignore
TagStandard.BOLT11 = type("TagStandard.BOLT11", (TagStandard.BOLT11, TagStandard,), {})  # type: ignore
TagStandard.PREIMAGE = type("TagStandard.PREIMAGE", (TagStandard.PREIMAGE, TagStandard,), {})  # type: ignore
TagStandard.RELAYS = type("TagStandard.RELAYS", (TagStandard.RELAYS, TagStandard,), {})  # type: ignore
TagStandard.AMOUNT = type("TagStandard.AMOUNT", (TagStandard.AMOUNT, TagStandard,), {})  # type: ignore
TagStandard.LNURL = type("TagStandard.LNURL", (TagStandard.LNURL, TagStandard,), {})  # type: ignore
TagStandard.NAME = type("TagStandard.NAME", (TagStandard.NAME, TagStandard,), {})  # type: ignore
TagStandard.PUBLISHED_AT = type("TagStandard.PUBLISHED_AT", (TagStandard.PUBLISHED_AT, TagStandard,), {})  # type: ignore
TagStandard.URL_TAG = type("TagStandard.URL_TAG", (TagStandard.URL_TAG, TagStandard,), {})  # type: ignore
TagStandard.MIME_TYPE = type("TagStandard.MIME_TYPE", (TagStandard.MIME_TYPE, TagStandard,), {})  # type: ignore
TagStandard.AES256_GCM = type("TagStandard.AES256_GCM", (TagStandard.AES256_GCM, TagStandard,), {})  # type: ignore
TagStandard.SERVER = type("TagStandard.SERVER", (TagStandard.SERVER, TagStandard,), {})  # type: ignore
TagStandard.SHA256 = type("TagStandard.SHA256", (TagStandard.SHA256, TagStandard,), {})  # type: ignore
TagStandard.SIZE = type("TagStandard.SIZE", (TagStandard.SIZE, TagStandard,), {})  # type: ignore
TagStandard.DIM = type("TagStandard.DIM", (TagStandard.DIM, TagStandard,), {})  # type: ignore
TagStandard.MAGNET = type("TagStandard.MAGNET", (TagStandard.MAGNET, TagStandard,), {})  # type: ignore
TagStandard.BLURHASH = type("TagStandard.BLURHASH", (TagStandard.BLURHASH, TagStandard,), {})  # type: ignore
TagStandard.STREAMING = type("TagStandard.STREAMING", (TagStandard.STREAMING, TagStandard,), {})  # type: ignore
TagStandard.RECORDING = type("TagStandard.RECORDING", (TagStandard.RECORDING, TagStandard,), {})  # type: ignore
TagStandard.STARTS = type("TagStandard.STARTS", (TagStandard.STARTS, TagStandard,), {})  # type: ignore
TagStandard.ENDS = type("TagStandard.ENDS", (TagStandard.ENDS, TagStandard,), {})  # type: ignore
TagStandard.LIVE_EVENT_STATUS_TAG = type("TagStandard.LIVE_EVENT_STATUS_TAG", (TagStandard.LIVE_EVENT_STATUS_TAG, TagStandard,), {})  # type: ignore
TagStandard.CURRENT_PARTICIPANTS = type("TagStandard.CURRENT_PARTICIPANTS", (TagStandard.CURRENT_PARTICIPANTS, TagStandard,), {})  # type: ignore
TagStandard.TOTAL_PARTICIPANTS = type("TagStandard.TOTAL_PARTICIPANTS", (TagStandard.TOTAL_PARTICIPANTS, TagStandard,), {})  # type: ignore
TagStandard.ABSOLUTE_URL = type("TagStandard.ABSOLUTE_URL", (TagStandard.ABSOLUTE_URL, TagStandard,), {})  # type: ignore
TagStandard.METHOD = type("TagStandard.METHOD", (TagStandard.METHOD, TagStandard,), {})  # type: ignore
TagStandard.PAYLOAD = type("TagStandard.PAYLOAD", (TagStandard.PAYLOAD, TagStandard,), {})  # type: ignore
TagStandard.ANON = type("TagStandard.ANON", (TagStandard.ANON, TagStandard,), {})  # type: ignore
TagStandard.PROXY = type("TagStandard.PROXY", (TagStandard.PROXY, TagStandard,), {})  # type: ignore
TagStandard.EMOJI = type("TagStandard.EMOJI", (TagStandard.EMOJI, TagStandard,), {})  # type: ignore
TagStandard.ENCRYPTED = type("TagStandard.ENCRYPTED", (TagStandard.ENCRYPTED, TagStandard,), {})  # type: ignore
TagStandard.REQUEST = type("TagStandard.REQUEST", (TagStandard.REQUEST, TagStandard,), {})  # type: ignore
TagStandard.DATA_VENDING_MACHINE_STATUS_TAG = type("TagStandard.DATA_VENDING_MACHINE_STATUS_TAG", (TagStandard.DATA_VENDING_MACHINE_STATUS_TAG, TagStandard,), {})  # type: ignore
TagStandard.LABEL_NAMESPACE = type("TagStandard.LABEL_NAMESPACE", (TagStandard.LABEL_NAMESPACE, TagStandard,), {})  # type: ignore
TagStandard.LABEL = type("TagStandard.LABEL", (TagStandard.LABEL, TagStandard,), {})  # type: ignore
TagStandard.PROTECTED = type("TagStandard.PROTECTED", (TagStandard.PROTECTED, TagStandard,), {})  # type: ignore
TagStandard.ALT = type("TagStandard.ALT", (TagStandard.ALT, TagStandard,), {})  # type: ignore
TagStandard.WORD = type("TagStandard.WORD", (TagStandard.WORD, TagStandard,), {})  # type: ignore
TagStandard.WEB = type("TagStandard.WEB", (TagStandard.WEB, TagStandard,), {})  # type: ignore
TagStandard.DEPENDENCY = type("TagStandard.DEPENDENCY", (TagStandard.DEPENDENCY, TagStandard,), {})  # type: ignore
TagStandard.EXTENSION = type("TagStandard.EXTENSION", (TagStandard.EXTENSION, TagStandard,), {})  # type: ignore
TagStandard.LICENSE = type("TagStandard.LICENSE", (TagStandard.LICENSE, TagStandard,), {})  # type: ignore
TagStandard.RUNTIME = type("TagStandard.RUNTIME", (TagStandard.RUNTIME, TagStandard,), {})  # type: ignore
TagStandard.REPOSITORY = type("TagStandard.REPOSITORY", (TagStandard.REPOSITORY, TagStandard,), {})  # type: ignore
TagStandard.NIP88_POLL_ENDS_AT = type("TagStandard.NIP88_POLL_ENDS_AT", (TagStandard.NIP88_POLL_ENDS_AT, TagStandard,), {})  # type: ignore
TagStandard.NIP88_POLL_OPTION = type("TagStandard.NIP88_POLL_OPTION", (TagStandard.NIP88_POLL_OPTION, TagStandard,), {})  # type: ignore
TagStandard.NIP88_POLL_RESPONSE = type("TagStandard.NIP88_POLL_RESPONSE", (TagStandard.NIP88_POLL_RESPONSE, TagStandard,), {})  # type: ignore
TagStandard.NIP88_POLL_TYPE = type("TagStandard.NIP88_POLL_TYPE", (TagStandard.NIP88_POLL_TYPE, TagStandard,), {})  # type: ignore




class _UniffiConverterTypeTagStandard(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return TagStandard.EVENT_TAG(
                _UniffiConverterTypeEventId.read(buf),
                _UniffiConverterOptionalTypeRelayUrl.read(buf),
                _UniffiConverterOptionalTypeMarker.read(buf),
                _UniffiConverterOptionalTypePublicKey.read(buf),
                _UniffiConverterBool.read(buf),
            )
        if variant == 2:
            return TagStandard.QUOTE(
                _UniffiConverterTypeEventId.read(buf),
                _UniffiConverterOptionalTypeRelayUrl.read(buf),
                _UniffiConverterOptionalTypePublicKey.read(buf),
            )
        if variant == 3:
            return TagStandard.QUOTE_ADDRESS(
                _UniffiConverterTypeCoordinate.read(buf),
                _UniffiConverterOptionalTypeRelayUrl.read(buf),
            )
        if variant == 4:
            return TagStandard.GIT_CLONE(
                _UniffiConverterSequenceString.read(buf),
            )
        if variant == 5:
            return TagStandard.GIT_COMMIT(
                _UniffiConverterString.read(buf),
            )
        if variant == 6:
            return TagStandard.GIT_EARLIEST_UNIQUE_COMMIT_ID(
                _UniffiConverterString.read(buf),
            )
        if variant == 7:
            return TagStandard.GIT_MAINTAINERS(
                _UniffiConverterSequenceTypePublicKey.read(buf),
            )
        if variant == 8:
            return TagStandard.GIT_HEAD(
                _UniffiConverterString.read(buf),
            )
        if variant == 9:
            return TagStandard.PUBLIC_KEY_TAG(
                _UniffiConverterTypePublicKey.read(buf),
                _UniffiConverterOptionalTypeRelayUrl.read(buf),
                _UniffiConverterOptionalString.read(buf),
                _UniffiConverterBool.read(buf),
            )
        if variant == 10:
            return TagStandard.EVENT_REPORT(
                _UniffiConverterTypeEventId.read(buf),
                _UniffiConverterTypeReport.read(buf),
            )
        if variant == 11:
            return TagStandard.PUB_KEY_REPORT(
                _UniffiConverterTypePublicKey.read(buf),
                _UniffiConverterTypeReport.read(buf),
            )
        if variant == 12:
            return TagStandard.PUBLIC_KEY_LIVE_EVENT(
                _UniffiConverterTypePublicKey.read(buf),
                _UniffiConverterOptionalTypeRelayUrl.read(buf),
                _UniffiConverterTypeLiveEventMarker.read(buf),
                _UniffiConverterOptionalString.read(buf),
            )
        if variant == 13:
            return TagStandard.REFERENCE(
                _UniffiConverterString.read(buf),
            )
        if variant == 14:
            return TagStandard.RELAY_METADATA_TAG(
                _UniffiConverterTypeRelayUrl.read(buf),
                _UniffiConverterOptionalTypeRelayMetadata.read(buf),
            )
        if variant == 15:
            return TagStandard.HASHTAG(
                _UniffiConverterString.read(buf),
            )
        if variant == 16:
            return TagStandard.GEOHASH(
                _UniffiConverterString.read(buf),
            )
        if variant == 17:
            return TagStandard.IDENTIFIER(
                _UniffiConverterString.read(buf),
            )
        if variant == 18:
            return TagStandard.EXTERNAL_CONTENT(
                _UniffiConverterTypeExternalContentId.read(buf),
                _UniffiConverterOptionalString.read(buf),
                _UniffiConverterBool.read(buf),
            )
        if variant == 19:
            return TagStandard.EXTERNAL_IDENTITY(
                _UniffiConverterTypeIdentity.read(buf),
            )
        if variant == 20:
            return TagStandard.COORDINATE_TAG(
                _UniffiConverterTypeCoordinate.read(buf),
                _UniffiConverterOptionalTypeRelayUrl.read(buf),
                _UniffiConverterBool.read(buf),
            )
        if variant == 21:
            return TagStandard.KIND_TAG(
                _UniffiConverterTypeKind.read(buf),
                _UniffiConverterBool.read(buf),
            )
        if variant == 22:
            return TagStandard.NIP73_KIND_TAG(
                _UniffiConverterTypeNip73Kind.read(buf),
                _UniffiConverterBool.read(buf),
            )
        if variant == 23:
            return TagStandard.RELAY(
                _UniffiConverterTypeRelayUrl.read(buf),
            )
        if variant == 24:
            return TagStandard.ALL_RELAYS(
            )
        if variant == 25:
            return TagStandard.POW(
                _UniffiConverterString.read(buf),
                _UniffiConverterUInt8.read(buf),
            )
        if variant == 26:
            return TagStandard.CLIENT(
                _UniffiConverterString.read(buf),
                _UniffiConverterOptionalTypeTagClientAddress.read(buf),
            )
        if variant == 27:
            return TagStandard.CONTENT_WARNING(
                _UniffiConverterOptionalString.read(buf),
            )
        if variant == 28:
            return TagStandard.EXPIRATION(
                _UniffiConverterTypeTimestamp.read(buf),
            )
        if variant == 29:
            return TagStandard.SUBJECT(
                _UniffiConverterString.read(buf),
            )
        if variant == 30:
            return TagStandard.CHALLENGE(
                _UniffiConverterString.read(buf),
            )
        if variant == 31:
            return TagStandard.TITLE(
                _UniffiConverterString.read(buf),
            )
        if variant == 32:
            return TagStandard.IMAGE(
                _UniffiConverterString.read(buf),
                _UniffiConverterOptionalTypeImageDimensions.read(buf),
            )
        if variant == 33:
            return TagStandard.THUMB(
                _UniffiConverterString.read(buf),
                _UniffiConverterOptionalTypeImageDimensions.read(buf),
            )
        if variant == 34:
            return TagStandard.SUMMARY(
                _UniffiConverterString.read(buf),
            )
        if variant == 35:
            return TagStandard.DESCRIPTION(
                _UniffiConverterString.read(buf),
            )
        if variant == 36:
            return TagStandard.BOLT11(
                _UniffiConverterString.read(buf),
            )
        if variant == 37:
            return TagStandard.PREIMAGE(
                _UniffiConverterString.read(buf),
            )
        if variant == 38:
            return TagStandard.RELAYS(
                _UniffiConverterSequenceTypeRelayUrl.read(buf),
            )
        if variant == 39:
            return TagStandard.AMOUNT(
                _UniffiConverterUInt64.read(buf),
                _UniffiConverterOptionalString.read(buf),
            )
        if variant == 40:
            return TagStandard.LNURL(
                _UniffiConverterString.read(buf),
            )
        if variant == 41:
            return TagStandard.NAME(
                _UniffiConverterString.read(buf),
            )
        if variant == 42:
            return TagStandard.PUBLISHED_AT(
                _UniffiConverterTypeTimestamp.read(buf),
            )
        if variant == 43:
            return TagStandard.URL_TAG(
                _UniffiConverterString.read(buf),
            )
        if variant == 44:
            return TagStandard.MIME_TYPE(
                _UniffiConverterString.read(buf),
            )
        if variant == 45:
            return TagStandard.AES256_GCM(
                _UniffiConverterString.read(buf),
                _UniffiConverterString.read(buf),
            )
        if variant == 46:
            return TagStandard.SERVER(
                _UniffiConverterString.read(buf),
            )
        if variant == 47:
            return TagStandard.SHA256(
                _UniffiConverterString.read(buf),
            )
        if variant == 48:
            return TagStandard.SIZE(
                _UniffiConverterUInt64.read(buf),
            )
        if variant == 49:
            return TagStandard.DIM(
                _UniffiConverterTypeImageDimensions.read(buf),
            )
        if variant == 50:
            return TagStandard.MAGNET(
                _UniffiConverterString.read(buf),
            )
        if variant == 51:
            return TagStandard.BLURHASH(
                _UniffiConverterString.read(buf),
            )
        if variant == 52:
            return TagStandard.STREAMING(
                _UniffiConverterString.read(buf),
            )
        if variant == 53:
            return TagStandard.RECORDING(
                _UniffiConverterString.read(buf),
            )
        if variant == 54:
            return TagStandard.STARTS(
                _UniffiConverterTypeTimestamp.read(buf),
            )
        if variant == 55:
            return TagStandard.ENDS(
                _UniffiConverterTypeTimestamp.read(buf),
            )
        if variant == 56:
            return TagStandard.LIVE_EVENT_STATUS_TAG(
                _UniffiConverterTypeLiveEventStatus.read(buf),
            )
        if variant == 57:
            return TagStandard.CURRENT_PARTICIPANTS(
                _UniffiConverterUInt64.read(buf),
            )
        if variant == 58:
            return TagStandard.TOTAL_PARTICIPANTS(
                _UniffiConverterUInt64.read(buf),
            )
        if variant == 59:
            return TagStandard.ABSOLUTE_URL(
                _UniffiConverterString.read(buf),
            )
        if variant == 60:
            return TagStandard.METHOD(
                _UniffiConverterTypeHttpMethod.read(buf),
            )
        if variant == 61:
            return TagStandard.PAYLOAD(
                _UniffiConverterString.read(buf),
            )
        if variant == 62:
            return TagStandard.ANON(
                _UniffiConverterOptionalString.read(buf),
            )
        if variant == 63:
            return TagStandard.PROXY(
                _UniffiConverterString.read(buf),
                _UniffiConverterTypeProtocol.read(buf),
            )
        if variant == 64:
            return TagStandard.EMOJI(
                _UniffiConverterString.read(buf),
                _UniffiConverterString.read(buf),
            )
        if variant == 65:
            return TagStandard.ENCRYPTED(
            )
        if variant == 66:
            return TagStandard.REQUEST(
                _UniffiConverterTypeEvent.read(buf),
            )
        if variant == 67:
            return TagStandard.DATA_VENDING_MACHINE_STATUS_TAG(
                _UniffiConverterTypeDataVendingMachineStatus.read(buf),
                _UniffiConverterOptionalString.read(buf),
            )
        if variant == 68:
            return TagStandard.LABEL_NAMESPACE(
                _UniffiConverterString.read(buf),
            )
        if variant == 69:
            return TagStandard.LABEL(
                _UniffiConverterString.read(buf),
                _UniffiConverterOptionalString.read(buf),
            )
        if variant == 70:
            return TagStandard.PROTECTED(
            )
        if variant == 71:
            return TagStandard.ALT(
                _UniffiConverterString.read(buf),
            )
        if variant == 72:
            return TagStandard.WORD(
                _UniffiConverterString.read(buf),
            )
        if variant == 73:
            return TagStandard.WEB(
                _UniffiConverterSequenceString.read(buf),
            )
        if variant == 74:
            return TagStandard.DEPENDENCY(
                _UniffiConverterString.read(buf),
            )
        if variant == 75:
            return TagStandard.EXTENSION(
                _UniffiConverterString.read(buf),
            )
        if variant == 76:
            return TagStandard.LICENSE(
                _UniffiConverterString.read(buf),
            )
        if variant == 77:
            return TagStandard.RUNTIME(
                _UniffiConverterString.read(buf),
            )
        if variant == 78:
            return TagStandard.REPOSITORY(
                _UniffiConverterString.read(buf),
            )
        if variant == 79:
            return TagStandard.NIP88_POLL_ENDS_AT(
                _UniffiConverterTypeTimestamp.read(buf),
            )
        if variant == 80:
            return TagStandard.NIP88_POLL_OPTION(
                _UniffiConverterTypePollOption.read(buf),
            )
        if variant == 81:
            return TagStandard.NIP88_POLL_RESPONSE(
                _UniffiConverterString.read(buf),
            )
        if variant == 82:
            return TagStandard.NIP88_POLL_TYPE(
                _UniffiConverterTypePollType.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value.is_EVENT_TAG():
            _UniffiConverterTypeEventId.check_lower(value.event_id)
            _UniffiConverterOptionalTypeRelayUrl.check_lower(value.relay_url)
            _UniffiConverterOptionalTypeMarker.check_lower(value.marker)
            _UniffiConverterOptionalTypePublicKey.check_lower(value.public_key)
            _UniffiConverterBool.check_lower(value.uppercase)
            return
        if value.is_QUOTE():
            _UniffiConverterTypeEventId.check_lower(value.event_id)
            _UniffiConverterOptionalTypeRelayUrl.check_lower(value.relay_url)
            _UniffiConverterOptionalTypePublicKey.check_lower(value.public_key)
            return
        if value.is_QUOTE_ADDRESS():
            _UniffiConverterTypeCoordinate.check_lower(value.coordinate)
            _UniffiConverterOptionalTypeRelayUrl.check_lower(value.relay_url)
            return
        if value.is_GIT_CLONE():
            _UniffiConverterSequenceString.check_lower(value.urls)
            return
        if value.is_GIT_COMMIT():
            _UniffiConverterString.check_lower(value.hash)
            return
        if value.is_GIT_EARLIEST_UNIQUE_COMMIT_ID():
            _UniffiConverterString.check_lower(value.commit)
            return
        if value.is_GIT_MAINTAINERS():
            _UniffiConverterSequenceTypePublicKey.check_lower(value.public_keys)
            return
        if value.is_GIT_HEAD():
            _UniffiConverterString.check_lower(value.head)
            return
        if value.is_PUBLIC_KEY_TAG():
            _UniffiConverterTypePublicKey.check_lower(value.public_key)
            _UniffiConverterOptionalTypeRelayUrl.check_lower(value.relay_url)
            _UniffiConverterOptionalString.check_lower(value.alias)
            _UniffiConverterBool.check_lower(value.uppercase)
            return
        if value.is_EVENT_REPORT():
            _UniffiConverterTypeEventId.check_lower(value.event_id)
            _UniffiConverterTypeReport.check_lower(value.report)
            return
        if value.is_PUB_KEY_REPORT():
            _UniffiConverterTypePublicKey.check_lower(value.public_key)
            _UniffiConverterTypeReport.check_lower(value.report)
            return
        if value.is_PUBLIC_KEY_LIVE_EVENT():
            _UniffiConverterTypePublicKey.check_lower(value.public_key)
            _UniffiConverterOptionalTypeRelayUrl.check_lower(value.relay_url)
            _UniffiConverterTypeLiveEventMarker.check_lower(value.marker)
            _UniffiConverterOptionalString.check_lower(value.proof)
            return
        if value.is_REFERENCE():
            _UniffiConverterString.check_lower(value.reference)
            return
        if value.is_RELAY_METADATA_TAG():
            _UniffiConverterTypeRelayUrl.check_lower(value.relay_url)
            _UniffiConverterOptionalTypeRelayMetadata.check_lower(value.rw)
            return
        if value.is_HASHTAG():
            _UniffiConverterString.check_lower(value.hashtag)
            return
        if value.is_GEOHASH():
            _UniffiConverterString.check_lower(value.geohash)
            return
        if value.is_IDENTIFIER():
            _UniffiConverterString.check_lower(value.identifier)
            return
        if value.is_EXTERNAL_CONTENT():
            _UniffiConverterTypeExternalContentId.check_lower(value.content)
            _UniffiConverterOptionalString.check_lower(value.hint)
            _UniffiConverterBool.check_lower(value.uppercase)
            return
        if value.is_EXTERNAL_IDENTITY():
            _UniffiConverterTypeIdentity.check_lower(value.identity)
            return
        if value.is_COORDINATE_TAG():
            _UniffiConverterTypeCoordinate.check_lower(value.coordinate)
            _UniffiConverterOptionalTypeRelayUrl.check_lower(value.relay_url)
            _UniffiConverterBool.check_lower(value.uppercase)
            return
        if value.is_KIND_TAG():
            _UniffiConverterTypeKind.check_lower(value.kind)
            _UniffiConverterBool.check_lower(value.uppercase)
            return
        if value.is_NIP73_KIND_TAG():
            _UniffiConverterTypeNip73Kind.check_lower(value.kind)
            _UniffiConverterBool.check_lower(value.uppercase)
            return
        if value.is_RELAY():
            _UniffiConverterTypeRelayUrl.check_lower(value.url)
            return
        if value.is_ALL_RELAYS():
            return
        if value.is_POW():
            _UniffiConverterString.check_lower(value.nonce)
            _UniffiConverterUInt8.check_lower(value.difficulty)
            return
        if value.is_CLIENT():
            _UniffiConverterString.check_lower(value.name)
            _UniffiConverterOptionalTypeTagClientAddress.check_lower(value.address)
            return
        if value.is_CONTENT_WARNING():
            _UniffiConverterOptionalString.check_lower(value.reason)
            return
        if value.is_EXPIRATION():
            _UniffiConverterTypeTimestamp.check_lower(value.timestamp)
            return
        if value.is_SUBJECT():
            _UniffiConverterString.check_lower(value.subject)
            return
        if value.is_CHALLENGE():
            _UniffiConverterString.check_lower(value.challenge)
            return
        if value.is_TITLE():
            _UniffiConverterString.check_lower(value.title)
            return
        if value.is_IMAGE():
            _UniffiConverterString.check_lower(value.url)
            _UniffiConverterOptionalTypeImageDimensions.check_lower(value.dimensions)
            return
        if value.is_THUMB():
            _UniffiConverterString.check_lower(value.url)
            _UniffiConverterOptionalTypeImageDimensions.check_lower(value.dimensions)
            return
        if value.is_SUMMARY():
            _UniffiConverterString.check_lower(value.summary)
            return
        if value.is_DESCRIPTION():
            _UniffiConverterString.check_lower(value.desc)
            return
        if value.is_BOLT11():
            _UniffiConverterString.check_lower(value.bolt11)
            return
        if value.is_PREIMAGE():
            _UniffiConverterString.check_lower(value.preimage)
            return
        if value.is_RELAYS():
            _UniffiConverterSequenceTypeRelayUrl.check_lower(value.urls)
            return
        if value.is_AMOUNT():
            _UniffiConverterUInt64.check_lower(value.millisats)
            _UniffiConverterOptionalString.check_lower(value.bolt11)
            return
        if value.is_LNURL():
            _UniffiConverterString.check_lower(value.lnurl)
            return
        if value.is_NAME():
            _UniffiConverterString.check_lower(value.name)
            return
        if value.is_PUBLISHED_AT():
            _UniffiConverterTypeTimestamp.check_lower(value.timestamp)
            return
        if value.is_URL_TAG():
            _UniffiConverterString.check_lower(value.url)
            return
        if value.is_MIME_TYPE():
            _UniffiConverterString.check_lower(value.mime)
            return
        if value.is_AES256_GCM():
            _UniffiConverterString.check_lower(value.key)
            _UniffiConverterString.check_lower(value.iv)
            return
        if value.is_SERVER():
            _UniffiConverterString.check_lower(value.url)
            return
        if value.is_SHA256():
            _UniffiConverterString.check_lower(value.hash)
            return
        if value.is_SIZE():
            _UniffiConverterUInt64.check_lower(value.size)
            return
        if value.is_DIM():
            _UniffiConverterTypeImageDimensions.check_lower(value.dimensions)
            return
        if value.is_MAGNET():
            _UniffiConverterString.check_lower(value.uri)
            return
        if value.is_BLURHASH():
            _UniffiConverterString.check_lower(value.blurhash)
            return
        if value.is_STREAMING():
            _UniffiConverterString.check_lower(value.url)
            return
        if value.is_RECORDING():
            _UniffiConverterString.check_lower(value.url)
            return
        if value.is_STARTS():
            _UniffiConverterTypeTimestamp.check_lower(value.timestamp)
            return
        if value.is_ENDS():
            _UniffiConverterTypeTimestamp.check_lower(value.timestamp)
            return
        if value.is_LIVE_EVENT_STATUS_TAG():
            _UniffiConverterTypeLiveEventStatus.check_lower(value.status)
            return
        if value.is_CURRENT_PARTICIPANTS():
            _UniffiConverterUInt64.check_lower(value.num)
            return
        if value.is_TOTAL_PARTICIPANTS():
            _UniffiConverterUInt64.check_lower(value.num)
            return
        if value.is_ABSOLUTE_URL():
            _UniffiConverterString.check_lower(value.url)
            return
        if value.is_METHOD():
            _UniffiConverterTypeHttpMethod.check_lower(value.method)
            return
        if value.is_PAYLOAD():
            _UniffiConverterString.check_lower(value.hash)
            return
        if value.is_ANON():
            _UniffiConverterOptionalString.check_lower(value.msg)
            return
        if value.is_PROXY():
            _UniffiConverterString.check_lower(value.id)
            _UniffiConverterTypeProtocol.check_lower(value.protocol)
            return
        if value.is_EMOJI():
            _UniffiConverterString.check_lower(value.shortcode)
            _UniffiConverterString.check_lower(value.url)
            return
        if value.is_ENCRYPTED():
            return
        if value.is_REQUEST():
            _UniffiConverterTypeEvent.check_lower(value.event)
            return
        if value.is_DATA_VENDING_MACHINE_STATUS_TAG():
            _UniffiConverterTypeDataVendingMachineStatus.check_lower(value.status)
            _UniffiConverterOptionalString.check_lower(value.extra_info)
            return
        if value.is_LABEL_NAMESPACE():
            _UniffiConverterString.check_lower(value.namespace)
            return
        if value.is_LABEL():
            _UniffiConverterString.check_lower(value.value)
            _UniffiConverterOptionalString.check_lower(value.namespace)
            return
        if value.is_PROTECTED():
            return
        if value.is_ALT():
            _UniffiConverterString.check_lower(value.summary)
            return
        if value.is_WORD():
            _UniffiConverterString.check_lower(value.word)
            return
        if value.is_WEB():
            _UniffiConverterSequenceString.check_lower(value.urls)
            return
        if value.is_DEPENDENCY():
            _UniffiConverterString.check_lower(value.dep)
            return
        if value.is_EXTENSION():
            _UniffiConverterString.check_lower(value.ext)
            return
        if value.is_LICENSE():
            _UniffiConverterString.check_lower(value.license)
            return
        if value.is_RUNTIME():
            _UniffiConverterString.check_lower(value.runtime)
            return
        if value.is_REPOSITORY():
            _UniffiConverterString.check_lower(value.url)
            return
        if value.is_NIP88_POLL_ENDS_AT():
            _UniffiConverterTypeTimestamp.check_lower(value.timestamp)
            return
        if value.is_NIP88_POLL_OPTION():
            _UniffiConverterTypePollOption.check_lower(value.option)
            return
        if value.is_NIP88_POLL_RESPONSE():
            _UniffiConverterString.check_lower(value.response)
            return
        if value.is_NIP88_POLL_TYPE():
            _UniffiConverterTypePollType.check_lower(value.poll_type)
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value.is_EVENT_TAG():
            buf.write_i32(1)
            _UniffiConverterTypeEventId.write(value.event_id, buf)
            _UniffiConverterOptionalTypeRelayUrl.write(value.relay_url, buf)
            _UniffiConverterOptionalTypeMarker.write(value.marker, buf)
            _UniffiConverterOptionalTypePublicKey.write(value.public_key, buf)
            _UniffiConverterBool.write(value.uppercase, buf)
        if value.is_QUOTE():
            buf.write_i32(2)
            _UniffiConverterTypeEventId.write(value.event_id, buf)
            _UniffiConverterOptionalTypeRelayUrl.write(value.relay_url, buf)
            _UniffiConverterOptionalTypePublicKey.write(value.public_key, buf)
        if value.is_QUOTE_ADDRESS():
            buf.write_i32(3)
            _UniffiConverterTypeCoordinate.write(value.coordinate, buf)
            _UniffiConverterOptionalTypeRelayUrl.write(value.relay_url, buf)
        if value.is_GIT_CLONE():
            buf.write_i32(4)
            _UniffiConverterSequenceString.write(value.urls, buf)
        if value.is_GIT_COMMIT():
            buf.write_i32(5)
            _UniffiConverterString.write(value.hash, buf)
        if value.is_GIT_EARLIEST_UNIQUE_COMMIT_ID():
            buf.write_i32(6)
            _UniffiConverterString.write(value.commit, buf)
        if value.is_GIT_MAINTAINERS():
            buf.write_i32(7)
            _UniffiConverterSequenceTypePublicKey.write(value.public_keys, buf)
        if value.is_GIT_HEAD():
            buf.write_i32(8)
            _UniffiConverterString.write(value.head, buf)
        if value.is_PUBLIC_KEY_TAG():
            buf.write_i32(9)
            _UniffiConverterTypePublicKey.write(value.public_key, buf)
            _UniffiConverterOptionalTypeRelayUrl.write(value.relay_url, buf)
            _UniffiConverterOptionalString.write(value.alias, buf)
            _UniffiConverterBool.write(value.uppercase, buf)
        if value.is_EVENT_REPORT():
            buf.write_i32(10)
            _UniffiConverterTypeEventId.write(value.event_id, buf)
            _UniffiConverterTypeReport.write(value.report, buf)
        if value.is_PUB_KEY_REPORT():
            buf.write_i32(11)
            _UniffiConverterTypePublicKey.write(value.public_key, buf)
            _UniffiConverterTypeReport.write(value.report, buf)
        if value.is_PUBLIC_KEY_LIVE_EVENT():
            buf.write_i32(12)
            _UniffiConverterTypePublicKey.write(value.public_key, buf)
            _UniffiConverterOptionalTypeRelayUrl.write(value.relay_url, buf)
            _UniffiConverterTypeLiveEventMarker.write(value.marker, buf)
            _UniffiConverterOptionalString.write(value.proof, buf)
        if value.is_REFERENCE():
            buf.write_i32(13)
            _UniffiConverterString.write(value.reference, buf)
        if value.is_RELAY_METADATA_TAG():
            buf.write_i32(14)
            _UniffiConverterTypeRelayUrl.write(value.relay_url, buf)
            _UniffiConverterOptionalTypeRelayMetadata.write(value.rw, buf)
        if value.is_HASHTAG():
            buf.write_i32(15)
            _UniffiConverterString.write(value.hashtag, buf)
        if value.is_GEOHASH():
            buf.write_i32(16)
            _UniffiConverterString.write(value.geohash, buf)
        if value.is_IDENTIFIER():
            buf.write_i32(17)
            _UniffiConverterString.write(value.identifier, buf)
        if value.is_EXTERNAL_CONTENT():
            buf.write_i32(18)
            _UniffiConverterTypeExternalContentId.write(value.content, buf)
            _UniffiConverterOptionalString.write(value.hint, buf)
            _UniffiConverterBool.write(value.uppercase, buf)
        if value.is_EXTERNAL_IDENTITY():
            buf.write_i32(19)
            _UniffiConverterTypeIdentity.write(value.identity, buf)
        if value.is_COORDINATE_TAG():
            buf.write_i32(20)
            _UniffiConverterTypeCoordinate.write(value.coordinate, buf)
            _UniffiConverterOptionalTypeRelayUrl.write(value.relay_url, buf)
            _UniffiConverterBool.write(value.uppercase, buf)
        if value.is_KIND_TAG():
            buf.write_i32(21)
            _UniffiConverterTypeKind.write(value.kind, buf)
            _UniffiConverterBool.write(value.uppercase, buf)
        if value.is_NIP73_KIND_TAG():
            buf.write_i32(22)
            _UniffiConverterTypeNip73Kind.write(value.kind, buf)
            _UniffiConverterBool.write(value.uppercase, buf)
        if value.is_RELAY():
            buf.write_i32(23)
            _UniffiConverterTypeRelayUrl.write(value.url, buf)
        if value.is_ALL_RELAYS():
            buf.write_i32(24)
        if value.is_POW():
            buf.write_i32(25)
            _UniffiConverterString.write(value.nonce, buf)
            _UniffiConverterUInt8.write(value.difficulty, buf)
        if value.is_CLIENT():
            buf.write_i32(26)
            _UniffiConverterString.write(value.name, buf)
            _UniffiConverterOptionalTypeTagClientAddress.write(value.address, buf)
        if value.is_CONTENT_WARNING():
            buf.write_i32(27)
            _UniffiConverterOptionalString.write(value.reason, buf)
        if value.is_EXPIRATION():
            buf.write_i32(28)
            _UniffiConverterTypeTimestamp.write(value.timestamp, buf)
        if value.is_SUBJECT():
            buf.write_i32(29)
            _UniffiConverterString.write(value.subject, buf)
        if value.is_CHALLENGE():
            buf.write_i32(30)
            _UniffiConverterString.write(value.challenge, buf)
        if value.is_TITLE():
            buf.write_i32(31)
            _UniffiConverterString.write(value.title, buf)
        if value.is_IMAGE():
            buf.write_i32(32)
            _UniffiConverterString.write(value.url, buf)
            _UniffiConverterOptionalTypeImageDimensions.write(value.dimensions, buf)
        if value.is_THUMB():
            buf.write_i32(33)
            _UniffiConverterString.write(value.url, buf)
            _UniffiConverterOptionalTypeImageDimensions.write(value.dimensions, buf)
        if value.is_SUMMARY():
            buf.write_i32(34)
            _UniffiConverterString.write(value.summary, buf)
        if value.is_DESCRIPTION():
            buf.write_i32(35)
            _UniffiConverterString.write(value.desc, buf)
        if value.is_BOLT11():
            buf.write_i32(36)
            _UniffiConverterString.write(value.bolt11, buf)
        if value.is_PREIMAGE():
            buf.write_i32(37)
            _UniffiConverterString.write(value.preimage, buf)
        if value.is_RELAYS():
            buf.write_i32(38)
            _UniffiConverterSequenceTypeRelayUrl.write(value.urls, buf)
        if value.is_AMOUNT():
            buf.write_i32(39)
            _UniffiConverterUInt64.write(value.millisats, buf)
            _UniffiConverterOptionalString.write(value.bolt11, buf)
        if value.is_LNURL():
            buf.write_i32(40)
            _UniffiConverterString.write(value.lnurl, buf)
        if value.is_NAME():
            buf.write_i32(41)
            _UniffiConverterString.write(value.name, buf)
        if value.is_PUBLISHED_AT():
            buf.write_i32(42)
            _UniffiConverterTypeTimestamp.write(value.timestamp, buf)
        if value.is_URL_TAG():
            buf.write_i32(43)
            _UniffiConverterString.write(value.url, buf)
        if value.is_MIME_TYPE():
            buf.write_i32(44)
            _UniffiConverterString.write(value.mime, buf)
        if value.is_AES256_GCM():
            buf.write_i32(45)
            _UniffiConverterString.write(value.key, buf)
            _UniffiConverterString.write(value.iv, buf)
        if value.is_SERVER():
            buf.write_i32(46)
            _UniffiConverterString.write(value.url, buf)
        if value.is_SHA256():
            buf.write_i32(47)
            _UniffiConverterString.write(value.hash, buf)
        if value.is_SIZE():
            buf.write_i32(48)
            _UniffiConverterUInt64.write(value.size, buf)
        if value.is_DIM():
            buf.write_i32(49)
            _UniffiConverterTypeImageDimensions.write(value.dimensions, buf)
        if value.is_MAGNET():
            buf.write_i32(50)
            _UniffiConverterString.write(value.uri, buf)
        if value.is_BLURHASH():
            buf.write_i32(51)
            _UniffiConverterString.write(value.blurhash, buf)
        if value.is_STREAMING():
            buf.write_i32(52)
            _UniffiConverterString.write(value.url, buf)
        if value.is_RECORDING():
            buf.write_i32(53)
            _UniffiConverterString.write(value.url, buf)
        if value.is_STARTS():
            buf.write_i32(54)
            _UniffiConverterTypeTimestamp.write(value.timestamp, buf)
        if value.is_ENDS():
            buf.write_i32(55)
            _UniffiConverterTypeTimestamp.write(value.timestamp, buf)
        if value.is_LIVE_EVENT_STATUS_TAG():
            buf.write_i32(56)
            _UniffiConverterTypeLiveEventStatus.write(value.status, buf)
        if value.is_CURRENT_PARTICIPANTS():
            buf.write_i32(57)
            _UniffiConverterUInt64.write(value.num, buf)
        if value.is_TOTAL_PARTICIPANTS():
            buf.write_i32(58)
            _UniffiConverterUInt64.write(value.num, buf)
        if value.is_ABSOLUTE_URL():
            buf.write_i32(59)
            _UniffiConverterString.write(value.url, buf)
        if value.is_METHOD():
            buf.write_i32(60)
            _UniffiConverterTypeHttpMethod.write(value.method, buf)
        if value.is_PAYLOAD():
            buf.write_i32(61)
            _UniffiConverterString.write(value.hash, buf)
        if value.is_ANON():
            buf.write_i32(62)
            _UniffiConverterOptionalString.write(value.msg, buf)
        if value.is_PROXY():
            buf.write_i32(63)
            _UniffiConverterString.write(value.id, buf)
            _UniffiConverterTypeProtocol.write(value.protocol, buf)
        if value.is_EMOJI():
            buf.write_i32(64)
            _UniffiConverterString.write(value.shortcode, buf)
            _UniffiConverterString.write(value.url, buf)
        if value.is_ENCRYPTED():
            buf.write_i32(65)
        if value.is_REQUEST():
            buf.write_i32(66)
            _UniffiConverterTypeEvent.write(value.event, buf)
        if value.is_DATA_VENDING_MACHINE_STATUS_TAG():
            buf.write_i32(67)
            _UniffiConverterTypeDataVendingMachineStatus.write(value.status, buf)
            _UniffiConverterOptionalString.write(value.extra_info, buf)
        if value.is_LABEL_NAMESPACE():
            buf.write_i32(68)
            _UniffiConverterString.write(value.namespace, buf)
        if value.is_LABEL():
            buf.write_i32(69)
            _UniffiConverterString.write(value.value, buf)
            _UniffiConverterOptionalString.write(value.namespace, buf)
        if value.is_PROTECTED():
            buf.write_i32(70)
        if value.is_ALT():
            buf.write_i32(71)
            _UniffiConverterString.write(value.summary, buf)
        if value.is_WORD():
            buf.write_i32(72)
            _UniffiConverterString.write(value.word, buf)
        if value.is_WEB():
            buf.write_i32(73)
            _UniffiConverterSequenceString.write(value.urls, buf)
        if value.is_DEPENDENCY():
            buf.write_i32(74)
            _UniffiConverterString.write(value.dep, buf)
        if value.is_EXTENSION():
            buf.write_i32(75)
            _UniffiConverterString.write(value.ext, buf)
        if value.is_LICENSE():
            buf.write_i32(76)
            _UniffiConverterString.write(value.license, buf)
        if value.is_RUNTIME():
            buf.write_i32(77)
            _UniffiConverterString.write(value.runtime, buf)
        if value.is_REPOSITORY():
            buf.write_i32(78)
            _UniffiConverterString.write(value.url, buf)
        if value.is_NIP88_POLL_ENDS_AT():
            buf.write_i32(79)
            _UniffiConverterTypeTimestamp.write(value.timestamp, buf)
        if value.is_NIP88_POLL_OPTION():
            buf.write_i32(80)
            _UniffiConverterTypePollOption.write(value.option, buf)
        if value.is_NIP88_POLL_RESPONSE():
            buf.write_i32(81)
            _UniffiConverterString.write(value.response, buf)
        if value.is_NIP88_POLL_TYPE():
            buf.write_i32(82)
            _UniffiConverterTypePollType.write(value.poll_type, buf)







class TransactionState(enum.Enum):
    """
    Transaction State
    """

    PENDING = 0
    """
    Pending
    """

    
    SETTLED = 1
    """
    Settled
    """

    
    EXPIRED = 2
    """
    Expired (for invoices)
    """

    
    FAILED = 3
    """
    Failed (for payments)
    """

    


class _UniffiConverterTypeTransactionState(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return TransactionState.PENDING
        if variant == 2:
            return TransactionState.SETTLED
        if variant == 3:
            return TransactionState.EXPIRED
        if variant == 4:
            return TransactionState.FAILED
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == TransactionState.PENDING:
            return
        if value == TransactionState.SETTLED:
            return
        if value == TransactionState.EXPIRED:
            return
        if value == TransactionState.FAILED:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == TransactionState.PENDING:
            buf.write_i32(1)
        if value == TransactionState.SETTLED:
            buf.write_i32(2)
        if value == TransactionState.EXPIRED:
            buf.write_i32(3)
        if value == TransactionState.FAILED:
            buf.write_i32(4)







class TransactionType(enum.Enum):
    """
    Transaction Type
    """

    INCOMING = 0
    """
    Incoming payments
    """

    
    OUTGOING = 1
    """
    Outgoing payments
    """

    


class _UniffiConverterTypeTransactionType(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return TransactionType.INCOMING
        if variant == 2:
            return TransactionType.OUTGOING
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == TransactionType.INCOMING:
            return
        if value == TransactionType.OUTGOING:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == TransactionType.INCOMING:
            buf.write_i32(1)
        if value == TransactionType.OUTGOING:
            buf.write_i32(2)







class WebSocketMessage:
    def __init__(self):
        raise RuntimeError("WebSocketMessage cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class TEXT:
        text: "str"

        def __init__(self,text: "str"):
            self.text = text

        def __str__(self):
            return "WebSocketMessage.TEXT(text={})".format(self.text)

        def __eq__(self, other):
            if not other.is_TEXT():
                return False
            if self.text != other.text:
                return False
            return True
    
    class BINARY:
        bytes: "bytes"

        def __init__(self,bytes: "bytes"):
            self.bytes = bytes

        def __str__(self):
            return "WebSocketMessage.BINARY(bytes={})".format(self.bytes)

        def __eq__(self, other):
            if not other.is_BINARY():
                return False
            if self.bytes != other.bytes:
                return False
            return True
    
    class PING:
        bytes: "bytes"

        def __init__(self,bytes: "bytes"):
            self.bytes = bytes

        def __str__(self):
            return "WebSocketMessage.PING(bytes={})".format(self.bytes)

        def __eq__(self, other):
            if not other.is_PING():
                return False
            if self.bytes != other.bytes:
                return False
            return True
    
    class PONG:
        bytes: "bytes"

        def __init__(self,bytes: "bytes"):
            self.bytes = bytes

        def __str__(self):
            return "WebSocketMessage.PONG(bytes={})".format(self.bytes)

        def __eq__(self, other):
            if not other.is_PONG():
                return False
            if self.bytes != other.bytes:
                return False
            return True
    
    class CLOSE:
        frame: "typing.Optional[WebSocketCloseFrame]"

        def __init__(self,frame: "typing.Optional[WebSocketCloseFrame]"):
            self.frame = frame

        def __str__(self):
            return "WebSocketMessage.CLOSE(frame={})".format(self.frame)

        def __eq__(self, other):
            if not other.is_CLOSE():
                return False
            if self.frame != other.frame:
                return False
            return True
    
    

    # For each variant, we have `is_NAME` and `is_name` methods for easily checking
    # whether an instance is that variant.
    def is_TEXT(self) -> bool:
        return isinstance(self, WebSocketMessage.TEXT)
    def is_text(self) -> bool:
        return isinstance(self, WebSocketMessage.TEXT)
    def is_BINARY(self) -> bool:
        return isinstance(self, WebSocketMessage.BINARY)
    def is_binary(self) -> bool:
        return isinstance(self, WebSocketMessage.BINARY)
    def is_PING(self) -> bool:
        return isinstance(self, WebSocketMessage.PING)
    def is_ping(self) -> bool:
        return isinstance(self, WebSocketMessage.PING)
    def is_PONG(self) -> bool:
        return isinstance(self, WebSocketMessage.PONG)
    def is_pong(self) -> bool:
        return isinstance(self, WebSocketMessage.PONG)
    def is_CLOSE(self) -> bool:
        return isinstance(self, WebSocketMessage.CLOSE)
    def is_close(self) -> bool:
        return isinstance(self, WebSocketMessage.CLOSE)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
WebSocketMessage.TEXT = type("WebSocketMessage.TEXT", (WebSocketMessage.TEXT, WebSocketMessage,), {})  # type: ignore
WebSocketMessage.BINARY = type("WebSocketMessage.BINARY", (WebSocketMessage.BINARY, WebSocketMessage,), {})  # type: ignore
WebSocketMessage.PING = type("WebSocketMessage.PING", (WebSocketMessage.PING, WebSocketMessage,), {})  # type: ignore
WebSocketMessage.PONG = type("WebSocketMessage.PONG", (WebSocketMessage.PONG, WebSocketMessage,), {})  # type: ignore
WebSocketMessage.CLOSE = type("WebSocketMessage.CLOSE", (WebSocketMessage.CLOSE, WebSocketMessage,), {})  # type: ignore




class _UniffiConverterTypeWebSocketMessage(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return WebSocketMessage.TEXT(
                _UniffiConverterString.read(buf),
            )
        if variant == 2:
            return WebSocketMessage.BINARY(
                _UniffiConverterBytes.read(buf),
            )
        if variant == 3:
            return WebSocketMessage.PING(
                _UniffiConverterBytes.read(buf),
            )
        if variant == 4:
            return WebSocketMessage.PONG(
                _UniffiConverterBytes.read(buf),
            )
        if variant == 5:
            return WebSocketMessage.CLOSE(
                _UniffiConverterOptionalTypeWebSocketCloseFrame.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value.is_TEXT():
            _UniffiConverterString.check_lower(value.text)
            return
        if value.is_BINARY():
            _UniffiConverterBytes.check_lower(value.bytes)
            return
        if value.is_PING():
            _UniffiConverterBytes.check_lower(value.bytes)
            return
        if value.is_PONG():
            _UniffiConverterBytes.check_lower(value.bytes)
            return
        if value.is_CLOSE():
            _UniffiConverterOptionalTypeWebSocketCloseFrame.check_lower(value.frame)
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value.is_TEXT():
            buf.write_i32(1)
            _UniffiConverterString.write(value.text, buf)
        if value.is_BINARY():
            buf.write_i32(2)
            _UniffiConverterBytes.write(value.bytes, buf)
        if value.is_PING():
            buf.write_i32(3)
            _UniffiConverterBytes.write(value.bytes, buf)
        if value.is_PONG():
            buf.write_i32(4)
            _UniffiConverterBytes.write(value.bytes, buf)
        if value.is_CLOSE():
            buf.write_i32(5)
            _UniffiConverterOptionalTypeWebSocketCloseFrame.write(value.frame, buf)







class ZapType(enum.Enum):
    PUBLIC = 0
    """
    Public
    """

    
    PRIVATE = 1
    """
    Private
    """

    
    ANONYMOUS = 2
    """
    Anonymous
    """

    


class _UniffiConverterTypeZapType(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return ZapType.PUBLIC
        if variant == 2:
            return ZapType.PRIVATE
        if variant == 3:
            return ZapType.ANONYMOUS
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == ZapType.PUBLIC:
            return
        if value == ZapType.PRIVATE:
            return
        if value == ZapType.ANONYMOUS:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == ZapType.PUBLIC:
            buf.write_i32(1)
        if value == ZapType.PRIVATE:
            buf.write_i32(2)
        if value == ZapType.ANONYMOUS:
            buf.write_i32(3)





class _UniffiConverterOptionalUInt8(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterUInt8.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterUInt8.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterUInt8.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalUInt16(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterUInt16.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterUInt16.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterUInt16.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalUInt32(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterUInt32.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterUInt32.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterUInt32.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalInt32(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterInt32.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterInt32.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterInt32.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalUInt64(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterUInt64.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterUInt64.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterUInt64.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalBool(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterBool.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterBool.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterBool.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalString(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterString.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterString.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterString.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalDuration(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterDuration.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterDuration.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterDuration.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeAdmitStatus(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeAdmitStatus.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeAdmitStatus.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeAdmitStatus.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeEvent(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeEvent.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeEvent.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeEvent.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeEventId(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeEventId.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeEventId.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeEventId.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeKind(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeKind.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeKind.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeKind.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeMetadata(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeMetadata.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeMetadata.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeMetadata.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeNostrSigner(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeNostrSigner.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeNostrSigner.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeNostrSigner.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypePublicKey(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypePublicKey.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypePublicKey.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypePublicKey.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeRelayOptions(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeRelayOptions.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeRelayOptions.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeRelayOptions.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeRelayUrl(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeRelayUrl.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeRelayUrl.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeRelayUrl.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeSaveEventStatus(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeSaveEventStatus.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeSaveEventStatus.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeSaveEventStatus.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeSingleLetterTag(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeSingleLetterTag.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeSingleLetterTag.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeSingleLetterTag.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeSubscribeAutoCloseOptions(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeSubscribeAutoCloseOptions.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeSubscribeAutoCloseOptions.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeSubscribeAutoCloseOptions.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeTag(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeTag.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeTag.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeTag.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeTimestamp(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeTimestamp.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeTimestamp.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeTimestamp.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeWebSocketAdapterWrapper(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeWebSocketAdapterWrapper.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeWebSocketAdapterWrapper.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeWebSocketAdapterWrapper.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeFeeSchedules(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeFeeSchedules.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeFeeSchedules.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeFeeSchedules.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeImage(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeImage.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeImage.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeImage.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeImageDimensions(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeImageDimensions.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeImageDimensions.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeImageDimensions.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeLimitation(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeLimitation.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeLimitation.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeLimitation.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeLiveEventHost(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeLiveEventHost.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeLiveEventHost.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeLiveEventHost.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeNostrParserOptions(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeNostrParserOptions.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeNostrParserOptions.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeNostrParserOptions.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeTagClientAddress(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeTagClientAddress.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeTagClientAddress.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeTagClientAddress.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeWebSocketCloseFrame(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeWebSocketCloseFrame.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeWebSocketCloseFrame.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeWebSocketCloseFrame.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeCommentTarget(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeCommentTarget.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeCommentTarget.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeCommentTarget.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeJsonValue(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeJsonValue.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeJsonValue.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeJsonValue.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeKindStandard(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeKindStandard.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeKindStandard.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeKindStandard.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeLiveEventStatus(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeLiveEventStatus.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeLiveEventStatus.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeLiveEventStatus.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeMarker(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeMarker.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeMarker.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeMarker.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeRejectedReason(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeRejectedReason.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeRejectedReason.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeRejectedReason.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeRelayMetadata(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeRelayMetadata.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeRelayMetadata.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeRelayMetadata.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeTagStandard(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeTagStandard.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeTagStandard.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeTagStandard.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeTransactionState(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeTransactionState.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeTransactionState.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeTransactionState.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeTransactionType(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeTransactionType.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeTransactionType.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeTransactionType.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeWebSocketMessage(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeWebSocketMessage.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeWebSocketMessage.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeWebSocketMessage.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalSequenceUInt16(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterSequenceUInt16.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterSequenceUInt16.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterSequenceUInt16.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalSequenceString(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterSequenceString.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterSequenceString.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterSequenceString.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalSequenceTypeEventId(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterSequenceTypeEventId.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterSequenceTypeEventId.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterSequenceTypeEventId.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalSequenceTypeFilter(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterSequenceTypeFilter.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterSequenceTypeFilter.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterSequenceTypeFilter.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalSequenceTypeKind(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterSequenceTypeKind.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterSequenceTypeKind.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterSequenceTypeKind.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalSequenceTypePublicKey(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterSequenceTypePublicKey.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterSequenceTypePublicKey.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterSequenceTypePublicKey.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalSequenceTypeRetentionKind(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterSequenceTypeRetentionKind.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterSequenceTypeRetentionKind.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterSequenceTypeRetentionKind.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalSequenceSequenceString(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterSequenceSequenceString.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterSequenceSequenceString.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterSequenceSequenceString.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalMapStringTypeJsonValue(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterMapStringTypeJsonValue.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterMapStringTypeJsonValue.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterMapStringTypeJsonValue.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterSequenceUInt16(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterUInt16.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterUInt16.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterUInt16.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceString(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterString.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterString.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterString.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeClientMessage(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeClientMessage.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeClientMessage.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeClientMessage.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeCoordinate(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeCoordinate.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeCoordinate.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeCoordinate.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeEvent(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeEvent.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeEvent.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeEvent.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeEventId(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeEventId.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeEventId.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeEventId.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeFilter(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeFilter.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeFilter.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeFilter.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeKind(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeKind.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeKind.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeKind.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypePublicKey(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypePublicKey.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypePublicKey.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypePublicKey.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeRelayUrl(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeRelayUrl.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeRelayUrl.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeRelayUrl.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeShippingMethod(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeShippingMethod.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeShippingMethod.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeShippingMethod.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeTag(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeTag.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeTag.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeTag.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeContact(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeContact.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeContact.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeContact.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeEmojiInfo(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeEmojiInfo.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeEmojiInfo.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeEmojiInfo.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeFeeSchedule(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeFeeSchedule.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeFeeSchedule.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeFeeSchedule.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeGenericTag(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeGenericTag.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeGenericTag.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeGenericTag.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeImage(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeImage.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeImage.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeImage.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeKeysendTlvRecord(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeKeysendTlvRecord.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeKeysendTlvRecord.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeKeysendTlvRecord.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeLookupInvoiceResponse(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeLookupInvoiceResponse.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeLookupInvoiceResponse.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeLookupInvoiceResponse.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeNegentropyItem(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeNegentropyItem.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeNegentropyItem.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeNegentropyItem.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypePayInvoiceRequest(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypePayInvoiceRequest.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypePayInvoiceRequest.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypePayInvoiceRequest.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypePayKeysendRequest(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypePayKeysendRequest.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypePayKeysendRequest.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypePayKeysendRequest.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypePerson(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypePerson.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypePerson.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypePerson.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeReconciliationSendFailureItem(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeReconciliationSendFailureItem.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeReconciliationSendFailureItem.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeReconciliationSendFailureItem.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeRetention(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeRetention.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeRetention.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeRetention.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeShippingCost(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeShippingCost.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeShippingCost.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeShippingCost.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeShippingMethodRecord(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeShippingMethodRecord.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeShippingMethodRecord.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeShippingMethodRecord.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeJsonValue(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeJsonValue.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeJsonValue.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeJsonValue.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeMethod(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeMethod.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeMethod.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeMethod.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeNostrParserToken(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeNostrParserToken.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeNostrParserToken.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeNostrParserToken.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeRetentionKind(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeRetentionKind.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeRetentionKind.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeRetentionKind.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeTagStandard(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeTagStandard.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeTagStandard.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeTagStandard.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceSequenceString(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterSequenceString.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterSequenceString.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterSequenceString.read(buf) for i in range(count)
        ]



class _UniffiConverterMapStringTypeJsonValue(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, items):
        for (key, value) in items.items():
            _UniffiConverterString.check_lower(key)
            _UniffiConverterTypeJsonValue.check_lower(value)

    @classmethod
    def write(cls, items, buf):
        buf.write_i32(len(items))
        for (key, value) in items.items():
            _UniffiConverterString.write(key, buf)
            _UniffiConverterTypeJsonValue.write(value, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative map size")

        # It would be nice to use a dict comprehension,
        # but in Python 3.7 and before the evaluation order is not according to spec,
        # so we we're reading the value before the key.
        # This loop makes the order explicit: first reading the key, then the value.
        d = {}
        for i in range(count):
            key = _UniffiConverterString.read(buf)
            val = _UniffiConverterTypeJsonValue.read(buf)
            d[key] = val
        return d



class _UniffiConverterMapStringSequenceTypeFilter(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, items):
        for (key, value) in items.items():
            _UniffiConverterString.check_lower(key)
            _UniffiConverterSequenceTypeFilter.check_lower(value)

    @classmethod
    def write(cls, items, buf):
        buf.write_i32(len(items))
        for (key, value) in items.items():
            _UniffiConverterString.write(key, buf)
            _UniffiConverterSequenceTypeFilter.write(value, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative map size")

        # It would be nice to use a dict comprehension,
        # but in Python 3.7 and before the evaluation order is not according to spec,
        # so we we're reading the value before the key.
        # This loop makes the order explicit: first reading the key, then the value.
        d = {}
        for i in range(count):
            key = _UniffiConverterString.read(buf)
            val = _UniffiConverterSequenceTypeFilter.read(buf)
            d[key] = val
        return d



class _UniffiConverterMapStringMapTypeRelayUrlSequenceTypeFilter(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, items):
        for (key, value) in items.items():
            _UniffiConverterString.check_lower(key)
            _UniffiConverterMapTypeRelayUrlSequenceTypeFilter.check_lower(value)

    @classmethod
    def write(cls, items, buf):
        buf.write_i32(len(items))
        for (key, value) in items.items():
            _UniffiConverterString.write(key, buf)
            _UniffiConverterMapTypeRelayUrlSequenceTypeFilter.write(value, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative map size")

        # It would be nice to use a dict comprehension,
        # but in Python 3.7 and before the evaluation order is not according to spec,
        # so we we're reading the value before the key.
        # This loop makes the order explicit: first reading the key, then the value.
        d = {}
        for i in range(count):
            key = _UniffiConverterString.read(buf)
            val = _UniffiConverterMapTypeRelayUrlSequenceTypeFilter.read(buf)
            d[key] = val
        return d



class _UniffiConverterMapTypeRelayUrlString(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, items):
        for (key, value) in items.items():
            _UniffiConverterTypeRelayUrl.check_lower(key)
            _UniffiConverterString.check_lower(value)

    @classmethod
    def write(cls, items, buf):
        buf.write_i32(len(items))
        for (key, value) in items.items():
            _UniffiConverterTypeRelayUrl.write(key, buf)
            _UniffiConverterString.write(value, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative map size")

        # It would be nice to use a dict comprehension,
        # but in Python 3.7 and before the evaluation order is not according to spec,
        # so we we're reading the value before the key.
        # This loop makes the order explicit: first reading the key, then the value.
        d = {}
        for i in range(count):
            key = _UniffiConverterTypeRelayUrl.read(buf)
            val = _UniffiConverterString.read(buf)
            d[key] = val
        return d



class _UniffiConverterMapTypeRelayUrlTypeFilter(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, items):
        for (key, value) in items.items():
            _UniffiConverterTypeRelayUrl.check_lower(key)
            _UniffiConverterTypeFilter.check_lower(value)

    @classmethod
    def write(cls, items, buf):
        buf.write_i32(len(items))
        for (key, value) in items.items():
            _UniffiConverterTypeRelayUrl.write(key, buf)
            _UniffiConverterTypeFilter.write(value, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative map size")

        # It would be nice to use a dict comprehension,
        # but in Python 3.7 and before the evaluation order is not according to spec,
        # so we we're reading the value before the key.
        # This loop makes the order explicit: first reading the key, then the value.
        d = {}
        for i in range(count):
            key = _UniffiConverterTypeRelayUrl.read(buf)
            val = _UniffiConverterTypeFilter.read(buf)
            d[key] = val
        return d



class _UniffiConverterMapTypeRelayUrlTypeRelay(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, items):
        for (key, value) in items.items():
            _UniffiConverterTypeRelayUrl.check_lower(key)
            _UniffiConverterTypeRelay.check_lower(value)

    @classmethod
    def write(cls, items, buf):
        buf.write_i32(len(items))
        for (key, value) in items.items():
            _UniffiConverterTypeRelayUrl.write(key, buf)
            _UniffiConverterTypeRelay.write(value, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative map size")

        # It would be nice to use a dict comprehension,
        # but in Python 3.7 and before the evaluation order is not according to spec,
        # so we we're reading the value before the key.
        # This loop makes the order explicit: first reading the key, then the value.
        d = {}
        for i in range(count):
            key = _UniffiConverterTypeRelayUrl.read(buf)
            val = _UniffiConverterTypeRelay.read(buf)
            d[key] = val
        return d



class _UniffiConverterMapTypeRelayUrlTypeRelayStatus(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, items):
        for (key, value) in items.items():
            _UniffiConverterTypeRelayUrl.check_lower(key)
            _UniffiConverterTypeRelayStatus.check_lower(value)

    @classmethod
    def write(cls, items, buf):
        buf.write_i32(len(items))
        for (key, value) in items.items():
            _UniffiConverterTypeRelayUrl.write(key, buf)
            _UniffiConverterTypeRelayStatus.write(value, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative map size")

        # It would be nice to use a dict comprehension,
        # but in Python 3.7 and before the evaluation order is not according to spec,
        # so we we're reading the value before the key.
        # This loop makes the order explicit: first reading the key, then the value.
        d = {}
        for i in range(count):
            key = _UniffiConverterTypeRelayUrl.read(buf)
            val = _UniffiConverterTypeRelayStatus.read(buf)
            d[key] = val
        return d



class _UniffiConverterMapTypeRelayUrlOptionalTypeRelayMetadata(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, items):
        for (key, value) in items.items():
            _UniffiConverterTypeRelayUrl.check_lower(key)
            _UniffiConverterOptionalTypeRelayMetadata.check_lower(value)

    @classmethod
    def write(cls, items, buf):
        buf.write_i32(len(items))
        for (key, value) in items.items():
            _UniffiConverterTypeRelayUrl.write(key, buf)
            _UniffiConverterOptionalTypeRelayMetadata.write(value, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative map size")

        # It would be nice to use a dict comprehension,
        # but in Python 3.7 and before the evaluation order is not according to spec,
        # so we we're reading the value before the key.
        # This loop makes the order explicit: first reading the key, then the value.
        d = {}
        for i in range(count):
            key = _UniffiConverterTypeRelayUrl.read(buf)
            val = _UniffiConverterOptionalTypeRelayMetadata.read(buf)
            d[key] = val
        return d



class _UniffiConverterMapTypeRelayUrlSequenceTypeFilter(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, items):
        for (key, value) in items.items():
            _UniffiConverterTypeRelayUrl.check_lower(key)
            _UniffiConverterSequenceTypeFilter.check_lower(value)

    @classmethod
    def write(cls, items, buf):
        buf.write_i32(len(items))
        for (key, value) in items.items():
            _UniffiConverterTypeRelayUrl.write(key, buf)
            _UniffiConverterSequenceTypeFilter.write(value, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative map size")

        # It would be nice to use a dict comprehension,
        # but in Python 3.7 and before the evaluation order is not according to spec,
        # so we we're reading the value before the key.
        # This loop makes the order explicit: first reading the key, then the value.
        d = {}
        for i in range(count):
            key = _UniffiConverterTypeRelayUrl.read(buf)
            val = _UniffiConverterSequenceTypeFilter.read(buf)
            d[key] = val
        return d



class _UniffiConverterMapTypeRelayUrlSequenceTypeReconciliationSendFailureItem(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, items):
        for (key, value) in items.items():
            _UniffiConverterTypeRelayUrl.check_lower(key)
            _UniffiConverterSequenceTypeReconciliationSendFailureItem.check_lower(value)

    @classmethod
    def write(cls, items, buf):
        buf.write_i32(len(items))
        for (key, value) in items.items():
            _UniffiConverterTypeRelayUrl.write(key, buf)
            _UniffiConverterSequenceTypeReconciliationSendFailureItem.write(value, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative map size")

        # It would be nice to use a dict comprehension,
        # but in Python 3.7 and before the evaluation order is not according to spec,
        # so we we're reading the value before the key.
        # This loop makes the order explicit: first reading the key, then the value.
        d = {}
        for i in range(count):
            key = _UniffiConverterTypeRelayUrl.read(buf)
            val = _UniffiConverterSequenceTypeReconciliationSendFailureItem.read(buf)
            d[key] = val
        return d

# objects.
class AdmitPolicyProtocol(typing.Protocol):
    def admit_connection(self, relay_url: "RelayUrl"):
        """
        Admit connecting to a relay

        Returns `AdmitStatus`: `success` if the connection is allowed, otherwise `rejected`.
        """

        raise NotImplementedError
    def admit_event(self, relay_url: "RelayUrl",subscription_id: "str",event: "Event"):
        """
        Admit Event

        Returns `AdmitStatus`: `success` if the event is admitted, otherwise `rejected`.
        """

        raise NotImplementedError
# AdmitPolicy is a foreign trait so treated like a callback interface, where the
# primary use-case is the trait being implemented locally.
# It is a base-class local implementations might subclass.


class AdmitPolicy():
    def admit_connection(self, relay_url: "RelayUrl"):
        """
        Admit connecting to a relay

        Returns `AdmitStatus`: `success` if the connection is allowed, otherwise `rejected`.
        """

        raise NotImplementedError
    def admit_event(self, relay_url: "RelayUrl",subscription_id: "str",event: "Event"):
        """
        Admit Event

        Returns `AdmitStatus`: `success` if the event is admitted, otherwise `rejected`.
        """

        raise NotImplementedError
# `AdmitPolicyImpl` is the implementation for a Rust implemented version.
class AdmitPolicyImpl():
    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_admitpolicy, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_admitpolicy, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    async def admit_connection(self, relay_url: "RelayUrl") -> "typing.Optional[AdmitStatus]":
        """
        Admit connecting to a relay

        Returns `AdmitStatus`: `success` if the connection is allowed, otherwise `rejected`.
        """

        _UniffiConverterTypeRelayUrl.check_lower(relay_url)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_nostr_sdk_ffi_fn_method_admitpolicy_admit_connection(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeRelayUrl.lower(relay_url)
            ),
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterOptionalTypeAdmitStatus.lift,
            
    # Error FFI converter
_UniffiConverterTypeNostrSdkError,

        )



    async def admit_event(self, relay_url: "RelayUrl",subscription_id: "str",event: "Event") -> "typing.Optional[AdmitStatus]":
        """
        Admit Event

        Returns `AdmitStatus`: `success` if the event is admitted, otherwise `rejected`.
        """

        _UniffiConverterTypeRelayUrl.check_lower(relay_url)
        
        _UniffiConverterString.check_lower(subscription_id)
        
        _UniffiConverterTypeEvent.check_lower(event)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_nostr_sdk_ffi_fn_method_admitpolicy_admit_event(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeRelayUrl.lower(relay_url),
        _UniffiConverterString.lower(subscription_id),
        _UniffiConverterTypeEvent.lower(event)
            ),
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterOptionalTypeAdmitStatus.lift,
            
    # Error FFI converter
_UniffiConverterTypeNostrSdkError,

        )




# Put all the bits inside a class to keep the top-level namespace clean
class _UniffiTraitImplAdmitPolicy:
    # For each method, generate a callback function to pass to Rust

    @_UNIFFI_CALLBACK_INTERFACE_ADMIT_POLICY_METHOD0
    def admit_connection(
            uniffi_handle,
            relay_url,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeAdmitPolicy._handle_map.get(uniffi_handle)
        def make_call():
            args = (_UniffiConverterTypeRelayUrl.lift(relay_url), )
            method = uniffi_obj.admit_connection
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiConverterOptionalTypeAdmitStatus.lower(return_value),
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiRustBuffer.default(),
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, NostrSdkError, _UniffiConverterTypeNostrSdkError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_ADMIT_POLICY_METHOD1
    def admit_event(
            uniffi_handle,
            relay_url,
            subscription_id,
            event,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeAdmitPolicy._handle_map.get(uniffi_handle)
        def make_call():
            args = (_UniffiConverterTypeRelayUrl.lift(relay_url), _UniffiConverterString.lift(subscription_id), _UniffiConverterTypeEvent.lift(event), )
            method = uniffi_obj.admit_event
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiConverterOptionalTypeAdmitStatus.lower(return_value),
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiRustBuffer.default(),
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, NostrSdkError, _UniffiConverterTypeNostrSdkError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_FREE
    def _uniffi_free(uniffi_handle):
        _UniffiConverterTypeAdmitPolicy._handle_map.remove(uniffi_handle)

    # Generate the FFI VTable.  This has a field for each callback interface method.
    _uniffi_vtable = _UniffiVTableCallbackInterfaceAdmitPolicy(
        admit_connection,
        admit_event,
        _uniffi_free
    )
    # Send Rust a pointer to the VTable.  Note: this means we need to keep the struct alive forever,
    # or else bad things will happen when Rust tries to access it.
    _UniffiLib.uniffi_nostr_sdk_ffi_fn_init_callback_vtable_admitpolicy(ctypes.byref(_uniffi_vtable))



class _UniffiConverterTypeAdmitPolicy:
    _handle_map = _UniffiHandleMap()

    @staticmethod
    def lift(value: int):
        return AdmitPolicyImpl._make_instance_(value)

    @staticmethod
    def check_lower(value: AdmitPolicy):
        pass

    @staticmethod
    def lower(value: AdmitPolicyProtocol):
        return _UniffiConverterTypeAdmitPolicy._handle_map.insert(value)

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: AdmitPolicyProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class CustomNostrDatabaseProtocol(typing.Protocol):
    def backend(self, ):
        """
        Name of backend
        """

        raise NotImplementedError
    def save_event(self, event: "Event"):
        """
        Save [`Event`] into store

        **This method assumes that [`Event`] was already verified**
        """

        raise NotImplementedError
    def check_id(self, event_id: "EventId"):
        """
        Check event status by ID

        Check if the event is saved, deleted or not existent.
        """

        raise NotImplementedError
    def event_by_id(self, event_id: "EventId"):
        """
        Get event by ID
        """

        raise NotImplementedError
    def count(self, filters: "Filter"):
        """
        Count the number of [`Event`] found by filter

        Use `Filter::new()` or `Filter::default()` to count all events.
        """

        raise NotImplementedError
    def query(self, filter: "Filter"):
        """
        Query store with filter
        """

        raise NotImplementedError
    def delete(self, filter: "Filter"):
        """
        Delete all events that match the `Filter`
        """

        raise NotImplementedError
    def wipe(self, ):
        """
        Wipe all data
        """

        raise NotImplementedError
# CustomNostrDatabase is a foreign trait so treated like a callback interface, where the
# primary use-case is the trait being implemented locally.
# It is a base-class local implementations might subclass.


class CustomNostrDatabase():
    def backend(self, ):
        """
        Name of backend
        """

        raise NotImplementedError
    def save_event(self, event: "Event"):
        """
        Save [`Event`] into store

        **This method assumes that [`Event`] was already verified**
        """

        raise NotImplementedError
    def check_id(self, event_id: "EventId"):
        """
        Check event status by ID

        Check if the event is saved, deleted or not existent.
        """

        raise NotImplementedError
    def event_by_id(self, event_id: "EventId"):
        """
        Get event by ID
        """

        raise NotImplementedError
    def count(self, filters: "Filter"):
        """
        Count the number of [`Event`] found by filter

        Use `Filter::new()` or `Filter::default()` to count all events.
        """

        raise NotImplementedError
    def query(self, filter: "Filter"):
        """
        Query store with filter
        """

        raise NotImplementedError
    def delete(self, filter: "Filter"):
        """
        Delete all events that match the `Filter`
        """

        raise NotImplementedError
    def wipe(self, ):
        """
        Wipe all data
        """

        raise NotImplementedError
# `CustomNostrDatabaseImpl` is the implementation for a Rust implemented version.
class CustomNostrDatabaseImpl():
    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_customnostrdatabase, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_customnostrdatabase, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def backend(self, ) -> "str":
        """
        Name of backend
        """

        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_customnostrdatabase_backend,self._uniffi_clone_pointer(),)
        )




    async def save_event(self, event: "Event") -> "typing.Optional[SaveEventStatus]":
        """
        Save [`Event`] into store

        **This method assumes that [`Event`] was already verified**
        """

        _UniffiConverterTypeEvent.check_lower(event)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_nostr_sdk_ffi_fn_method_customnostrdatabase_save_event(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeEvent.lower(event)
            ),
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterOptionalTypeSaveEventStatus.lift,
            
    # Error FFI converter
_UniffiConverterTypeNostrSdkError,

        )



    async def check_id(self, event_id: "EventId") -> "DatabaseEventStatus":
        """
        Check event status by ID

        Check if the event is saved, deleted or not existent.
        """

        _UniffiConverterTypeEventId.check_lower(event_id)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_nostr_sdk_ffi_fn_method_customnostrdatabase_check_id(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeEventId.lower(event_id)
            ),
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeDatabaseEventStatus.lift,
            
    # Error FFI converter
_UniffiConverterTypeNostrSdkError,

        )



    async def event_by_id(self, event_id: "EventId") -> "typing.Optional[Event]":
        """
        Get event by ID
        """

        _UniffiConverterTypeEventId.check_lower(event_id)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_nostr_sdk_ffi_fn_method_customnostrdatabase_event_by_id(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeEventId.lower(event_id)
            ),
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterOptionalTypeEvent.lift,
            
    # Error FFI converter
_UniffiConverterTypeNostrSdkError,

        )



    async def count(self, filters: "Filter") -> "int":
        """
        Count the number of [`Event`] found by filter

        Use `Filter::new()` or `Filter::default()` to count all events.
        """

        _UniffiConverterTypeFilter.check_lower(filters)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_nostr_sdk_ffi_fn_method_customnostrdatabase_count(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeFilter.lower(filters)
            ),
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_poll_u64,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_complete_u64,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_free_u64,
            # lift function
            _UniffiConverterUInt64.lift,
            
    # Error FFI converter
_UniffiConverterTypeNostrSdkError,

        )



    async def query(self, filter: "Filter") -> "typing.List[Event]":
        """
        Query store with filter
        """

        _UniffiConverterTypeFilter.check_lower(filter)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_nostr_sdk_ffi_fn_method_customnostrdatabase_query(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeFilter.lower(filter)
            ),
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterSequenceTypeEvent.lift,
            
    # Error FFI converter
_UniffiConverterTypeNostrSdkError,

        )



    async def delete(self, filter: "Filter") -> None:

        """
        Delete all events that match the `Filter`
        """

        _UniffiConverterTypeFilter.check_lower(filter)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_nostr_sdk_ffi_fn_method_customnostrdatabase_delete(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeFilter.lower(filter)
            ),
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_poll_void,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_complete_void,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeNostrSdkError,

        )



    async def wipe(self, ) -> None:

        """
        Wipe all data
        """

        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_nostr_sdk_ffi_fn_method_customnostrdatabase_wipe(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_poll_void,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_complete_void,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeNostrSdkError,

        )




# Put all the bits inside a class to keep the top-level namespace clean
class _UniffiTraitImplCustomNostrDatabase:
    # For each method, generate a callback function to pass to Rust

    @_UNIFFI_CALLBACK_INTERFACE_CUSTOM_NOSTR_DATABASE_METHOD0
    def backend(
            uniffi_handle,
            uniffi_out_return,
            uniffi_call_status_ptr,
        ):
        uniffi_obj = _UniffiConverterTypeCustomNostrDatabase._handle_map.get(uniffi_handle)
        def make_call():
            args = ()
            method = uniffi_obj.backend
            return method(*args)

        
        def write_return_value(v):
            uniffi_out_return[0] = _UniffiConverterString.lower(v)
        _uniffi_trait_interface_call(
                uniffi_call_status_ptr.contents,
                make_call,
                write_return_value,
        )

    @_UNIFFI_CALLBACK_INTERFACE_CUSTOM_NOSTR_DATABASE_METHOD1
    def save_event(
            uniffi_handle,
            event,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeCustomNostrDatabase._handle_map.get(uniffi_handle)
        def make_call():
            args = (_UniffiConverterTypeEvent.lift(event), )
            method = uniffi_obj.save_event
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiConverterOptionalTypeSaveEventStatus.lower(return_value),
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiRustBuffer.default(),
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, NostrSdkError, _UniffiConverterTypeNostrSdkError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_CUSTOM_NOSTR_DATABASE_METHOD2
    def check_id(
            uniffi_handle,
            event_id,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeCustomNostrDatabase._handle_map.get(uniffi_handle)
        def make_call():
            args = (_UniffiConverterTypeEventId.lift(event_id), )
            method = uniffi_obj.check_id
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiConverterTypeDatabaseEventStatus.lower(return_value),
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiRustBuffer.default(),
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, NostrSdkError, _UniffiConverterTypeNostrSdkError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_CUSTOM_NOSTR_DATABASE_METHOD3
    def event_by_id(
            uniffi_handle,
            event_id,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeCustomNostrDatabase._handle_map.get(uniffi_handle)
        def make_call():
            args = (_UniffiConverterTypeEventId.lift(event_id), )
            method = uniffi_obj.event_by_id
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiConverterOptionalTypeEvent.lower(return_value),
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiRustBuffer.default(),
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, NostrSdkError, _UniffiConverterTypeNostrSdkError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_CUSTOM_NOSTR_DATABASE_METHOD4
    def count(
            uniffi_handle,
            filters,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeCustomNostrDatabase._handle_map.get(uniffi_handle)
        def make_call():
            args = (_UniffiConverterTypeFilter.lift(filters), )
            method = uniffi_obj.count
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructU64(
                    _UniffiConverterUInt64.lower(return_value),
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructU64(
                    0,
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, NostrSdkError, _UniffiConverterTypeNostrSdkError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_CUSTOM_NOSTR_DATABASE_METHOD5
    def query(
            uniffi_handle,
            filter,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeCustomNostrDatabase._handle_map.get(uniffi_handle)
        def make_call():
            args = (_UniffiConverterTypeFilter.lift(filter), )
            method = uniffi_obj.query
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiConverterSequenceTypeEvent.lower(return_value),
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiRustBuffer.default(),
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, NostrSdkError, _UniffiConverterTypeNostrSdkError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_CUSTOM_NOSTR_DATABASE_METHOD6
    def delete(
            uniffi_handle,
            filter,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeCustomNostrDatabase._handle_map.get(uniffi_handle)
        def make_call():
            args = (_UniffiConverterTypeFilter.lift(filter), )
            method = uniffi_obj.delete
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructVoid(
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructVoid(
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, NostrSdkError, _UniffiConverterTypeNostrSdkError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_CUSTOM_NOSTR_DATABASE_METHOD7
    def wipe(
            uniffi_handle,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeCustomNostrDatabase._handle_map.get(uniffi_handle)
        def make_call():
            args = ()
            method = uniffi_obj.wipe
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructVoid(
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructVoid(
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, NostrSdkError, _UniffiConverterTypeNostrSdkError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_FREE
    def _uniffi_free(uniffi_handle):
        _UniffiConverterTypeCustomNostrDatabase._handle_map.remove(uniffi_handle)

    # Generate the FFI VTable.  This has a field for each callback interface method.
    _uniffi_vtable = _UniffiVTableCallbackInterfaceCustomNostrDatabase(
        backend,
        save_event,
        check_id,
        event_by_id,
        count,
        query,
        delete,
        wipe,
        _uniffi_free
    )
    # Send Rust a pointer to the VTable.  Note: this means we need to keep the struct alive forever,
    # or else bad things will happen when Rust tries to access it.
    _UniffiLib.uniffi_nostr_sdk_ffi_fn_init_callback_vtable_customnostrdatabase(ctypes.byref(_uniffi_vtable))



class _UniffiConverterTypeCustomNostrDatabase:
    _handle_map = _UniffiHandleMap()

    @staticmethod
    def lift(value: int):
        return CustomNostrDatabaseImpl._make_instance_(value)

    @staticmethod
    def check_lower(value: CustomNostrDatabase):
        pass

    @staticmethod
    def lower(value: CustomNostrDatabaseProtocol):
        return _UniffiConverterTypeCustomNostrDatabase._handle_map.insert(value)

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: CustomNostrDatabaseProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class CustomNostrSignerProtocol(typing.Protocol):
    def backend(self, ):
        raise NotImplementedError
    def get_public_key(self, ):
        """
        Get signer public key
        """

        raise NotImplementedError
    def sign_event(self, unsigned_event: "UnsignedEvent"):
        """
        Sign an unsigned event
        """

        raise NotImplementedError
    def nip04_encrypt(self, public_key: "PublicKey",content: "str"):
        """
        NIP04 encrypt (deprecate and unsecure)
        """

        raise NotImplementedError
    def nip04_decrypt(self, public_key: "PublicKey",encrypted_content: "str"):
        """
        NIP04 decrypt
        """

        raise NotImplementedError
    def nip44_encrypt(self, public_key: "PublicKey",content: "str"):
        """
        NIP44 encrypt
        """

        raise NotImplementedError
    def nip44_decrypt(self, public_key: "PublicKey",payload: "str"):
        """
        NIP44 decrypt
        """

        raise NotImplementedError
# CustomNostrSigner is a foreign trait so treated like a callback interface, where the
# primary use-case is the trait being implemented locally.
# It is a base-class local implementations might subclass.


class CustomNostrSigner():
    def backend(self, ):
        raise NotImplementedError
    def get_public_key(self, ):
        """
        Get signer public key
        """

        raise NotImplementedError
    def sign_event(self, unsigned_event: "UnsignedEvent"):
        """
        Sign an unsigned event
        """

        raise NotImplementedError
    def nip04_encrypt(self, public_key: "PublicKey",content: "str"):
        """
        NIP04 encrypt (deprecate and unsecure)
        """

        raise NotImplementedError
    def nip04_decrypt(self, public_key: "PublicKey",encrypted_content: "str"):
        """
        NIP04 decrypt
        """

        raise NotImplementedError
    def nip44_encrypt(self, public_key: "PublicKey",content: "str"):
        """
        NIP44 encrypt
        """

        raise NotImplementedError
    def nip44_decrypt(self, public_key: "PublicKey",payload: "str"):
        """
        NIP44 decrypt
        """

        raise NotImplementedError
# `CustomNostrSignerImpl` is the implementation for a Rust implemented version.
class CustomNostrSignerImpl():
    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_customnostrsigner, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_customnostrsigner, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def backend(self, ) -> "SignerBackend":
        return _UniffiConverterTypeSignerBackend.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_customnostrsigner_backend,self._uniffi_clone_pointer(),)
        )




    async def get_public_key(self, ) -> "typing.Optional[PublicKey]":
        """
        Get signer public key
        """

        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_nostr_sdk_ffi_fn_method_customnostrsigner_get_public_key(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterOptionalTypePublicKey.lift,
            
    # Error FFI converter
_UniffiConverterTypeNostrSdkError,

        )



    async def sign_event(self, unsigned_event: "UnsignedEvent") -> "typing.Optional[Event]":
        """
        Sign an unsigned event
        """

        _UniffiConverterTypeUnsignedEvent.check_lower(unsigned_event)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_nostr_sdk_ffi_fn_method_customnostrsigner_sign_event(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeUnsignedEvent.lower(unsigned_event)
            ),
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterOptionalTypeEvent.lift,
            
    # Error FFI converter
_UniffiConverterTypeNostrSdkError,

        )



    async def nip04_encrypt(self, public_key: "PublicKey",content: "str") -> "str":
        """
        NIP04 encrypt (deprecate and unsecure)
        """

        _UniffiConverterTypePublicKey.check_lower(public_key)
        
        _UniffiConverterString.check_lower(content)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_nostr_sdk_ffi_fn_method_customnostrsigner_nip04_encrypt(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypePublicKey.lower(public_key),
        _UniffiConverterString.lower(content)
            ),
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterString.lift,
            
    # Error FFI converter
_UniffiConverterTypeNostrSdkError,

        )



    async def nip04_decrypt(self, public_key: "PublicKey",encrypted_content: "str") -> "str":
        """
        NIP04 decrypt
        """

        _UniffiConverterTypePublicKey.check_lower(public_key)
        
        _UniffiConverterString.check_lower(encrypted_content)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_nostr_sdk_ffi_fn_method_customnostrsigner_nip04_decrypt(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypePublicKey.lower(public_key),
        _UniffiConverterString.lower(encrypted_content)
            ),
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterString.lift,
            
    # Error FFI converter
_UniffiConverterTypeNostrSdkError,

        )



    async def nip44_encrypt(self, public_key: "PublicKey",content: "str") -> "str":
        """
        NIP44 encrypt
        """

        _UniffiConverterTypePublicKey.check_lower(public_key)
        
        _UniffiConverterString.check_lower(content)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_nostr_sdk_ffi_fn_method_customnostrsigner_nip44_encrypt(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypePublicKey.lower(public_key),
        _UniffiConverterString.lower(content)
            ),
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterString.lift,
            
    # Error FFI converter
_UniffiConverterTypeNostrSdkError,

        )



    async def nip44_decrypt(self, public_key: "PublicKey",payload: "str") -> "str":
        """
        NIP44 decrypt
        """

        _UniffiConverterTypePublicKey.check_lower(public_key)
        
        _UniffiConverterString.check_lower(payload)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_nostr_sdk_ffi_fn_method_customnostrsigner_nip44_decrypt(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypePublicKey.lower(public_key),
        _UniffiConverterString.lower(payload)
            ),
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterString.lift,
            
    # Error FFI converter
_UniffiConverterTypeNostrSdkError,

        )




# Put all the bits inside a class to keep the top-level namespace clean
class _UniffiTraitImplCustomNostrSigner:
    # For each method, generate a callback function to pass to Rust

    @_UNIFFI_CALLBACK_INTERFACE_CUSTOM_NOSTR_SIGNER_METHOD0
    def backend(
            uniffi_handle,
            uniffi_out_return,
            uniffi_call_status_ptr,
        ):
        uniffi_obj = _UniffiConverterTypeCustomNostrSigner._handle_map.get(uniffi_handle)
        def make_call():
            args = ()
            method = uniffi_obj.backend
            return method(*args)

        
        def write_return_value(v):
            uniffi_out_return[0] = _UniffiConverterTypeSignerBackend.lower(v)
        _uniffi_trait_interface_call(
                uniffi_call_status_ptr.contents,
                make_call,
                write_return_value,
        )

    @_UNIFFI_CALLBACK_INTERFACE_CUSTOM_NOSTR_SIGNER_METHOD1
    def get_public_key(
            uniffi_handle,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeCustomNostrSigner._handle_map.get(uniffi_handle)
        def make_call():
            args = ()
            method = uniffi_obj.get_public_key
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiConverterOptionalTypePublicKey.lower(return_value),
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiRustBuffer.default(),
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, NostrSdkError, _UniffiConverterTypeNostrSdkError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_CUSTOM_NOSTR_SIGNER_METHOD2
    def sign_event(
            uniffi_handle,
            unsigned_event,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeCustomNostrSigner._handle_map.get(uniffi_handle)
        def make_call():
            args = (_UniffiConverterTypeUnsignedEvent.lift(unsigned_event), )
            method = uniffi_obj.sign_event
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiConverterOptionalTypeEvent.lower(return_value),
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiRustBuffer.default(),
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, NostrSdkError, _UniffiConverterTypeNostrSdkError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_CUSTOM_NOSTR_SIGNER_METHOD3
    def nip04_encrypt(
            uniffi_handle,
            public_key,
            content,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeCustomNostrSigner._handle_map.get(uniffi_handle)
        def make_call():
            args = (_UniffiConverterTypePublicKey.lift(public_key), _UniffiConverterString.lift(content), )
            method = uniffi_obj.nip04_encrypt
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiConverterString.lower(return_value),
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiRustBuffer.default(),
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, NostrSdkError, _UniffiConverterTypeNostrSdkError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_CUSTOM_NOSTR_SIGNER_METHOD4
    def nip04_decrypt(
            uniffi_handle,
            public_key,
            encrypted_content,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeCustomNostrSigner._handle_map.get(uniffi_handle)
        def make_call():
            args = (_UniffiConverterTypePublicKey.lift(public_key), _UniffiConverterString.lift(encrypted_content), )
            method = uniffi_obj.nip04_decrypt
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiConverterString.lower(return_value),
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiRustBuffer.default(),
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, NostrSdkError, _UniffiConverterTypeNostrSdkError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_CUSTOM_NOSTR_SIGNER_METHOD5
    def nip44_encrypt(
            uniffi_handle,
            public_key,
            content,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeCustomNostrSigner._handle_map.get(uniffi_handle)
        def make_call():
            args = (_UniffiConverterTypePublicKey.lift(public_key), _UniffiConverterString.lift(content), )
            method = uniffi_obj.nip44_encrypt
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiConverterString.lower(return_value),
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiRustBuffer.default(),
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, NostrSdkError, _UniffiConverterTypeNostrSdkError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_CUSTOM_NOSTR_SIGNER_METHOD6
    def nip44_decrypt(
            uniffi_handle,
            public_key,
            payload,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeCustomNostrSigner._handle_map.get(uniffi_handle)
        def make_call():
            args = (_UniffiConverterTypePublicKey.lift(public_key), _UniffiConverterString.lift(payload), )
            method = uniffi_obj.nip44_decrypt
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiConverterString.lower(return_value),
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiRustBuffer.default(),
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, NostrSdkError, _UniffiConverterTypeNostrSdkError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_FREE
    def _uniffi_free(uniffi_handle):
        _UniffiConverterTypeCustomNostrSigner._handle_map.remove(uniffi_handle)

    # Generate the FFI VTable.  This has a field for each callback interface method.
    _uniffi_vtable = _UniffiVTableCallbackInterfaceCustomNostrSigner(
        backend,
        get_public_key,
        sign_event,
        nip04_encrypt,
        nip04_decrypt,
        nip44_encrypt,
        nip44_decrypt,
        _uniffi_free
    )
    # Send Rust a pointer to the VTable.  Note: this means we need to keep the struct alive forever,
    # or else bad things will happen when Rust tries to access it.
    _UniffiLib.uniffi_nostr_sdk_ffi_fn_init_callback_vtable_customnostrsigner(ctypes.byref(_uniffi_vtable))



class _UniffiConverterTypeCustomNostrSigner:
    _handle_map = _UniffiHandleMap()

    @staticmethod
    def lift(value: int):
        return CustomNostrSignerImpl._make_instance_(value)

    @staticmethod
    def check_lower(value: CustomNostrSigner):
        pass

    @staticmethod
    def lower(value: CustomNostrSignerProtocol):
        return _UniffiConverterTypeCustomNostrSigner._handle_map.insert(value)

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: CustomNostrSignerProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class CustomWebSocketTransportProtocol(typing.Protocol):
    def support_ping(self, ):
        """
        If returns `true`, the WebSocket implementation must handle and forward the PING/PONG messages.
        The ping is used by the SDK,
        for example, to calculate the average latency or to make sure the relay is still connected.
        """

        raise NotImplementedError
    def connect(self, url: "str",mode: "ConnectionMode",timeout: "Duration"):
        """
        Connect to a relay
        """

        raise NotImplementedError
# CustomWebSocketTransport is a foreign trait so treated like a callback interface, where the
# primary use-case is the trait being implemented locally.
# It is a base-class local implementations might subclass.


class CustomWebSocketTransport():
    def support_ping(self, ):
        """
        If returns `true`, the WebSocket implementation must handle and forward the PING/PONG messages.
        The ping is used by the SDK,
        for example, to calculate the average latency or to make sure the relay is still connected.
        """

        raise NotImplementedError
    def connect(self, url: "str",mode: "ConnectionMode",timeout: "Duration"):
        """
        Connect to a relay
        """

        raise NotImplementedError
# `CustomWebSocketTransportImpl` is the implementation for a Rust implemented version.
class CustomWebSocketTransportImpl():
    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_customwebsockettransport, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_customwebsockettransport, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def support_ping(self, ) -> "bool":
        """
        If returns `true`, the WebSocket implementation must handle and forward the PING/PONG messages.
        The ping is used by the SDK,
        for example, to calculate the average latency or to make sure the relay is still connected.
        """

        return _UniffiConverterBool.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_customwebsockettransport_support_ping,self._uniffi_clone_pointer(),)
        )




    async def connect(self, url: "str",mode: "ConnectionMode",timeout: "Duration") -> "typing.Optional[WebSocketAdapterWrapper]":
        """
        Connect to a relay
        """

        _UniffiConverterString.check_lower(url)
        
        _UniffiConverterTypeConnectionMode.check_lower(mode)
        
        _UniffiConverterDuration.check_lower(timeout)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_nostr_sdk_ffi_fn_method_customwebsockettransport_connect(
                self._uniffi_clone_pointer(), 
        _UniffiConverterString.lower(url),
        _UniffiConverterTypeConnectionMode.lower(mode),
        _UniffiConverterDuration.lower(timeout)
            ),
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterOptionalTypeWebSocketAdapterWrapper.lift,
            
    # Error FFI converter
_UniffiConverterTypeNostrSdkError,

        )




# Put all the bits inside a class to keep the top-level namespace clean
class _UniffiTraitImplCustomWebSocketTransport:
    # For each method, generate a callback function to pass to Rust

    @_UNIFFI_CALLBACK_INTERFACE_CUSTOM_WEB_SOCKET_TRANSPORT_METHOD0
    def support_ping(
            uniffi_handle,
            uniffi_out_return,
            uniffi_call_status_ptr,
        ):
        uniffi_obj = _UniffiConverterTypeCustomWebSocketTransport._handle_map.get(uniffi_handle)
        def make_call():
            args = ()
            method = uniffi_obj.support_ping
            return method(*args)

        
        def write_return_value(v):
            uniffi_out_return[0] = _UniffiConverterBool.lower(v)
        _uniffi_trait_interface_call(
                uniffi_call_status_ptr.contents,
                make_call,
                write_return_value,
        )

    @_UNIFFI_CALLBACK_INTERFACE_CUSTOM_WEB_SOCKET_TRANSPORT_METHOD1
    def connect(
            uniffi_handle,
            url,
            mode,
            timeout,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeCustomWebSocketTransport._handle_map.get(uniffi_handle)
        def make_call():
            args = (_UniffiConverterString.lift(url), _UniffiConverterTypeConnectionMode.lift(mode), _UniffiConverterDuration.lift(timeout), )
            method = uniffi_obj.connect
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiConverterOptionalTypeWebSocketAdapterWrapper.lower(return_value),
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiRustBuffer.default(),
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, NostrSdkError, _UniffiConverterTypeNostrSdkError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_FREE
    def _uniffi_free(uniffi_handle):
        _UniffiConverterTypeCustomWebSocketTransport._handle_map.remove(uniffi_handle)

    # Generate the FFI VTable.  This has a field for each callback interface method.
    _uniffi_vtable = _UniffiVTableCallbackInterfaceCustomWebSocketTransport(
        support_ping,
        connect,
        _uniffi_free
    )
    # Send Rust a pointer to the VTable.  Note: this means we need to keep the struct alive forever,
    # or else bad things will happen when Rust tries to access it.
    _UniffiLib.uniffi_nostr_sdk_ffi_fn_init_callback_vtable_customwebsockettransport(ctypes.byref(_uniffi_vtable))



class _UniffiConverterTypeCustomWebSocketTransport:
    _handle_map = _UniffiHandleMap()

    @staticmethod
    def lift(value: int):
        return CustomWebSocketTransportImpl._make_instance_(value)

    @staticmethod
    def check_lower(value: CustomWebSocketTransport):
        pass

    @staticmethod
    def lower(value: CustomWebSocketTransportProtocol):
        return _UniffiConverterTypeCustomWebSocketTransport._handle_map.insert(value)

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: CustomWebSocketTransportProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class HandleNotificationProtocol(typing.Protocol):
    def handle_msg(self, relay_url: "RelayUrl",msg: "RelayMessage"):
        raise NotImplementedError
    def handle(self, relay_url: "RelayUrl",subscription_id: "str",event: "Event"):
        raise NotImplementedError
# HandleNotification is a foreign trait so treated like a callback interface, where the
# primary use-case is the trait being implemented locally.
# It is a base-class local implementations might subclass.


class HandleNotification():
    def handle_msg(self, relay_url: "RelayUrl",msg: "RelayMessage"):
        raise NotImplementedError
    def handle(self, relay_url: "RelayUrl",subscription_id: "str",event: "Event"):
        raise NotImplementedError
# `HandleNotificationImpl` is the implementation for a Rust implemented version.
class HandleNotificationImpl():
    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_handlenotification, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_handlenotification, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    async def handle_msg(self, relay_url: "RelayUrl",msg: "RelayMessage") -> None:

        _UniffiConverterTypeRelayUrl.check_lower(relay_url)
        
        _UniffiConverterTypeRelayMessage.check_lower(msg)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_nostr_sdk_ffi_fn_method_handlenotification_handle_msg(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeRelayUrl.lower(relay_url),
        _UniffiConverterTypeRelayMessage.lower(msg)
            ),
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_poll_void,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_complete_void,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter

    None,

        )



    async def handle(self, relay_url: "RelayUrl",subscription_id: "str",event: "Event") -> None:

        _UniffiConverterTypeRelayUrl.check_lower(relay_url)
        
        _UniffiConverterString.check_lower(subscription_id)
        
        _UniffiConverterTypeEvent.check_lower(event)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_nostr_sdk_ffi_fn_method_handlenotification_handle(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeRelayUrl.lower(relay_url),
        _UniffiConverterString.lower(subscription_id),
        _UniffiConverterTypeEvent.lower(event)
            ),
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_poll_void,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_complete_void,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter

    None,

        )




# Put all the bits inside a class to keep the top-level namespace clean
class _UniffiTraitImplHandleNotification:
    # For each method, generate a callback function to pass to Rust

    @_UNIFFI_CALLBACK_INTERFACE_HANDLE_NOTIFICATION_METHOD0
    def handle_msg(
            uniffi_handle,
            relay_url,
            msg,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeHandleNotification._handle_map.get(uniffi_handle)
        def make_call():
            args = (_UniffiConverterTypeRelayUrl.lift(relay_url), _UniffiConverterTypeRelayMessage.lift(msg), )
            method = uniffi_obj.handle_msg
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructVoid(
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructVoid(
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async(make_call, handle_success, handle_error)

    @_UNIFFI_CALLBACK_INTERFACE_HANDLE_NOTIFICATION_METHOD1
    def handle(
            uniffi_handle,
            relay_url,
            subscription_id,
            event,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeHandleNotification._handle_map.get(uniffi_handle)
        def make_call():
            args = (_UniffiConverterTypeRelayUrl.lift(relay_url), _UniffiConverterString.lift(subscription_id), _UniffiConverterTypeEvent.lift(event), )
            method = uniffi_obj.handle
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructVoid(
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructVoid(
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async(make_call, handle_success, handle_error)

    @_UNIFFI_CALLBACK_INTERFACE_FREE
    def _uniffi_free(uniffi_handle):
        _UniffiConverterTypeHandleNotification._handle_map.remove(uniffi_handle)

    # Generate the FFI VTable.  This has a field for each callback interface method.
    _uniffi_vtable = _UniffiVTableCallbackInterfaceHandleNotification(
        handle_msg,
        handle,
        _uniffi_free
    )
    # Send Rust a pointer to the VTable.  Note: this means we need to keep the struct alive forever,
    # or else bad things will happen when Rust tries to access it.
    _UniffiLib.uniffi_nostr_sdk_ffi_fn_init_callback_vtable_handlenotification(ctypes.byref(_uniffi_vtable))



class _UniffiConverterTypeHandleNotification:
    _handle_map = _UniffiHandleMap()

    @staticmethod
    def lift(value: int):
        return HandleNotificationImpl._make_instance_(value)

    @staticmethod
    def check_lower(value: HandleNotification):
        pass

    @staticmethod
    def lower(value: HandleNotificationProtocol):
        return _UniffiConverterTypeHandleNotification._handle_map.insert(value)

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: HandleNotificationProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class QueryPolicyProtocol(typing.Protocol):
    """
    Filters REQ's to the internal relay database
    """

    def admit_query(self, query: "Filter",socket_addr: "str"):
        """
        Check if the policy should accept a query
        """

        raise NotImplementedError
# QueryPolicy is a foreign trait so treated like a callback interface, where the
# primary use-case is the trait being implemented locally.
# It is a base-class local implementations might subclass.


class QueryPolicy():
    """
    Filters REQ's to the internal relay database
    """

    def admit_query(self, query: "Filter",socket_addr: "str"):
        """
        Check if the policy should accept a query
        """

        raise NotImplementedError
# `QueryPolicyImpl` is the implementation for a Rust implemented version.
class QueryPolicyImpl():
    """
    Filters REQ's to the internal relay database
    """

    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_querypolicy, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_querypolicy, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    async def admit_query(self, query: "Filter",socket_addr: "str") -> "PolicyResult":
        """
        Check if the policy should accept a query
        """

        _UniffiConverterTypeFilter.check_lower(query)
        
        _UniffiConverterString.check_lower(socket_addr)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_nostr_sdk_ffi_fn_method_querypolicy_admit_query(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeFilter.lower(query),
        _UniffiConverterString.lower(socket_addr)
            ),
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypePolicyResult.lift,
            
    # Error FFI converter

    None,

        )




# Put all the bits inside a class to keep the top-level namespace clean
class _UniffiTraitImplQueryPolicy:
    # For each method, generate a callback function to pass to Rust

    @_UNIFFI_CALLBACK_INTERFACE_QUERY_POLICY_METHOD0
    def admit_query(
            uniffi_handle,
            query,
            socket_addr,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeQueryPolicy._handle_map.get(uniffi_handle)
        def make_call():
            args = (_UniffiConverterTypeFilter.lift(query), _UniffiConverterString.lift(socket_addr), )
            method = uniffi_obj.admit_query
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiConverterTypePolicyResult.lower(return_value),
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiRustBuffer.default(),
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async(make_call, handle_success, handle_error)

    @_UNIFFI_CALLBACK_INTERFACE_FREE
    def _uniffi_free(uniffi_handle):
        _UniffiConverterTypeQueryPolicy._handle_map.remove(uniffi_handle)

    # Generate the FFI VTable.  This has a field for each callback interface method.
    _uniffi_vtable = _UniffiVTableCallbackInterfaceQueryPolicy(
        admit_query,
        _uniffi_free
    )
    # Send Rust a pointer to the VTable.  Note: this means we need to keep the struct alive forever,
    # or else bad things will happen when Rust tries to access it.
    _UniffiLib.uniffi_nostr_sdk_ffi_fn_init_callback_vtable_querypolicy(ctypes.byref(_uniffi_vtable))



class _UniffiConverterTypeQueryPolicy:
    _handle_map = _UniffiHandleMap()

    @staticmethod
    def lift(value: int):
        return QueryPolicyImpl._make_instance_(value)

    @staticmethod
    def check_lower(value: QueryPolicy):
        pass

    @staticmethod
    def lower(value: QueryPolicyProtocol):
        return _UniffiConverterTypeQueryPolicy._handle_map.insert(value)

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: QueryPolicyProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class WebSocketAdapterProtocol(typing.Protocol):
    def send(self, msg: "WebSocketMessage"):
        """
        Send a WebSocket message
        """

        raise NotImplementedError
    def recv(self, ):
        """
        Receive a message

        This method MUST await for a message.

        Return `None` to mark the stream as terminated.
        """

        raise NotImplementedError
    def close_connection(self, ):
        """
        Close the WebSocket connection
        """

        raise NotImplementedError
# WebSocketAdapter is a foreign trait so treated like a callback interface, where the
# primary use-case is the trait being implemented locally.
# It is a base-class local implementations might subclass.


class WebSocketAdapter():
    def send(self, msg: "WebSocketMessage"):
        """
        Send a WebSocket message
        """

        raise NotImplementedError
    def recv(self, ):
        """
        Receive a message

        This method MUST await for a message.

        Return `None` to mark the stream as terminated.
        """

        raise NotImplementedError
    def close_connection(self, ):
        """
        Close the WebSocket connection
        """

        raise NotImplementedError
# `WebSocketAdapterImpl` is the implementation for a Rust implemented version.
class WebSocketAdapterImpl():
    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_websocketadapter, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_websocketadapter, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    async def send(self, msg: "WebSocketMessage") -> None:

        """
        Send a WebSocket message
        """

        _UniffiConverterTypeWebSocketMessage.check_lower(msg)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_nostr_sdk_ffi_fn_method_websocketadapter_send(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeWebSocketMessage.lower(msg)
            ),
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_poll_void,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_complete_void,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeNostrSdkError,

        )



    async def recv(self, ) -> "typing.Optional[WebSocketMessage]":
        """
        Receive a message

        This method MUST await for a message.

        Return `None` to mark the stream as terminated.
        """

        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_nostr_sdk_ffi_fn_method_websocketadapter_recv(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterOptionalTypeWebSocketMessage.lift,
            
    # Error FFI converter
_UniffiConverterTypeNostrSdkError,

        )



    async def close_connection(self, ) -> None:

        """
        Close the WebSocket connection
        """

        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_nostr_sdk_ffi_fn_method_websocketadapter_close_connection(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_poll_void,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_complete_void,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeNostrSdkError,

        )




# Put all the bits inside a class to keep the top-level namespace clean
class _UniffiTraitImplWebSocketAdapter:
    # For each method, generate a callback function to pass to Rust

    @_UNIFFI_CALLBACK_INTERFACE_WEB_SOCKET_ADAPTER_METHOD0
    def send(
            uniffi_handle,
            msg,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeWebSocketAdapter._handle_map.get(uniffi_handle)
        def make_call():
            args = (_UniffiConverterTypeWebSocketMessage.lift(msg), )
            method = uniffi_obj.send
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructVoid(
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructVoid(
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, NostrSdkError, _UniffiConverterTypeNostrSdkError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_WEB_SOCKET_ADAPTER_METHOD1
    def recv(
            uniffi_handle,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeWebSocketAdapter._handle_map.get(uniffi_handle)
        def make_call():
            args = ()
            method = uniffi_obj.recv
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiConverterOptionalTypeWebSocketMessage.lower(return_value),
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiRustBuffer.default(),
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, NostrSdkError, _UniffiConverterTypeNostrSdkError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_WEB_SOCKET_ADAPTER_METHOD2
    def close_connection(
            uniffi_handle,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeWebSocketAdapter._handle_map.get(uniffi_handle)
        def make_call():
            args = ()
            method = uniffi_obj.close_connection
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructVoid(
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructVoid(
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, NostrSdkError, _UniffiConverterTypeNostrSdkError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_FREE
    def _uniffi_free(uniffi_handle):
        _UniffiConverterTypeWebSocketAdapter._handle_map.remove(uniffi_handle)

    # Generate the FFI VTable.  This has a field for each callback interface method.
    _uniffi_vtable = _UniffiVTableCallbackInterfaceWebSocketAdapter(
        send,
        recv,
        close_connection,
        _uniffi_free
    )
    # Send Rust a pointer to the VTable.  Note: this means we need to keep the struct alive forever,
    # or else bad things will happen when Rust tries to access it.
    _UniffiLib.uniffi_nostr_sdk_ffi_fn_init_callback_vtable_websocketadapter(ctypes.byref(_uniffi_vtable))



class _UniffiConverterTypeWebSocketAdapter:
    _handle_map = _UniffiHandleMap()

    @staticmethod
    def lift(value: int):
        return WebSocketAdapterImpl._make_instance_(value)

    @staticmethod
    def check_lower(value: WebSocketAdapter):
        pass

    @staticmethod
    def lower(value: WebSocketAdapterProtocol):
        return _UniffiConverterTypeWebSocketAdapter._handle_map.insert(value)

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: WebSocketAdapterProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class WritePolicyProtocol(typing.Protocol):
    """
    Custom policy for accepting events into the relay database
    """

    def admit_event(self, event: "Event",socket_addr: "str"):
        """
        Check if the policy should accept an event
        """

        raise NotImplementedError
# WritePolicy is a foreign trait so treated like a callback interface, where the
# primary use-case is the trait being implemented locally.
# It is a base-class local implementations might subclass.


class WritePolicy():
    """
    Custom policy for accepting events into the relay database
    """

    def admit_event(self, event: "Event",socket_addr: "str"):
        """
        Check if the policy should accept an event
        """

        raise NotImplementedError
# `WritePolicyImpl` is the implementation for a Rust implemented version.
class WritePolicyImpl():
    """
    Custom policy for accepting events into the relay database
    """

    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_writepolicy, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_writepolicy, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    async def admit_event(self, event: "Event",socket_addr: "str") -> "PolicyResult":
        """
        Check if the policy should accept an event
        """

        _UniffiConverterTypeEvent.check_lower(event)
        
        _UniffiConverterString.check_lower(socket_addr)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_nostr_sdk_ffi_fn_method_writepolicy_admit_event(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeEvent.lower(event),
        _UniffiConverterString.lower(socket_addr)
            ),
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypePolicyResult.lift,
            
    # Error FFI converter

    None,

        )




# Put all the bits inside a class to keep the top-level namespace clean
class _UniffiTraitImplWritePolicy:
    # For each method, generate a callback function to pass to Rust

    @_UNIFFI_CALLBACK_INTERFACE_WRITE_POLICY_METHOD0
    def admit_event(
            uniffi_handle,
            event,
            socket_addr,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeWritePolicy._handle_map.get(uniffi_handle)
        def make_call():
            args = (_UniffiConverterTypeEvent.lift(event), _UniffiConverterString.lift(socket_addr), )
            method = uniffi_obj.admit_event
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiConverterTypePolicyResult.lower(return_value),
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiRustBuffer.default(),
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async(make_call, handle_success, handle_error)

    @_UNIFFI_CALLBACK_INTERFACE_FREE
    def _uniffi_free(uniffi_handle):
        _UniffiConverterTypeWritePolicy._handle_map.remove(uniffi_handle)

    # Generate the FFI VTable.  This has a field for each callback interface method.
    _uniffi_vtable = _UniffiVTableCallbackInterfaceWritePolicy(
        admit_event,
        _uniffi_free
    )
    # Send Rust a pointer to the VTable.  Note: this means we need to keep the struct alive forever,
    # or else bad things will happen when Rust tries to access it.
    _UniffiLib.uniffi_nostr_sdk_ffi_fn_init_callback_vtable_writepolicy(ctypes.byref(_uniffi_vtable))



class _UniffiConverterTypeWritePolicy:
    _handle_map = _UniffiHandleMap()

    @staticmethod
    def lift(value: int):
        return WritePolicyImpl._make_instance_(value)

    @staticmethod
    def check_lower(value: WritePolicy):
        pass

    @staticmethod
    def lower(value: WritePolicyProtocol):
        return _UniffiConverterTypeWritePolicy._handle_map.insert(value)

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: WritePolicyProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class AdmitStatusProtocol(typing.Protocol):
    pass
# AdmitStatus is a Rust-only trait - it's a wrapper around a Rust implementation.
class AdmitStatus():
    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_admitstatus, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_admitstatus, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst
    @classmethod
    def rejected(cls, reason: "typing.Union[object, typing.Optional[str]]" = _DEFAULT):
        if reason is _DEFAULT:
            reason = None
        _UniffiConverterOptionalString.check_lower(reason)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_admitstatus_rejected,
        _UniffiConverterOptionalString.lower(reason))
        return cls._make_instance_(pointer)

    @classmethod
    def success(cls, ):
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_admitstatus_success,)
        return cls._make_instance_(pointer)



    def __repr__(self, ) -> "str":
        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_admitstatus_uniffi_trait_debug,self._uniffi_clone_pointer(),)
        )



    def __eq__(self, other: object) -> bool:
        if not isinstance(other, AdmitStatus):
            return NotImplemented

        return _UniffiConverterBool.lift(_uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_admitstatus_uniffi_trait_eq_eq,self._uniffi_clone_pointer(),
        _UniffiConverterTypeAdmitStatus.lower(other)))

    def __ne__(self, other: object) -> bool:
        if not isinstance(other, AdmitStatus):
            return NotImplemented

        return _UniffiConverterBool.lift(_uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_admitstatus_uniffi_trait_eq_ne,self._uniffi_clone_pointer(),
        _UniffiConverterTypeAdmitStatus.lower(other)))


    def __hash__(self, ) -> "int":
        return _UniffiConverterUInt64.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_admitstatus_uniffi_trait_hash,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeAdmitStatus:

    @staticmethod
    def lift(value: int):
        return AdmitStatus._make_instance_(value)

    @staticmethod
    def check_lower(value: AdmitStatus):
        if not isinstance(value, AdmitStatus):
            raise TypeError("Expected AdmitStatus instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: AdmitStatusProtocol):
        if not isinstance(value, AdmitStatus):
            raise TypeError("Expected AdmitStatus instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: AdmitStatusProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class ClientProtocol(typing.Protocol):
    def add_discovery_relay(self, url: "RelayUrl"):
        """
        Add discovery relay

        If relay already exists, this method automatically add the `DISCOVERY` flag to it and return `false`.

        <https://github.com/nostr-protocol/nips/blob/master/65.md>
        """

        raise NotImplementedError
    def add_read_relay(self, url: "RelayUrl"):
        """
        Add read relay

        If relay already exists, this method add the `READ` flag to it and return `false`.
        """

        raise NotImplementedError
    def add_relay(self, url: "RelayUrl"):
        """
        Add new relay

        Relays added with this method will have both `READ` and `WRITE` flags enabled

        If the relay already exists, the flags will be updated and `false` returned.

        If are set pool subscriptions, the new added relay will inherit them. Use `subscribe_to` method instead of `subscribe`,
        to avoid to set pool subscriptions.

        This method use previously set or default `Options` to configure the `Relay` (ex. set proxy, set min POW, set relay limits, ...).

        Connection is **NOT** automatically started with relay, remember to call `connect` method!
        """

        raise NotImplementedError
    def add_relay_with_opts(self, url: "RelayUrl",opts: "RelayOptions"):
        """
        Add new relay with custom options
        """

        raise NotImplementedError
    def add_write_relay(self, url: "RelayUrl"):
        """
        Add write relay

        If relay already exists, this method add the `WRITE` flag to it and return `false`.
        """

        raise NotImplementedError
    def automatic_authentication(self, enable: "bool"):
        """
        Auto authenticate to relays (default: true)

        <https://github.com/nostr-protocol/nips/blob/master/42.md>
        """

        raise NotImplementedError
    def connect(self, ):
        """
        Connect to all added relays

        Attempts to initiate a connection for every relay currently in
        [`RelayStatus::Initialized`] or [`RelayStatus::Terminated`].
        A background connection task is spawned for each such relay, which then tries
        to establish the connection.
        Any relay not in one of these two statuses is skipped.

        For further details, see the documentation of [`Relay::connect`].
        """

        raise NotImplementedError
    def connect_relay(self, url: "RelayUrl"):
        """
        Connect to a previously added relay
        """

        raise NotImplementedError
    def database(self, ):
        raise NotImplementedError
    def disconnect(self, ):
        """
        Disconnect from all relays
        """

        raise NotImplementedError
    def disconnect_relay(self, url: "RelayUrl"):
        raise NotImplementedError
    def fetch_combined_events(self, filter: "Filter",timeout: "Duration"):
        """
        Get events both from database and relays

        This is an auto-closing subscription and will be closed automatically on `EOSE`.

        You can obtain the same result by merging the `Events` from different type of sources.

        This method will be deprecated in the future!
        This is a temporary solution for who still want to query events both from database and relays and merge the result.
        The optimal solution is to execute a [`Client::sync`] to get all old events, [`Client::subscribe`] to get all
        new future events, [`NostrDatabase::query`] to query events and [`Client::handle_notifications`] to listen-for/handle new events (i.e. to know when update the UI).
        This will allow very fast queries, low bandwidth usage (depending on how many events the client have to sync) and a low load on relays.

        # Gossip

        If `gossip` is enabled (see [`Options::gossip`]) the events will be requested also to
        NIP65 relays (automatically discovered) of public keys included in filters (if any).
        """

        raise NotImplementedError
    def fetch_events(self, filter: "Filter",timeout: "Duration"):
        """
        Fetch events from relays

        This is an auto-closing subscription and will be closed automatically on `EOSE`.

        # Gossip

        If `gossip` is enabled (see `Options`) the events will be requested also to
        NIP65 relays (automatically discovered) of public keys included in filters (if any).
        """

        raise NotImplementedError
    def fetch_events_from(self, urls: "typing.List[RelayUrl]",filter: "Filter",timeout: "Duration"):
        """
        Fetch events from specific relays

        This is an auto-closing subscription and will be closed automatically on `EOSE`.
        """

        raise NotImplementedError
    def fetch_metadata(self, public_key: "PublicKey",timeout: "Duration"):
        """
        Fetch the newest public key metadata from relays.

        Returns `None` if the `Metadata` of the `PublicKey` has not been found.

        Check `Client::fetch_events` for more details.

        If you only want to consult cached data,
        consider `client.database().profile(PUBKEY)`.

        <https://github.com/nostr-protocol/nips/blob/master/01.md>
        """

        raise NotImplementedError
    def force_remove_all_relays(self, ):
        """
        Disconnect and force remove all relays
        """

        raise NotImplementedError
    def force_remove_relay(self, url: "RelayUrl"):
        """
        Force remove and disconnect relay

        Note: this method will remove the relay, also if it's in use for the gossip model or other service!
        """

        raise NotImplementedError
    def gift_wrap(self, receiver: "PublicKey",rumor: "UnsignedEvent",extra_tags: "typing.List[Tag]"):
        """
        Construct Gift Wrap and send to relays

        Check `send_event` method to know how sending events works.

        <https://github.com/nostr-protocol/nips/blob/master/59.md>
        """

        raise NotImplementedError
    def gift_wrap_to(self, urls: "typing.List[RelayUrl]",receiver: "PublicKey",rumor: "UnsignedEvent",extra_tags: "typing.List[Tag]"):
        """
        Construct Gift Wrap and send to specific relays

        <https://github.com/nostr-protocol/nips/blob/master/59.md>
        """

        raise NotImplementedError
    def handle_notifications(self, handler: "HandleNotification"):
        """
        Handle notifications
        """

        raise NotImplementedError
    def relay(self, url: "RelayUrl"):
        raise NotImplementedError
    def relays(self, ):
        """
        Get relays with `READ` or `WRITE` flags
        """

        raise NotImplementedError
    def remove_all_relays(self, ):
        """
        Disconnect and remove all relays

        Some relays used by some services could not be disconnected with this method
        (like the ones used for gossip).
        Use [`Client::force_remove_all_relays`] to remove every relay.
        """

        raise NotImplementedError
    def remove_relay(self, url: "RelayUrl"):
        """
        Remove and disconnect relay

        If the relay has `GOSSIP` flag, it will not be removed from the pool and its
        flags will be updated (remove `READ`, `WRITE` and `DISCOVERY` flags).
        """

        raise NotImplementedError
    def send_event(self, event: "Event"):
        """
        Send event

        Send event to all relays with `WRITE` flag.
        If `gossip` is enabled (see `Options`) the event will be sent also to NIP65 relays (automatically discovered).
        """

        raise NotImplementedError
    def send_event_builder(self, builder: "EventBuilder"):
        """
        Take an `EventBuilder`, sign it by using the `NostrSigner` and broadcast to relays (check `send_event` method for more details)

        Rise an error if the `NostrSigner` is not set.
        """

        raise NotImplementedError
    def send_event_builder_to(self, urls: "typing.List[RelayUrl]",builder: "EventBuilder"):
        """
        Take an `EventBuilder`, sign it by using the `NostrSigner` and broadcast to specific relays.

        Rise an error if the `NostrSigner` is not set.
        """

        raise NotImplementedError
    def send_event_to(self, urls: "typing.List[RelayUrl]",event: "Event"):
        """
        Send event to specific relays.
        """

        raise NotImplementedError
    def send_msg_to(self, urls: "typing.List[RelayUrl]",msg: "ClientMessage"):
        raise NotImplementedError
    def send_private_msg(self, receiver: "PublicKey",message: "str",rumor_extra_tags: "typing.Union[object, typing.List[Tag]]" = _DEFAULT):
        """
        Send a private direct message

        If gossip is enabled, the message will be sent to the NIP17 relays (automatically discovered).
        If gossip is not enabled will be sent to all relays with WRITE` relay service flag.

        <https://github.com/nostr-protocol/nips/blob/master/17.md>
        """

        raise NotImplementedError
    def send_private_msg_to(self, urls: "typing.List[RelayUrl]",receiver: "PublicKey",message: "str",rumor_extra_tags: "typing.Union[object, typing.List[Tag]]" = _DEFAULT):
        """
        Send private direct message to specific relays

        <https://github.com/nostr-protocol/nips/blob/master/17.md>
        """

        raise NotImplementedError
    def set_metadata(self, metadata: "Metadata"):
        raise NotImplementedError
    def shutdown(self, ):
        raise NotImplementedError
    def sign_event_builder(self, builder: "EventBuilder"):
        """
        Signs the `EventBuilder` into an `Event` using the `NostrSigner`
        """

        raise NotImplementedError
    def signer(self, ):
        raise NotImplementedError
    def stream_events(self, filter: "Filter",timeout: "Duration"):
        """
        Stream events from relays

        # Overview

        This is an **auto-closing subscription** and will be closed automatically on `EOSE`.
        For long-lived subscriptions, check [`Client::subscribe`].

        # Gossip

        If `gossip` is enabled the events will be streamed also from
        NIP65 relays (automatically discovered) of public keys included in filters (if any).
        """

        raise NotImplementedError
    def stream_events_from(self, urls: "typing.List[RelayUrl]",filter: "Filter",timeout: "Duration"):
        """
        Stream events from specific relays

        # Overview

        This is an **auto-closing subscription** and will be closed automatically on `EOSE`.
        For long-lived subscriptions, check [`Client::subscribe_to`].
        """

        raise NotImplementedError
    def stream_events_targeted(self, targets: "dict[RelayUrl, Filter]",timeout: "Duration"):
        """
        Stream events from specific relays with specific filters

        # Overview

        This is an **auto-closing subscription** and will be closed automatically on `EOSE`.
        """

        raise NotImplementedError
    def subscribe(self, filter: "Filter",opts: "typing.Union[object, typing.Optional[SubscribeAutoCloseOptions]]" = _DEFAULT):
        """
        Subscribe to filters

        If `gossip` is enabled (see `Options]) the events will be requested also to
        NIP65 relays (automatically discovered) of public keys included in filters (if any).

        ### Auto-closing subscription

        It's possible to automatically close a subscription by configuring the `SubscribeAutoCloseOptions`.
        """

        raise NotImplementedError
    def subscribe_to(self, urls: "typing.List[RelayUrl]",filter: "Filter",opts: "typing.Union[object, typing.Optional[SubscribeAutoCloseOptions]]" = _DEFAULT):
        """
        Subscribe to filters to specific relays

        ### Auto-closing subscription

        It's possible to automatically close a subscription by configuring the `SubscribeAutoCloseOptions`.
        """

        raise NotImplementedError
    def subscribe_with_id(self, id: "str",filter: "Filter",opts: "typing.Union[object, typing.Optional[SubscribeAutoCloseOptions]]" = _DEFAULT):
        """
        Subscribe to filters with custom subscription ID

        If `gossip` is enabled (see `Options]) the events will be requested also to
        NIP65 relays (automatically discovered) of public keys included in filters (if any).

        ### Auto-closing subscription

        It's possible to automatically close a subscription by configuring the `SubscribeAutoCloseOptions`.
        """

        raise NotImplementedError
    def subscribe_with_id_to(self, urls: "typing.List[RelayUrl]",id: "str",filter: "Filter",opts: "typing.Union[object, typing.Optional[SubscribeAutoCloseOptions]]" = _DEFAULT):
        """
        Subscribe to filters with custom subscription ID to specific relays

        ### Auto-closing subscription

        It's possible to automatically close a subscription by configuring the `SubscribeAutoCloseOptions`.
        """

        raise NotImplementedError
    def subscription(self, id: "str"):
        raise NotImplementedError
    def subscriptions(self, ):
        raise NotImplementedError
    def sync(self, filter: "Filter",opts: "SyncOptions"):
        """
        Sync events with relays (negentropy reconciliation)

        If `gossip` is enabled (see `Options`) the events will be reconciled also with
        NIP65 relays (automatically discovered) of public keys included in filters (if any).

        <https://github.com/hoytech/negentropy>
        """

        raise NotImplementedError
    def try_connect(self, timeout: "Duration"):
        """
        Try to establish a connection with the relays.

        Attempts to establish a connection for every relay currently in
        [`RelayStatus::Initialized`] or [`RelayStatus::Terminated`]
        without spawning the connection task if it fails.
        This means that if the connection fails, no automatic retries are scheduled.
        Use [`Client::connect`] if you want to immediately spawn a connection task,
        regardless of whether the initial connection succeeds.

        For further details, see the documentation of [`Relay::try_connect`].
        """

        raise NotImplementedError
    def unsubscribe(self, subscription_id: "str"):
        raise NotImplementedError
    def unsubscribe_all(self, ):
        raise NotImplementedError
    def unwrap_gift_wrap(self, gift_wrap: "Event"):
        """
        Unwrap Gift Wrap event

        Internally verify the `seal` event

        <https://github.com/nostr-protocol/nips/blob/master/59.md>
        """

        raise NotImplementedError
    def wait_for_connection(self, timeout: "Duration"):
        """
        Waits for relays connections

        Wait for relays connections at most for the specified `timeout`.
        The code continues when the relays are connected or the `timeout` is reached.
        """

        raise NotImplementedError
# Client is a Rust-only trait - it's a wrapper around a Rust implementation.
class Client():
    _pointer: ctypes.c_void_p
    def __init__(self, signer: "typing.Union[object, typing.Optional[NostrSigner]]" = _DEFAULT):
        if signer is _DEFAULT:
            signer = None
        _UniffiConverterOptionalTypeNostrSigner.check_lower(signer)
        
        self._pointer = _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_client_new,
        _UniffiConverterOptionalTypeNostrSigner.lower(signer))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_client, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_client, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    async def add_discovery_relay(self, url: "RelayUrl") -> "bool":
        """
        Add discovery relay

        If relay already exists, this method automatically add the `DISCOVERY` flag to it and return `false`.

        <https://github.com/nostr-protocol/nips/blob/master/65.md>
        """

        _UniffiConverterTypeRelayUrl.check_lower(url)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_nostr_sdk_ffi_fn_method_client_add_discovery_relay(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeRelayUrl.lower(url)
            ),
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_poll_i8,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_complete_i8,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_free_i8,
            # lift function
            _UniffiConverterBool.lift,
            
    # Error FFI converter
_UniffiConverterTypeNostrSdkError,

        )



    async def add_read_relay(self, url: "RelayUrl") -> "bool":
        """
        Add read relay

        If relay already exists, this method add the `READ` flag to it and return `false`.
        """

        _UniffiConverterTypeRelayUrl.check_lower(url)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_nostr_sdk_ffi_fn_method_client_add_read_relay(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeRelayUrl.lower(url)
            ),
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_poll_i8,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_complete_i8,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_free_i8,
            # lift function
            _UniffiConverterBool.lift,
            
    # Error FFI converter
_UniffiConverterTypeNostrSdkError,

        )



    async def add_relay(self, url: "RelayUrl") -> "bool":
        """
        Add new relay

        Relays added with this method will have both `READ` and `WRITE` flags enabled

        If the relay already exists, the flags will be updated and `false` returned.

        If are set pool subscriptions, the new added relay will inherit them. Use `subscribe_to` method instead of `subscribe`,
        to avoid to set pool subscriptions.

        This method use previously set or default `Options` to configure the `Relay` (ex. set proxy, set min POW, set relay limits, ...).

        Connection is **NOT** automatically started with relay, remember to call `connect` method!
        """

        _UniffiConverterTypeRelayUrl.check_lower(url)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_nostr_sdk_ffi_fn_method_client_add_relay(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeRelayUrl.lower(url)
            ),
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_poll_i8,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_complete_i8,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_free_i8,
            # lift function
            _UniffiConverterBool.lift,
            
    # Error FFI converter
_UniffiConverterTypeNostrSdkError,

        )



    async def add_relay_with_opts(self, url: "RelayUrl",opts: "RelayOptions") -> "bool":
        """
        Add new relay with custom options
        """

        _UniffiConverterTypeRelayUrl.check_lower(url)
        
        _UniffiConverterTypeRelayOptions.check_lower(opts)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_nostr_sdk_ffi_fn_method_client_add_relay_with_opts(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeRelayUrl.lower(url),
        _UniffiConverterTypeRelayOptions.lower(opts)
            ),
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_poll_i8,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_complete_i8,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_free_i8,
            # lift function
            _UniffiConverterBool.lift,
            
    # Error FFI converter
_UniffiConverterTypeNostrSdkError,

        )



    async def add_write_relay(self, url: "RelayUrl") -> "bool":
        """
        Add write relay

        If relay already exists, this method add the `WRITE` flag to it and return `false`.
        """

        _UniffiConverterTypeRelayUrl.check_lower(url)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_nostr_sdk_ffi_fn_method_client_add_write_relay(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeRelayUrl.lower(url)
            ),
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_poll_i8,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_complete_i8,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_free_i8,
            # lift function
            _UniffiConverterBool.lift,
            
    # Error FFI converter
_UniffiConverterTypeNostrSdkError,

        )




    def automatic_authentication(self, enable: "bool") -> None:
        """
        Auto authenticate to relays (default: true)

        <https://github.com/nostr-protocol/nips/blob/master/42.md>
        """

        _UniffiConverterBool.check_lower(enable)
        
        _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_client_automatic_authentication,self._uniffi_clone_pointer(),
        _UniffiConverterBool.lower(enable))





    async def connect(self, ) -> None:

        """
        Connect to all added relays

        Attempts to initiate a connection for every relay currently in
        [`RelayStatus::Initialized`] or [`RelayStatus::Terminated`].
        A background connection task is spawned for each such relay, which then tries
        to establish the connection.
        Any relay not in one of these two statuses is skipped.

        For further details, see the documentation of [`Relay::connect`].
        """

        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_nostr_sdk_ffi_fn_method_client_connect(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_poll_void,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_complete_void,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter

    None,

        )



    async def connect_relay(self, url: "RelayUrl") -> None:

        """
        Connect to a previously added relay
        """

        _UniffiConverterTypeRelayUrl.check_lower(url)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_nostr_sdk_ffi_fn_method_client_connect_relay(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeRelayUrl.lower(url)
            ),
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_poll_void,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_complete_void,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeNostrSdkError,

        )




    def database(self, ) -> "NostrDatabase":
        return _UniffiConverterTypeNostrDatabase.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_client_database,self._uniffi_clone_pointer(),)
        )




    async def disconnect(self, ) -> None:

        """
        Disconnect from all relays
        """

        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_nostr_sdk_ffi_fn_method_client_disconnect(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_poll_void,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_complete_void,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter

    None,

        )



    async def disconnect_relay(self, url: "RelayUrl") -> None:

        _UniffiConverterTypeRelayUrl.check_lower(url)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_nostr_sdk_ffi_fn_method_client_disconnect_relay(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeRelayUrl.lower(url)
            ),
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_poll_void,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_complete_void,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeNostrSdkError,

        )



    async def fetch_combined_events(self, filter: "Filter",timeout: "Duration") -> "Events":
        """
        Get events both from database and relays

        This is an auto-closing subscription and will be closed automatically on `EOSE`.

        You can obtain the same result by merging the `Events` from different type of sources.

        This method will be deprecated in the future!
        This is a temporary solution for who still want to query events both from database and relays and merge the result.
        The optimal solution is to execute a [`Client::sync`] to get all old events, [`Client::subscribe`] to get all
        new future events, [`NostrDatabase::query`] to query events and [`Client::handle_notifications`] to listen-for/handle new events (i.e. to know when update the UI).
        This will allow very fast queries, low bandwidth usage (depending on how many events the client have to sync) and a low load on relays.

        # Gossip

        If `gossip` is enabled (see [`Options::gossip`]) the events will be requested also to
        NIP65 relays (automatically discovered) of public keys included in filters (if any).
        """

        _UniffiConverterTypeFilter.check_lower(filter)
        
        _UniffiConverterDuration.check_lower(timeout)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_nostr_sdk_ffi_fn_method_client_fetch_combined_events(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeFilter.lower(filter),
        _UniffiConverterDuration.lower(timeout)
            ),
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_poll_pointer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_complete_pointer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_free_pointer,
            # lift function
            _UniffiConverterTypeEvents.lift,
            
    # Error FFI converter
_UniffiConverterTypeNostrSdkError,

        )



    async def fetch_events(self, filter: "Filter",timeout: "Duration") -> "Events":
        """
        Fetch events from relays

        This is an auto-closing subscription and will be closed automatically on `EOSE`.

        # Gossip

        If `gossip` is enabled (see `Options`) the events will be requested also to
        NIP65 relays (automatically discovered) of public keys included in filters (if any).
        """

        _UniffiConverterTypeFilter.check_lower(filter)
        
        _UniffiConverterDuration.check_lower(timeout)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_nostr_sdk_ffi_fn_method_client_fetch_events(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeFilter.lower(filter),
        _UniffiConverterDuration.lower(timeout)
            ),
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_poll_pointer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_complete_pointer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_free_pointer,
            # lift function
            _UniffiConverterTypeEvents.lift,
            
    # Error FFI converter
_UniffiConverterTypeNostrSdkError,

        )



    async def fetch_events_from(self, urls: "typing.List[RelayUrl]",filter: "Filter",timeout: "Duration") -> "Events":
        """
        Fetch events from specific relays

        This is an auto-closing subscription and will be closed automatically on `EOSE`.
        """

        _UniffiConverterSequenceTypeRelayUrl.check_lower(urls)
        
        _UniffiConverterTypeFilter.check_lower(filter)
        
        _UniffiConverterDuration.check_lower(timeout)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_nostr_sdk_ffi_fn_method_client_fetch_events_from(
                self._uniffi_clone_pointer(), 
        _UniffiConverterSequenceTypeRelayUrl.lower(urls),
        _UniffiConverterTypeFilter.lower(filter),
        _UniffiConverterDuration.lower(timeout)
            ),
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_poll_pointer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_complete_pointer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_free_pointer,
            # lift function
            _UniffiConverterTypeEvents.lift,
            
    # Error FFI converter
_UniffiConverterTypeNostrSdkError,

        )



    async def fetch_metadata(self, public_key: "PublicKey",timeout: "Duration") -> "typing.Optional[Metadata]":
        """
        Fetch the newest public key metadata from relays.

        Returns `None` if the `Metadata` of the `PublicKey` has not been found.

        Check `Client::fetch_events` for more details.

        If you only want to consult cached data,
        consider `client.database().profile(PUBKEY)`.

        <https://github.com/nostr-protocol/nips/blob/master/01.md>
        """

        _UniffiConverterTypePublicKey.check_lower(public_key)
        
        _UniffiConverterDuration.check_lower(timeout)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_nostr_sdk_ffi_fn_method_client_fetch_metadata(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypePublicKey.lower(public_key),
        _UniffiConverterDuration.lower(timeout)
            ),
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterOptionalTypeMetadata.lift,
            
    # Error FFI converter
_UniffiConverterTypeNostrSdkError,

        )



    async def force_remove_all_relays(self, ) -> None:

        """
        Disconnect and force remove all relays
        """

        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_nostr_sdk_ffi_fn_method_client_force_remove_all_relays(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_poll_void,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_complete_void,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter

    None,

        )



    async def force_remove_relay(self, url: "RelayUrl") -> None:

        """
        Force remove and disconnect relay

        Note: this method will remove the relay, also if it's in use for the gossip model or other service!
        """

        _UniffiConverterTypeRelayUrl.check_lower(url)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_nostr_sdk_ffi_fn_method_client_force_remove_relay(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeRelayUrl.lower(url)
            ),
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_poll_void,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_complete_void,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeNostrSdkError,

        )



    async def gift_wrap(self, receiver: "PublicKey",rumor: "UnsignedEvent",extra_tags: "typing.List[Tag]") -> "SendEventOutput":
        """
        Construct Gift Wrap and send to relays

        Check `send_event` method to know how sending events works.

        <https://github.com/nostr-protocol/nips/blob/master/59.md>
        """

        _UniffiConverterTypePublicKey.check_lower(receiver)
        
        _UniffiConverterTypeUnsignedEvent.check_lower(rumor)
        
        _UniffiConverterSequenceTypeTag.check_lower(extra_tags)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_nostr_sdk_ffi_fn_method_client_gift_wrap(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypePublicKey.lower(receiver),
        _UniffiConverterTypeUnsignedEvent.lower(rumor),
        _UniffiConverterSequenceTypeTag.lower(extra_tags)
            ),
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeSendEventOutput.lift,
            
    # Error FFI converter
_UniffiConverterTypeNostrSdkError,

        )



    async def gift_wrap_to(self, urls: "typing.List[RelayUrl]",receiver: "PublicKey",rumor: "UnsignedEvent",extra_tags: "typing.List[Tag]") -> "SendEventOutput":
        """
        Construct Gift Wrap and send to specific relays

        <https://github.com/nostr-protocol/nips/blob/master/59.md>
        """

        _UniffiConverterSequenceTypeRelayUrl.check_lower(urls)
        
        _UniffiConverterTypePublicKey.check_lower(receiver)
        
        _UniffiConverterTypeUnsignedEvent.check_lower(rumor)
        
        _UniffiConverterSequenceTypeTag.check_lower(extra_tags)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_nostr_sdk_ffi_fn_method_client_gift_wrap_to(
                self._uniffi_clone_pointer(), 
        _UniffiConverterSequenceTypeRelayUrl.lower(urls),
        _UniffiConverterTypePublicKey.lower(receiver),
        _UniffiConverterTypeUnsignedEvent.lower(rumor),
        _UniffiConverterSequenceTypeTag.lower(extra_tags)
            ),
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeSendEventOutput.lift,
            
    # Error FFI converter
_UniffiConverterTypeNostrSdkError,

        )



    async def handle_notifications(self, handler: "HandleNotification") -> None:

        """
        Handle notifications
        """

        _UniffiConverterTypeHandleNotification.check_lower(handler)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_nostr_sdk_ffi_fn_method_client_handle_notifications(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeHandleNotification.lower(handler)
            ),
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_poll_void,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_complete_void,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeNostrSdkError,

        )



    async def relay(self, url: "RelayUrl") -> "Relay":
        _UniffiConverterTypeRelayUrl.check_lower(url)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_nostr_sdk_ffi_fn_method_client_relay(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeRelayUrl.lower(url)
            ),
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_poll_pointer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_complete_pointer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_free_pointer,
            # lift function
            _UniffiConverterTypeRelay.lift,
            
    # Error FFI converter
_UniffiConverterTypeNostrSdkError,

        )



    async def relays(self, ) -> "dict[RelayUrl, Relay]":
        """
        Get relays with `READ` or `WRITE` flags
        """

        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_nostr_sdk_ffi_fn_method_client_relays(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterMapTypeRelayUrlTypeRelay.lift,
            
    # Error FFI converter

    None,

        )



    async def remove_all_relays(self, ) -> None:

        """
        Disconnect and remove all relays

        Some relays used by some services could not be disconnected with this method
        (like the ones used for gossip).
        Use [`Client::force_remove_all_relays`] to remove every relay.
        """

        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_nostr_sdk_ffi_fn_method_client_remove_all_relays(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_poll_void,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_complete_void,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter

    None,

        )



    async def remove_relay(self, url: "RelayUrl") -> None:

        """
        Remove and disconnect relay

        If the relay has `GOSSIP` flag, it will not be removed from the pool and its
        flags will be updated (remove `READ`, `WRITE` and `DISCOVERY` flags).
        """

        _UniffiConverterTypeRelayUrl.check_lower(url)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_nostr_sdk_ffi_fn_method_client_remove_relay(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeRelayUrl.lower(url)
            ),
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_poll_void,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_complete_void,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeNostrSdkError,

        )



    async def send_event(self, event: "Event") -> "SendEventOutput":
        """
        Send event

        Send event to all relays with `WRITE` flag.
        If `gossip` is enabled (see `Options`) the event will be sent also to NIP65 relays (automatically discovered).
        """

        _UniffiConverterTypeEvent.check_lower(event)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_nostr_sdk_ffi_fn_method_client_send_event(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeEvent.lower(event)
            ),
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeSendEventOutput.lift,
            
    # Error FFI converter
_UniffiConverterTypeNostrSdkError,

        )



    async def send_event_builder(self, builder: "EventBuilder") -> "SendEventOutput":
        """
        Take an `EventBuilder`, sign it by using the `NostrSigner` and broadcast to relays (check `send_event` method for more details)

        Rise an error if the `NostrSigner` is not set.
        """

        _UniffiConverterTypeEventBuilder.check_lower(builder)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_nostr_sdk_ffi_fn_method_client_send_event_builder(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeEventBuilder.lower(builder)
            ),
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeSendEventOutput.lift,
            
    # Error FFI converter
_UniffiConverterTypeNostrSdkError,

        )



    async def send_event_builder_to(self, urls: "typing.List[RelayUrl]",builder: "EventBuilder") -> "SendEventOutput":
        """
        Take an `EventBuilder`, sign it by using the `NostrSigner` and broadcast to specific relays.

        Rise an error if the `NostrSigner` is not set.
        """

        _UniffiConverterSequenceTypeRelayUrl.check_lower(urls)
        
        _UniffiConverterTypeEventBuilder.check_lower(builder)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_nostr_sdk_ffi_fn_method_client_send_event_builder_to(
                self._uniffi_clone_pointer(), 
        _UniffiConverterSequenceTypeRelayUrl.lower(urls),
        _UniffiConverterTypeEventBuilder.lower(builder)
            ),
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeSendEventOutput.lift,
            
    # Error FFI converter
_UniffiConverterTypeNostrSdkError,

        )



    async def send_event_to(self, urls: "typing.List[RelayUrl]",event: "Event") -> "SendEventOutput":
        """
        Send event to specific relays.
        """

        _UniffiConverterSequenceTypeRelayUrl.check_lower(urls)
        
        _UniffiConverterTypeEvent.check_lower(event)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_nostr_sdk_ffi_fn_method_client_send_event_to(
                self._uniffi_clone_pointer(), 
        _UniffiConverterSequenceTypeRelayUrl.lower(urls),
        _UniffiConverterTypeEvent.lower(event)
            ),
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeSendEventOutput.lift,
            
    # Error FFI converter
_UniffiConverterTypeNostrSdkError,

        )



    async def send_msg_to(self, urls: "typing.List[RelayUrl]",msg: "ClientMessage") -> "Output":
        _UniffiConverterSequenceTypeRelayUrl.check_lower(urls)
        
        _UniffiConverterTypeClientMessage.check_lower(msg)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_nostr_sdk_ffi_fn_method_client_send_msg_to(
                self._uniffi_clone_pointer(), 
        _UniffiConverterSequenceTypeRelayUrl.lower(urls),
        _UniffiConverterTypeClientMessage.lower(msg)
            ),
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeOutput.lift,
            
    # Error FFI converter
_UniffiConverterTypeNostrSdkError,

        )



    async def send_private_msg(self, receiver: "PublicKey",message: "str",rumor_extra_tags: "typing.Union[object, typing.List[Tag]]" = _DEFAULT) -> "SendEventOutput":
        """
        Send a private direct message

        If gossip is enabled, the message will be sent to the NIP17 relays (automatically discovered).
        If gossip is not enabled will be sent to all relays with WRITE` relay service flag.

        <https://github.com/nostr-protocol/nips/blob/master/17.md>
        """

        _UniffiConverterTypePublicKey.check_lower(receiver)
        
        _UniffiConverterString.check_lower(message)
        
        if rumor_extra_tags is _DEFAULT:
            rumor_extra_tags = []
        _UniffiConverterSequenceTypeTag.check_lower(rumor_extra_tags)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_nostr_sdk_ffi_fn_method_client_send_private_msg(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypePublicKey.lower(receiver),
        _UniffiConverterString.lower(message),
        _UniffiConverterSequenceTypeTag.lower(rumor_extra_tags)
            ),
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeSendEventOutput.lift,
            
    # Error FFI converter
_UniffiConverterTypeNostrSdkError,

        )



    async def send_private_msg_to(self, urls: "typing.List[RelayUrl]",receiver: "PublicKey",message: "str",rumor_extra_tags: "typing.Union[object, typing.List[Tag]]" = _DEFAULT) -> "SendEventOutput":
        """
        Send private direct message to specific relays

        <https://github.com/nostr-protocol/nips/blob/master/17.md>
        """

        _UniffiConverterSequenceTypeRelayUrl.check_lower(urls)
        
        _UniffiConverterTypePublicKey.check_lower(receiver)
        
        _UniffiConverterString.check_lower(message)
        
        if rumor_extra_tags is _DEFAULT:
            rumor_extra_tags = []
        _UniffiConverterSequenceTypeTag.check_lower(rumor_extra_tags)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_nostr_sdk_ffi_fn_method_client_send_private_msg_to(
                self._uniffi_clone_pointer(), 
        _UniffiConverterSequenceTypeRelayUrl.lower(urls),
        _UniffiConverterTypePublicKey.lower(receiver),
        _UniffiConverterString.lower(message),
        _UniffiConverterSequenceTypeTag.lower(rumor_extra_tags)
            ),
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeSendEventOutput.lift,
            
    # Error FFI converter
_UniffiConverterTypeNostrSdkError,

        )



    async def set_metadata(self, metadata: "Metadata") -> "SendEventOutput":
        _UniffiConverterTypeMetadata.check_lower(metadata)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_nostr_sdk_ffi_fn_method_client_set_metadata(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeMetadata.lower(metadata)
            ),
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeSendEventOutput.lift,
            
    # Error FFI converter
_UniffiConverterTypeNostrSdkError,

        )



    async def shutdown(self, ) -> None:

        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_nostr_sdk_ffi_fn_method_client_shutdown(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_poll_void,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_complete_void,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter

    None,

        )



    async def sign_event_builder(self, builder: "EventBuilder") -> "Event":
        """
        Signs the `EventBuilder` into an `Event` using the `NostrSigner`
        """

        _UniffiConverterTypeEventBuilder.check_lower(builder)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_nostr_sdk_ffi_fn_method_client_sign_event_builder(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeEventBuilder.lower(builder)
            ),
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_poll_pointer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_complete_pointer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_free_pointer,
            # lift function
            _UniffiConverterTypeEvent.lift,
            
    # Error FFI converter
_UniffiConverterTypeNostrSdkError,

        )



    async def signer(self, ) -> "NostrSigner":
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_nostr_sdk_ffi_fn_method_client_signer(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_poll_pointer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_complete_pointer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_free_pointer,
            # lift function
            _UniffiConverterTypeNostrSigner.lift,
            
    # Error FFI converter
_UniffiConverterTypeNostrSdkError,

        )



    async def stream_events(self, filter: "Filter",timeout: "Duration") -> "EventStream":
        """
        Stream events from relays

        # Overview

        This is an **auto-closing subscription** and will be closed automatically on `EOSE`.
        For long-lived subscriptions, check [`Client::subscribe`].

        # Gossip

        If `gossip` is enabled the events will be streamed also from
        NIP65 relays (automatically discovered) of public keys included in filters (if any).
        """

        _UniffiConverterTypeFilter.check_lower(filter)
        
        _UniffiConverterDuration.check_lower(timeout)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_nostr_sdk_ffi_fn_method_client_stream_events(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeFilter.lower(filter),
        _UniffiConverterDuration.lower(timeout)
            ),
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_poll_pointer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_complete_pointer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_free_pointer,
            # lift function
            _UniffiConverterTypeEventStream.lift,
            
    # Error FFI converter
_UniffiConverterTypeNostrSdkError,

        )



    async def stream_events_from(self, urls: "typing.List[RelayUrl]",filter: "Filter",timeout: "Duration") -> "EventStream":
        """
        Stream events from specific relays

        # Overview

        This is an **auto-closing subscription** and will be closed automatically on `EOSE`.
        For long-lived subscriptions, check [`Client::subscribe_to`].
        """

        _UniffiConverterSequenceTypeRelayUrl.check_lower(urls)
        
        _UniffiConverterTypeFilter.check_lower(filter)
        
        _UniffiConverterDuration.check_lower(timeout)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_nostr_sdk_ffi_fn_method_client_stream_events_from(
                self._uniffi_clone_pointer(), 
        _UniffiConverterSequenceTypeRelayUrl.lower(urls),
        _UniffiConverterTypeFilter.lower(filter),
        _UniffiConverterDuration.lower(timeout)
            ),
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_poll_pointer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_complete_pointer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_free_pointer,
            # lift function
            _UniffiConverterTypeEventStream.lift,
            
    # Error FFI converter
_UniffiConverterTypeNostrSdkError,

        )



    async def stream_events_targeted(self, targets: "dict[RelayUrl, Filter]",timeout: "Duration") -> "EventStream":
        """
        Stream events from specific relays with specific filters

        # Overview

        This is an **auto-closing subscription** and will be closed automatically on `EOSE`.
        """

        _UniffiConverterMapTypeRelayUrlTypeFilter.check_lower(targets)
        
        _UniffiConverterDuration.check_lower(timeout)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_nostr_sdk_ffi_fn_method_client_stream_events_targeted(
                self._uniffi_clone_pointer(), 
        _UniffiConverterMapTypeRelayUrlTypeFilter.lower(targets),
        _UniffiConverterDuration.lower(timeout)
            ),
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_poll_pointer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_complete_pointer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_free_pointer,
            # lift function
            _UniffiConverterTypeEventStream.lift,
            
    # Error FFI converter
_UniffiConverterTypeNostrSdkError,

        )



    async def subscribe(self, filter: "Filter",opts: "typing.Union[object, typing.Optional[SubscribeAutoCloseOptions]]" = _DEFAULT) -> "SubscribeOutput":
        """
        Subscribe to filters

        If `gossip` is enabled (see `Options]) the events will be requested also to
        NIP65 relays (automatically discovered) of public keys included in filters (if any).

        ### Auto-closing subscription

        It's possible to automatically close a subscription by configuring the `SubscribeAutoCloseOptions`.
        """

        _UniffiConverterTypeFilter.check_lower(filter)
        
        if opts is _DEFAULT:
            opts = None
        _UniffiConverterOptionalTypeSubscribeAutoCloseOptions.check_lower(opts)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_nostr_sdk_ffi_fn_method_client_subscribe(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeFilter.lower(filter),
        _UniffiConverterOptionalTypeSubscribeAutoCloseOptions.lower(opts)
            ),
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeSubscribeOutput.lift,
            
    # Error FFI converter
_UniffiConverterTypeNostrSdkError,

        )



    async def subscribe_to(self, urls: "typing.List[RelayUrl]",filter: "Filter",opts: "typing.Union[object, typing.Optional[SubscribeAutoCloseOptions]]" = _DEFAULT) -> "SubscribeOutput":
        """
        Subscribe to filters to specific relays

        ### Auto-closing subscription

        It's possible to automatically close a subscription by configuring the `SubscribeAutoCloseOptions`.
        """

        _UniffiConverterSequenceTypeRelayUrl.check_lower(urls)
        
        _UniffiConverterTypeFilter.check_lower(filter)
        
        if opts is _DEFAULT:
            opts = None
        _UniffiConverterOptionalTypeSubscribeAutoCloseOptions.check_lower(opts)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_nostr_sdk_ffi_fn_method_client_subscribe_to(
                self._uniffi_clone_pointer(), 
        _UniffiConverterSequenceTypeRelayUrl.lower(urls),
        _UniffiConverterTypeFilter.lower(filter),
        _UniffiConverterOptionalTypeSubscribeAutoCloseOptions.lower(opts)
            ),
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeSubscribeOutput.lift,
            
    # Error FFI converter
_UniffiConverterTypeNostrSdkError,

        )



    async def subscribe_with_id(self, id: "str",filter: "Filter",opts: "typing.Union[object, typing.Optional[SubscribeAutoCloseOptions]]" = _DEFAULT) -> "Output":
        """
        Subscribe to filters with custom subscription ID

        If `gossip` is enabled (see `Options]) the events will be requested also to
        NIP65 relays (automatically discovered) of public keys included in filters (if any).

        ### Auto-closing subscription

        It's possible to automatically close a subscription by configuring the `SubscribeAutoCloseOptions`.
        """

        _UniffiConverterString.check_lower(id)
        
        _UniffiConverterTypeFilter.check_lower(filter)
        
        if opts is _DEFAULT:
            opts = None
        _UniffiConverterOptionalTypeSubscribeAutoCloseOptions.check_lower(opts)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_nostr_sdk_ffi_fn_method_client_subscribe_with_id(
                self._uniffi_clone_pointer(), 
        _UniffiConverterString.lower(id),
        _UniffiConverterTypeFilter.lower(filter),
        _UniffiConverterOptionalTypeSubscribeAutoCloseOptions.lower(opts)
            ),
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeOutput.lift,
            
    # Error FFI converter
_UniffiConverterTypeNostrSdkError,

        )



    async def subscribe_with_id_to(self, urls: "typing.List[RelayUrl]",id: "str",filter: "Filter",opts: "typing.Union[object, typing.Optional[SubscribeAutoCloseOptions]]" = _DEFAULT) -> "Output":
        """
        Subscribe to filters with custom subscription ID to specific relays

        ### Auto-closing subscription

        It's possible to automatically close a subscription by configuring the `SubscribeAutoCloseOptions`.
        """

        _UniffiConverterSequenceTypeRelayUrl.check_lower(urls)
        
        _UniffiConverterString.check_lower(id)
        
        _UniffiConverterTypeFilter.check_lower(filter)
        
        if opts is _DEFAULT:
            opts = None
        _UniffiConverterOptionalTypeSubscribeAutoCloseOptions.check_lower(opts)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_nostr_sdk_ffi_fn_method_client_subscribe_with_id_to(
                self._uniffi_clone_pointer(), 
        _UniffiConverterSequenceTypeRelayUrl.lower(urls),
        _UniffiConverterString.lower(id),
        _UniffiConverterTypeFilter.lower(filter),
        _UniffiConverterOptionalTypeSubscribeAutoCloseOptions.lower(opts)
            ),
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeOutput.lift,
            
    # Error FFI converter
_UniffiConverterTypeNostrSdkError,

        )



    async def subscription(self, id: "str") -> "dict[RelayUrl, typing.List[Filter]]":
        _UniffiConverterString.check_lower(id)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_nostr_sdk_ffi_fn_method_client_subscription(
                self._uniffi_clone_pointer(), 
        _UniffiConverterString.lower(id)
            ),
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterMapTypeRelayUrlSequenceTypeFilter.lift,
            
    # Error FFI converter

    None,

        )



    async def subscriptions(self, ) -> "dict[str, dict[RelayUrl, typing.List[Filter]]]":
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_nostr_sdk_ffi_fn_method_client_subscriptions(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterMapStringMapTypeRelayUrlSequenceTypeFilter.lift,
            
    # Error FFI converter

    None,

        )



    async def sync(self, filter: "Filter",opts: "SyncOptions") -> "ReconciliationOutput":
        """
        Sync events with relays (negentropy reconciliation)

        If `gossip` is enabled (see `Options`) the events will be reconciled also with
        NIP65 relays (automatically discovered) of public keys included in filters (if any).

        <https://github.com/hoytech/negentropy>
        """

        _UniffiConverterTypeFilter.check_lower(filter)
        
        _UniffiConverterTypeSyncOptions.check_lower(opts)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_nostr_sdk_ffi_fn_method_client_sync(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeFilter.lower(filter),
        _UniffiConverterTypeSyncOptions.lower(opts)
            ),
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeReconciliationOutput.lift,
            
    # Error FFI converter
_UniffiConverterTypeNostrSdkError,

        )



    async def try_connect(self, timeout: "Duration") -> "Output":
        """
        Try to establish a connection with the relays.

        Attempts to establish a connection for every relay currently in
        [`RelayStatus::Initialized`] or [`RelayStatus::Terminated`]
        without spawning the connection task if it fails.
        This means that if the connection fails, no automatic retries are scheduled.
        Use [`Client::connect`] if you want to immediately spawn a connection task,
        regardless of whether the initial connection succeeds.

        For further details, see the documentation of [`Relay::try_connect`].
        """

        _UniffiConverterDuration.check_lower(timeout)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_nostr_sdk_ffi_fn_method_client_try_connect(
                self._uniffi_clone_pointer(), 
        _UniffiConverterDuration.lower(timeout)
            ),
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeOutput.lift,
            
    # Error FFI converter

    None,

        )



    async def unsubscribe(self, subscription_id: "str") -> None:

        _UniffiConverterString.check_lower(subscription_id)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_nostr_sdk_ffi_fn_method_client_unsubscribe(
                self._uniffi_clone_pointer(), 
        _UniffiConverterString.lower(subscription_id)
            ),
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_poll_void,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_complete_void,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter

    None,

        )



    async def unsubscribe_all(self, ) -> None:

        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_nostr_sdk_ffi_fn_method_client_unsubscribe_all(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_poll_void,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_complete_void,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter

    None,

        )



    async def unwrap_gift_wrap(self, gift_wrap: "Event") -> "UnwrappedGift":
        """
        Unwrap Gift Wrap event

        Internally verify the `seal` event

        <https://github.com/nostr-protocol/nips/blob/master/59.md>
        """

        _UniffiConverterTypeEvent.check_lower(gift_wrap)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_nostr_sdk_ffi_fn_method_client_unwrap_gift_wrap(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeEvent.lower(gift_wrap)
            ),
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_poll_pointer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_complete_pointer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_free_pointer,
            # lift function
            _UniffiConverterTypeUnwrappedGift.lift,
            
    # Error FFI converter
_UniffiConverterTypeNostrSdkError,

        )



    async def wait_for_connection(self, timeout: "Duration") -> None:

        """
        Waits for relays connections

        Wait for relays connections at most for the specified `timeout`.
        The code continues when the relays are connected or the `timeout` is reached.
        """

        _UniffiConverterDuration.check_lower(timeout)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_nostr_sdk_ffi_fn_method_client_wait_for_connection(
                self._uniffi_clone_pointer(), 
        _UniffiConverterDuration.lower(timeout)
            ),
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_poll_void,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_complete_void,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter

    None,

        )





class _UniffiConverterTypeClient:

    @staticmethod
    def lift(value: int):
        return Client._make_instance_(value)

    @staticmethod
    def check_lower(value: Client):
        if not isinstance(value, Client):
            raise TypeError("Expected Client instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: ClientProtocol):
        if not isinstance(value, Client):
            raise TypeError("Expected Client instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: ClientProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class ClientBuilderProtocol(typing.Protocol):
    def admit_policy(self, policy: "AdmitPolicy"):
        """
        Set an admission policy
        """

        raise NotImplementedError
    def build(self, ):
        """
        Build [`Client`]
        """

        raise NotImplementedError
    def database(self, database: "NostrDatabase"):
        raise NotImplementedError
    def gossip(self, gossip: "NostrGossip"):
        """
        Set a gossip store
        """

        raise NotImplementedError
    def opts(self, opts: "ClientOptions"):
        """
        Set opts
        """

        raise NotImplementedError
    def signer(self, signer: "NostrSigner"):
        raise NotImplementedError
    def websocket_transport(self, transport: "CustomWebSocketTransport"):
        """
        Set a custom WebSocket transport
        """

        raise NotImplementedError
# ClientBuilder is a Rust-only trait - it's a wrapper around a Rust implementation.
class ClientBuilder():
    _pointer: ctypes.c_void_p
    def __init__(self, ):
        """
        New client builder
        """

        self._pointer = _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_clientbuilder_new,)

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_clientbuilder, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_clientbuilder, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def admit_policy(self, policy: "AdmitPolicy") -> "ClientBuilder":
        """
        Set an admission policy
        """

        _UniffiConverterTypeAdmitPolicy.check_lower(policy)
        
        return _UniffiConverterTypeClientBuilder.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_clientbuilder_admit_policy,self._uniffi_clone_pointer(),
        _UniffiConverterTypeAdmitPolicy.lower(policy))
        )





    def build(self, ) -> "Client":
        """
        Build [`Client`]
        """

        return _UniffiConverterTypeClient.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_clientbuilder_build,self._uniffi_clone_pointer(),)
        )





    def database(self, database: "NostrDatabase") -> "ClientBuilder":
        _UniffiConverterTypeNostrDatabase.check_lower(database)
        
        return _UniffiConverterTypeClientBuilder.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_clientbuilder_database,self._uniffi_clone_pointer(),
        _UniffiConverterTypeNostrDatabase.lower(database))
        )





    def gossip(self, gossip: "NostrGossip") -> "ClientBuilder":
        """
        Set a gossip store
        """

        _UniffiConverterTypeNostrGossip.check_lower(gossip)
        
        return _UniffiConverterTypeClientBuilder.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_clientbuilder_gossip,self._uniffi_clone_pointer(),
        _UniffiConverterTypeNostrGossip.lower(gossip))
        )





    def opts(self, opts: "ClientOptions") -> "ClientBuilder":
        """
        Set opts
        """

        _UniffiConverterTypeClientOptions.check_lower(opts)
        
        return _UniffiConverterTypeClientBuilder.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_clientbuilder_opts,self._uniffi_clone_pointer(),
        _UniffiConverterTypeClientOptions.lower(opts))
        )





    def signer(self, signer: "NostrSigner") -> "ClientBuilder":
        _UniffiConverterTypeNostrSigner.check_lower(signer)
        
        return _UniffiConverterTypeClientBuilder.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_clientbuilder_signer,self._uniffi_clone_pointer(),
        _UniffiConverterTypeNostrSigner.lower(signer))
        )





    def websocket_transport(self, transport: "CustomWebSocketTransport") -> "ClientBuilder":
        """
        Set a custom WebSocket transport
        """

        _UniffiConverterTypeCustomWebSocketTransport.check_lower(transport)
        
        return _UniffiConverterTypeClientBuilder.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_clientbuilder_websocket_transport,self._uniffi_clone_pointer(),
        _UniffiConverterTypeCustomWebSocketTransport.lower(transport))
        )






class _UniffiConverterTypeClientBuilder:

    @staticmethod
    def lift(value: int):
        return ClientBuilder._make_instance_(value)

    @staticmethod
    def check_lower(value: ClientBuilder):
        if not isinstance(value, ClientBuilder):
            raise TypeError("Expected ClientBuilder instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: ClientBuilderProtocol):
        if not isinstance(value, ClientBuilder):
            raise TypeError("Expected ClientBuilder instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: ClientBuilderProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class ClientMessageProtocol(typing.Protocol):
    def as_enum(self, ):
        """
        Clone `ClientMessage` and convert it to `ClientMessageEnum`
        """

        raise NotImplementedError
    def as_json(self, ):
        raise NotImplementedError
# ClientMessage is a Rust-only trait - it's a wrapper around a Rust implementation.
class ClientMessage():
    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_clientmessage, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_clientmessage, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst
    @classmethod
    def auth(cls, event: "Event"):
        """
        Create new `AUTH` message
        """

        _UniffiConverterTypeEvent.check_lower(event)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_clientmessage_auth,
        _UniffiConverterTypeEvent.lower(event))
        return cls._make_instance_(pointer)

    @classmethod
    def close(cls, subscription_id: "str"):
        """
        Create new `CLOSE` message
        """

        _UniffiConverterString.check_lower(subscription_id)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_clientmessage_close,
        _UniffiConverterString.lower(subscription_id))
        return cls._make_instance_(pointer)

    @classmethod
    def count(cls, subscription_id: "str",filter: "Filter"):
        """
        Create new `COUNT` message
        """

        _UniffiConverterString.check_lower(subscription_id)
        
        _UniffiConverterTypeFilter.check_lower(filter)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_clientmessage_count,
        _UniffiConverterString.lower(subscription_id),
        _UniffiConverterTypeFilter.lower(filter))
        return cls._make_instance_(pointer)

    @classmethod
    def event(cls, event: "Event"):
        """
        Create new `EVENT` message
        """

        _UniffiConverterTypeEvent.check_lower(event)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_clientmessage_event,
        _UniffiConverterTypeEvent.lower(event))
        return cls._make_instance_(pointer)

    @classmethod
    def from_enum(cls, e: "ClientMessageEnum"):
        """
        Convert `ClientMessageEnum` to `ClientMessage`
        """

        _UniffiConverterTypeClientMessageEnum.check_lower(e)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_clientmessage_from_enum,
        _UniffiConverterTypeClientMessageEnum.lower(e))
        return cls._make_instance_(pointer)

    @classmethod
    def from_json(cls, json: "str"):
        """
        Deserialize `ClientMessage` from JSON string

        **This method NOT verify the event signature!**
        """

        _UniffiConverterString.check_lower(json)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeNostrSdkError,_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_clientmessage_from_json,
        _UniffiConverterString.lower(json))
        return cls._make_instance_(pointer)

    @classmethod
    def req(cls, subscription_id: "str",filter: "Filter"):
        """
        Create new `REQ` message
        """

        _UniffiConverterString.check_lower(subscription_id)
        
        _UniffiConverterTypeFilter.check_lower(filter)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_clientmessage_req,
        _UniffiConverterString.lower(subscription_id),
        _UniffiConverterTypeFilter.lower(filter))
        return cls._make_instance_(pointer)



    def as_enum(self, ) -> "ClientMessageEnum":
        """
        Clone `ClientMessage` and convert it to `ClientMessageEnum`
        """

        return _UniffiConverterTypeClientMessageEnum.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_clientmessage_as_enum,self._uniffi_clone_pointer(),)
        )





    def as_json(self, ) -> "str":
        return _UniffiConverterString.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeNostrSdkError,_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_clientmessage_as_json,self._uniffi_clone_pointer(),)
        )





    def __repr__(self, ) -> "str":
        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_clientmessage_uniffi_trait_debug,self._uniffi_clone_pointer(),)
        )



    def __eq__(self, other: object) -> bool:
        if not isinstance(other, ClientMessage):
            return NotImplemented

        return _UniffiConverterBool.lift(_uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_clientmessage_uniffi_trait_eq_eq,self._uniffi_clone_pointer(),
        _UniffiConverterTypeClientMessage.lower(other)))

    def __ne__(self, other: object) -> bool:
        if not isinstance(other, ClientMessage):
            return NotImplemented

        return _UniffiConverterBool.lift(_uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_clientmessage_uniffi_trait_eq_ne,self._uniffi_clone_pointer(),
        _UniffiConverterTypeClientMessage.lower(other)))


    def __hash__(self, ) -> "int":
        return _UniffiConverterUInt64.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_clientmessage_uniffi_trait_hash,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeClientMessage:

    @staticmethod
    def lift(value: int):
        return ClientMessage._make_instance_(value)

    @staticmethod
    def check_lower(value: ClientMessage):
        if not isinstance(value, ClientMessage):
            raise TypeError("Expected ClientMessage instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: ClientMessageProtocol):
        if not isinstance(value, ClientMessage):
            raise TypeError("Expected ClientMessage instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: ClientMessageProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class ClientOptionsProtocol(typing.Protocol):
    """
    Nostr client options
    """

    def autoconnect(self, val: "bool"):
        """
        Automatically start connection with relays (default: false)

        When set to `true`, there isn't the need of calling the connect methods.
        """

        raise NotImplementedError
    def automatic_authentication(self, enabled: "bool"):
        """
        Auto authenticate to relays (default: true)

        <https://github.com/nostr-protocol/nips/blob/master/42.md>
        """

        raise NotImplementedError
    def ban_relay_on_mismatch(self, enable: "bool"):
        """
        If true, ban a relay when it sends an event that doesn't match the subscription filter.
        """

        raise NotImplementedError
    def connection(self, connection: "Connection"):
        """
        Connection
        """

        raise NotImplementedError
    def gossip(self, opts: "GossipOptions"):
        """
        Gossip options
        """

        raise NotImplementedError
    def max_avg_latency(self, max: "Duration"):
        """
        Set max latency (default: None)

        Relays with an avg. latency greater that this value will be skipped.
        """

        raise NotImplementedError
    def relay_limits(self, limits: "RelayLimits"):
        """
        Set custom relay limits
        """

        raise NotImplementedError
    def verify_subscriptions(self, enable: "bool"):
        """
        Verify that received events belong to a subscription and match the filter.
        """

        raise NotImplementedError
# ClientOptions is a Rust-only trait - it's a wrapper around a Rust implementation.
class ClientOptions():
    """
    Nostr client options
    """

    _pointer: ctypes.c_void_p
    def __init__(self, ):
        self._pointer = _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_clientoptions_new,)

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_clientoptions, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_clientoptions, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def autoconnect(self, val: "bool") -> "ClientOptions":
        """
        Automatically start connection with relays (default: false)

        When set to `true`, there isn't the need of calling the connect methods.
        """

        _UniffiConverterBool.check_lower(val)
        
        return _UniffiConverterTypeClientOptions.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_clientoptions_autoconnect,self._uniffi_clone_pointer(),
        _UniffiConverterBool.lower(val))
        )





    def automatic_authentication(self, enabled: "bool") -> "ClientOptions":
        """
        Auto authenticate to relays (default: true)

        <https://github.com/nostr-protocol/nips/blob/master/42.md>
        """

        _UniffiConverterBool.check_lower(enabled)
        
        return _UniffiConverterTypeClientOptions.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_clientoptions_automatic_authentication,self._uniffi_clone_pointer(),
        _UniffiConverterBool.lower(enabled))
        )





    def ban_relay_on_mismatch(self, enable: "bool") -> "ClientOptions":
        """
        If true, ban a relay when it sends an event that doesn't match the subscription filter.
        """

        _UniffiConverterBool.check_lower(enable)
        
        return _UniffiConverterTypeClientOptions.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_clientoptions_ban_relay_on_mismatch,self._uniffi_clone_pointer(),
        _UniffiConverterBool.lower(enable))
        )





    def connection(self, connection: "Connection") -> "ClientOptions":
        """
        Connection
        """

        _UniffiConverterTypeConnection.check_lower(connection)
        
        return _UniffiConverterTypeClientOptions.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_clientoptions_connection,self._uniffi_clone_pointer(),
        _UniffiConverterTypeConnection.lower(connection))
        )





    def gossip(self, opts: "GossipOptions") -> "ClientOptions":
        """
        Gossip options
        """

        _UniffiConverterTypeGossipOptions.check_lower(opts)
        
        return _UniffiConverterTypeClientOptions.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_clientoptions_gossip,self._uniffi_clone_pointer(),
        _UniffiConverterTypeGossipOptions.lower(opts))
        )





    def max_avg_latency(self, max: "Duration") -> "ClientOptions":
        """
        Set max latency (default: None)

        Relays with an avg. latency greater that this value will be skipped.
        """

        _UniffiConverterDuration.check_lower(max)
        
        return _UniffiConverterTypeClientOptions.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_clientoptions_max_avg_latency,self._uniffi_clone_pointer(),
        _UniffiConverterDuration.lower(max))
        )





    def relay_limits(self, limits: "RelayLimits") -> "ClientOptions":
        """
        Set custom relay limits
        """

        _UniffiConverterTypeRelayLimits.check_lower(limits)
        
        return _UniffiConverterTypeClientOptions.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_clientoptions_relay_limits,self._uniffi_clone_pointer(),
        _UniffiConverterTypeRelayLimits.lower(limits))
        )





    def verify_subscriptions(self, enable: "bool") -> "ClientOptions":
        """
        Verify that received events belong to a subscription and match the filter.
        """

        _UniffiConverterBool.check_lower(enable)
        
        return _UniffiConverterTypeClientOptions.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_clientoptions_verify_subscriptions,self._uniffi_clone_pointer(),
        _UniffiConverterBool.lower(enable))
        )






class _UniffiConverterTypeClientOptions:

    @staticmethod
    def lift(value: int):
        return ClientOptions._make_instance_(value)

    @staticmethod
    def check_lower(value: ClientOptions):
        if not isinstance(value, ClientOptions):
            raise TypeError("Expected ClientOptions instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: ClientOptionsProtocol):
        if not isinstance(value, ClientOptions):
            raise TypeError("Expected ClientOptions instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: ClientOptionsProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class ConnectionProtocol(typing.Protocol):
    """
    Connection
    """

    def addr(self, addr: "str"):
        """
        Set proxy (ex. `127.0.0.1:9050`)
        """

        raise NotImplementedError
    def mode(self, mode: "ConnectionMode"):
        """
        Set connection mode (default: direct)
        """

        raise NotImplementedError
    def target(self, target: "ConnectionTarget"):
        """
        Set connection target (default: all)
        """

        raise NotImplementedError
# Connection is a Rust-only trait - it's a wrapper around a Rust implementation.
class Connection():
    """
    Connection
    """

    _pointer: ctypes.c_void_p
    def __init__(self, ):
        self._pointer = _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_connection_new,)

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_connection, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_connection, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def addr(self, addr: "str") -> "Connection":
        """
        Set proxy (ex. `127.0.0.1:9050`)
        """

        _UniffiConverterString.check_lower(addr)
        
        return _UniffiConverterTypeConnection.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeNostrSdkError,_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_connection_addr,self._uniffi_clone_pointer(),
        _UniffiConverterString.lower(addr))
        )





    def mode(self, mode: "ConnectionMode") -> "Connection":
        """
        Set connection mode (default: direct)
        """

        _UniffiConverterTypeConnectionMode.check_lower(mode)
        
        return _UniffiConverterTypeConnection.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeNostrSdkError,_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_connection_mode,self._uniffi_clone_pointer(),
        _UniffiConverterTypeConnectionMode.lower(mode))
        )





    def target(self, target: "ConnectionTarget") -> "Connection":
        """
        Set connection target (default: all)
        """

        _UniffiConverterTypeConnectionTarget.check_lower(target)
        
        return _UniffiConverterTypeConnection.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_connection_target,self._uniffi_clone_pointer(),
        _UniffiConverterTypeConnectionTarget.lower(target))
        )





    def __repr__(self, ) -> "str":
        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_connection_uniffi_trait_debug,self._uniffi_clone_pointer(),)
        )



    def __eq__(self, other: object) -> bool:
        if not isinstance(other, Connection):
            return NotImplemented

        return _UniffiConverterBool.lift(_uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_connection_uniffi_trait_eq_eq,self._uniffi_clone_pointer(),
        _UniffiConverterTypeConnection.lower(other)))

    def __ne__(self, other: object) -> bool:
        if not isinstance(other, Connection):
            return NotImplemented

        return _UniffiConverterBool.lift(_uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_connection_uniffi_trait_eq_ne,self._uniffi_clone_pointer(),
        _UniffiConverterTypeConnection.lower(other)))


    def __hash__(self, ) -> "int":
        return _UniffiConverterUInt64.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_connection_uniffi_trait_hash,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeConnection:

    @staticmethod
    def lift(value: int):
        return Connection._make_instance_(value)

    @staticmethod
    def check_lower(value: Connection):
        if not isinstance(value, Connection):
            raise TypeError("Expected Connection instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: ConnectionProtocol):
        if not isinstance(value, Connection):
            raise TypeError("Expected Connection instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: ConnectionProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class CoordinateProtocol(typing.Protocol):
    """
    Coordinate for event (`a` tag)
    """

    def identifier(self, ):
        raise NotImplementedError
    def kind(self, ):
        raise NotImplementedError
    def public_key(self, ):
        raise NotImplementedError
    def verify(self, ):
        """
        Check if the coordinate is valid.

        Returns `false` if:
        - the `Kind` is `replaceable` and the identifier is not empty
        - the `Kind` is `addressable` and the identifier is empty
        """

        raise NotImplementedError
# Coordinate is a Rust-only trait - it's a wrapper around a Rust implementation.
class Coordinate():
    """
    Coordinate for event (`a` tag)
    """

    _pointer: ctypes.c_void_p
    def __init__(self, kind: "Kind",public_key: "PublicKey",identifier: "typing.Union[object, str]" = _DEFAULT):
        _UniffiConverterTypeKind.check_lower(kind)
        
        _UniffiConverterTypePublicKey.check_lower(public_key)
        
        if identifier is _DEFAULT:
            identifier = ""
        _UniffiConverterString.check_lower(identifier)
        
        self._pointer = _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_coordinate_new,
        _UniffiConverterTypeKind.lower(kind),
        _UniffiConverterTypePublicKey.lower(public_key),
        _UniffiConverterString.lower(identifier))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_coordinate, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_coordinate, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst
    @classmethod
    def parse(cls, coordinate: "str"):
        _UniffiConverterString.check_lower(coordinate)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeNostrSdkError,_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_coordinate_parse,
        _UniffiConverterString.lower(coordinate))
        return cls._make_instance_(pointer)



    def identifier(self, ) -> "str":
        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_coordinate_identifier,self._uniffi_clone_pointer(),)
        )





    def kind(self, ) -> "Kind":
        return _UniffiConverterTypeKind.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_coordinate_kind,self._uniffi_clone_pointer(),)
        )





    def public_key(self, ) -> "PublicKey":
        return _UniffiConverterTypePublicKey.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_coordinate_public_key,self._uniffi_clone_pointer(),)
        )





    def verify(self, ) -> "bool":
        """
        Check if the coordinate is valid.

        Returns `false` if:
        - the `Kind` is `replaceable` and the identifier is not empty
        - the `Kind` is `addressable` and the identifier is empty
        """

        return _UniffiConverterBool.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_coordinate_verify,self._uniffi_clone_pointer(),)
        )





    def __repr__(self, ) -> "str":
        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_coordinate_uniffi_trait_debug,self._uniffi_clone_pointer(),)
        )





    def __str__(self, ) -> "str":
        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_coordinate_uniffi_trait_display,self._uniffi_clone_pointer(),)
        )



    def __eq__(self, other: object) -> bool:
        if not isinstance(other, Coordinate):
            return NotImplemented

        return _UniffiConverterBool.lift(_uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_coordinate_uniffi_trait_eq_eq,self._uniffi_clone_pointer(),
        _UniffiConverterTypeCoordinate.lower(other)))

    def __ne__(self, other: object) -> bool:
        if not isinstance(other, Coordinate):
            return NotImplemented

        return _UniffiConverterBool.lift(_uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_coordinate_uniffi_trait_eq_ne,self._uniffi_clone_pointer(),
        _UniffiConverterTypeCoordinate.lower(other)))


    def __hash__(self, ) -> "int":
        return _UniffiConverterUInt64.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_coordinate_uniffi_trait_hash,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeCoordinate:

    @staticmethod
    def lift(value: int):
        return Coordinate._make_instance_(value)

    @staticmethod
    def check_lower(value: Coordinate):
        if not isinstance(value, Coordinate):
            raise TypeError("Expected Coordinate instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: CoordinateProtocol):
        if not isinstance(value, Coordinate):
            raise TypeError("Expected Coordinate instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: CoordinateProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class EncryptedSecretKeyProtocol(typing.Protocol):
    """
    Encrypted Secret Key
    """

    def decrypt(self, password: "str"):
        """
        Decrypt secret key
        """

        raise NotImplementedError
    def key_security(self, ):
        """
        Get encrypted secret key security
        """

        raise NotImplementedError
    def to_bech32(self, ):
        raise NotImplementedError
    def version(self, ):
        """
        Get encrypted secret key version
        """

        raise NotImplementedError
# EncryptedSecretKey is a Rust-only trait - it's a wrapper around a Rust implementation.
class EncryptedSecretKey():
    """
    Encrypted Secret Key
    """

    _pointer: ctypes.c_void_p
    def __init__(self, secret_key: "SecretKey",password: "str",log_n: "int",key_security: "KeySecurity"):
        """
        Encrypt secret key
        """

        _UniffiConverterTypeSecretKey.check_lower(secret_key)
        
        _UniffiConverterString.check_lower(password)
        
        _UniffiConverterUInt8.check_lower(log_n)
        
        _UniffiConverterTypeKeySecurity.check_lower(key_security)
        
        self._pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeNostrSdkError,_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_encryptedsecretkey_new,
        _UniffiConverterTypeSecretKey.lower(secret_key),
        _UniffiConverterString.lower(password),
        _UniffiConverterUInt8.lower(log_n),
        _UniffiConverterTypeKeySecurity.lower(key_security))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_encryptedsecretkey, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_encryptedsecretkey, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst
    @classmethod
    def from_bech32(cls, bech32: "str"):
        _UniffiConverterString.check_lower(bech32)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeNostrSdkError,_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_encryptedsecretkey_from_bech32,
        _UniffiConverterString.lower(bech32))
        return cls._make_instance_(pointer)



    def decrypt(self, password: "str") -> "SecretKey":
        """
        Decrypt secret key
        """

        _UniffiConverterString.check_lower(password)
        
        return _UniffiConverterTypeSecretKey.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeNostrSdkError,_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_encryptedsecretkey_decrypt,self._uniffi_clone_pointer(),
        _UniffiConverterString.lower(password))
        )





    def key_security(self, ) -> "KeySecurity":
        """
        Get encrypted secret key security
        """

        return _UniffiConverterTypeKeySecurity.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_encryptedsecretkey_key_security,self._uniffi_clone_pointer(),)
        )





    def to_bech32(self, ) -> "str":
        return _UniffiConverterString.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeNostrSdkError,_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_encryptedsecretkey_to_bech32,self._uniffi_clone_pointer(),)
        )





    def version(self, ) -> "EncryptedSecretKeyVersion":
        """
        Get encrypted secret key version
        """

        return _UniffiConverterTypeEncryptedSecretKeyVersion.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_encryptedsecretkey_version,self._uniffi_clone_pointer(),)
        )





    def __repr__(self, ) -> "str":
        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_encryptedsecretkey_uniffi_trait_debug,self._uniffi_clone_pointer(),)
        )



    def __eq__(self, other: object) -> bool:
        if not isinstance(other, EncryptedSecretKey):
            return NotImplemented

        return _UniffiConverterBool.lift(_uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_encryptedsecretkey_uniffi_trait_eq_eq,self._uniffi_clone_pointer(),
        _UniffiConverterTypeEncryptedSecretKey.lower(other)))

    def __ne__(self, other: object) -> bool:
        if not isinstance(other, EncryptedSecretKey):
            return NotImplemented

        return _UniffiConverterBool.lift(_uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_encryptedsecretkey_uniffi_trait_eq_ne,self._uniffi_clone_pointer(),
        _UniffiConverterTypeEncryptedSecretKey.lower(other)))


    def __hash__(self, ) -> "int":
        return _UniffiConverterUInt64.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_encryptedsecretkey_uniffi_trait_hash,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeEncryptedSecretKey:

    @staticmethod
    def lift(value: int):
        return EncryptedSecretKey._make_instance_(value)

    @staticmethod
    def check_lower(value: EncryptedSecretKey):
        if not isinstance(value, EncryptedSecretKey):
            raise TypeError("Expected EncryptedSecretKey instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: EncryptedSecretKeyProtocol):
        if not isinstance(value, EncryptedSecretKey):
            raise TypeError("Expected EncryptedSecretKey instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: EncryptedSecretKeyProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class EventProtocol(typing.Protocol):
    def as_json(self, ):
        raise NotImplementedError
    def as_pretty_json(self, ):
        raise NotImplementedError
    def author(self, ):
        """
        Get event author (`pubkey` field)
        """

        raise NotImplementedError
    def content(self, ):
        raise NotImplementedError
    def created_at(self, ):
        raise NotImplementedError
    def id(self, ):
        raise NotImplementedError
    def is_expired(self, ):
        """
        Returns `true` if the event has an expiration tag that is expired.
        If an event has no expiration tag, then it will return `false`.

        <https://github.com/nostr-protocol/nips/blob/master/40.md>
        """

        raise NotImplementedError
    def is_protected(self, ):
        """
        Check if it's a protected event

        <https://github.com/nostr-protocol/nips/blob/master/70.md>
        """

        raise NotImplementedError
    def kind(self, ):
        raise NotImplementedError
    def signature(self, ):
        raise NotImplementedError
    def tags(self, ):
        raise NotImplementedError
    def verify(self, ):
        """
        Verify both `EventId` and `Signature`
        """

        raise NotImplementedError
    def verify_id(self, ):
        """
        Verify if the `EventId` it's composed correctly
        """

        raise NotImplementedError
    def verify_signature(self, ):
        """
        Verify only event `Signature`
        """

        raise NotImplementedError
# Event is a Rust-only trait - it's a wrapper around a Rust implementation.
class Event():
    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_event, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_event, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst
    @classmethod
    def from_json(cls, json: "str"):
        _UniffiConverterString.check_lower(json)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeNostrSdkError,_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_event_from_json,
        _UniffiConverterString.lower(json))
        return cls._make_instance_(pointer)



    def as_json(self, ) -> "str":
        return _UniffiConverterString.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeNostrSdkError,_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_event_as_json,self._uniffi_clone_pointer(),)
        )





    def as_pretty_json(self, ) -> "str":
        return _UniffiConverterString.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeNostrSdkError,_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_event_as_pretty_json,self._uniffi_clone_pointer(),)
        )





    def author(self, ) -> "PublicKey":
        """
        Get event author (`pubkey` field)
        """

        return _UniffiConverterTypePublicKey.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_event_author,self._uniffi_clone_pointer(),)
        )





    def content(self, ) -> "str":
        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_event_content,self._uniffi_clone_pointer(),)
        )





    def created_at(self, ) -> "Timestamp":
        return _UniffiConverterTypeTimestamp.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_event_created_at,self._uniffi_clone_pointer(),)
        )





    def id(self, ) -> "EventId":
        return _UniffiConverterTypeEventId.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_event_id,self._uniffi_clone_pointer(),)
        )





    def is_expired(self, ) -> "bool":
        """
        Returns `true` if the event has an expiration tag that is expired.
        If an event has no expiration tag, then it will return `false`.

        <https://github.com/nostr-protocol/nips/blob/master/40.md>
        """

        return _UniffiConverterBool.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_event_is_expired,self._uniffi_clone_pointer(),)
        )





    def is_protected(self, ) -> "bool":
        """
        Check if it's a protected event

        <https://github.com/nostr-protocol/nips/blob/master/70.md>
        """

        return _UniffiConverterBool.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_event_is_protected,self._uniffi_clone_pointer(),)
        )





    def kind(self, ) -> "Kind":
        return _UniffiConverterTypeKind.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_event_kind,self._uniffi_clone_pointer(),)
        )





    def signature(self, ) -> "str":
        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_event_signature,self._uniffi_clone_pointer(),)
        )





    def tags(self, ) -> "Tags":
        return _UniffiConverterTypeTags.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_event_tags,self._uniffi_clone_pointer(),)
        )





    def verify(self, ) -> "bool":
        """
        Verify both `EventId` and `Signature`
        """

        return _UniffiConverterBool.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_event_verify,self._uniffi_clone_pointer(),)
        )





    def verify_id(self, ) -> "bool":
        """
        Verify if the `EventId` it's composed correctly
        """

        return _UniffiConverterBool.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_event_verify_id,self._uniffi_clone_pointer(),)
        )





    def verify_signature(self, ) -> "bool":
        """
        Verify only event `Signature`
        """

        return _UniffiConverterBool.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_event_verify_signature,self._uniffi_clone_pointer(),)
        )





    def __repr__(self, ) -> "str":
        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_event_uniffi_trait_debug,self._uniffi_clone_pointer(),)
        )



    def __eq__(self, other: object) -> bool:
        if not isinstance(other, Event):
            return NotImplemented

        return _UniffiConverterBool.lift(_uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_event_uniffi_trait_eq_eq,self._uniffi_clone_pointer(),
        _UniffiConverterTypeEvent.lower(other)))

    def __ne__(self, other: object) -> bool:
        if not isinstance(other, Event):
            return NotImplemented

        return _UniffiConverterBool.lift(_uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_event_uniffi_trait_eq_ne,self._uniffi_clone_pointer(),
        _UniffiConverterTypeEvent.lower(other)))


    def __hash__(self, ) -> "int":
        return _UniffiConverterUInt64.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_event_uniffi_trait_hash,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeEvent:

    @staticmethod
    def lift(value: int):
        return Event._make_instance_(value)

    @staticmethod
    def check_lower(value: Event):
        if not isinstance(value, Event):
            raise TypeError("Expected Event instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: EventProtocol):
        if not isinstance(value, Event):
            raise TypeError("Expected Event instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: EventProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class EventBuilderProtocol(typing.Protocol):
    def allow_self_tagging(self, ):
        """
        Allow self-tagging

        When this mode is enabled, any `p` tags referencing the authors public key will not be discarded.
        """

        raise NotImplementedError
    def build(self, public_key: "PublicKey"):
        """
        Build an unsigned event

        By default, this method removes any `p` tags that match the author's public key.
        To allow self-tagging, call [`EventBuilder::allow_self_tagging`] first.
        """

        raise NotImplementedError
    def custom_created_at(self, created_at: "Timestamp"):
        """
        Set a custom `created_at` UNIX timestamp
        """

        raise NotImplementedError
    def dedup_tags(self, ):
        """
        Deduplicate tags

        For more details check [`Tags::dedup`].
        """

        raise NotImplementedError
    def pow(self, difficulty: "int"):
        """
        Set POW difficulty

        Only values `> 0` are accepted!
        """

        raise NotImplementedError
    def sign(self, signer: "NostrSigner"):
        """
        Build, sign and return [`Event`]

        Check [`EventBuilder::build`] to learn more.
        """

        raise NotImplementedError
    def sign_with_keys(self, keys: "Keys"):
        """
        Build, sign and return [`Event`] using [`Keys`] signer

        Check [`EventBuilder::build`] to learn more.
        """

        raise NotImplementedError
    def tags(self, tags: "typing.List[Tag]"):
        """
        Add tags

        This method extend the current tags (if any).
        """

        raise NotImplementedError
# EventBuilder is a Rust-only trait - it's a wrapper around a Rust implementation.
class EventBuilder():
    _pointer: ctypes.c_void_p
    def __init__(self, kind: "Kind",content: "str"):
        _UniffiConverterTypeKind.check_lower(kind)
        
        _UniffiConverterString.check_lower(content)
        
        self._pointer = _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_new,
        _UniffiConverterTypeKind.lower(kind),
        _UniffiConverterString.lower(content))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_eventbuilder, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_eventbuilder, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst
    @classmethod
    def articles_curation_set(cls, identifier: "str",list: "ArticlesCuration"):
        """
        Article Curation set

        <https://github.com/nostr-protocol/nips/blob/master/51.md>
        """

        _UniffiConverterString.check_lower(identifier)
        
        _UniffiConverterTypeArticlesCuration.check_lower(list)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_articles_curation_set,
        _UniffiConverterString.lower(identifier),
        _UniffiConverterTypeArticlesCuration.lower(list))
        return cls._make_instance_(pointer)

    @classmethod
    def auth(cls, challenge: "str",relay_url: "RelayUrl"):
        """
        Authentication of clients to relays

        <https://github.com/nostr-protocol/nips/blob/master/42.md>
        """

        _UniffiConverterString.check_lower(challenge)
        
        _UniffiConverterTypeRelayUrl.check_lower(relay_url)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeNostrSdkError,_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_auth,
        _UniffiConverterString.lower(challenge),
        _UniffiConverterTypeRelayUrl.lower(relay_url))
        return cls._make_instance_(pointer)

    @classmethod
    def award_badge(cls, badge_definition: "Event",awarded_public_keys: "typing.List[PublicKey]"):
        """
        Badge award

        <https://github.com/nostr-protocol/nips/blob/master/58.md>
        """

        _UniffiConverterTypeEvent.check_lower(badge_definition)
        
        _UniffiConverterSequenceTypePublicKey.check_lower(awarded_public_keys)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeNostrSdkError,_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_award_badge,
        _UniffiConverterTypeEvent.lower(badge_definition),
        _UniffiConverterSequenceTypePublicKey.lower(awarded_public_keys))
        return cls._make_instance_(pointer)

    @classmethod
    def blocked_relays(cls, relay: "typing.List[RelayUrl]"):
        """
        Blocked relays

        <https://github.com/nostr-protocol/nips/blob/master/51.md>
        """

        _UniffiConverterSequenceTypeRelayUrl.check_lower(relay)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_blocked_relays,
        _UniffiConverterSequenceTypeRelayUrl.lower(relay))
        return cls._make_instance_(pointer)

    @classmethod
    def bookmarks(cls, list: "Bookmarks"):
        """
        Bookmarks

        <https://github.com/nostr-protocol/nips/blob/master/51.md>
        """

        _UniffiConverterTypeBookmarks.check_lower(list)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeNostrSdkError,_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_bookmarks,
        _UniffiConverterTypeBookmarks.lower(list))
        return cls._make_instance_(pointer)

    @classmethod
    def bookmarks_set(cls, identifier: "str",list: "Bookmarks"):
        """
        Bookmark set

        <https://github.com/nostr-protocol/nips/blob/master/51.md>
        """

        _UniffiConverterString.check_lower(identifier)
        
        _UniffiConverterTypeBookmarks.check_lower(list)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeNostrSdkError,_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_bookmarks_set,
        _UniffiConverterString.lower(identifier),
        _UniffiConverterTypeBookmarks.lower(list))
        return cls._make_instance_(pointer)

    @classmethod
    def channel(cls, metadata: "Metadata"):
        """
        Create new channel

        <https://github.com/nostr-protocol/nips/blob/master/28.md>
        """

        _UniffiConverterTypeMetadata.check_lower(metadata)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_channel,
        _UniffiConverterTypeMetadata.lower(metadata))
        return cls._make_instance_(pointer)

    @classmethod
    def channel_metadata(cls, channel_id: "EventId",metadata: "Metadata",relay_url: "typing.Union[object, typing.Optional[RelayUrl]]" = _DEFAULT):
        """
        Channel metadata

        <https://github.com/nostr-protocol/nips/blob/master/28.md>
        """

        _UniffiConverterTypeEventId.check_lower(channel_id)
        
        _UniffiConverterTypeMetadata.check_lower(metadata)
        
        if relay_url is _DEFAULT:
            relay_url = None
        _UniffiConverterOptionalTypeRelayUrl.check_lower(relay_url)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeNostrSdkError,_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_channel_metadata,
        _UniffiConverterTypeEventId.lower(channel_id),
        _UniffiConverterTypeMetadata.lower(metadata),
        _UniffiConverterOptionalTypeRelayUrl.lower(relay_url))
        return cls._make_instance_(pointer)

    @classmethod
    def channel_msg(cls, channel_id: "EventId",relay_url: "RelayUrl",content: "str"):
        """
        Channel message

        <https://github.com/nostr-protocol/nips/blob/master/28.md>
        """

        _UniffiConverterTypeEventId.check_lower(channel_id)
        
        _UniffiConverterTypeRelayUrl.check_lower(relay_url)
        
        _UniffiConverterString.check_lower(content)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeNostrSdkError,_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_channel_msg,
        _UniffiConverterTypeEventId.lower(channel_id),
        _UniffiConverterTypeRelayUrl.lower(relay_url),
        _UniffiConverterString.lower(content))
        return cls._make_instance_(pointer)

    @classmethod
    def comment(cls, content: "str",comment_to: "CommentTarget",root: "typing.Union[object, typing.Optional[CommentTarget]]" = _DEFAULT):
        """
        Comment

        <https://github.com/nostr-protocol/nips/blob/master/22.md>
        """

        _UniffiConverterString.check_lower(content)
        
        _UniffiConverterTypeCommentTarget.check_lower(comment_to)
        
        if root is _DEFAULT:
            root = None
        _UniffiConverterOptionalTypeCommentTarget.check_lower(root)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeNostrSdkError,_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_comment,
        _UniffiConverterString.lower(content),
        _UniffiConverterTypeCommentTarget.lower(comment_to),
        _UniffiConverterOptionalTypeCommentTarget.lower(root))
        return cls._make_instance_(pointer)

    @classmethod
    def communities(cls, communities: "typing.List[Coordinate]"):
        """
        Communities

        <https://github.com/nostr-protocol/nips/blob/master/51.md>
        """

        _UniffiConverterSequenceTypeCoordinate.check_lower(communities)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_communities,
        _UniffiConverterSequenceTypeCoordinate.lower(communities))
        return cls._make_instance_(pointer)

    @classmethod
    def contact_list(cls, contacts: "typing.List[Contact]"):
        """
        Contact/Follow list

        <https://github.com/nostr-protocol/nips/blob/master/02.md>
        """

        _UniffiConverterSequenceTypeContact.check_lower(contacts)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_contact_list,
        _UniffiConverterSequenceTypeContact.lower(contacts))
        return cls._make_instance_(pointer)

    @classmethod
    def define_badge(cls, badge_id: "str",name: "typing.Union[object, typing.Optional[str]]" = _DEFAULT,description: "typing.Union[object, typing.Optional[str]]" = _DEFAULT,image: "typing.Union[object, typing.Optional[str]]" = _DEFAULT,image_dimensions: "typing.Union[object, typing.Optional[ImageDimensions]]" = _DEFAULT,thumbnails: "typing.Union[object, typing.List[Image]]" = _DEFAULT):
        """
        Badge definition

        <https://github.com/nostr-protocol/nips/blob/master/58.md>
        """

        _UniffiConverterString.check_lower(badge_id)
        
        if name is _DEFAULT:
            name = None
        _UniffiConverterOptionalString.check_lower(name)
        
        if description is _DEFAULT:
            description = None
        _UniffiConverterOptionalString.check_lower(description)
        
        if image is _DEFAULT:
            image = None
        _UniffiConverterOptionalString.check_lower(image)
        
        if image_dimensions is _DEFAULT:
            image_dimensions = None
        _UniffiConverterOptionalTypeImageDimensions.check_lower(image_dimensions)
        
        if thumbnails is _DEFAULT:
            thumbnails = []
        _UniffiConverterSequenceTypeImage.check_lower(thumbnails)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeNostrSdkError,_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_define_badge,
        _UniffiConverterString.lower(badge_id),
        _UniffiConverterOptionalString.lower(name),
        _UniffiConverterOptionalString.lower(description),
        _UniffiConverterOptionalString.lower(image),
        _UniffiConverterOptionalTypeImageDimensions.lower(image_dimensions),
        _UniffiConverterSequenceTypeImage.lower(thumbnails))
        return cls._make_instance_(pointer)

    @classmethod
    def delete(cls, request: "EventDeletionRequest"):
        """
        Event deletion request

        <https://github.com/nostr-protocol/nips/blob/master/09.md>
        """

        _UniffiConverterTypeEventDeletionRequest.check_lower(request)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_delete,
        _UniffiConverterTypeEventDeletionRequest.lower(request))
        return cls._make_instance_(pointer)

    @classmethod
    def emoji_set(cls, identifier: "str",emojis: "typing.List[EmojiInfo]"):
        """
        Emoji set

        <https://github.com/nostr-protocol/nips/blob/master/51.md>
        """

        _UniffiConverterString.check_lower(identifier)
        
        _UniffiConverterSequenceTypeEmojiInfo.check_lower(emojis)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_emoji_set,
        _UniffiConverterString.lower(identifier),
        _UniffiConverterSequenceTypeEmojiInfo.lower(emojis))
        return cls._make_instance_(pointer)

    @classmethod
    def emojis(cls, list: "Emojis"):
        """
        Emojis

        <https://github.com/nostr-protocol/nips/blob/master/51.md>
        """

        _UniffiConverterTypeEmojis.check_lower(list)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_emojis,
        _UniffiConverterTypeEmojis.lower(list))
        return cls._make_instance_(pointer)

    @classmethod
    def file_metadata(cls, description: "str",metadata: "FileMetadata"):
        """
        File metadata

        <https://github.com/nostr-protocol/nips/blob/master/94.md>
        """

        _UniffiConverterString.check_lower(description)
        
        _UniffiConverterTypeFileMetadata.check_lower(metadata)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_file_metadata,
        _UniffiConverterString.lower(description),
        _UniffiConverterTypeFileMetadata.lower(metadata))
        return cls._make_instance_(pointer)

    @classmethod
    def follow_set(cls, identifier: "str",public_keys: "typing.List[PublicKey]"):
        """
        Follow set

        <https://github.com/nostr-protocol/nips/blob/master/51.md>
        """

        _UniffiConverterString.check_lower(identifier)
        
        _UniffiConverterSequenceTypePublicKey.check_lower(public_keys)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_follow_set,
        _UniffiConverterString.lower(identifier),
        _UniffiConverterSequenceTypePublicKey.lower(public_keys))
        return cls._make_instance_(pointer)

    @classmethod
    def git_issue(cls, issue: "GitIssue"):
        """
        Git Issue

        <https://github.com/nostr-protocol/nips/blob/master/34.md>
        """

        _UniffiConverterTypeGitIssue.check_lower(issue)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeNostrSdkError,_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_git_issue,
        _UniffiConverterTypeGitIssue.lower(issue))
        return cls._make_instance_(pointer)

    @classmethod
    def git_patch(cls, patch: "GitPatch"):
        """
        Git Patch

        <https://github.com/nostr-protocol/nips/blob/master/34.md>
        """

        _UniffiConverterTypeGitPatch.check_lower(patch)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeNostrSdkError,_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_git_patch,
        _UniffiConverterTypeGitPatch.lower(patch))
        return cls._make_instance_(pointer)

    @classmethod
    def git_repository_announcement(cls, data: "GitRepositoryAnnouncement"):
        """
        Git Repository Announcement

        <https://github.com/nostr-protocol/nips/blob/master/34.md>
        """

        _UniffiConverterTypeGitRepositoryAnnouncement.check_lower(data)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeNostrSdkError,_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_git_repository_announcement,
        _UniffiConverterTypeGitRepositoryAnnouncement.lower(data))
        return cls._make_instance_(pointer)

    @classmethod
    def hide_channel_msg(cls, message_id: "EventId",reason: "typing.Union[object, typing.Optional[str]]" = _DEFAULT):
        """
        Hide message

        <https://github.com/nostr-protocol/nips/blob/master/28.md>
        """

        _UniffiConverterTypeEventId.check_lower(message_id)
        
        if reason is _DEFAULT:
            reason = None
        _UniffiConverterOptionalString.check_lower(reason)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_hide_channel_msg,
        _UniffiConverterTypeEventId.lower(message_id),
        _UniffiConverterOptionalString.lower(reason))
        return cls._make_instance_(pointer)

    @classmethod
    def http_auth(cls, data: "HttpData"):
        """
        HTTP Auth

        <https://github.com/nostr-protocol/nips/blob/master/98.md>
        """

        _UniffiConverterTypeHttpData.check_lower(data)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeNostrSdkError,_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_http_auth,
        _UniffiConverterTypeHttpData.lower(data))
        return cls._make_instance_(pointer)

    @classmethod
    def interest_set(cls, identifier: "str",hashtags: "typing.List[str]"):
        """
        Interest set

        <https://github.com/nostr-protocol/nips/blob/master/51.md>
        """

        _UniffiConverterString.check_lower(identifier)
        
        _UniffiConverterSequenceString.check_lower(hashtags)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_interest_set,
        _UniffiConverterString.lower(identifier),
        _UniffiConverterSequenceString.lower(hashtags))
        return cls._make_instance_(pointer)

    @classmethod
    def interests(cls, list: "Interests"):
        """
        Interests

        <https://github.com/nostr-protocol/nips/blob/master/51.md>
        """

        _UniffiConverterTypeInterests.check_lower(list)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_interests,
        _UniffiConverterTypeInterests.lower(list))
        return cls._make_instance_(pointer)

    @classmethod
    def job_feedback(cls, data: "JobFeedbackData"):
        """
        Data Vending Machine (DVM) - Job Feedback

        <https://github.com/nostr-protocol/nips/blob/master/90.md>
        """

        _UniffiConverterTypeJobFeedbackData.check_lower(data)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_job_feedback,
        _UniffiConverterTypeJobFeedbackData.lower(data))
        return cls._make_instance_(pointer)

    @classmethod
    def job_request(cls, kind: "Kind"):
        """
        Data Vending Machine (DVM) - Job Request

        <https://github.com/nostr-protocol/nips/blob/master/90.md>
        """

        _UniffiConverterTypeKind.check_lower(kind)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeNostrSdkError,_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_job_request,
        _UniffiConverterTypeKind.lower(kind))
        return cls._make_instance_(pointer)

    @classmethod
    def job_result(cls, job_request: "Event",payload: "str",millisats: "int",bolt11: "typing.Union[object, typing.Optional[str]]" = _DEFAULT):
        """
        Data Vending Machine (DVM) - Job Result

        <https://github.com/nostr-protocol/nips/blob/master/90.md>
        """

        _UniffiConverterTypeEvent.check_lower(job_request)
        
        _UniffiConverterString.check_lower(payload)
        
        _UniffiConverterUInt64.check_lower(millisats)
        
        if bolt11 is _DEFAULT:
            bolt11 = None
        _UniffiConverterOptionalString.check_lower(bolt11)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeNostrSdkError,_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_job_result,
        _UniffiConverterTypeEvent.lower(job_request),
        _UniffiConverterString.lower(payload),
        _UniffiConverterUInt64.lower(millisats),
        _UniffiConverterOptionalString.lower(bolt11))
        return cls._make_instance_(pointer)

    @classmethod
    def label(cls, label_namespace: "str",label: "str"):
        """
        Label

        <https://github.com/nostr-protocol/nips/blob/master/32.md>
        """

        _UniffiConverterString.check_lower(label_namespace)
        
        _UniffiConverterString.check_lower(label)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_label,
        _UniffiConverterString.lower(label_namespace),
        _UniffiConverterString.lower(label))
        return cls._make_instance_(pointer)

    @classmethod
    def live_event(cls, live_event: "LiveEvent"):
        """
        Live Event

        <https://github.com/nostr-protocol/nips/blob/master/53.md>
        """

        _UniffiConverterTypeLiveEvent.check_lower(live_event)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeNostrSdkError,_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_live_event,
        _UniffiConverterTypeLiveEvent.lower(live_event))
        return cls._make_instance_(pointer)

    @classmethod
    def live_event_msg(cls, live_event_id: "str",live_event_host: "PublicKey",content: "str",relay_url: "typing.Union[object, typing.Optional[RelayUrl]]" = _DEFAULT):
        """
        Live Event Message

        <https://github.com/nostr-protocol/nips/blob/master/53.md>
        """

        _UniffiConverterString.check_lower(live_event_id)
        
        _UniffiConverterTypePublicKey.check_lower(live_event_host)
        
        _UniffiConverterString.check_lower(content)
        
        if relay_url is _DEFAULT:
            relay_url = None
        _UniffiConverterOptionalTypeRelayUrl.check_lower(relay_url)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeNostrSdkError,_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_live_event_msg,
        _UniffiConverterString.lower(live_event_id),
        _UniffiConverterTypePublicKey.lower(live_event_host),
        _UniffiConverterString.lower(content),
        _UniffiConverterOptionalTypeRelayUrl.lower(relay_url))
        return cls._make_instance_(pointer)

    @classmethod
    def long_form_text_note(cls, content: "str"):
        """
        Long-form text note (generally referred to as "articles" or "blog posts").

        <https://github.com/nostr-protocol/nips/blob/master/23.md>
        """

        _UniffiConverterString.check_lower(content)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_long_form_text_note,
        _UniffiConverterString.lower(content))
        return cls._make_instance_(pointer)

    @classmethod
    def metadata(cls, metadata: "Metadata"):
        """
        Profile metadata

        <https://github.com/nostr-protocol/nips/blob/master/01.md>
        """

        _UniffiConverterTypeMetadata.check_lower(metadata)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_metadata,
        _UniffiConverterTypeMetadata.lower(metadata))
        return cls._make_instance_(pointer)

    @classmethod
    def mute_channel_user(cls, public_key: "PublicKey",reason: "typing.Union[object, typing.Optional[str]]" = _DEFAULT):
        """
        Mute channel user

        <https://github.com/nostr-protocol/nips/blob/master/28.md>
        """

        _UniffiConverterTypePublicKey.check_lower(public_key)
        
        if reason is _DEFAULT:
            reason = None
        _UniffiConverterOptionalString.check_lower(reason)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_mute_channel_user,
        _UniffiConverterTypePublicKey.lower(public_key),
        _UniffiConverterOptionalString.lower(reason))
        return cls._make_instance_(pointer)

    @classmethod
    def mute_list(cls, list: "MuteList"):
        """
        Mute list

        <https://github.com/nostr-protocol/nips/blob/master/51.md>
        """

        _UniffiConverterTypeMuteList.check_lower(list)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_mute_list,
        _UniffiConverterTypeMuteList.lower(list))
        return cls._make_instance_(pointer)

    @classmethod
    def nostr_connect(cls, sender_keys: "Keys",receiver_pubkey: "PublicKey",msg: "NostrConnectMessage"):
        """
        Nostr Connect / Nostr Remote Signing

        <https://github.com/nostr-protocol/nips/blob/master/46.md>
        """

        _UniffiConverterTypeKeys.check_lower(sender_keys)
        
        _UniffiConverterTypePublicKey.check_lower(receiver_pubkey)
        
        _UniffiConverterTypeNostrConnectMessage.check_lower(msg)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeNostrSdkError,_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_nostr_connect,
        _UniffiConverterTypeKeys.lower(sender_keys),
        _UniffiConverterTypePublicKey.lower(receiver_pubkey),
        _UniffiConverterTypeNostrConnectMessage.lower(msg))
        return cls._make_instance_(pointer)

    @classmethod
    def pinned_notes(cls, ids: "typing.List[EventId]"):
        """
        Pinned notes

        <https://github.com/nostr-protocol/nips/blob/master/51.md>
        """

        _UniffiConverterSequenceTypeEventId.check_lower(ids)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_pinned_notes,
        _UniffiConverterSequenceTypeEventId.lower(ids))
        return cls._make_instance_(pointer)

    @classmethod
    def private_msg_rumor(cls, receiver: "PublicKey",message: "str"):
        """
        Private Direct message rumor

        <div class="warning">
        This constructor compose ONLY the rumor for the private direct message!
        NOT USE THIS IF YOU DON'T KNOW WHAT YOU ARE DOING!
        </div>

        <https://github.com/nostr-protocol/nips/blob/master/17.md>
        """

        _UniffiConverterTypePublicKey.check_lower(receiver)
        
        _UniffiConverterString.check_lower(message)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_private_msg_rumor,
        _UniffiConverterTypePublicKey.lower(receiver),
        _UniffiConverterString.lower(message))
        return cls._make_instance_(pointer)

    @classmethod
    def product_data(cls, data: "ProductData"):
        """
        Set product data

        <https://github.com/nostr-protocol/nips/blob/master/15.md>
        """

        _UniffiConverterTypeProductData.check_lower(data)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_product_data,
        _UniffiConverterTypeProductData.lower(data))
        return cls._make_instance_(pointer)

    @classmethod
    def profile_badges(cls, badge_definitions: "typing.List[Event]",badge_awards: "typing.List[Event]",pubkey_awarded: "PublicKey"):
        """
        Profile badges

        <https://github.com/nostr-protocol/nips/blob/master/58.md>
        """

        _UniffiConverterSequenceTypeEvent.check_lower(badge_definitions)
        
        _UniffiConverterSequenceTypeEvent.check_lower(badge_awards)
        
        _UniffiConverterTypePublicKey.check_lower(pubkey_awarded)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeNostrSdkError,_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_profile_badges,
        _UniffiConverterSequenceTypeEvent.lower(badge_definitions),
        _UniffiConverterSequenceTypeEvent.lower(badge_awards),
        _UniffiConverterTypePublicKey.lower(pubkey_awarded))
        return cls._make_instance_(pointer)

    @classmethod
    def public_chats(cls, chat: "typing.List[EventId]"):
        """
        Public chats

        <https://github.com/nostr-protocol/nips/blob/master/51.md>
        """

        _UniffiConverterSequenceTypeEventId.check_lower(chat)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_public_chats,
        _UniffiConverterSequenceTypeEventId.lower(chat))
        return cls._make_instance_(pointer)

    @classmethod
    def public_zap_request(cls, data: "ZapRequestData"):
        """
        Create **public** zap request event

        **This event MUST NOT be broadcasted to relays**, instead must be sent to a recipient's LNURL pay callback url.

        To build a **private** or **anonymous** zap request use `nip57_private_zap_request(...)` or `nip57_anonymous_zap_request(...)` functions.

        <https://github.com/nostr-protocol/nips/blob/master/57.md>
        """

        _UniffiConverterTypeZapRequestData.check_lower(data)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_public_zap_request,
        _UniffiConverterTypeZapRequestData.lower(data))
        return cls._make_instance_(pointer)

    @classmethod
    def reaction(cls, event: "Event",reaction: "str"):
        """
        Add reaction (like/upvote, dislike/downvote or emoji) to an event

        <https://github.com/nostr-protocol/nips/blob/master/25.md>
        """

        _UniffiConverterTypeEvent.check_lower(event)
        
        _UniffiConverterString.check_lower(reaction)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_reaction,
        _UniffiConverterTypeEvent.lower(event),
        _UniffiConverterString.lower(reaction))
        return cls._make_instance_(pointer)

    @classmethod
    def relay_list(cls, map: "dict[RelayUrl, typing.Optional[RelayMetadata]]"):
        """
        Relay list metadata

        <https://github.com/nostr-protocol/nips/blob/master/65.md>
        """

        _UniffiConverterMapTypeRelayUrlOptionalTypeRelayMetadata.check_lower(map)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeNostrSdkError,_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_relay_list,
        _UniffiConverterMapTypeRelayUrlOptionalTypeRelayMetadata.lower(map))
        return cls._make_instance_(pointer)

    @classmethod
    def relay_set(cls, identifier: "str",relays: "typing.List[RelayUrl]"):
        """
        Relay set

        <https://github.com/nostr-protocol/nips/blob/master/51.md>
        """

        _UniffiConverterString.check_lower(identifier)
        
        _UniffiConverterSequenceTypeRelayUrl.check_lower(relays)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_relay_set,
        _UniffiConverterString.lower(identifier),
        _UniffiConverterSequenceTypeRelayUrl.lower(relays))
        return cls._make_instance_(pointer)

    @classmethod
    def report(cls, tags: "typing.List[Tag]",content: "str"):
        """
        Reporting

        <https://github.com/nostr-protocol/nips/blob/master/56.md>
        """

        _UniffiConverterSequenceTypeTag.check_lower(tags)
        
        _UniffiConverterString.check_lower(content)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_report,
        _UniffiConverterSequenceTypeTag.lower(tags),
        _UniffiConverterString.lower(content))
        return cls._make_instance_(pointer)

    @classmethod
    def repost(cls, event: "Event",relay_url: "typing.Union[object, typing.Optional[RelayUrl]]" = _DEFAULT):
        """
        Repost

        <https://github.com/nostr-protocol/nips/blob/master/18.md>
        """

        _UniffiConverterTypeEvent.check_lower(event)
        
        if relay_url is _DEFAULT:
            relay_url = None
        _UniffiConverterOptionalTypeRelayUrl.check_lower(relay_url)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeNostrSdkError,_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_repost,
        _UniffiConverterTypeEvent.lower(event),
        _UniffiConverterOptionalTypeRelayUrl.lower(relay_url))
        return cls._make_instance_(pointer)

    @classmethod
    async def seal(cls, signer: "NostrSigner",receiver_public_key: "PublicKey",rumor: "UnsignedEvent"):
        """
        Seal

        <https://github.com/nostr-protocol/nips/blob/master/59.md>
        """

        _UniffiConverterTypeNostrSigner.check_lower(signer)
        
        _UniffiConverterTypePublicKey.check_lower(receiver_public_key)
        
        _UniffiConverterTypeUnsignedEvent.check_lower(rumor)
        

        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_seal(
        _UniffiConverterTypeNostrSigner.lower(signer),
        _UniffiConverterTypePublicKey.lower(receiver_public_key),
        _UniffiConverterTypeUnsignedEvent.lower(rumor)),
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_poll_pointer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_complete_pointer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_free_pointer,
            _UniffiConverterTypeEventBuilder.lift,
            
    # Error FFI converter
_UniffiConverterTypeNostrSdkError,

        )

    @classmethod
    def search_relays(cls, relay: "typing.List[RelayUrl]"):
        """
        Search relays

        <https://github.com/nostr-protocol/nips/blob/master/51.md>
        """

        _UniffiConverterSequenceTypeRelayUrl.check_lower(relay)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_search_relays,
        _UniffiConverterSequenceTypeRelayUrl.lower(relay))
        return cls._make_instance_(pointer)

    @classmethod
    def stall_data(cls, data: "StallData"):
        """
        Set stall data

        <https://github.com/nostr-protocol/nips/blob/master/15.md>
        """

        _UniffiConverterTypeStallData.check_lower(data)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_stall_data,
        _UniffiConverterTypeStallData.lower(data))
        return cls._make_instance_(pointer)

    @classmethod
    def text_note(cls, content: "str"):
        """
        Text note

        <https://github.com/nostr-protocol/nips/blob/master/01.md>
        """

        _UniffiConverterString.check_lower(content)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_text_note,
        _UniffiConverterString.lower(content))
        return cls._make_instance_(pointer)

    @classmethod
    def text_note_reply(cls, content: "str",reply_to: "Event",root: "typing.Union[object, typing.Optional[Event]]" = _DEFAULT,relay_url: "typing.Union[object, typing.Optional[RelayUrl]]" = _DEFAULT):
        """
        Text note reply

        This adds only the most significant tags, like:
        - `p` tag with the author of the `reply_to` and `root` events;
        - `e` tag of the `reply_to` and `root` events.

        Any additional necessary tag can be added with [`EventBuilder::tag`] or [`EventBuilder::tags`].

        <https://github.com/nostr-protocol/nips/blob/master/10.md>
        """

        _UniffiConverterString.check_lower(content)
        
        _UniffiConverterTypeEvent.check_lower(reply_to)
        
        if root is _DEFAULT:
            root = None
        _UniffiConverterOptionalTypeEvent.check_lower(root)
        
        if relay_url is _DEFAULT:
            relay_url = None
        _UniffiConverterOptionalTypeRelayUrl.check_lower(relay_url)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeNostrSdkError,_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_text_note_reply,
        _UniffiConverterString.lower(content),
        _UniffiConverterTypeEvent.lower(reply_to),
        _UniffiConverterOptionalTypeEvent.lower(root),
        _UniffiConverterOptionalTypeRelayUrl.lower(relay_url))
        return cls._make_instance_(pointer)

    @classmethod
    def videos_curation_set(cls, identifier: "str",video: "typing.List[Coordinate]"):
        """
        Videos Curation set

        <https://github.com/nostr-protocol/nips/blob/master/51.md>
        """

        _UniffiConverterString.check_lower(identifier)
        
        _UniffiConverterSequenceTypeCoordinate.check_lower(video)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_videos_curation_set,
        _UniffiConverterString.lower(identifier),
        _UniffiConverterSequenceTypeCoordinate.lower(video))
        return cls._make_instance_(pointer)

    @classmethod
    def zap_receipt(cls, bolt11: "str",preimage: "typing.Optional[str]",zap_request: "Event"):
        """
        Zap Receipt

        <https://github.com/nostr-protocol/nips/blob/master/57.md>
        """

        _UniffiConverterString.check_lower(bolt11)
        
        _UniffiConverterOptionalString.check_lower(preimage)
        
        _UniffiConverterTypeEvent.check_lower(zap_request)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_zap_receipt,
        _UniffiConverterString.lower(bolt11),
        _UniffiConverterOptionalString.lower(preimage),
        _UniffiConverterTypeEvent.lower(zap_request))
        return cls._make_instance_(pointer)



    def allow_self_tagging(self, ) -> "EventBuilder":
        """
        Allow self-tagging

        When this mode is enabled, any `p` tags referencing the authors public key will not be discarded.
        """

        return _UniffiConverterTypeEventBuilder.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_eventbuilder_allow_self_tagging,self._uniffi_clone_pointer(),)
        )





    def build(self, public_key: "PublicKey") -> "UnsignedEvent":
        """
        Build an unsigned event

        By default, this method removes any `p` tags that match the author's public key.
        To allow self-tagging, call [`EventBuilder::allow_self_tagging`] first.
        """

        _UniffiConverterTypePublicKey.check_lower(public_key)
        
        return _UniffiConverterTypeUnsignedEvent.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_eventbuilder_build,self._uniffi_clone_pointer(),
        _UniffiConverterTypePublicKey.lower(public_key))
        )





    def custom_created_at(self, created_at: "Timestamp") -> "EventBuilder":
        """
        Set a custom `created_at` UNIX timestamp
        """

        _UniffiConverterTypeTimestamp.check_lower(created_at)
        
        return _UniffiConverterTypeEventBuilder.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_eventbuilder_custom_created_at,self._uniffi_clone_pointer(),
        _UniffiConverterTypeTimestamp.lower(created_at))
        )





    def dedup_tags(self, ) -> "EventBuilder":
        """
        Deduplicate tags

        For more details check [`Tags::dedup`].
        """

        return _UniffiConverterTypeEventBuilder.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_eventbuilder_dedup_tags,self._uniffi_clone_pointer(),)
        )





    def pow(self, difficulty: "int") -> "EventBuilder":
        """
        Set POW difficulty

        Only values `> 0` are accepted!
        """

        _UniffiConverterUInt8.check_lower(difficulty)
        
        return _UniffiConverterTypeEventBuilder.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_eventbuilder_pow,self._uniffi_clone_pointer(),
        _UniffiConverterUInt8.lower(difficulty))
        )




    async def sign(self, signer: "NostrSigner") -> "Event":
        """
        Build, sign and return [`Event`]

        Check [`EventBuilder::build`] to learn more.
        """

        _UniffiConverterTypeNostrSigner.check_lower(signer)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_nostr_sdk_ffi_fn_method_eventbuilder_sign(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeNostrSigner.lower(signer)
            ),
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_poll_pointer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_complete_pointer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_free_pointer,
            # lift function
            _UniffiConverterTypeEvent.lift,
            
    # Error FFI converter
_UniffiConverterTypeNostrSdkError,

        )




    def sign_with_keys(self, keys: "Keys") -> "Event":
        """
        Build, sign and return [`Event`] using [`Keys`] signer

        Check [`EventBuilder::build`] to learn more.
        """

        _UniffiConverterTypeKeys.check_lower(keys)
        
        return _UniffiConverterTypeEvent.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeNostrSdkError,_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_eventbuilder_sign_with_keys,self._uniffi_clone_pointer(),
        _UniffiConverterTypeKeys.lower(keys))
        )





    def tags(self, tags: "typing.List[Tag]") -> "EventBuilder":
        """
        Add tags

        This method extend the current tags (if any).
        """

        _UniffiConverterSequenceTypeTag.check_lower(tags)
        
        return _UniffiConverterTypeEventBuilder.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_eventbuilder_tags,self._uniffi_clone_pointer(),
        _UniffiConverterSequenceTypeTag.lower(tags))
        )





    def __repr__(self, ) -> "str":
        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_eventbuilder_uniffi_trait_debug,self._uniffi_clone_pointer(),)
        )



    def __eq__(self, other: object) -> bool:
        if not isinstance(other, EventBuilder):
            return NotImplemented

        return _UniffiConverterBool.lift(_uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_eventbuilder_uniffi_trait_eq_eq,self._uniffi_clone_pointer(),
        _UniffiConverterTypeEventBuilder.lower(other)))

    def __ne__(self, other: object) -> bool:
        if not isinstance(other, EventBuilder):
            return NotImplemented

        return _UniffiConverterBool.lift(_uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_eventbuilder_uniffi_trait_eq_ne,self._uniffi_clone_pointer(),
        _UniffiConverterTypeEventBuilder.lower(other)))


    def __hash__(self, ) -> "int":
        return _UniffiConverterUInt64.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_eventbuilder_uniffi_trait_hash,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeEventBuilder:

    @staticmethod
    def lift(value: int):
        return EventBuilder._make_instance_(value)

    @staticmethod
    def check_lower(value: EventBuilder):
        if not isinstance(value, EventBuilder):
            raise TypeError("Expected EventBuilder instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: EventBuilderProtocol):
        if not isinstance(value, EventBuilder):
            raise TypeError("Expected EventBuilder instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: EventBuilderProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class EventIdProtocol(typing.Protocol):
    def as_bytes(self, ):
        raise NotImplementedError
    def to_bech32(self, ):
        raise NotImplementedError
    def to_hex(self, ):
        raise NotImplementedError
    def to_nostr_uri(self, ):
        raise NotImplementedError
# EventId is a Rust-only trait - it's a wrapper around a Rust implementation.
class EventId():
    _pointer: ctypes.c_void_p
    def __init__(self, public_key: "PublicKey",created_at: "Timestamp",kind: "Kind",tags: "Tags",content: "str"):
        _UniffiConverterTypePublicKey.check_lower(public_key)
        
        _UniffiConverterTypeTimestamp.check_lower(created_at)
        
        _UniffiConverterTypeKind.check_lower(kind)
        
        _UniffiConverterTypeTags.check_lower(tags)
        
        _UniffiConverterString.check_lower(content)
        
        self._pointer = _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventid_new,
        _UniffiConverterTypePublicKey.lower(public_key),
        _UniffiConverterTypeTimestamp.lower(created_at),
        _UniffiConverterTypeKind.lower(kind),
        _UniffiConverterTypeTags.lower(tags),
        _UniffiConverterString.lower(content))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_eventid, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_eventid, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst
    @classmethod
    def from_bytes(cls, bytes: "bytes"):
        _UniffiConverterBytes.check_lower(bytes)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeNostrSdkError,_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventid_from_bytes,
        _UniffiConverterBytes.lower(bytes))
        return cls._make_instance_(pointer)

    @classmethod
    def parse(cls, id: "str"):
        """
        Try to parse event ID from `hex`, `bech32` or [NIP21](https://github.com/nostr-protocol/nips/blob/master/21.md) uri
        """

        _UniffiConverterString.check_lower(id)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeNostrSdkError,_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_eventid_parse,
        _UniffiConverterString.lower(id))
        return cls._make_instance_(pointer)



    def as_bytes(self, ) -> "bytes":
        return _UniffiConverterBytes.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_eventid_as_bytes,self._uniffi_clone_pointer(),)
        )





    def to_bech32(self, ) -> "str":
        return _UniffiConverterString.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeNostrSdkError,_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_eventid_to_bech32,self._uniffi_clone_pointer(),)
        )





    def to_hex(self, ) -> "str":
        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_eventid_to_hex,self._uniffi_clone_pointer(),)
        )





    def to_nostr_uri(self, ) -> "str":
        return _UniffiConverterString.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeNostrSdkError,_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_eventid_to_nostr_uri,self._uniffi_clone_pointer(),)
        )





    def __repr__(self, ) -> "str":
        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_eventid_uniffi_trait_debug,self._uniffi_clone_pointer(),)
        )



    def __eq__(self, other: object) -> bool:
        if not isinstance(other, EventId):
            return NotImplemented

        return _UniffiConverterBool.lift(_uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_eventid_uniffi_trait_eq_eq,self._uniffi_clone_pointer(),
        _UniffiConverterTypeEventId.lower(other)))

    def __ne__(self, other: object) -> bool:
        if not isinstance(other, EventId):
            return NotImplemented

        return _UniffiConverterBool.lift(_uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_eventid_uniffi_trait_eq_ne,self._uniffi_clone_pointer(),
        _UniffiConverterTypeEventId.lower(other)))


    def __hash__(self, ) -> "int":
        return _UniffiConverterUInt64.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_eventid_uniffi_trait_hash,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeEventId:

    @staticmethod
    def lift(value: int):
        return EventId._make_instance_(value)

    @staticmethod
    def check_lower(value: EventId):
        if not isinstance(value, EventId):
            raise TypeError("Expected EventId instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: EventIdProtocol):
        if not isinstance(value, EventId):
            raise TypeError("Expected EventId instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: EventIdProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class EventStreamProtocol(typing.Protocol):
    def next(self, ):
        raise NotImplementedError
# EventStream is a Rust-only trait - it's a wrapper around a Rust implementation.
class EventStream():
    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_eventstream, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_eventstream, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    async def next(self, ) -> "typing.Optional[Event]":
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_nostr_sdk_ffi_fn_method_eventstream_next(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterOptionalTypeEvent.lift,
            
    # Error FFI converter

    None,

        )





class _UniffiConverterTypeEventStream:

    @staticmethod
    def lift(value: int):
        return EventStream._make_instance_(value)

    @staticmethod
    def check_lower(value: EventStream):
        if not isinstance(value, EventStream):
            raise TypeError("Expected EventStream instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: EventStreamProtocol):
        if not isinstance(value, EventStream):
            raise TypeError("Expected EventStream instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: EventStreamProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class EventsProtocol(typing.Protocol):
    def contains(self, event: "Event"):
        """
        Check if contains `Event`
        """

        raise NotImplementedError
    def first(self, ):
        """
        Get first `Event` (descending order)
        """

        raise NotImplementedError
    def is_empty(self, ):
        """
        Returns the number of events in the collection.
        """

        raise NotImplementedError
    def len(self, ):
        """
        Returns the number of events in the collection.
        """

        raise NotImplementedError
    def merge(self, other: "Events"):
        """
        Merge events collections into a single one.

        This method consumes the object, making it unavailable for further use.

        Collection is converted to unbounded if one of the merge `Events` has a different hash.
        In other words, the filter limit is respected only if the `Events` are related to the same
        list of filters.
        """

        raise NotImplementedError
    def to_vec(self, ):
        """
        Convert the collection to vector of events.

        This method consumes the object, making it unavailable for further use.
        """

        raise NotImplementedError
# Events is a Rust-only trait - it's a wrapper around a Rust implementation.
class Events():
    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_events, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_events, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def contains(self, event: "Event") -> "bool":
        """
        Check if contains `Event`
        """

        _UniffiConverterTypeEvent.check_lower(event)
        
        return _UniffiConverterBool.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_events_contains,self._uniffi_clone_pointer(),
        _UniffiConverterTypeEvent.lower(event))
        )





    def first(self, ) -> "typing.Optional[Event]":
        """
        Get first `Event` (descending order)
        """

        return _UniffiConverterOptionalTypeEvent.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_events_first,self._uniffi_clone_pointer(),)
        )





    def is_empty(self, ) -> "bool":
        """
        Returns the number of events in the collection.
        """

        return _UniffiConverterBool.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_events_is_empty,self._uniffi_clone_pointer(),)
        )





    def len(self, ) -> "int":
        """
        Returns the number of events in the collection.
        """

        return _UniffiConverterUInt64.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_events_len,self._uniffi_clone_pointer(),)
        )





    def merge(self, other: "Events") -> "Events":
        """
        Merge events collections into a single one.

        This method consumes the object, making it unavailable for further use.

        Collection is converted to unbounded if one of the merge `Events` has a different hash.
        In other words, the filter limit is respected only if the `Events` are related to the same
        list of filters.
        """

        _UniffiConverterTypeEvents.check_lower(other)
        
        return _UniffiConverterTypeEvents.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeNostrSdkError,_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_events_merge,self._uniffi_clone_pointer(),
        _UniffiConverterTypeEvents.lower(other))
        )





    def to_vec(self, ) -> "typing.List[Event]":
        """
        Convert the collection to vector of events.

        This method consumes the object, making it unavailable for further use.
        """

        return _UniffiConverterSequenceTypeEvent.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeNostrSdkError,_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_events_to_vec,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeEvents:

    @staticmethod
    def lift(value: int):
        return Events._make_instance_(value)

    @staticmethod
    def check_lower(value: Events):
        if not isinstance(value, Events):
            raise TypeError("Expected Events instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: EventsProtocol):
        if not isinstance(value, Events):
            raise TypeError("Expected Events instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: EventsProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class FileMetadataProtocol(typing.Protocol):
    def aes_256_gcm(self, key: "str",iv: "str"):
        raise NotImplementedError
    def blurhash(self, blurhash: "str"):
        """
        Add blurhash
        """

        raise NotImplementedError
    def dimensions(self, dim: "ImageDimensions"):
        """
        Add file size (pixels)
        """

        raise NotImplementedError
    def magnet(self, magnet: "str"):
        """
        Add magnet
        """

        raise NotImplementedError
    def size(self, size: "int"):
        """
        Add file size (bytes)
        """

        raise NotImplementedError
# FileMetadata is a Rust-only trait - it's a wrapper around a Rust implementation.
class FileMetadata():
    _pointer: ctypes.c_void_p
    def __init__(self, url: "str",mime_type: "str",hash: "str"):
        _UniffiConverterString.check_lower(url)
        
        _UniffiConverterString.check_lower(mime_type)
        
        _UniffiConverterString.check_lower(hash)
        
        self._pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeNostrSdkError,_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_filemetadata_new,
        _UniffiConverterString.lower(url),
        _UniffiConverterString.lower(mime_type),
        _UniffiConverterString.lower(hash))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_filemetadata, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_filemetadata, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def aes_256_gcm(self, key: "str",iv: "str") -> "FileMetadata":
        _UniffiConverterString.check_lower(key)
        
        _UniffiConverterString.check_lower(iv)
        
        return _UniffiConverterTypeFileMetadata.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filemetadata_aes_256_gcm,self._uniffi_clone_pointer(),
        _UniffiConverterString.lower(key),
        _UniffiConverterString.lower(iv))
        )





    def blurhash(self, blurhash: "str") -> "FileMetadata":
        """
        Add blurhash
        """

        _UniffiConverterString.check_lower(blurhash)
        
        return _UniffiConverterTypeFileMetadata.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filemetadata_blurhash,self._uniffi_clone_pointer(),
        _UniffiConverterString.lower(blurhash))
        )





    def dimensions(self, dim: "ImageDimensions") -> "FileMetadata":
        """
        Add file size (pixels)
        """

        _UniffiConverterTypeImageDimensions.check_lower(dim)
        
        return _UniffiConverterTypeFileMetadata.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filemetadata_dimensions,self._uniffi_clone_pointer(),
        _UniffiConverterTypeImageDimensions.lower(dim))
        )





    def magnet(self, magnet: "str") -> "FileMetadata":
        """
        Add magnet
        """

        _UniffiConverterString.check_lower(magnet)
        
        return _UniffiConverterTypeFileMetadata.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filemetadata_magnet,self._uniffi_clone_pointer(),
        _UniffiConverterString.lower(magnet))
        )





    def size(self, size: "int") -> "FileMetadata":
        """
        Add file size (bytes)
        """

        _UniffiConverterUInt64.check_lower(size)
        
        return _UniffiConverterTypeFileMetadata.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filemetadata_size,self._uniffi_clone_pointer(),
        _UniffiConverterUInt64.lower(size))
        )





    def __repr__(self, ) -> "str":
        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filemetadata_uniffi_trait_debug,self._uniffi_clone_pointer(),)
        )



    def __eq__(self, other: object) -> bool:
        if not isinstance(other, FileMetadata):
            return NotImplemented

        return _UniffiConverterBool.lift(_uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filemetadata_uniffi_trait_eq_eq,self._uniffi_clone_pointer(),
        _UniffiConverterTypeFileMetadata.lower(other)))

    def __ne__(self, other: object) -> bool:
        if not isinstance(other, FileMetadata):
            return NotImplemented

        return _UniffiConverterBool.lift(_uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filemetadata_uniffi_trait_eq_ne,self._uniffi_clone_pointer(),
        _UniffiConverterTypeFileMetadata.lower(other)))


    def __hash__(self, ) -> "int":
        return _UniffiConverterUInt64.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filemetadata_uniffi_trait_hash,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeFileMetadata:

    @staticmethod
    def lift(value: int):
        return FileMetadata._make_instance_(value)

    @staticmethod
    def check_lower(value: FileMetadata):
        if not isinstance(value, FileMetadata):
            raise TypeError("Expected FileMetadata instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: FileMetadataProtocol):
        if not isinstance(value, FileMetadata):
            raise TypeError("Expected FileMetadata instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: FileMetadataProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class FilterProtocol(typing.Protocol):
    def as_json(self, ):
        raise NotImplementedError
    def as_record(self, ):
        raise NotImplementedError
    def author(self, author: "PublicKey"):
        """
        Add event author Public Key
        """

        raise NotImplementedError
    def authors(self, authors: "typing.List[PublicKey]"):
        raise NotImplementedError
    def coordinate(self, coordinate: "Coordinate"):
        """
        Add coordinate

        Query for `a` tag.

        <https://github.com/nostr-protocol/nips/blob/master/01.md>
        """

        raise NotImplementedError
    def coordinates(self, coordinates: "typing.List[Coordinate]"):
        """
        Add coordinates

        Query for `a` tags.

        <https://github.com/nostr-protocol/nips/blob/master/01.md>
        """

        raise NotImplementedError
    def custom_tag(self, tag: "SingleLetterTag",content: "str"):
        raise NotImplementedError
    def custom_tags(self, tag: "SingleLetterTag",contents: "typing.List[str]"):
        raise NotImplementedError
    def event(self, event_id: "EventId"):
        """
        Add event ID (`e` tag)
        """

        raise NotImplementedError
    def events(self, ids: "typing.List[EventId]"):
        """
        Add event IDs (`e` tag)
        """

        raise NotImplementedError
    def hashtag(self, hashtag: "str"):
        raise NotImplementedError
    def hashtags(self, hashtags: "typing.List[str]"):
        raise NotImplementedError
    def id(self, id: "EventId"):
        raise NotImplementedError
    def identifier(self, identifier: "str"):
        raise NotImplementedError
    def identifiers(self, identifiers: "typing.List[str]"):
        raise NotImplementedError
    def ids(self, ids: "typing.List[EventId]"):
        raise NotImplementedError
    def is_empty(self, ):
        raise NotImplementedError
    def kind(self, kind: "Kind"):
        raise NotImplementedError
    def kinds(self, kinds: "typing.List[Kind]"):
        raise NotImplementedError
    def limit(self, limit: "int"):
        raise NotImplementedError
    def match_event(self, event: "Event"):
        """
        Determine if `Filter` match given `Event`.
        """

        raise NotImplementedError
    def pubkey(self, pubkey: "PublicKey"):
        """
        Add Public Key (`p` tag)
        """

        raise NotImplementedError
    def pubkeys(self, pubkeys: "typing.List[PublicKey]"):
        """
        Add Public Keys (`p` tag)
        """

        raise NotImplementedError
    def reference(self, reference: "str"):
        raise NotImplementedError
    def references(self, references: "typing.List[str]"):
        raise NotImplementedError
    def remove_authors(self, authors: "typing.List[PublicKey]"):
        raise NotImplementedError
    def remove_coordinates(self, coordinates: "typing.List[Coordinate]"):
        """
        Remove coordinates

        Remove `a` tags.

        <https://github.com/nostr-protocol/nips/blob/master/01.md>
        """

        raise NotImplementedError
    def remove_custom_tags(self, tag: "SingleLetterTag",contents: "typing.List[str]"):
        raise NotImplementedError
    def remove_events(self, ids: "typing.List[EventId]"):
        raise NotImplementedError
    def remove_hashtags(self, hashtags: "typing.List[str]"):
        raise NotImplementedError
    def remove_identifiers(self, identifiers: "typing.List[str]"):
        raise NotImplementedError
    def remove_ids(self, ids: "typing.List[EventId]"):
        raise NotImplementedError
    def remove_kinds(self, kinds: "typing.List[Kind]"):
        raise NotImplementedError
    def remove_limit(self, ):
        raise NotImplementedError
    def remove_pubkeys(self, pubkeys: "typing.List[PublicKey]"):
        raise NotImplementedError
    def remove_references(self, references: "typing.List[str]"):
        raise NotImplementedError
    def remove_search(self, ):
        raise NotImplementedError
    def remove_since(self, ):
        raise NotImplementedError
    def remove_until(self, ):
        raise NotImplementedError
    def search(self, text: "str"):
        raise NotImplementedError
    def since(self, timestamp: "Timestamp"):
        raise NotImplementedError
    def until(self, timestamp: "Timestamp"):
        raise NotImplementedError
# Filter is a Rust-only trait - it's a wrapper around a Rust implementation.
class Filter():
    _pointer: ctypes.c_void_p
    def __init__(self, ):
        self._pointer = _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_filter_new,)

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_filter, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_filter, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst
    @classmethod
    def from_json(cls, json: "str"):
        _UniffiConverterString.check_lower(json)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeNostrSdkError,_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_filter_from_json,
        _UniffiConverterString.lower(json))
        return cls._make_instance_(pointer)

    @classmethod
    def from_record(cls, record: "FilterRecord"):
        _UniffiConverterTypeFilterRecord.check_lower(record)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_filter_from_record,
        _UniffiConverterTypeFilterRecord.lower(record))
        return cls._make_instance_(pointer)



    def as_json(self, ) -> "str":
        return _UniffiConverterString.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeNostrSdkError,_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filter_as_json,self._uniffi_clone_pointer(),)
        )





    def as_record(self, ) -> "FilterRecord":
        return _UniffiConverterTypeFilterRecord.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filter_as_record,self._uniffi_clone_pointer(),)
        )





    def author(self, author: "PublicKey") -> "Filter":
        """
        Add event author Public Key
        """

        _UniffiConverterTypePublicKey.check_lower(author)
        
        return _UniffiConverterTypeFilter.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filter_author,self._uniffi_clone_pointer(),
        _UniffiConverterTypePublicKey.lower(author))
        )





    def authors(self, authors: "typing.List[PublicKey]") -> "Filter":
        _UniffiConverterSequenceTypePublicKey.check_lower(authors)
        
        return _UniffiConverterTypeFilter.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filter_authors,self._uniffi_clone_pointer(),
        _UniffiConverterSequenceTypePublicKey.lower(authors))
        )





    def coordinate(self, coordinate: "Coordinate") -> "Filter":
        """
        Add coordinate

        Query for `a` tag.

        <https://github.com/nostr-protocol/nips/blob/master/01.md>
        """

        _UniffiConverterTypeCoordinate.check_lower(coordinate)
        
        return _UniffiConverterTypeFilter.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filter_coordinate,self._uniffi_clone_pointer(),
        _UniffiConverterTypeCoordinate.lower(coordinate))
        )





    def coordinates(self, coordinates: "typing.List[Coordinate]") -> "Filter":
        """
        Add coordinates

        Query for `a` tags.

        <https://github.com/nostr-protocol/nips/blob/master/01.md>
        """

        _UniffiConverterSequenceTypeCoordinate.check_lower(coordinates)
        
        return _UniffiConverterTypeFilter.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filter_coordinates,self._uniffi_clone_pointer(),
        _UniffiConverterSequenceTypeCoordinate.lower(coordinates))
        )





    def custom_tag(self, tag: "SingleLetterTag",content: "str") -> "Filter":
        _UniffiConverterTypeSingleLetterTag.check_lower(tag)
        
        _UniffiConverterString.check_lower(content)
        
        return _UniffiConverterTypeFilter.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filter_custom_tag,self._uniffi_clone_pointer(),
        _UniffiConverterTypeSingleLetterTag.lower(tag),
        _UniffiConverterString.lower(content))
        )





    def custom_tags(self, tag: "SingleLetterTag",contents: "typing.List[str]") -> "Filter":
        _UniffiConverterTypeSingleLetterTag.check_lower(tag)
        
        _UniffiConverterSequenceString.check_lower(contents)
        
        return _UniffiConverterTypeFilter.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filter_custom_tags,self._uniffi_clone_pointer(),
        _UniffiConverterTypeSingleLetterTag.lower(tag),
        _UniffiConverterSequenceString.lower(contents))
        )





    def event(self, event_id: "EventId") -> "Filter":
        """
        Add event ID (`e` tag)
        """

        _UniffiConverterTypeEventId.check_lower(event_id)
        
        return _UniffiConverterTypeFilter.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filter_event,self._uniffi_clone_pointer(),
        _UniffiConverterTypeEventId.lower(event_id))
        )





    def events(self, ids: "typing.List[EventId]") -> "Filter":
        """
        Add event IDs (`e` tag)
        """

        _UniffiConverterSequenceTypeEventId.check_lower(ids)
        
        return _UniffiConverterTypeFilter.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filter_events,self._uniffi_clone_pointer(),
        _UniffiConverterSequenceTypeEventId.lower(ids))
        )





    def hashtag(self, hashtag: "str") -> "Filter":
        _UniffiConverterString.check_lower(hashtag)
        
        return _UniffiConverterTypeFilter.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filter_hashtag,self._uniffi_clone_pointer(),
        _UniffiConverterString.lower(hashtag))
        )





    def hashtags(self, hashtags: "typing.List[str]") -> "Filter":
        _UniffiConverterSequenceString.check_lower(hashtags)
        
        return _UniffiConverterTypeFilter.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filter_hashtags,self._uniffi_clone_pointer(),
        _UniffiConverterSequenceString.lower(hashtags))
        )





    def id(self, id: "EventId") -> "Filter":
        _UniffiConverterTypeEventId.check_lower(id)
        
        return _UniffiConverterTypeFilter.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filter_id,self._uniffi_clone_pointer(),
        _UniffiConverterTypeEventId.lower(id))
        )





    def identifier(self, identifier: "str") -> "Filter":
        _UniffiConverterString.check_lower(identifier)
        
        return _UniffiConverterTypeFilter.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filter_identifier,self._uniffi_clone_pointer(),
        _UniffiConverterString.lower(identifier))
        )





    def identifiers(self, identifiers: "typing.List[str]") -> "Filter":
        _UniffiConverterSequenceString.check_lower(identifiers)
        
        return _UniffiConverterTypeFilter.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filter_identifiers,self._uniffi_clone_pointer(),
        _UniffiConverterSequenceString.lower(identifiers))
        )





    def ids(self, ids: "typing.List[EventId]") -> "Filter":
        _UniffiConverterSequenceTypeEventId.check_lower(ids)
        
        return _UniffiConverterTypeFilter.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filter_ids,self._uniffi_clone_pointer(),
        _UniffiConverterSequenceTypeEventId.lower(ids))
        )





    def is_empty(self, ) -> "bool":
        return _UniffiConverterBool.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filter_is_empty,self._uniffi_clone_pointer(),)
        )





    def kind(self, kind: "Kind") -> "Filter":
        _UniffiConverterTypeKind.check_lower(kind)
        
        return _UniffiConverterTypeFilter.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filter_kind,self._uniffi_clone_pointer(),
        _UniffiConverterTypeKind.lower(kind))
        )





    def kinds(self, kinds: "typing.List[Kind]") -> "Filter":
        _UniffiConverterSequenceTypeKind.check_lower(kinds)
        
        return _UniffiConverterTypeFilter.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filter_kinds,self._uniffi_clone_pointer(),
        _UniffiConverterSequenceTypeKind.lower(kinds))
        )





    def limit(self, limit: "int") -> "Filter":
        _UniffiConverterUInt64.check_lower(limit)
        
        return _UniffiConverterTypeFilter.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filter_limit,self._uniffi_clone_pointer(),
        _UniffiConverterUInt64.lower(limit))
        )





    def match_event(self, event: "Event") -> "bool":
        """
        Determine if `Filter` match given `Event`.
        """

        _UniffiConverterTypeEvent.check_lower(event)
        
        return _UniffiConverterBool.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filter_match_event,self._uniffi_clone_pointer(),
        _UniffiConverterTypeEvent.lower(event))
        )





    def pubkey(self, pubkey: "PublicKey") -> "Filter":
        """
        Add Public Key (`p` tag)
        """

        _UniffiConverterTypePublicKey.check_lower(pubkey)
        
        return _UniffiConverterTypeFilter.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filter_pubkey,self._uniffi_clone_pointer(),
        _UniffiConverterTypePublicKey.lower(pubkey))
        )





    def pubkeys(self, pubkeys: "typing.List[PublicKey]") -> "Filter":
        """
        Add Public Keys (`p` tag)
        """

        _UniffiConverterSequenceTypePublicKey.check_lower(pubkeys)
        
        return _UniffiConverterTypeFilter.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filter_pubkeys,self._uniffi_clone_pointer(),
        _UniffiConverterSequenceTypePublicKey.lower(pubkeys))
        )





    def reference(self, reference: "str") -> "Filter":
        _UniffiConverterString.check_lower(reference)
        
        return _UniffiConverterTypeFilter.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filter_reference,self._uniffi_clone_pointer(),
        _UniffiConverterString.lower(reference))
        )





    def references(self, references: "typing.List[str]") -> "Filter":
        _UniffiConverterSequenceString.check_lower(references)
        
        return _UniffiConverterTypeFilter.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filter_references,self._uniffi_clone_pointer(),
        _UniffiConverterSequenceString.lower(references))
        )





    def remove_authors(self, authors: "typing.List[PublicKey]") -> "Filter":
        _UniffiConverterSequenceTypePublicKey.check_lower(authors)
        
        return _UniffiConverterTypeFilter.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filter_remove_authors,self._uniffi_clone_pointer(),
        _UniffiConverterSequenceTypePublicKey.lower(authors))
        )





    def remove_coordinates(self, coordinates: "typing.List[Coordinate]") -> "Filter":
        """
        Remove coordinates

        Remove `a` tags.

        <https://github.com/nostr-protocol/nips/blob/master/01.md>
        """

        _UniffiConverterSequenceTypeCoordinate.check_lower(coordinates)
        
        return _UniffiConverterTypeFilter.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filter_remove_coordinates,self._uniffi_clone_pointer(),
        _UniffiConverterSequenceTypeCoordinate.lower(coordinates))
        )





    def remove_custom_tags(self, tag: "SingleLetterTag",contents: "typing.List[str]") -> "Filter":
        _UniffiConverterTypeSingleLetterTag.check_lower(tag)
        
        _UniffiConverterSequenceString.check_lower(contents)
        
        return _UniffiConverterTypeFilter.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filter_remove_custom_tags,self._uniffi_clone_pointer(),
        _UniffiConverterTypeSingleLetterTag.lower(tag),
        _UniffiConverterSequenceString.lower(contents))
        )





    def remove_events(self, ids: "typing.List[EventId]") -> "Filter":
        _UniffiConverterSequenceTypeEventId.check_lower(ids)
        
        return _UniffiConverterTypeFilter.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filter_remove_events,self._uniffi_clone_pointer(),
        _UniffiConverterSequenceTypeEventId.lower(ids))
        )





    def remove_hashtags(self, hashtags: "typing.List[str]") -> "Filter":
        _UniffiConverterSequenceString.check_lower(hashtags)
        
        return _UniffiConverterTypeFilter.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filter_remove_hashtags,self._uniffi_clone_pointer(),
        _UniffiConverterSequenceString.lower(hashtags))
        )





    def remove_identifiers(self, identifiers: "typing.List[str]") -> "Filter":
        _UniffiConverterSequenceString.check_lower(identifiers)
        
        return _UniffiConverterTypeFilter.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filter_remove_identifiers,self._uniffi_clone_pointer(),
        _UniffiConverterSequenceString.lower(identifiers))
        )





    def remove_ids(self, ids: "typing.List[EventId]") -> "Filter":
        _UniffiConverterSequenceTypeEventId.check_lower(ids)
        
        return _UniffiConverterTypeFilter.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filter_remove_ids,self._uniffi_clone_pointer(),
        _UniffiConverterSequenceTypeEventId.lower(ids))
        )





    def remove_kinds(self, kinds: "typing.List[Kind]") -> "Filter":
        _UniffiConverterSequenceTypeKind.check_lower(kinds)
        
        return _UniffiConverterTypeFilter.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filter_remove_kinds,self._uniffi_clone_pointer(),
        _UniffiConverterSequenceTypeKind.lower(kinds))
        )





    def remove_limit(self, ) -> "Filter":
        return _UniffiConverterTypeFilter.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filter_remove_limit,self._uniffi_clone_pointer(),)
        )





    def remove_pubkeys(self, pubkeys: "typing.List[PublicKey]") -> "Filter":
        _UniffiConverterSequenceTypePublicKey.check_lower(pubkeys)
        
        return _UniffiConverterTypeFilter.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filter_remove_pubkeys,self._uniffi_clone_pointer(),
        _UniffiConverterSequenceTypePublicKey.lower(pubkeys))
        )





    def remove_references(self, references: "typing.List[str]") -> "Filter":
        _UniffiConverterSequenceString.check_lower(references)
        
        return _UniffiConverterTypeFilter.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filter_remove_references,self._uniffi_clone_pointer(),
        _UniffiConverterSequenceString.lower(references))
        )





    def remove_search(self, ) -> "Filter":
        return _UniffiConverterTypeFilter.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filter_remove_search,self._uniffi_clone_pointer(),)
        )





    def remove_since(self, ) -> "Filter":
        return _UniffiConverterTypeFilter.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filter_remove_since,self._uniffi_clone_pointer(),)
        )





    def remove_until(self, ) -> "Filter":
        return _UniffiConverterTypeFilter.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filter_remove_until,self._uniffi_clone_pointer(),)
        )





    def search(self, text: "str") -> "Filter":
        _UniffiConverterString.check_lower(text)
        
        return _UniffiConverterTypeFilter.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filter_search,self._uniffi_clone_pointer(),
        _UniffiConverterString.lower(text))
        )





    def since(self, timestamp: "Timestamp") -> "Filter":
        _UniffiConverterTypeTimestamp.check_lower(timestamp)
        
        return _UniffiConverterTypeFilter.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filter_since,self._uniffi_clone_pointer(),
        _UniffiConverterTypeTimestamp.lower(timestamp))
        )





    def until(self, timestamp: "Timestamp") -> "Filter":
        _UniffiConverterTypeTimestamp.check_lower(timestamp)
        
        return _UniffiConverterTypeFilter.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filter_until,self._uniffi_clone_pointer(),
        _UniffiConverterTypeTimestamp.lower(timestamp))
        )





    def __repr__(self, ) -> "str":
        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filter_uniffi_trait_debug,self._uniffi_clone_pointer(),)
        )



    def __eq__(self, other: object) -> bool:
        if not isinstance(other, Filter):
            return NotImplemented

        return _UniffiConverterBool.lift(_uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filter_uniffi_trait_eq_eq,self._uniffi_clone_pointer(),
        _UniffiConverterTypeFilter.lower(other)))

    def __ne__(self, other: object) -> bool:
        if not isinstance(other, Filter):
            return NotImplemented

        return _UniffiConverterBool.lift(_uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filter_uniffi_trait_eq_ne,self._uniffi_clone_pointer(),
        _UniffiConverterTypeFilter.lower(other)))


    def __hash__(self, ) -> "int":
        return _UniffiConverterUInt64.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_filter_uniffi_trait_hash,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeFilter:

    @staticmethod
    def lift(value: int):
        return Filter._make_instance_(value)

    @staticmethod
    def check_lower(value: Filter):
        if not isinstance(value, Filter):
            raise TypeError("Expected Filter instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: FilterProtocol):
        if not isinstance(value, Filter):
            raise TypeError("Expected Filter instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: FilterProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class JobFeedbackDataProtocol(typing.Protocol):
    """
    Data Vending Machine (DVM) - Job Feedback data

    <https://github.com/nostr-protocol/nips/blob/master/90.md>
    """

    def amount(self, millisats: "int",bolt11: "typing.Optional[str]"):
        """
        Add payment amount
        """

        raise NotImplementedError
    def extra_info(self, info: "str"):
        """
        Add extra info
        """

        raise NotImplementedError
    def payload(self, payload: "str"):
        """
        Add payload
        """

        raise NotImplementedError
# JobFeedbackData is a Rust-only trait - it's a wrapper around a Rust implementation.
class JobFeedbackData():
    """
    Data Vending Machine (DVM) - Job Feedback data

    <https://github.com/nostr-protocol/nips/blob/master/90.md>
    """

    _pointer: ctypes.c_void_p
    def __init__(self, job_request: "Event",status: "DataVendingMachineStatus"):
        """
        Construct new Job Feedback
        """

        _UniffiConverterTypeEvent.check_lower(job_request)
        
        _UniffiConverterTypeDataVendingMachineStatus.check_lower(status)
        
        self._pointer = _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_jobfeedbackdata_new,
        _UniffiConverterTypeEvent.lower(job_request),
        _UniffiConverterTypeDataVendingMachineStatus.lower(status))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_jobfeedbackdata, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_jobfeedbackdata, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def amount(self, millisats: "int",bolt11: "typing.Optional[str]") -> "JobFeedbackData":
        """
        Add payment amount
        """

        _UniffiConverterUInt64.check_lower(millisats)
        
        _UniffiConverterOptionalString.check_lower(bolt11)
        
        return _UniffiConverterTypeJobFeedbackData.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_jobfeedbackdata_amount,self._uniffi_clone_pointer(),
        _UniffiConverterUInt64.lower(millisats),
        _UniffiConverterOptionalString.lower(bolt11))
        )





    def extra_info(self, info: "str") -> "JobFeedbackData":
        """
        Add extra info
        """

        _UniffiConverterString.check_lower(info)
        
        return _UniffiConverterTypeJobFeedbackData.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_jobfeedbackdata_extra_info,self._uniffi_clone_pointer(),
        _UniffiConverterString.lower(info))
        )





    def payload(self, payload: "str") -> "JobFeedbackData":
        """
        Add payload
        """

        _UniffiConverterString.check_lower(payload)
        
        return _UniffiConverterTypeJobFeedbackData.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_jobfeedbackdata_payload,self._uniffi_clone_pointer(),
        _UniffiConverterString.lower(payload))
        )






class _UniffiConverterTypeJobFeedbackData:

    @staticmethod
    def lift(value: int):
        return JobFeedbackData._make_instance_(value)

    @staticmethod
    def check_lower(value: JobFeedbackData):
        if not isinstance(value, JobFeedbackData):
            raise TypeError("Expected JobFeedbackData instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: JobFeedbackDataProtocol):
        if not isinstance(value, JobFeedbackData):
            raise TypeError("Expected JobFeedbackData instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: JobFeedbackDataProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class KeysProtocol(typing.Protocol):
    """
    Nostr keys
    """

    def public_key(self, ):
        """
        Get public key
        """

        raise NotImplementedError
    def secret_key(self, ):
        """
        Get secret key
        """

        raise NotImplementedError
    def sign_schnorr(self, message: "bytes"):
        """
        Creates a schnorr signature of a message.

        This method use a random number generator that retrieves randomness from the operating system.
        """

        raise NotImplementedError
# Keys is a Rust-only trait - it's a wrapper around a Rust implementation.
class Keys():
    """
    Nostr keys
    """

    _pointer: ctypes.c_void_p
    def __init__(self, secret_key: "SecretKey"):
        """
        Initialize nostr keys from secret key.
        """

        _UniffiConverterTypeSecretKey.check_lower(secret_key)
        
        self._pointer = _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_keys_new,
        _UniffiConverterTypeSecretKey.lower(secret_key))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_keys, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_keys, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst
    @classmethod
    def from_mnemonic(cls, mnemonic: "str",passphrase: "typing.Union[object, typing.Optional[str]]" = _DEFAULT,account: "typing.Union[object, typing.Optional[int]]" = _DEFAULT,typ: "typing.Union[object, typing.Optional[int]]" = _DEFAULT,index: "typing.Union[object, typing.Optional[int]]" = _DEFAULT):
        """
        Derive keys from BIP-39 mnemonics (ENGLISH wordlist).

        <https://github.com/nostr-protocol/nips/blob/master/06.md>
        """

        _UniffiConverterString.check_lower(mnemonic)
        
        if passphrase is _DEFAULT:
            passphrase = None
        _UniffiConverterOptionalString.check_lower(passphrase)
        
        if account is _DEFAULT:
            account = None
        _UniffiConverterOptionalUInt32.check_lower(account)
        
        if typ is _DEFAULT:
            typ = None
        _UniffiConverterOptionalUInt32.check_lower(typ)
        
        if index is _DEFAULT:
            index = None
        _UniffiConverterOptionalUInt32.check_lower(index)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeNostrSdkError,_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_keys_from_mnemonic,
        _UniffiConverterString.lower(mnemonic),
        _UniffiConverterOptionalString.lower(passphrase),
        _UniffiConverterOptionalUInt32.lower(account),
        _UniffiConverterOptionalUInt32.lower(typ),
        _UniffiConverterOptionalUInt32.lower(index))
        return cls._make_instance_(pointer)

    @classmethod
    def generate(cls, ):
        """
        Generate random keys

        This constructor use a random number generator that retrieves randomness from the operating system.

        Generate random keys **without** construct the `Keypair`.
        This allows faster keys generation (i.e. for vanity pubkey mining).
        The `Keypair` will be automatically created when needed and stored in a cell.
        """

        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_keys_generate,)
        return cls._make_instance_(pointer)

    @classmethod
    def parse(cls, secret_key: "str"):
        """
        Parse secret key from `hex` or `bech32` and compose keys
        """

        _UniffiConverterString.check_lower(secret_key)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeNostrSdkError,_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_keys_parse,
        _UniffiConverterString.lower(secret_key))
        return cls._make_instance_(pointer)



    def public_key(self, ) -> "PublicKey":
        """
        Get public key
        """

        return _UniffiConverterTypePublicKey.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_keys_public_key,self._uniffi_clone_pointer(),)
        )





    def secret_key(self, ) -> "SecretKey":
        """
        Get secret key
        """

        return _UniffiConverterTypeSecretKey.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_keys_secret_key,self._uniffi_clone_pointer(),)
        )





    def sign_schnorr(self, message: "bytes") -> "str":
        """
        Creates a schnorr signature of a message.

        This method use a random number generator that retrieves randomness from the operating system.
        """

        _UniffiConverterBytes.check_lower(message)
        
        return _UniffiConverterString.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeNostrSdkError,_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_keys_sign_schnorr,self._uniffi_clone_pointer(),
        _UniffiConverterBytes.lower(message))
        )





    def __repr__(self, ) -> "str":
        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_keys_uniffi_trait_debug,self._uniffi_clone_pointer(),)
        )



    def __eq__(self, other: object) -> bool:
        if not isinstance(other, Keys):
            return NotImplemented

        return _UniffiConverterBool.lift(_uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_keys_uniffi_trait_eq_eq,self._uniffi_clone_pointer(),
        _UniffiConverterTypeKeys.lower(other)))

    def __ne__(self, other: object) -> bool:
        if not isinstance(other, Keys):
            return NotImplemented

        return _UniffiConverterBool.lift(_uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_keys_uniffi_trait_eq_ne,self._uniffi_clone_pointer(),
        _UniffiConverterTypeKeys.lower(other)))


    def __hash__(self, ) -> "int":
        return _UniffiConverterUInt64.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_keys_uniffi_trait_hash,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeKeys:

    @staticmethod
    def lift(value: int):
        return Keys._make_instance_(value)

    @staticmethod
    def check_lower(value: Keys):
        if not isinstance(value, Keys):
            raise TypeError("Expected Keys instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: KeysProtocol):
        if not isinstance(value, Keys):
            raise TypeError("Expected Keys instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: KeysProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class KindProtocol(typing.Protocol):
    """
    Event Kind
    """

    def as_std(self, ):
        raise NotImplementedError
    def as_u16(self, ):
        """
        Get as 16-bit unsigned integer
        """

        raise NotImplementedError
    def is_addressable(self, ):
        """
        Check if it's addressable

        Addressable means that, for each combination of `pubkey`, `kind` and the `d` tag's first value,
        only the latest event MUST be stored by relays, older versions MAY be discarded.

        <https://github.com/nostr-protocol/nips/blob/master/01.md>
        """

        raise NotImplementedError
    def is_ephemeral(self, ):
        """
        Check if it's ephemeral

        Ephemeral means that event is not expected to be stored by relays.

        <https://github.com/nostr-protocol/nips/blob/master/01.md>
        """

        raise NotImplementedError
    def is_job_request(self, ):
        """
        Check if it's a NIP90 job request

        <https://github.com/nostr-protocol/nips/blob/master/90.md>
        """

        raise NotImplementedError
    def is_job_result(self, ):
        """
        Check if it's a NIP90 job result

        <https://github.com/nostr-protocol/nips/blob/master/90.md>
        """

        raise NotImplementedError
    def is_regular(self, ):
        """
        Check if it's regular

        Regular means that event is expected to be stored by relays.

        <https://github.com/nostr-protocol/nips/blob/master/01.md>
        """

        raise NotImplementedError
    def is_replaceable(self, ):
        """
        Check if it's replaceable

        Replaceable means that, for each combination of `pubkey` and `kind`,
        only the latest event MUST be stored by relays, older versions MAY be discarded.

        <https://github.com/nostr-protocol/nips/blob/master/01.md>
        """

        raise NotImplementedError
# Kind is a Rust-only trait - it's a wrapper around a Rust implementation.
class Kind():
    """
    Event Kind
    """

    _pointer: ctypes.c_void_p
    def __init__(self, kind: "int"):
        _UniffiConverterUInt16.check_lower(kind)
        
        self._pointer = _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_kind_new,
        _UniffiConverterUInt16.lower(kind))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_kind, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_kind, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst
    @classmethod
    def from_std(cls, e: "KindStandard"):
        _UniffiConverterTypeKindStandard.check_lower(e)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_kind_from_std,
        _UniffiConverterTypeKindStandard.lower(e))
        return cls._make_instance_(pointer)



    def as_std(self, ) -> "typing.Optional[KindStandard]":
        return _UniffiConverterOptionalTypeKindStandard.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_kind_as_std,self._uniffi_clone_pointer(),)
        )





    def as_u16(self, ) -> "int":
        """
        Get as 16-bit unsigned integer
        """

        return _UniffiConverterUInt16.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_kind_as_u16,self._uniffi_clone_pointer(),)
        )





    def is_addressable(self, ) -> "bool":
        """
        Check if it's addressable

        Addressable means that, for each combination of `pubkey`, `kind` and the `d` tag's first value,
        only the latest event MUST be stored by relays, older versions MAY be discarded.

        <https://github.com/nostr-protocol/nips/blob/master/01.md>
        """

        return _UniffiConverterBool.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_kind_is_addressable,self._uniffi_clone_pointer(),)
        )





    def is_ephemeral(self, ) -> "bool":
        """
        Check if it's ephemeral

        Ephemeral means that event is not expected to be stored by relays.

        <https://github.com/nostr-protocol/nips/blob/master/01.md>
        """

        return _UniffiConverterBool.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_kind_is_ephemeral,self._uniffi_clone_pointer(),)
        )





    def is_job_request(self, ) -> "bool":
        """
        Check if it's a NIP90 job request

        <https://github.com/nostr-protocol/nips/blob/master/90.md>
        """

        return _UniffiConverterBool.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_kind_is_job_request,self._uniffi_clone_pointer(),)
        )





    def is_job_result(self, ) -> "bool":
        """
        Check if it's a NIP90 job result

        <https://github.com/nostr-protocol/nips/blob/master/90.md>
        """

        return _UniffiConverterBool.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_kind_is_job_result,self._uniffi_clone_pointer(),)
        )





    def is_regular(self, ) -> "bool":
        """
        Check if it's regular

        Regular means that event is expected to be stored by relays.

        <https://github.com/nostr-protocol/nips/blob/master/01.md>
        """

        return _UniffiConverterBool.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_kind_is_regular,self._uniffi_clone_pointer(),)
        )





    def is_replaceable(self, ) -> "bool":
        """
        Check if it's replaceable

        Replaceable means that, for each combination of `pubkey` and `kind`,
        only the latest event MUST be stored by relays, older versions MAY be discarded.

        <https://github.com/nostr-protocol/nips/blob/master/01.md>
        """

        return _UniffiConverterBool.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_kind_is_replaceable,self._uniffi_clone_pointer(),)
        )





    def __repr__(self, ) -> "str":
        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_kind_uniffi_trait_debug,self._uniffi_clone_pointer(),)
        )





    def __str__(self, ) -> "str":
        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_kind_uniffi_trait_display,self._uniffi_clone_pointer(),)
        )



    def __eq__(self, other: object) -> bool:
        if not isinstance(other, Kind):
            return NotImplemented

        return _UniffiConverterBool.lift(_uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_kind_uniffi_trait_eq_eq,self._uniffi_clone_pointer(),
        _UniffiConverterTypeKind.lower(other)))

    def __ne__(self, other: object) -> bool:
        if not isinstance(other, Kind):
            return NotImplemented

        return _UniffiConverterBool.lift(_uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_kind_uniffi_trait_eq_ne,self._uniffi_clone_pointer(),
        _UniffiConverterTypeKind.lower(other)))


    def __hash__(self, ) -> "int":
        return _UniffiConverterUInt64.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_kind_uniffi_trait_hash,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeKind:

    @staticmethod
    def lift(value: int):
        return Kind._make_instance_(value)

    @staticmethod
    def check_lower(value: Kind):
        if not isinstance(value, Kind):
            raise TypeError("Expected Kind instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: KindProtocol):
        if not isinstance(value, Kind):
            raise TypeError("Expected Kind instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: KindProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class LocalRelayProtocol(typing.Protocol):
    """
    A local nostr relay

    This is automatically shutdown when all instances/clones are dropped!
    """

    def notify_event(self, event: "Event"):
        """
        Send event to subscribers

        Return `true` if the event is successfully sent.

        This method doesn't save the event into the database!
        It's intended to be used ONLY when the database is shared with other apps (i.e. with the nostr-sdk `Client`).
        """

        raise NotImplementedError
    def run(self, ):
        """
        Run the local relay
        """

        raise NotImplementedError
    def shutdown(self, ):
        """
        Shutdown relay
        """

        raise NotImplementedError
    def url(self, ):
        """
        Get url
        """

        raise NotImplementedError
# LocalRelay is a Rust-only trait - it's a wrapper around a Rust implementation.
class LocalRelay():
    """
    A local nostr relay

    This is automatically shutdown when all instances/clones are dropped!
    """

    _pointer: ctypes.c_void_p
    def __init__(self, builder: "RelayBuilder"):
        """
        Construct a new relay
        """

        _UniffiConverterTypeRelayBuilder.check_lower(builder)
        
        self._pointer = _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_localrelay_new,
        _UniffiConverterTypeRelayBuilder.lower(builder))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_localrelay, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_localrelay, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def notify_event(self, event: "Event") -> "bool":
        """
        Send event to subscribers

        Return `true` if the event is successfully sent.

        This method doesn't save the event into the database!
        It's intended to be used ONLY when the database is shared with other apps (i.e. with the nostr-sdk `Client`).
        """

        _UniffiConverterTypeEvent.check_lower(event)
        
        return _UniffiConverterBool.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_localrelay_notify_event,self._uniffi_clone_pointer(),
        _UniffiConverterTypeEvent.lower(event))
        )




    async def run(self, ) -> None:

        """
        Run the local relay
        """

        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_nostr_sdk_ffi_fn_method_localrelay_run(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_poll_void,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_complete_void,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeNostrSdkError,

        )




    def shutdown(self, ) -> None:
        """
        Shutdown relay
        """

        _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_localrelay_shutdown,self._uniffi_clone_pointer(),)





    async def url(self, ) -> "RelayUrl":
        """
        Get url
        """

        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_nostr_sdk_ffi_fn_method_localrelay_url(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_poll_pointer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_complete_pointer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_free_pointer,
            # lift function
            _UniffiConverterTypeRelayUrl.lift,
            
    # Error FFI converter

    None,

        )





class _UniffiConverterTypeLocalRelay:

    @staticmethod
    def lift(value: int):
        return LocalRelay._make_instance_(value)

    @staticmethod
    def check_lower(value: LocalRelay):
        if not isinstance(value, LocalRelay):
            raise TypeError("Expected LocalRelay instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: LocalRelayProtocol):
        if not isinstance(value, LocalRelay):
            raise TypeError("Expected LocalRelay instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: LocalRelayProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class MetadataProtocol(typing.Protocol):
    def as_json(self, ):
        raise NotImplementedError
    def as_pretty_json(self, ):
        raise NotImplementedError
    def as_record(self, ):
        raise NotImplementedError
# Metadata is a Rust-only trait - it's a wrapper around a Rust implementation.
class Metadata():
    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_metadata, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_metadata, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst
    @classmethod
    def from_json(cls, json: "str"):
        """
        Parse metadata from JSON
        """

        _UniffiConverterString.check_lower(json)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeNostrSdkError,_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_metadata_from_json,
        _UniffiConverterString.lower(json))
        return cls._make_instance_(pointer)

    @classmethod
    def from_record(cls, r: "MetadataRecord"):
        _UniffiConverterTypeMetadataRecord.check_lower(r)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_metadata_from_record,
        _UniffiConverterTypeMetadataRecord.lower(r))
        return cls._make_instance_(pointer)



    def as_json(self, ) -> "str":
        return _UniffiConverterString.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeNostrSdkError,_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_metadata_as_json,self._uniffi_clone_pointer(),)
        )





    def as_pretty_json(self, ) -> "str":
        return _UniffiConverterString.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeNostrSdkError,_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_metadata_as_pretty_json,self._uniffi_clone_pointer(),)
        )





    def as_record(self, ) -> "MetadataRecord":
        return _UniffiConverterTypeMetadataRecord.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_metadata_as_record,self._uniffi_clone_pointer(),)
        )





    def __repr__(self, ) -> "str":
        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_metadata_uniffi_trait_debug,self._uniffi_clone_pointer(),)
        )



    def __eq__(self, other: object) -> bool:
        if not isinstance(other, Metadata):
            return NotImplemented

        return _UniffiConverterBool.lift(_uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_metadata_uniffi_trait_eq_eq,self._uniffi_clone_pointer(),
        _UniffiConverterTypeMetadata.lower(other)))

    def __ne__(self, other: object) -> bool:
        if not isinstance(other, Metadata):
            return NotImplemented

        return _UniffiConverterBool.lift(_uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_metadata_uniffi_trait_eq_ne,self._uniffi_clone_pointer(),
        _UniffiConverterTypeMetadata.lower(other)))


    def __hash__(self, ) -> "int":
        return _UniffiConverterUInt64.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_metadata_uniffi_trait_hash,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeMetadata:

    @staticmethod
    def lift(value: int):
        return Metadata._make_instance_(value)

    @staticmethod
    def check_lower(value: Metadata):
        if not isinstance(value, Metadata):
            raise TypeError("Expected Metadata instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: MetadataProtocol):
        if not isinstance(value, Metadata):
            raise TypeError("Expected Metadata instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: MetadataProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class Nip05AddressProtocol(typing.Protocol):
    """
    NIP-05 address
    """

    def domain(self, ):
        """
        Get the domain value
        """

        raise NotImplementedError
    def name(self, ):
        """
        Get the name value
        """

        raise NotImplementedError
    def url(self, ):
        """
        Get url for NIP05 address

        This can be used to make a `GET` HTTP request and get the NIP-05 JSON.
        """

        raise NotImplementedError
# Nip05Address is a Rust-only trait - it's a wrapper around a Rust implementation.
class Nip05Address():
    """
    NIP-05 address
    """

    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_nip05address, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_nip05address, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst
    @classmethod
    def parse(cls, address: "str"):
        """
        Parse a NIP-05 address (i.e., `yuki@yukikishimoto.com`).
        """

        _UniffiConverterString.check_lower(address)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeNostrSdkError,_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_nip05address_parse,
        _UniffiConverterString.lower(address))
        return cls._make_instance_(pointer)



    def domain(self, ) -> "str":
        """
        Get the domain value
        """

        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip05address_domain,self._uniffi_clone_pointer(),)
        )





    def name(self, ) -> "str":
        """
        Get the name value
        """

        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip05address_name,self._uniffi_clone_pointer(),)
        )





    def url(self, ) -> "str":
        """
        Get url for NIP05 address

        This can be used to make a `GET` HTTP request and get the NIP-05 JSON.
        """

        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip05address_url,self._uniffi_clone_pointer(),)
        )





    def __repr__(self, ) -> "str":
        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip05address_uniffi_trait_debug,self._uniffi_clone_pointer(),)
        )





    def __str__(self, ) -> "str":
        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip05address_uniffi_trait_display,self._uniffi_clone_pointer(),)
        )



    def __eq__(self, other: object) -> bool:
        if not isinstance(other, Nip05Address):
            return NotImplemented

        return _UniffiConverterBool.lift(_uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip05address_uniffi_trait_eq_eq,self._uniffi_clone_pointer(),
        _UniffiConverterTypeNip05Address.lower(other)))

    def __ne__(self, other: object) -> bool:
        if not isinstance(other, Nip05Address):
            return NotImplemented

        return _UniffiConverterBool.lift(_uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip05address_uniffi_trait_eq_ne,self._uniffi_clone_pointer(),
        _UniffiConverterTypeNip05Address.lower(other)))


    def __hash__(self, ) -> "int":
        return _UniffiConverterUInt64.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip05address_uniffi_trait_hash,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeNip05Address:

    @staticmethod
    def lift(value: int):
        return Nip05Address._make_instance_(value)

    @staticmethod
    def check_lower(value: Nip05Address):
        if not isinstance(value, Nip05Address):
            raise TypeError("Expected Nip05Address instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: Nip05AddressProtocol):
        if not isinstance(value, Nip05Address):
            raise TypeError("Expected Nip05Address instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: Nip05AddressProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class Nip05ProfileProtocol(typing.Protocol):
    def nip46(self, ):
        """
        Get NIP46 relays
        """

        raise NotImplementedError
    def public_key(self, ):
        raise NotImplementedError
    def relays(self, ):
        """
        Get relays
        """

        raise NotImplementedError
# Nip05Profile is a Rust-only trait - it's a wrapper around a Rust implementation.
class Nip05Profile():
    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_nip05profile, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_nip05profile, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst
    @classmethod
    def from_json(cls, address: "Nip05Address",json: "str"):
        """
        Extract a NIP-05 profile from raw JSON

        <https://github.com/nostr-protocol/nips/blob/master/05.md>
        """

        _UniffiConverterTypeNip05Address.check_lower(address)
        
        _UniffiConverterString.check_lower(json)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeNostrSdkError,_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_nip05profile_from_json,
        _UniffiConverterTypeNip05Address.lower(address),
        _UniffiConverterString.lower(json))
        return cls._make_instance_(pointer)



    def nip46(self, ) -> "typing.List[RelayUrl]":
        """
        Get NIP46 relays
        """

        return _UniffiConverterSequenceTypeRelayUrl.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip05profile_nip46,self._uniffi_clone_pointer(),)
        )





    def public_key(self, ) -> "PublicKey":
        return _UniffiConverterTypePublicKey.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip05profile_public_key,self._uniffi_clone_pointer(),)
        )





    def relays(self, ) -> "typing.List[RelayUrl]":
        """
        Get relays
        """

        return _UniffiConverterSequenceTypeRelayUrl.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip05profile_relays,self._uniffi_clone_pointer(),)
        )





    def __repr__(self, ) -> "str":
        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip05profile_uniffi_trait_debug,self._uniffi_clone_pointer(),)
        )



    def __eq__(self, other: object) -> bool:
        if not isinstance(other, Nip05Profile):
            return NotImplemented

        return _UniffiConverterBool.lift(_uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip05profile_uniffi_trait_eq_eq,self._uniffi_clone_pointer(),
        _UniffiConverterTypeNip05Profile.lower(other)))

    def __ne__(self, other: object) -> bool:
        if not isinstance(other, Nip05Profile):
            return NotImplemented

        return _UniffiConverterBool.lift(_uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip05profile_uniffi_trait_eq_ne,self._uniffi_clone_pointer(),
        _UniffiConverterTypeNip05Profile.lower(other)))


    def __hash__(self, ) -> "int":
        return _UniffiConverterUInt64.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip05profile_uniffi_trait_hash,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeNip05Profile:

    @staticmethod
    def lift(value: int):
        return Nip05Profile._make_instance_(value)

    @staticmethod
    def check_lower(value: Nip05Profile):
        if not isinstance(value, Nip05Profile):
            raise TypeError("Expected Nip05Profile instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: Nip05ProfileProtocol):
        if not isinstance(value, Nip05Profile):
            raise TypeError("Expected Nip05Profile instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: Nip05ProfileProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class Nip19Protocol(typing.Protocol):
    def as_enum(self, ):
        raise NotImplementedError
# Nip19 is a Rust-only trait - it's a wrapper around a Rust implementation.
class Nip19():
    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_nip19, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_nip19, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst
    @classmethod
    def from_bech32(cls, bech32: "str"):
        _UniffiConverterString.check_lower(bech32)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeNostrSdkError,_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_nip19_from_bech32,
        _UniffiConverterString.lower(bech32))
        return cls._make_instance_(pointer)



    def as_enum(self, ) -> "Nip19Enum":
        return _UniffiConverterTypeNip19Enum.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip19_as_enum,self._uniffi_clone_pointer(),)
        )





    def __repr__(self, ) -> "str":
        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip19_uniffi_trait_debug,self._uniffi_clone_pointer(),)
        )



    def __eq__(self, other: object) -> bool:
        if not isinstance(other, Nip19):
            return NotImplemented

        return _UniffiConverterBool.lift(_uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip19_uniffi_trait_eq_eq,self._uniffi_clone_pointer(),
        _UniffiConverterTypeNip19.lower(other)))

    def __ne__(self, other: object) -> bool:
        if not isinstance(other, Nip19):
            return NotImplemented

        return _UniffiConverterBool.lift(_uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip19_uniffi_trait_eq_ne,self._uniffi_clone_pointer(),
        _UniffiConverterTypeNip19.lower(other)))



class _UniffiConverterTypeNip19:

    @staticmethod
    def lift(value: int):
        return Nip19._make_instance_(value)

    @staticmethod
    def check_lower(value: Nip19):
        if not isinstance(value, Nip19):
            raise TypeError("Expected Nip19 instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: Nip19Protocol):
        if not isinstance(value, Nip19):
            raise TypeError("Expected Nip19 instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: Nip19Protocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class Nip19CoordinateProtocol(typing.Protocol):
    def coordinate(self, ):
        raise NotImplementedError
    def relays(self, ):
        raise NotImplementedError
    def to_bech32(self, ):
        raise NotImplementedError
    def to_nostr_uri(self, ):
        raise NotImplementedError
# Nip19Coordinate is a Rust-only trait - it's a wrapper around a Rust implementation.
class Nip19Coordinate():
    _pointer: ctypes.c_void_p
    def __init__(self, coordinate: "Coordinate",relays: "typing.Union[object, typing.List[RelayUrl]]" = _DEFAULT):
        _UniffiConverterTypeCoordinate.check_lower(coordinate)
        
        if relays is _DEFAULT:
            relays = []
        _UniffiConverterSequenceTypeRelayUrl.check_lower(relays)
        
        self._pointer = _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_nip19coordinate_new,
        _UniffiConverterTypeCoordinate.lower(coordinate),
        _UniffiConverterSequenceTypeRelayUrl.lower(relays))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_nip19coordinate, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_nip19coordinate, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst
    @classmethod
    def from_bech32(cls, bech32: "str"):
        _UniffiConverterString.check_lower(bech32)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeNostrSdkError,_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_nip19coordinate_from_bech32,
        _UniffiConverterString.lower(bech32))
        return cls._make_instance_(pointer)

    @classmethod
    def from_nostr_uri(cls, uri: "str"):
        _UniffiConverterString.check_lower(uri)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeNostrSdkError,_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_nip19coordinate_from_nostr_uri,
        _UniffiConverterString.lower(uri))
        return cls._make_instance_(pointer)



    def coordinate(self, ) -> "Coordinate":
        return _UniffiConverterTypeCoordinate.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip19coordinate_coordinate,self._uniffi_clone_pointer(),)
        )





    def relays(self, ) -> "typing.List[RelayUrl]":
        return _UniffiConverterSequenceTypeRelayUrl.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip19coordinate_relays,self._uniffi_clone_pointer(),)
        )





    def to_bech32(self, ) -> "str":
        return _UniffiConverterString.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeNostrSdkError,_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip19coordinate_to_bech32,self._uniffi_clone_pointer(),)
        )





    def to_nostr_uri(self, ) -> "str":
        return _UniffiConverterString.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeNostrSdkError,_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip19coordinate_to_nostr_uri,self._uniffi_clone_pointer(),)
        )





    def __repr__(self, ) -> "str":
        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip19coordinate_uniffi_trait_debug,self._uniffi_clone_pointer(),)
        )



    def __eq__(self, other: object) -> bool:
        if not isinstance(other, Nip19Coordinate):
            return NotImplemented

        return _UniffiConverterBool.lift(_uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip19coordinate_uniffi_trait_eq_eq,self._uniffi_clone_pointer(),
        _UniffiConverterTypeNip19Coordinate.lower(other)))

    def __ne__(self, other: object) -> bool:
        if not isinstance(other, Nip19Coordinate):
            return NotImplemented

        return _UniffiConverterBool.lift(_uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip19coordinate_uniffi_trait_eq_ne,self._uniffi_clone_pointer(),
        _UniffiConverterTypeNip19Coordinate.lower(other)))


    def __hash__(self, ) -> "int":
        return _UniffiConverterUInt64.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip19coordinate_uniffi_trait_hash,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeNip19Coordinate:

    @staticmethod
    def lift(value: int):
        return Nip19Coordinate._make_instance_(value)

    @staticmethod
    def check_lower(value: Nip19Coordinate):
        if not isinstance(value, Nip19Coordinate):
            raise TypeError("Expected Nip19Coordinate instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: Nip19CoordinateProtocol):
        if not isinstance(value, Nip19Coordinate):
            raise TypeError("Expected Nip19Coordinate instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: Nip19CoordinateProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class Nip19EventProtocol(typing.Protocol):
    def author(self, ):
        raise NotImplementedError
    def event_id(self, ):
        raise NotImplementedError
    def kind(self, ):
        raise NotImplementedError
    def relays(self, ):
        raise NotImplementedError
    def to_bech32(self, ):
        raise NotImplementedError
    def to_nostr_uri(self, ):
        raise NotImplementedError
# Nip19Event is a Rust-only trait - it's a wrapper around a Rust implementation.
class Nip19Event():
    _pointer: ctypes.c_void_p
    def __init__(self, event_id: "EventId",author: "typing.Union[object, typing.Optional[PublicKey]]" = _DEFAULT,kind: "typing.Union[object, typing.Optional[Kind]]" = _DEFAULT,relays: "typing.Union[object, typing.List[RelayUrl]]" = _DEFAULT):
        _UniffiConverterTypeEventId.check_lower(event_id)
        
        if author is _DEFAULT:
            author = None
        _UniffiConverterOptionalTypePublicKey.check_lower(author)
        
        if kind is _DEFAULT:
            kind = None
        _UniffiConverterOptionalTypeKind.check_lower(kind)
        
        if relays is _DEFAULT:
            relays = []
        _UniffiConverterSequenceTypeRelayUrl.check_lower(relays)
        
        self._pointer = _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_nip19event_new,
        _UniffiConverterTypeEventId.lower(event_id),
        _UniffiConverterOptionalTypePublicKey.lower(author),
        _UniffiConverterOptionalTypeKind.lower(kind),
        _UniffiConverterSequenceTypeRelayUrl.lower(relays))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_nip19event, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_nip19event, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst
    @classmethod
    def from_bech32(cls, bech32: "str"):
        _UniffiConverterString.check_lower(bech32)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeNostrSdkError,_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_nip19event_from_bech32,
        _UniffiConverterString.lower(bech32))
        return cls._make_instance_(pointer)

    @classmethod
    def from_event(cls, event: "Event"):
        _UniffiConverterTypeEvent.check_lower(event)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_nip19event_from_event,
        _UniffiConverterTypeEvent.lower(event))
        return cls._make_instance_(pointer)

    @classmethod
    def from_nostr_uri(cls, uri: "str"):
        _UniffiConverterString.check_lower(uri)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeNostrSdkError,_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_nip19event_from_nostr_uri,
        _UniffiConverterString.lower(uri))
        return cls._make_instance_(pointer)



    def author(self, ) -> "typing.Optional[PublicKey]":
        return _UniffiConverterOptionalTypePublicKey.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip19event_author,self._uniffi_clone_pointer(),)
        )





    def event_id(self, ) -> "EventId":
        return _UniffiConverterTypeEventId.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip19event_event_id,self._uniffi_clone_pointer(),)
        )





    def kind(self, ) -> "typing.Optional[Kind]":
        return _UniffiConverterOptionalTypeKind.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip19event_kind,self._uniffi_clone_pointer(),)
        )





    def relays(self, ) -> "typing.List[RelayUrl]":
        return _UniffiConverterSequenceTypeRelayUrl.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip19event_relays,self._uniffi_clone_pointer(),)
        )





    def to_bech32(self, ) -> "str":
        return _UniffiConverterString.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeNostrSdkError,_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip19event_to_bech32,self._uniffi_clone_pointer(),)
        )





    def to_nostr_uri(self, ) -> "str":
        return _UniffiConverterString.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeNostrSdkError,_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip19event_to_nostr_uri,self._uniffi_clone_pointer(),)
        )





    def __repr__(self, ) -> "str":
        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip19event_uniffi_trait_debug,self._uniffi_clone_pointer(),)
        )



    def __eq__(self, other: object) -> bool:
        if not isinstance(other, Nip19Event):
            return NotImplemented

        return _UniffiConverterBool.lift(_uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip19event_uniffi_trait_eq_eq,self._uniffi_clone_pointer(),
        _UniffiConverterTypeNip19Event.lower(other)))

    def __ne__(self, other: object) -> bool:
        if not isinstance(other, Nip19Event):
            return NotImplemented

        return _UniffiConverterBool.lift(_uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip19event_uniffi_trait_eq_ne,self._uniffi_clone_pointer(),
        _UniffiConverterTypeNip19Event.lower(other)))


    def __hash__(self, ) -> "int":
        return _UniffiConverterUInt64.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip19event_uniffi_trait_hash,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeNip19Event:

    @staticmethod
    def lift(value: int):
        return Nip19Event._make_instance_(value)

    @staticmethod
    def check_lower(value: Nip19Event):
        if not isinstance(value, Nip19Event):
            raise TypeError("Expected Nip19Event instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: Nip19EventProtocol):
        if not isinstance(value, Nip19Event):
            raise TypeError("Expected Nip19Event instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: Nip19EventProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class Nip19ProfileProtocol(typing.Protocol):
    def public_key(self, ):
        raise NotImplementedError
    def relays(self, ):
        raise NotImplementedError
    def to_bech32(self, ):
        raise NotImplementedError
    def to_nostr_uri(self, ):
        raise NotImplementedError
# Nip19Profile is a Rust-only trait - it's a wrapper around a Rust implementation.
class Nip19Profile():
    _pointer: ctypes.c_void_p
    def __init__(self, public_key: "PublicKey",relays: "typing.Union[object, typing.List[RelayUrl]]" = _DEFAULT):
        """
        New NIP19 profile
        """

        _UniffiConverterTypePublicKey.check_lower(public_key)
        
        if relays is _DEFAULT:
            relays = []
        _UniffiConverterSequenceTypeRelayUrl.check_lower(relays)
        
        self._pointer = _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_nip19profile_new,
        _UniffiConverterTypePublicKey.lower(public_key),
        _UniffiConverterSequenceTypeRelayUrl.lower(relays))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_nip19profile, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_nip19profile, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst
    @classmethod
    def from_bech32(cls, bech32: "str"):
        _UniffiConverterString.check_lower(bech32)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeNostrSdkError,_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_nip19profile_from_bech32,
        _UniffiConverterString.lower(bech32))
        return cls._make_instance_(pointer)

    @classmethod
    def from_nostr_uri(cls, uri: "str"):
        _UniffiConverterString.check_lower(uri)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeNostrSdkError,_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_nip19profile_from_nostr_uri,
        _UniffiConverterString.lower(uri))
        return cls._make_instance_(pointer)



    def public_key(self, ) -> "PublicKey":
        return _UniffiConverterTypePublicKey.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip19profile_public_key,self._uniffi_clone_pointer(),)
        )





    def relays(self, ) -> "typing.List[RelayUrl]":
        return _UniffiConverterSequenceTypeRelayUrl.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip19profile_relays,self._uniffi_clone_pointer(),)
        )





    def to_bech32(self, ) -> "str":
        return _UniffiConverterString.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeNostrSdkError,_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip19profile_to_bech32,self._uniffi_clone_pointer(),)
        )





    def to_nostr_uri(self, ) -> "str":
        return _UniffiConverterString.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeNostrSdkError,_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip19profile_to_nostr_uri,self._uniffi_clone_pointer(),)
        )





    def __repr__(self, ) -> "str":
        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip19profile_uniffi_trait_debug,self._uniffi_clone_pointer(),)
        )



    def __eq__(self, other: object) -> bool:
        if not isinstance(other, Nip19Profile):
            return NotImplemented

        return _UniffiConverterBool.lift(_uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip19profile_uniffi_trait_eq_eq,self._uniffi_clone_pointer(),
        _UniffiConverterTypeNip19Profile.lower(other)))

    def __ne__(self, other: object) -> bool:
        if not isinstance(other, Nip19Profile):
            return NotImplemented

        return _UniffiConverterBool.lift(_uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip19profile_uniffi_trait_eq_ne,self._uniffi_clone_pointer(),
        _UniffiConverterTypeNip19Profile.lower(other)))


    def __hash__(self, ) -> "int":
        return _UniffiConverterUInt64.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip19profile_uniffi_trait_hash,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeNip19Profile:

    @staticmethod
    def lift(value: int):
        return Nip19Profile._make_instance_(value)

    @staticmethod
    def check_lower(value: Nip19Profile):
        if not isinstance(value, Nip19Profile):
            raise TypeError("Expected Nip19Profile instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: Nip19ProfileProtocol):
        if not isinstance(value, Nip19Profile):
            raise TypeError("Expected Nip19Profile instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: Nip19ProfileProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class Nip21Protocol(typing.Protocol):
    def as_enum(self, ):
        raise NotImplementedError
    def to_nostr_uri(self, ):
        """
        Serialize to NIP21 nostr URI
        """

        raise NotImplementedError
# Nip21 is a Rust-only trait - it's a wrapper around a Rust implementation.
class Nip21():
    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_nip21, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_nip21, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst
    @classmethod
    def parse(cls, uri: "str"):
        """
        Parse NIP21 string
        """

        _UniffiConverterString.check_lower(uri)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeNostrSdkError,_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_nip21_parse,
        _UniffiConverterString.lower(uri))
        return cls._make_instance_(pointer)



    def as_enum(self, ) -> "Nip21Enum":
        return _UniffiConverterTypeNip21Enum.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip21_as_enum,self._uniffi_clone_pointer(),)
        )





    def to_nostr_uri(self, ) -> "str":
        """
        Serialize to NIP21 nostr URI
        """

        return _UniffiConverterString.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeNostrSdkError,_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip21_to_nostr_uri,self._uniffi_clone_pointer(),)
        )





    def __repr__(self, ) -> "str":
        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip21_uniffi_trait_debug,self._uniffi_clone_pointer(),)
        )



    def __eq__(self, other: object) -> bool:
        if not isinstance(other, Nip21):
            return NotImplemented

        return _UniffiConverterBool.lift(_uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip21_uniffi_trait_eq_eq,self._uniffi_clone_pointer(),
        _UniffiConverterTypeNip21.lower(other)))

    def __ne__(self, other: object) -> bool:
        if not isinstance(other, Nip21):
            return NotImplemented

        return _UniffiConverterBool.lift(_uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip21_uniffi_trait_eq_ne,self._uniffi_clone_pointer(),
        _UniffiConverterTypeNip21.lower(other)))


    def __hash__(self, ) -> "int":
        return _UniffiConverterUInt64.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip21_uniffi_trait_hash,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeNip21:

    @staticmethod
    def lift(value: int):
        return Nip21._make_instance_(value)

    @staticmethod
    def check_lower(value: Nip21):
        if not isinstance(value, Nip21):
            raise TypeError("Expected Nip21 instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: Nip21Protocol):
        if not isinstance(value, Nip21):
            raise TypeError("Expected Nip21 instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: Nip21Protocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class Nip96ServerConfigProtocol(typing.Protocol):
    """
    NIP-96 server config
    """

    def api_url(self, ):
        """
        API URL
        """

        raise NotImplementedError
    def as_json(self, ):
        """
        Serialize as JSON
        """

        raise NotImplementedError
    def content_types(self, ):
        """
        Allowed content types
        """

        raise NotImplementedError
    def delegated_to_url(self, ):
        """
        Delegated URL
        """

        raise NotImplementedError
    def download_url(self, ):
        """
        Download URL
        """

        raise NotImplementedError
# Nip96ServerConfig is a Rust-only trait - it's a wrapper around a Rust implementation.
class Nip96ServerConfig():
    """
    NIP-96 server config
    """

    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_nip96serverconfig, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_nip96serverconfig, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst
    @classmethod
    def from_json(cls, json: "str"):
        """
        Parse NIP-96 server config from JSON
        """

        _UniffiConverterString.check_lower(json)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeNostrSdkError,_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_nip96serverconfig_from_json,
        _UniffiConverterString.lower(json))
        return cls._make_instance_(pointer)



    def api_url(self, ) -> "str":
        """
        API URL
        """

        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip96serverconfig_api_url,self._uniffi_clone_pointer(),)
        )





    def as_json(self, ) -> "str":
        """
        Serialize as JSON
        """

        return _UniffiConverterString.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeNostrSdkError,_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip96serverconfig_as_json,self._uniffi_clone_pointer(),)
        )





    def content_types(self, ) -> "typing.Optional[typing.List[str]]":
        """
        Allowed content types
        """

        return _UniffiConverterOptionalSequenceString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip96serverconfig_content_types,self._uniffi_clone_pointer(),)
        )





    def delegated_to_url(self, ) -> "typing.Optional[str]":
        """
        Delegated URL
        """

        return _UniffiConverterOptionalString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip96serverconfig_delegated_to_url,self._uniffi_clone_pointer(),)
        )





    def download_url(self, ) -> "str":
        """
        Download URL
        """

        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip96serverconfig_download_url,self._uniffi_clone_pointer(),)
        )





    def __repr__(self, ) -> "str":
        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip96serverconfig_uniffi_trait_debug,self._uniffi_clone_pointer(),)
        )



    def __eq__(self, other: object) -> bool:
        if not isinstance(other, Nip96ServerConfig):
            return NotImplemented

        return _UniffiConverterBool.lift(_uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip96serverconfig_uniffi_trait_eq_eq,self._uniffi_clone_pointer(),
        _UniffiConverterTypeNip96ServerConfig.lower(other)))

    def __ne__(self, other: object) -> bool:
        if not isinstance(other, Nip96ServerConfig):
            return NotImplemented

        return _UniffiConverterBool.lift(_uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip96serverconfig_uniffi_trait_eq_ne,self._uniffi_clone_pointer(),
        _UniffiConverterTypeNip96ServerConfig.lower(other)))


    def __hash__(self, ) -> "int":
        return _UniffiConverterUInt64.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip96serverconfig_uniffi_trait_hash,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeNip96ServerConfig:

    @staticmethod
    def lift(value: int):
        return Nip96ServerConfig._make_instance_(value)

    @staticmethod
    def check_lower(value: Nip96ServerConfig):
        if not isinstance(value, Nip96ServerConfig):
            raise TypeError("Expected Nip96ServerConfig instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: Nip96ServerConfigProtocol):
        if not isinstance(value, Nip96ServerConfig):
            raise TypeError("Expected Nip96ServerConfig instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: Nip96ServerConfigProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class Nip96UploadRequestProtocol(typing.Protocol):
    """
    NIP96 upload request information
    Contains all data needed to make a file upload request
    """

    def authorization(self, ):
        """
        Get the Authorization header value
        """

        raise NotImplementedError
    def url(self, ):
        """
        Get the URL to POST to
        """

        raise NotImplementedError
# Nip96UploadRequest is a Rust-only trait - it's a wrapper around a Rust implementation.
class Nip96UploadRequest():
    """
    NIP96 upload request information
    Contains all data needed to make a file upload request
    """

    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_nip96uploadrequest, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_nip96uploadrequest, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst
    @classmethod
    async def create(cls, signer: "NostrSigner",config: "Nip96ServerConfig",file_data: "bytes"):
        """
        Prepare upload request data

        This function prepares the authorization header and returns all the data
        needed to make an upload request with the HTTP client.

        Note: please create the multipart form data yourself using your
        preferred HTTP client's multipart impl.
        """

        _UniffiConverterTypeNostrSigner.check_lower(signer)
        
        _UniffiConverterTypeNip96ServerConfig.check_lower(config)
        
        _UniffiConverterBytes.check_lower(file_data)
        

        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_nip96uploadrequest_create(
        _UniffiConverterTypeNostrSigner.lower(signer),
        _UniffiConverterTypeNip96ServerConfig.lower(config),
        _UniffiConverterBytes.lower(file_data)),
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_poll_pointer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_complete_pointer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_free_pointer,
            _UniffiConverterTypeNip96UploadRequest.lift,
            
    # Error FFI converter
_UniffiConverterTypeNostrSdkError,

        )



    def authorization(self, ) -> "str":
        """
        Get the Authorization header value
        """

        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip96uploadrequest_authorization,self._uniffi_clone_pointer(),)
        )





    def url(self, ) -> "str":
        """
        Get the URL to POST to
        """

        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip96uploadrequest_url,self._uniffi_clone_pointer(),)
        )





    def __repr__(self, ) -> "str":
        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip96uploadrequest_uniffi_trait_debug,self._uniffi_clone_pointer(),)
        )



    def __eq__(self, other: object) -> bool:
        if not isinstance(other, Nip96UploadRequest):
            return NotImplemented

        return _UniffiConverterBool.lift(_uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip96uploadrequest_uniffi_trait_eq_eq,self._uniffi_clone_pointer(),
        _UniffiConverterTypeNip96UploadRequest.lower(other)))

    def __ne__(self, other: object) -> bool:
        if not isinstance(other, Nip96UploadRequest):
            return NotImplemented

        return _UniffiConverterBool.lift(_uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip96uploadrequest_uniffi_trait_eq_ne,self._uniffi_clone_pointer(),
        _UniffiConverterTypeNip96UploadRequest.lower(other)))


    def __hash__(self, ) -> "int":
        return _UniffiConverterUInt64.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip96uploadrequest_uniffi_trait_hash,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeNip96UploadRequest:

    @staticmethod
    def lift(value: int):
        return Nip96UploadRequest._make_instance_(value)

    @staticmethod
    def check_lower(value: Nip96UploadRequest):
        if not isinstance(value, Nip96UploadRequest):
            raise TypeError("Expected Nip96UploadRequest instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: Nip96UploadRequestProtocol):
        if not isinstance(value, Nip96UploadRequest):
            raise TypeError("Expected Nip96UploadRequest instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: Nip96UploadRequestProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class Nip96UploadResponseProtocol(typing.Protocol):
    """
    NIP-96 upload response
    """

    def as_json(self, ):
        """
        Serialize as JSON
        """

        raise NotImplementedError
    def download_url(self, ):
        """
        Extract the download URL from the upload response

        Returns an error if the upload was unsuccessful or if the URL cannot be found
        """

        raise NotImplementedError
    def is_success(self, ):
        """
        Check if success
        """

        raise NotImplementedError
    def message(self, ):
        """
        Free text success, failure or info message
        """

        raise NotImplementedError
# Nip96UploadResponse is a Rust-only trait - it's a wrapper around a Rust implementation.
class Nip96UploadResponse():
    """
    NIP-96 upload response
    """

    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_nip96uploadresponse, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_nip96uploadresponse, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst
    @classmethod
    def from_json(cls, json: "str"):
        """
        Parse NIP-96 upload response from JSON
        """

        _UniffiConverterString.check_lower(json)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeNostrSdkError,_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_nip96uploadresponse_from_json,
        _UniffiConverterString.lower(json))
        return cls._make_instance_(pointer)



    def as_json(self, ) -> "str":
        """
        Serialize as JSON
        """

        return _UniffiConverterString.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeNostrSdkError,_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip96uploadresponse_as_json,self._uniffi_clone_pointer(),)
        )





    def download_url(self, ) -> "str":
        """
        Extract the download URL from the upload response

        Returns an error if the upload was unsuccessful or if the URL cannot be found
        """

        return _UniffiConverterString.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeNostrSdkError,_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip96uploadresponse_download_url,self._uniffi_clone_pointer(),)
        )





    def is_success(self, ) -> "bool":
        """
        Check if success
        """

        return _UniffiConverterBool.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip96uploadresponse_is_success,self._uniffi_clone_pointer(),)
        )





    def message(self, ) -> "str":
        """
        Free text success, failure or info message
        """

        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip96uploadresponse_message,self._uniffi_clone_pointer(),)
        )





    def __repr__(self, ) -> "str":
        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip96uploadresponse_uniffi_trait_debug,self._uniffi_clone_pointer(),)
        )



    def __eq__(self, other: object) -> bool:
        if not isinstance(other, Nip96UploadResponse):
            return NotImplemented

        return _UniffiConverterBool.lift(_uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip96uploadresponse_uniffi_trait_eq_eq,self._uniffi_clone_pointer(),
        _UniffiConverterTypeNip96UploadResponse.lower(other)))

    def __ne__(self, other: object) -> bool:
        if not isinstance(other, Nip96UploadResponse):
            return NotImplemented

        return _UniffiConverterBool.lift(_uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip96uploadresponse_uniffi_trait_eq_ne,self._uniffi_clone_pointer(),
        _UniffiConverterTypeNip96UploadResponse.lower(other)))


    def __hash__(self, ) -> "int":
        return _UniffiConverterUInt64.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nip96uploadresponse_uniffi_trait_hash,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeNip96UploadResponse:

    @staticmethod
    def lift(value: int):
        return Nip96UploadResponse._make_instance_(value)

    @staticmethod
    def check_lower(value: Nip96UploadResponse):
        if not isinstance(value, Nip96UploadResponse):
            raise TypeError("Expected Nip96UploadResponse instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: Nip96UploadResponseProtocol):
        if not isinstance(value, Nip96UploadResponse):
            raise TypeError("Expected Nip96UploadResponse instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: Nip96UploadResponseProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class NostrConnectProtocol(typing.Protocol):
    def bunker_uri(self, ):
        """
        Get `bunker` URI
        """

        raise NotImplementedError
    def get_public_key(self, ):
        raise NotImplementedError
    def nip04_decrypt(self, public_key: "PublicKey",encrypted_content: "str"):
        raise NotImplementedError
    def nip04_encrypt(self, public_key: "PublicKey",content: "str"):
        raise NotImplementedError
    def nip44_decrypt(self, public_key: "PublicKey",payload: "str"):
        raise NotImplementedError
    def nip44_encrypt(self, public_key: "PublicKey",content: "str"):
        raise NotImplementedError
    def relays(self, ):
        """
        Get signer relays
        """

        raise NotImplementedError
    def sign_event(self, unsigned_event: "UnsignedEvent"):
        raise NotImplementedError
# NostrConnect is a Rust-only trait - it's a wrapper around a Rust implementation.
class NostrConnect():
    _pointer: ctypes.c_void_p
    def __init__(self, uri: "NostrConnectUri",app_keys: "Keys",timeout: "Duration",opts: "typing.Optional[RelayOptions]"):
        """
        Construct Nostr Connect client
        """

        _UniffiConverterTypeNostrConnectUri.check_lower(uri)
        
        _UniffiConverterTypeKeys.check_lower(app_keys)
        
        _UniffiConverterDuration.check_lower(timeout)
        
        _UniffiConverterOptionalTypeRelayOptions.check_lower(opts)
        
        self._pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeNostrSdkError,_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_nostrconnect_new,
        _UniffiConverterTypeNostrConnectUri.lower(uri),
        _UniffiConverterTypeKeys.lower(app_keys),
        _UniffiConverterDuration.lower(timeout),
        _UniffiConverterOptionalTypeRelayOptions.lower(opts))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_nostrconnect, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_nostrconnect, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    async def bunker_uri(self, ) -> "NostrConnectUri":
        """
        Get `bunker` URI
        """

        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nostrconnect_bunker_uri(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_poll_pointer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_complete_pointer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_free_pointer,
            # lift function
            _UniffiConverterTypeNostrConnectUri.lift,
            
    # Error FFI converter
_UniffiConverterTypeNostrSdkError,

        )



    async def get_public_key(self, ) -> "PublicKey":
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nostrconnect_get_public_key(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_poll_pointer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_complete_pointer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_free_pointer,
            # lift function
            _UniffiConverterTypePublicKey.lift,
            
    # Error FFI converter
_UniffiConverterTypeNostrSdkError,

        )



    async def nip04_decrypt(self, public_key: "PublicKey",encrypted_content: "str") -> "str":
        _UniffiConverterTypePublicKey.check_lower(public_key)
        
        _UniffiConverterString.check_lower(encrypted_content)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nostrconnect_nip04_decrypt(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypePublicKey.lower(public_key),
        _UniffiConverterString.lower(encrypted_content)
            ),
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterString.lift,
            
    # Error FFI converter
_UniffiConverterTypeNostrSdkError,

        )



    async def nip04_encrypt(self, public_key: "PublicKey",content: "str") -> "str":
        _UniffiConverterTypePublicKey.check_lower(public_key)
        
        _UniffiConverterString.check_lower(content)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nostrconnect_nip04_encrypt(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypePublicKey.lower(public_key),
        _UniffiConverterString.lower(content)
            ),
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterString.lift,
            
    # Error FFI converter
_UniffiConverterTypeNostrSdkError,

        )



    async def nip44_decrypt(self, public_key: "PublicKey",payload: "str") -> "str":
        _UniffiConverterTypePublicKey.check_lower(public_key)
        
        _UniffiConverterString.check_lower(payload)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nostrconnect_nip44_decrypt(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypePublicKey.lower(public_key),
        _UniffiConverterString.lower(payload)
            ),
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterString.lift,
            
    # Error FFI converter
_UniffiConverterTypeNostrSdkError,

        )



    async def nip44_encrypt(self, public_key: "PublicKey",content: "str") -> "str":
        _UniffiConverterTypePublicKey.check_lower(public_key)
        
        _UniffiConverterString.check_lower(content)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nostrconnect_nip44_encrypt(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypePublicKey.lower(public_key),
        _UniffiConverterString.lower(content)
            ),
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterString.lift,
            
    # Error FFI converter
_UniffiConverterTypeNostrSdkError,

        )




    def relays(self, ) -> "typing.List[RelayUrl]":
        """
        Get signer relays
        """

        return _UniffiConverterSequenceTypeRelayUrl.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nostrconnect_relays,self._uniffi_clone_pointer(),)
        )




    async def sign_event(self, unsigned_event: "UnsignedEvent") -> "Event":
        _UniffiConverterTypeUnsignedEvent.check_lower(unsigned_event)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nostrconnect_sign_event(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeUnsignedEvent.lower(unsigned_event)
            ),
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_poll_pointer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_complete_pointer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_free_pointer,
            # lift function
            _UniffiConverterTypeEvent.lift,
            
    # Error FFI converter
_UniffiConverterTypeNostrSdkError,

        )





class _UniffiConverterTypeNostrConnect:

    @staticmethod
    def lift(value: int):
        return NostrConnect._make_instance_(value)

    @staticmethod
    def check_lower(value: NostrConnect):
        if not isinstance(value, NostrConnect):
            raise TypeError("Expected NostrConnect instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: NostrConnectProtocol):
        if not isinstance(value, NostrConnect):
            raise TypeError("Expected NostrConnect instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: NostrConnectProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class NostrConnectMetadataProtocol(typing.Protocol):
    def as_json(self, ):
        """
        Serialize as JSON string
        """

        raise NotImplementedError
    def description(self, description: "str"):
        """
        Description of the `App`
        """

        raise NotImplementedError
    def icons(self, icons: "typing.List[str]"):
        """
        List of URLs for icons of the `App`
        """

        raise NotImplementedError
    def url(self, url: "str"):
        """
        URL of the website requesting the connection
        """

        raise NotImplementedError
# NostrConnectMetadata is a Rust-only trait - it's a wrapper around a Rust implementation.
class NostrConnectMetadata():
    _pointer: ctypes.c_void_p
    def __init__(self, name: "str"):
        """
        New Nostr Connect Metadata
        """

        _UniffiConverterString.check_lower(name)
        
        self._pointer = _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_nostrconnectmetadata_new,
        _UniffiConverterString.lower(name))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_nostrconnectmetadata, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_nostrconnectmetadata, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def as_json(self, ) -> "str":
        """
        Serialize as JSON string
        """

        return _UniffiConverterString.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeNostrSdkError,_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nostrconnectmetadata_as_json,self._uniffi_clone_pointer(),)
        )





    def description(self, description: "str") -> "NostrConnectMetadata":
        """
        Description of the `App`
        """

        _UniffiConverterString.check_lower(description)
        
        return _UniffiConverterTypeNostrConnectMetadata.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nostrconnectmetadata_description,self._uniffi_clone_pointer(),
        _UniffiConverterString.lower(description))
        )





    def icons(self, icons: "typing.List[str]") -> "NostrConnectMetadata":
        """
        List of URLs for icons of the `App`
        """

        _UniffiConverterSequenceString.check_lower(icons)
        
        return _UniffiConverterTypeNostrConnectMetadata.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nostrconnectmetadata_icons,self._uniffi_clone_pointer(),
        _UniffiConverterSequenceString.lower(icons))
        )





    def url(self, url: "str") -> "NostrConnectMetadata":
        """
        URL of the website requesting the connection
        """

        _UniffiConverterString.check_lower(url)
        
        return _UniffiConverterTypeNostrConnectMetadata.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeNostrSdkError,_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nostrconnectmetadata_url,self._uniffi_clone_pointer(),
        _UniffiConverterString.lower(url))
        )





    def __repr__(self, ) -> "str":
        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nostrconnectmetadata_uniffi_trait_debug,self._uniffi_clone_pointer(),)
        )



    def __eq__(self, other: object) -> bool:
        if not isinstance(other, NostrConnectMetadata):
            return NotImplemented

        return _UniffiConverterBool.lift(_uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nostrconnectmetadata_uniffi_trait_eq_eq,self._uniffi_clone_pointer(),
        _UniffiConverterTypeNostrConnectMetadata.lower(other)))

    def __ne__(self, other: object) -> bool:
        if not isinstance(other, NostrConnectMetadata):
            return NotImplemented

        return _UniffiConverterBool.lift(_uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nostrconnectmetadata_uniffi_trait_eq_ne,self._uniffi_clone_pointer(),
        _UniffiConverterTypeNostrConnectMetadata.lower(other)))


    def __hash__(self, ) -> "int":
        return _UniffiConverterUInt64.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nostrconnectmetadata_uniffi_trait_hash,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeNostrConnectMetadata:

    @staticmethod
    def lift(value: int):
        return NostrConnectMetadata._make_instance_(value)

    @staticmethod
    def check_lower(value: NostrConnectMetadata):
        if not isinstance(value, NostrConnectMetadata):
            raise TypeError("Expected NostrConnectMetadata instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: NostrConnectMetadataProtocol):
        if not isinstance(value, NostrConnectMetadata):
            raise TypeError("Expected NostrConnectMetadata instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: NostrConnectMetadataProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class NostrConnectUriProtocol(typing.Protocol):
    pass
# NostrConnectUri is a Rust-only trait - it's a wrapper around a Rust implementation.
class NostrConnectUri():
    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_nostrconnecturi, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_nostrconnecturi, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst
    @classmethod
    def parse(cls, uri: "str"):
        _UniffiConverterString.check_lower(uri)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeNostrSdkError,_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_nostrconnecturi_parse,
        _UniffiConverterString.lower(uri))
        return cls._make_instance_(pointer)



    def __repr__(self, ) -> "str":
        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nostrconnecturi_uniffi_trait_debug,self._uniffi_clone_pointer(),)
        )





    def __str__(self, ) -> "str":
        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nostrconnecturi_uniffi_trait_display,self._uniffi_clone_pointer(),)
        )



    def __eq__(self, other: object) -> bool:
        if not isinstance(other, NostrConnectUri):
            return NotImplemented

        return _UniffiConverterBool.lift(_uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nostrconnecturi_uniffi_trait_eq_eq,self._uniffi_clone_pointer(),
        _UniffiConverterTypeNostrConnectUri.lower(other)))

    def __ne__(self, other: object) -> bool:
        if not isinstance(other, NostrConnectUri):
            return NotImplemented

        return _UniffiConverterBool.lift(_uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nostrconnecturi_uniffi_trait_eq_ne,self._uniffi_clone_pointer(),
        _UniffiConverterTypeNostrConnectUri.lower(other)))


    def __hash__(self, ) -> "int":
        return _UniffiConverterUInt64.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nostrconnecturi_uniffi_trait_hash,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeNostrConnectUri:

    @staticmethod
    def lift(value: int):
        return NostrConnectUri._make_instance_(value)

    @staticmethod
    def check_lower(value: NostrConnectUri):
        if not isinstance(value, NostrConnectUri):
            raise TypeError("Expected NostrConnectUri instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: NostrConnectUriProtocol):
        if not isinstance(value, NostrConnectUri):
            raise TypeError("Expected NostrConnectUri instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: NostrConnectUriProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class NostrDatabaseProtocol(typing.Protocol):
    def count(self, filter: "Filter"):
        raise NotImplementedError
    def delete(self, filter: "Filter"):
        """
        Delete all events that match the `Filter`
        """

        raise NotImplementedError
    def event_by_id(self, event_id: "EventId"):
        """
        Get [`Event`] by [`EventId`]
        """

        raise NotImplementedError
    def metadata(self, public_key: "PublicKey"):
        raise NotImplementedError
    def query(self, filter: "Filter"):
        raise NotImplementedError
    def save_event(self, event: "Event"):
        """
        Save [`Event`] into store
        """

        raise NotImplementedError
    def wipe(self, ):
        """
        Wipe all data
        """

        raise NotImplementedError
# NostrDatabase is a Rust-only trait - it's a wrapper around a Rust implementation.
class NostrDatabase():
    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_nostrdatabase, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_nostrdatabase, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst
    @classmethod
    def custom(cls, database: "CustomNostrDatabase"):
        """
        Open a custom nostr database
        """

        _UniffiConverterTypeCustomNostrDatabase.check_lower(database)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_nostrdatabase_custom,
        _UniffiConverterTypeCustomNostrDatabase.lower(database))
        return cls._make_instance_(pointer)

    @classmethod
    def lmdb(cls, path: "str"):
        """
        LMDB backend
        """

        _UniffiConverterString.check_lower(path)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeNostrSdkError,_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_nostrdatabase_lmdb,
        _UniffiConverterString.lower(path))
        return cls._make_instance_(pointer)


    async def count(self, filter: "Filter") -> "int":
        _UniffiConverterTypeFilter.check_lower(filter)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nostrdatabase_count(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeFilter.lower(filter)
            ),
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_poll_u64,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_complete_u64,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_free_u64,
            # lift function
            _UniffiConverterUInt64.lift,
            
    # Error FFI converter
_UniffiConverterTypeNostrSdkError,

        )



    async def delete(self, filter: "Filter") -> None:

        """
        Delete all events that match the `Filter`
        """

        _UniffiConverterTypeFilter.check_lower(filter)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nostrdatabase_delete(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeFilter.lower(filter)
            ),
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_poll_void,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_complete_void,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeNostrSdkError,

        )



    async def event_by_id(self, event_id: "EventId") -> "typing.Optional[Event]":
        """
        Get [`Event`] by [`EventId`]
        """

        _UniffiConverterTypeEventId.check_lower(event_id)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nostrdatabase_event_by_id(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeEventId.lower(event_id)
            ),
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterOptionalTypeEvent.lift,
            
    # Error FFI converter
_UniffiConverterTypeNostrSdkError,

        )



    async def metadata(self, public_key: "PublicKey") -> "typing.Optional[Metadata]":
        _UniffiConverterTypePublicKey.check_lower(public_key)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nostrdatabase_metadata(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypePublicKey.lower(public_key)
            ),
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterOptionalTypeMetadata.lift,
            
    # Error FFI converter
_UniffiConverterTypeNostrSdkError,

        )



    async def query(self, filter: "Filter") -> "Events":
        _UniffiConverterTypeFilter.check_lower(filter)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nostrdatabase_query(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeFilter.lower(filter)
            ),
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_poll_pointer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_complete_pointer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_free_pointer,
            # lift function
            _UniffiConverterTypeEvents.lift,
            
    # Error FFI converter
_UniffiConverterTypeNostrSdkError,

        )



    async def save_event(self, event: "Event") -> "SaveEventStatus":
        """
        Save [`Event`] into store
        """

        _UniffiConverterTypeEvent.check_lower(event)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nostrdatabase_save_event(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeEvent.lower(event)
            ),
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_poll_pointer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_complete_pointer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_free_pointer,
            # lift function
            _UniffiConverterTypeSaveEventStatus.lift,
            
    # Error FFI converter
_UniffiConverterTypeNostrSdkError,

        )



    async def wipe(self, ) -> None:

        """
        Wipe all data
        """

        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nostrdatabase_wipe(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_poll_void,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_complete_void,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeNostrSdkError,

        )





class _UniffiConverterTypeNostrDatabase:

    @staticmethod
    def lift(value: int):
        return NostrDatabase._make_instance_(value)

    @staticmethod
    def check_lower(value: NostrDatabase):
        if not isinstance(value, NostrDatabase):
            raise TypeError("Expected NostrDatabase instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: NostrDatabaseProtocol):
        if not isinstance(value, NostrDatabase):
            raise TypeError("Expected NostrDatabase instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: NostrDatabaseProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class NostrGossipProtocol(typing.Protocol):
    pass
# NostrGossip is a Rust-only trait - it's a wrapper around a Rust implementation.
class NostrGossip():
    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_nostrgossip, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_nostrgossip, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst
    @classmethod
    def in_memory(cls, ):
        """
        Construct a new in-memory gossip store
        """

        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_nostrgossip_in_memory,)
        return cls._make_instance_(pointer)




class _UniffiConverterTypeNostrGossip:

    @staticmethod
    def lift(value: int):
        return NostrGossip._make_instance_(value)

    @staticmethod
    def check_lower(value: NostrGossip):
        if not isinstance(value, NostrGossip):
            raise TypeError("Expected NostrGossip instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: NostrGossipProtocol):
        if not isinstance(value, NostrGossip):
            raise TypeError("Expected NostrGossip instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: NostrGossipProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class NostrParserProtocol(typing.Protocol):
    """
    Nostr parser
    """

    def parse(self, text: "str",opts: "typing.Union[object, typing.Optional[NostrParserOptions]]" = _DEFAULT):
        """
        Parse text into tokens
        """

        raise NotImplementedError
# NostrParser is a Rust-only trait - it's a wrapper around a Rust implementation.
class NostrParser():
    """
    Nostr parser
    """

    _pointer: ctypes.c_void_p
    def __init__(self, ):
        """
        Construct a new nostr parser

        It's suggested to construct this once and reuse it, to avoid regex re-compilation.
        """

        self._pointer = _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_nostrparser_new,)

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_nostrparser, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_nostrparser, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def parse(self, text: "str",opts: "typing.Union[object, typing.Optional[NostrParserOptions]]" = _DEFAULT) -> "typing.List[NostrParserToken]":
        """
        Parse text into tokens
        """

        _UniffiConverterString.check_lower(text)
        
        if opts is _DEFAULT:
            opts = None
        _UniffiConverterOptionalTypeNostrParserOptions.check_lower(opts)
        
        return _UniffiConverterSequenceTypeNostrParserToken.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nostrparser_parse,self._uniffi_clone_pointer(),
        _UniffiConverterString.lower(text),
        _UniffiConverterOptionalTypeNostrParserOptions.lower(opts))
        )






class _UniffiConverterTypeNostrParser:

    @staticmethod
    def lift(value: int):
        return NostrParser._make_instance_(value)

    @staticmethod
    def check_lower(value: NostrParser):
        if not isinstance(value, NostrParser):
            raise TypeError("Expected NostrParser instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: NostrParserProtocol):
        if not isinstance(value, NostrParser):
            raise TypeError("Expected NostrParser instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: NostrParserProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class NostrSignerProtocol(typing.Protocol):
    def backend(self, ):
        raise NotImplementedError
    def get_public_key(self, ):
        raise NotImplementedError
    def nip04_decrypt(self, public_key: "PublicKey",encrypted_content: "str"):
        raise NotImplementedError
    def nip04_encrypt(self, public_key: "PublicKey",content: "str"):
        raise NotImplementedError
    def nip44_decrypt(self, public_key: "PublicKey",payload: "str"):
        raise NotImplementedError
    def nip44_encrypt(self, public_key: "PublicKey",content: "str"):
        raise NotImplementedError
    def sign_event(self, unsigned_event: "UnsignedEvent"):
        raise NotImplementedError
# NostrSigner is a Rust-only trait - it's a wrapper around a Rust implementation.
class NostrSigner():
    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_nostrsigner, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_nostrsigner, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst
    @classmethod
    def custom(cls, custom: "CustomNostrSigner"):
        _UniffiConverterTypeCustomNostrSigner.check_lower(custom)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_nostrsigner_custom,
        _UniffiConverterTypeCustomNostrSigner.lower(custom))
        return cls._make_instance_(pointer)

    @classmethod
    def keys(cls, keys: "Keys"):
        _UniffiConverterTypeKeys.check_lower(keys)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_nostrsigner_keys,
        _UniffiConverterTypeKeys.lower(keys))
        return cls._make_instance_(pointer)

    @classmethod
    def nostr_connect(cls, connect: "NostrConnect"):
        _UniffiConverterTypeNostrConnect.check_lower(connect)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_nostrsigner_nostr_connect,
        _UniffiConverterTypeNostrConnect.lower(connect))
        return cls._make_instance_(pointer)



    def backend(self, ) -> "SignerBackend":
        return _UniffiConverterTypeSignerBackend.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nostrsigner_backend,self._uniffi_clone_pointer(),)
        )




    async def get_public_key(self, ) -> "PublicKey":
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nostrsigner_get_public_key(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_poll_pointer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_complete_pointer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_free_pointer,
            # lift function
            _UniffiConverterTypePublicKey.lift,
            
    # Error FFI converter
_UniffiConverterTypeNostrSdkError,

        )



    async def nip04_decrypt(self, public_key: "PublicKey",encrypted_content: "str") -> "str":
        _UniffiConverterTypePublicKey.check_lower(public_key)
        
        _UniffiConverterString.check_lower(encrypted_content)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nostrsigner_nip04_decrypt(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypePublicKey.lower(public_key),
        _UniffiConverterString.lower(encrypted_content)
            ),
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterString.lift,
            
    # Error FFI converter
_UniffiConverterTypeNostrSdkError,

        )



    async def nip04_encrypt(self, public_key: "PublicKey",content: "str") -> "str":
        _UniffiConverterTypePublicKey.check_lower(public_key)
        
        _UniffiConverterString.check_lower(content)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nostrsigner_nip04_encrypt(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypePublicKey.lower(public_key),
        _UniffiConverterString.lower(content)
            ),
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterString.lift,
            
    # Error FFI converter
_UniffiConverterTypeNostrSdkError,

        )



    async def nip44_decrypt(self, public_key: "PublicKey",payload: "str") -> "str":
        _UniffiConverterTypePublicKey.check_lower(public_key)
        
        _UniffiConverterString.check_lower(payload)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nostrsigner_nip44_decrypt(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypePublicKey.lower(public_key),
        _UniffiConverterString.lower(payload)
            ),
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterString.lift,
            
    # Error FFI converter
_UniffiConverterTypeNostrSdkError,

        )



    async def nip44_encrypt(self, public_key: "PublicKey",content: "str") -> "str":
        _UniffiConverterTypePublicKey.check_lower(public_key)
        
        _UniffiConverterString.check_lower(content)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nostrsigner_nip44_encrypt(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypePublicKey.lower(public_key),
        _UniffiConverterString.lower(content)
            ),
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterString.lift,
            
    # Error FFI converter
_UniffiConverterTypeNostrSdkError,

        )



    async def sign_event(self, unsigned_event: "UnsignedEvent") -> "Event":
        _UniffiConverterTypeUnsignedEvent.check_lower(unsigned_event)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nostrsigner_sign_event(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeUnsignedEvent.lower(unsigned_event)
            ),
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_poll_pointer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_complete_pointer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_free_pointer,
            # lift function
            _UniffiConverterTypeEvent.lift,
            
    # Error FFI converter
_UniffiConverterTypeNostrSdkError,

        )





class _UniffiConverterTypeNostrSigner:

    @staticmethod
    def lift(value: int):
        return NostrSigner._make_instance_(value)

    @staticmethod
    def check_lower(value: NostrSigner):
        if not isinstance(value, NostrSigner):
            raise TypeError("Expected NostrSigner instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: NostrSignerProtocol):
        if not isinstance(value, NostrSigner):
            raise TypeError("Expected NostrSigner instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: NostrSignerProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class NostrWalletConnectOptionsProtocol(typing.Protocol):
    """
    NWC options
    """

    def relay(self, opts: "RelayOptions"):
        """
        Set relay options
        """

        raise NotImplementedError
    def timeout(self, timeout: "Duration"):
        """
        Set NWC requests timeout (default: 10 secs)
        """

        raise NotImplementedError
# NostrWalletConnectOptions is a Rust-only trait - it's a wrapper around a Rust implementation.
class NostrWalletConnectOptions():
    """
    NWC options
    """

    _pointer: ctypes.c_void_p
    def __init__(self, ):
        """
        New default NWC options
        """

        self._pointer = _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_nostrwalletconnectoptions_new,)

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_nostrwalletconnectoptions, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_nostrwalletconnectoptions, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def relay(self, opts: "RelayOptions") -> "NostrWalletConnectOptions":
        """
        Set relay options
        """

        _UniffiConverterTypeRelayOptions.check_lower(opts)
        
        return _UniffiConverterTypeNostrWalletConnectOptions.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeNostrSdkError,_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nostrwalletconnectoptions_relay,self._uniffi_clone_pointer(),
        _UniffiConverterTypeRelayOptions.lower(opts))
        )





    def timeout(self, timeout: "Duration") -> "NostrWalletConnectOptions":
        """
        Set NWC requests timeout (default: 10 secs)
        """

        _UniffiConverterDuration.check_lower(timeout)
        
        return _UniffiConverterTypeNostrWalletConnectOptions.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nostrwalletconnectoptions_timeout,self._uniffi_clone_pointer(),
        _UniffiConverterDuration.lower(timeout))
        )






class _UniffiConverterTypeNostrWalletConnectOptions:

    @staticmethod
    def lift(value: int):
        return NostrWalletConnectOptions._make_instance_(value)

    @staticmethod
    def check_lower(value: NostrWalletConnectOptions):
        if not isinstance(value, NostrWalletConnectOptions):
            raise TypeError("Expected NostrWalletConnectOptions instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: NostrWalletConnectOptionsProtocol):
        if not isinstance(value, NostrWalletConnectOptions):
            raise TypeError("Expected NostrWalletConnectOptions instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: NostrWalletConnectOptionsProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class NostrWalletConnectUriProtocol(typing.Protocol):
    """
    Nostr Connect URI
    """

    def lud16(self, ):
        """
        A lightning address that clients can use to automatically setup the lud16 field on the user's profile if they have none configured.
        """

        raise NotImplementedError
    def public_key(self, ):
        """
        App Pubkey
        """

        raise NotImplementedError
    def relays(self, ):
        """
        URLs of the relays of choice where the `App` is connected and the `Signer` must send and listen for messages.
        """

        raise NotImplementedError
    def secret(self, ):
        """
        32-byte randomly generated hex encoded string
        """

        raise NotImplementedError
# NostrWalletConnectUri is a Rust-only trait - it's a wrapper around a Rust implementation.
class NostrWalletConnectUri():
    """
    Nostr Connect URI
    """

    _pointer: ctypes.c_void_p
    def __init__(self, public_key: "PublicKey",relays: "typing.List[RelayUrl]",random_secret_key: "SecretKey",lud16: "typing.Optional[str]"):
        """
        Create new Nostr Wallet Connect URI
        """

        _UniffiConverterTypePublicKey.check_lower(public_key)
        
        _UniffiConverterSequenceTypeRelayUrl.check_lower(relays)
        
        _UniffiConverterTypeSecretKey.check_lower(random_secret_key)
        
        _UniffiConverterOptionalString.check_lower(lud16)
        
        self._pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeNostrSdkError,_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_nostrwalletconnecturi_new,
        _UniffiConverterTypePublicKey.lower(public_key),
        _UniffiConverterSequenceTypeRelayUrl.lower(relays),
        _UniffiConverterTypeSecretKey.lower(random_secret_key),
        _UniffiConverterOptionalString.lower(lud16))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_nostrwalletconnecturi, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_nostrwalletconnecturi, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst
    @classmethod
    def parse(cls, uri: "str"):
        _UniffiConverterString.check_lower(uri)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeNostrSdkError,_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_nostrwalletconnecturi_parse,
        _UniffiConverterString.lower(uri))
        return cls._make_instance_(pointer)



    def lud16(self, ) -> "typing.Optional[str]":
        """
        A lightning address that clients can use to automatically setup the lud16 field on the user's profile if they have none configured.
        """

        return _UniffiConverterOptionalString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nostrwalletconnecturi_lud16,self._uniffi_clone_pointer(),)
        )





    def public_key(self, ) -> "PublicKey":
        """
        App Pubkey
        """

        return _UniffiConverterTypePublicKey.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nostrwalletconnecturi_public_key,self._uniffi_clone_pointer(),)
        )





    def relays(self, ) -> "typing.List[RelayUrl]":
        """
        URLs of the relays of choice where the `App` is connected and the `Signer` must send and listen for messages.
        """

        return _UniffiConverterSequenceTypeRelayUrl.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nostrwalletconnecturi_relays,self._uniffi_clone_pointer(),)
        )





    def secret(self, ) -> "SecretKey":
        """
        32-byte randomly generated hex encoded string
        """

        return _UniffiConverterTypeSecretKey.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nostrwalletconnecturi_secret,self._uniffi_clone_pointer(),)
        )





    def __repr__(self, ) -> "str":
        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nostrwalletconnecturi_uniffi_trait_debug,self._uniffi_clone_pointer(),)
        )





    def __str__(self, ) -> "str":
        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nostrwalletconnecturi_uniffi_trait_display,self._uniffi_clone_pointer(),)
        )



    def __eq__(self, other: object) -> bool:
        if not isinstance(other, NostrWalletConnectUri):
            return NotImplemented

        return _UniffiConverterBool.lift(_uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nostrwalletconnecturi_uniffi_trait_eq_eq,self._uniffi_clone_pointer(),
        _UniffiConverterTypeNostrWalletConnectUri.lower(other)))

    def __ne__(self, other: object) -> bool:
        if not isinstance(other, NostrWalletConnectUri):
            return NotImplemented

        return _UniffiConverterBool.lift(_uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nostrwalletconnecturi_uniffi_trait_eq_ne,self._uniffi_clone_pointer(),
        _UniffiConverterTypeNostrWalletConnectUri.lower(other)))



class _UniffiConverterTypeNostrWalletConnectUri:

    @staticmethod
    def lift(value: int):
        return NostrWalletConnectUri._make_instance_(value)

    @staticmethod
    def check_lower(value: NostrWalletConnectUri):
        if not isinstance(value, NostrWalletConnectUri):
            raise TypeError("Expected NostrWalletConnectUri instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: NostrWalletConnectUriProtocol):
        if not isinstance(value, NostrWalletConnectUri):
            raise TypeError("Expected NostrWalletConnectUri instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: NostrWalletConnectUriProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class NwcProtocol(typing.Protocol):
    """
    Nostr Wallet Connect client
    """

    def get_balance(self, ):
        """
        Get balance
        """

        raise NotImplementedError
    def get_info(self, ):
        """
        Get info
        """

        raise NotImplementedError
    def list_transactions(self, params: "ListTransactionsRequest"):
        """
        List transactions
        """

        raise NotImplementedError
    def lookup_invoice(self, params: "LookupInvoiceRequest"):
        """
        Lookup invoice
        """

        raise NotImplementedError
    def make_invoice(self, params: "MakeInvoiceRequest"):
        """
        Create invoice
        """

        raise NotImplementedError
    def pay_invoice(self, params: "PayInvoiceRequest"):
        """
        Pay invoice
        """

        raise NotImplementedError
    def pay_keysend(self, params: "PayKeysendRequest"):
        """
        Pay keysend
        """

        raise NotImplementedError
    def status(self, ):
        """
        Get relays status
        """

        raise NotImplementedError
# Nwc is a Rust-only trait - it's a wrapper around a Rust implementation.
class Nwc():
    """
    Nostr Wallet Connect client
    """

    _pointer: ctypes.c_void_p
    def __init__(self, uri: "NostrWalletConnectUri"):
        """
        Compose new `NWC` client
        """

        _UniffiConverterTypeNostrWalletConnectUri.check_lower(uri)
        
        self._pointer = _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_nwc_new,
        _UniffiConverterTypeNostrWalletConnectUri.lower(uri))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_nwc, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_nwc, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst
    @classmethod
    def with_opts(cls, uri: "NostrWalletConnectUri",opts: "NostrWalletConnectOptions"):
        """
        Compose new `NWC` client with `NostrWalletConnectOptions`
        """

        _UniffiConverterTypeNostrWalletConnectUri.check_lower(uri)
        
        _UniffiConverterTypeNostrWalletConnectOptions.check_lower(opts)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_nwc_with_opts,
        _UniffiConverterTypeNostrWalletConnectUri.lower(uri),
        _UniffiConverterTypeNostrWalletConnectOptions.lower(opts))
        return cls._make_instance_(pointer)


    async def get_balance(self, ) -> "int":
        """
        Get balance
        """

        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nwc_get_balance(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_poll_u64,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_complete_u64,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_free_u64,
            # lift function
            _UniffiConverterUInt64.lift,
            
    # Error FFI converter
_UniffiConverterTypeNostrSdkError,

        )



    async def get_info(self, ) -> "GetInfoResponse":
        """
        Get info
        """

        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nwc_get_info(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeGetInfoResponse.lift,
            
    # Error FFI converter
_UniffiConverterTypeNostrSdkError,

        )



    async def list_transactions(self, params: "ListTransactionsRequest") -> "typing.List[LookupInvoiceResponse]":
        """
        List transactions
        """

        _UniffiConverterTypeListTransactionsRequest.check_lower(params)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nwc_list_transactions(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeListTransactionsRequest.lower(params)
            ),
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterSequenceTypeLookupInvoiceResponse.lift,
            
    # Error FFI converter
_UniffiConverterTypeNostrSdkError,

        )



    async def lookup_invoice(self, params: "LookupInvoiceRequest") -> "LookupInvoiceResponse":
        """
        Lookup invoice
        """

        _UniffiConverterTypeLookupInvoiceRequest.check_lower(params)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nwc_lookup_invoice(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeLookupInvoiceRequest.lower(params)
            ),
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeLookupInvoiceResponse.lift,
            
    # Error FFI converter
_UniffiConverterTypeNostrSdkError,

        )



    async def make_invoice(self, params: "MakeInvoiceRequest") -> "MakeInvoiceResponse":
        """
        Create invoice
        """

        _UniffiConverterTypeMakeInvoiceRequest.check_lower(params)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nwc_make_invoice(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeMakeInvoiceRequest.lower(params)
            ),
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeMakeInvoiceResponse.lift,
            
    # Error FFI converter
_UniffiConverterTypeNostrSdkError,

        )



    async def pay_invoice(self, params: "PayInvoiceRequest") -> "PayInvoiceResponse":
        """
        Pay invoice
        """

        _UniffiConverterTypePayInvoiceRequest.check_lower(params)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nwc_pay_invoice(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypePayInvoiceRequest.lower(params)
            ),
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypePayInvoiceResponse.lift,
            
    # Error FFI converter
_UniffiConverterTypeNostrSdkError,

        )



    async def pay_keysend(self, params: "PayKeysendRequest") -> "PayKeysendResponse":
        """
        Pay keysend
        """

        _UniffiConverterTypePayKeysendRequest.check_lower(params)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nwc_pay_keysend(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypePayKeysendRequest.lower(params)
            ),
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypePayKeysendResponse.lift,
            
    # Error FFI converter
_UniffiConverterTypeNostrSdkError,

        )



    async def status(self, ) -> "dict[RelayUrl, RelayStatus]":
        """
        Get relays status
        """

        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_nostr_sdk_ffi_fn_method_nwc_status(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterMapTypeRelayUrlTypeRelayStatus.lift,
            
    # Error FFI converter

    None,

        )





class _UniffiConverterTypeNwc:

    @staticmethod
    def lift(value: int):
        return Nwc._make_instance_(value)

    @staticmethod
    def check_lower(value: Nwc):
        if not isinstance(value, Nwc):
            raise TypeError("Expected Nwc instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: NwcProtocol):
        if not isinstance(value, Nwc):
            raise TypeError("Expected Nwc instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: NwcProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class PublicKeyProtocol(typing.Protocol):
    def to_bech32(self, ):
        raise NotImplementedError
    def to_hex(self, ):
        raise NotImplementedError
    def to_nostr_uri(self, ):
        raise NotImplementedError
# PublicKey is a Rust-only trait - it's a wrapper around a Rust implementation.
class PublicKey():
    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_publickey, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_publickey, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst
    @classmethod
    def from_bytes(cls, bytes: "bytes"):
        _UniffiConverterBytes.check_lower(bytes)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeNostrSdkError,_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_publickey_from_bytes,
        _UniffiConverterBytes.lower(bytes))
        return cls._make_instance_(pointer)

    @classmethod
    def parse(cls, public_key: "str"):
        """
        Try to parse public key from `hex`, `bech32` or [NIP21](https://github.com/nostr-protocol/nips/blob/master/21.md) uri
        """

        _UniffiConverterString.check_lower(public_key)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeNostrSdkError,_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_publickey_parse,
        _UniffiConverterString.lower(public_key))
        return cls._make_instance_(pointer)



    def to_bech32(self, ) -> "str":
        return _UniffiConverterString.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeNostrSdkError,_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_publickey_to_bech32,self._uniffi_clone_pointer(),)
        )





    def to_hex(self, ) -> "str":
        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_publickey_to_hex,self._uniffi_clone_pointer(),)
        )





    def to_nostr_uri(self, ) -> "str":
        return _UniffiConverterString.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeNostrSdkError,_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_publickey_to_nostr_uri,self._uniffi_clone_pointer(),)
        )





    def __repr__(self, ) -> "str":
        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_publickey_uniffi_trait_debug,self._uniffi_clone_pointer(),)
        )



    def __eq__(self, other: object) -> bool:
        if not isinstance(other, PublicKey):
            return NotImplemented

        return _UniffiConverterBool.lift(_uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_publickey_uniffi_trait_eq_eq,self._uniffi_clone_pointer(),
        _UniffiConverterTypePublicKey.lower(other)))

    def __ne__(self, other: object) -> bool:
        if not isinstance(other, PublicKey):
            return NotImplemented

        return _UniffiConverterBool.lift(_uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_publickey_uniffi_trait_eq_ne,self._uniffi_clone_pointer(),
        _UniffiConverterTypePublicKey.lower(other)))


    def __hash__(self, ) -> "int":
        return _UniffiConverterUInt64.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_publickey_uniffi_trait_hash,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypePublicKey:

    @staticmethod
    def lift(value: int):
        return PublicKey._make_instance_(value)

    @staticmethod
    def check_lower(value: PublicKey):
        if not isinstance(value, PublicKey):
            raise TypeError("Expected PublicKey instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: PublicKeyProtocol):
        if not isinstance(value, PublicKey):
            raise TypeError("Expected PublicKey instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: PublicKeyProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class RelayProtocol(typing.Protocol):
    def ban(self, ):
        """
        Ban relay and set status to `Banned`.

        A banned relay can't reconnect again.
        """

        raise NotImplementedError
    def batch_msg(self, msgs: "typing.List[ClientMessage]"):
        """
        Send multiple `ClientMessage` at once
        """

        raise NotImplementedError
    def connect(self, ):
        """
        Connect to the relay

        # Overview

        If the relays status is not [`RelayStatus::Initialized`] or [`RelayStatus::Terminated`],
        this method returns immediately without doing anything.
        Otherwise, the connection task will be spawned, which will attempt to connect to relay.

        This method returns immediately and doesn't provide any information on if the connection was successful or not.

        # Automatic reconnection

        By default, in case of disconnection, the connection task will automatically attempt to reconnect.
        This behavior can be disabled by changing [`RelayOptions::reconnect`] option.
        """

        raise NotImplementedError
    def connection_mode(self, ):
        """
        Get connection mode
        """

        raise NotImplementedError
    def count_events(self, filter: "Filter",timeout: "Duration"):
        """
        Count events
        """

        raise NotImplementedError
    def disconnect(self, ):
        """
        Disconnect from relay and set status to `Terminated`
        """

        raise NotImplementedError
    def fetch_events(self, filter: "Filter",timeout: "Duration",policy: "ReqExitPolicy"):
        """
        Fetch events
        """

        raise NotImplementedError
    def is_connected(self, ):
        """
        Check if `Relay` is connected
        """

        raise NotImplementedError
    def opts(self, ):
        raise NotImplementedError
    def queue(self, ):
        """
        Get number of messages in queue
        """

        raise NotImplementedError
    def send_event(self, event: "Event"):
        """
        Send event and wait for `OK` relay msg
        """

        raise NotImplementedError
    def send_msg(self, msg: "ClientMessage"):
        """
        Send msg to relay
        """

        raise NotImplementedError
    def stats(self, ):
        raise NotImplementedError
    def status(self, ):
        """
        Get status
        """

        raise NotImplementedError
    def subscribe(self, filter: "Filter",opts: "SubscribeOptions"):
        """
        Subscribe to filters

        Internally generate a new random subscription ID. Check `subscribe_with_id` method to use a custom subscription ID.

        ### Auto-closing subscription

        It's possible to automatically close a subscription by configuring the `SubscribeOptions`.

        Note: auto-closing subscriptions aren't saved in subscriptions map!
        """

        raise NotImplementedError
    def subscribe_with_id(self, id: "str",filter: "Filter",opts: "SubscribeOptions"):
        """
        Subscribe with custom subscription ID

        ### Auto-closing subscription

        It's possible to automatically close a subscription by configuring the `SubscribeOptions`.

        Note: auto-closing subscriptions aren't saved in subscriptions map!
        """

        raise NotImplementedError
    def subscription(self, id: "str"):
        """
        Get filters by subscription ID
        """

        raise NotImplementedError
    def subscriptions(self, ):
        raise NotImplementedError
    def sync(self, filter: "Filter",opts: "SyncOptions"):
        """
        Sync events with relays (negentropy reconciliation)
        """

        raise NotImplementedError
    def sync_with_items(self, filter: "Filter",items: "typing.List[NegentropyItem]",opts: "SyncOptions"):
        """
        Sync events with relays (negentropy reconciliation)
        """

        raise NotImplementedError
    def try_connect(self, timeout: "Duration"):
        """
        Try to establish a connection with the relay.

        # Overview

        If the relays status is not [`RelayStatus::Initialized`] or [`RelayStatus::Terminated`],
        this method returns immediately without doing anything.
        Otherwise, attempts to establish a connection without spawning the connection task if it fails.
        This means that if the connection fails, no automatic retries are scheduled.
        Use [`Relay::connect`] if you want to immediately spawn a connection task,
        regardless of whether the initial connection succeeds.

        Returns an error if the connection fails.

        # Automatic reconnection

        By default, in case of disconnection (after a first successful connection),
        the connection task will automatically attempt to reconnect.
        This behavior can be disabled by changing [`RelayOptions::reconnect`] option.
        """

        raise NotImplementedError
    def unsubscribe(self, id: "str"):
        """
        Unsubscribe
        """

        raise NotImplementedError
    def unsubscribe_all(self, ):
        """
        Unsubscribe from all subscriptions
        """

        raise NotImplementedError
    def url(self, ):
        """
        Get relay url
        """

        raise NotImplementedError
# Relay is a Rust-only trait - it's a wrapper around a Rust implementation.
class Relay():
    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_relay, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_relay, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def ban(self, ) -> None:
        """
        Ban relay and set status to `Banned`.

        A banned relay can't reconnect again.
        """

        _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relay_ban,self._uniffi_clone_pointer(),)






    def batch_msg(self, msgs: "typing.List[ClientMessage]") -> None:
        """
        Send multiple `ClientMessage` at once
        """

        _UniffiConverterSequenceTypeClientMessage.check_lower(msgs)
        
        _uniffi_rust_call_with_error(_UniffiConverterTypeNostrSdkError,_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relay_batch_msg,self._uniffi_clone_pointer(),
        _UniffiConverterSequenceTypeClientMessage.lower(msgs))






    def connect(self, ) -> None:
        """
        Connect to the relay

        # Overview

        If the relays status is not [`RelayStatus::Initialized`] or [`RelayStatus::Terminated`],
        this method returns immediately without doing anything.
        Otherwise, the connection task will be spawned, which will attempt to connect to relay.

        This method returns immediately and doesn't provide any information on if the connection was successful or not.

        # Automatic reconnection

        By default, in case of disconnection, the connection task will automatically attempt to reconnect.
        This behavior can be disabled by changing [`RelayOptions::reconnect`] option.
        """

        _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relay_connect,self._uniffi_clone_pointer(),)






    def connection_mode(self, ) -> "ConnectionMode":
        """
        Get connection mode
        """

        return _UniffiConverterTypeConnectionMode.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relay_connection_mode,self._uniffi_clone_pointer(),)
        )




    async def count_events(self, filter: "Filter",timeout: "Duration") -> "int":
        """
        Count events
        """

        _UniffiConverterTypeFilter.check_lower(filter)
        
        _UniffiConverterDuration.check_lower(timeout)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relay_count_events(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeFilter.lower(filter),
        _UniffiConverterDuration.lower(timeout)
            ),
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_poll_u64,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_complete_u64,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_free_u64,
            # lift function
            _UniffiConverterUInt64.lift,
            
    # Error FFI converter
_UniffiConverterTypeNostrSdkError,

        )




    def disconnect(self, ) -> None:
        """
        Disconnect from relay and set status to `Terminated`
        """

        _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relay_disconnect,self._uniffi_clone_pointer(),)





    async def fetch_events(self, filter: "Filter",timeout: "Duration",policy: "ReqExitPolicy") -> "Events":
        """
        Fetch events
        """

        _UniffiConverterTypeFilter.check_lower(filter)
        
        _UniffiConverterDuration.check_lower(timeout)
        
        _UniffiConverterTypeReqExitPolicy.check_lower(policy)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relay_fetch_events(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeFilter.lower(filter),
        _UniffiConverterDuration.lower(timeout),
        _UniffiConverterTypeReqExitPolicy.lower(policy)
            ),
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_poll_pointer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_complete_pointer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_free_pointer,
            # lift function
            _UniffiConverterTypeEvents.lift,
            
    # Error FFI converter
_UniffiConverterTypeNostrSdkError,

        )




    def is_connected(self, ) -> "bool":
        """
        Check if `Relay` is connected
        """

        return _UniffiConverterBool.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relay_is_connected,self._uniffi_clone_pointer(),)
        )





    def opts(self, ) -> "RelayOptions":
        return _UniffiConverterTypeRelayOptions.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relay_opts,self._uniffi_clone_pointer(),)
        )





    def queue(self, ) -> "int":
        """
        Get number of messages in queue
        """

        return _UniffiConverterUInt64.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relay_queue,self._uniffi_clone_pointer(),)
        )




    async def send_event(self, event: "Event") -> "EventId":
        """
        Send event and wait for `OK` relay msg
        """

        _UniffiConverterTypeEvent.check_lower(event)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relay_send_event(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeEvent.lower(event)
            ),
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_poll_pointer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_complete_pointer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_free_pointer,
            # lift function
            _UniffiConverterTypeEventId.lift,
            
    # Error FFI converter
_UniffiConverterTypeNostrSdkError,

        )




    def send_msg(self, msg: "ClientMessage") -> None:
        """
        Send msg to relay
        """

        _UniffiConverterTypeClientMessage.check_lower(msg)
        
        _uniffi_rust_call_with_error(_UniffiConverterTypeNostrSdkError,_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relay_send_msg,self._uniffi_clone_pointer(),
        _UniffiConverterTypeClientMessage.lower(msg))






    def stats(self, ) -> "RelayConnectionStats":
        return _UniffiConverterTypeRelayConnectionStats.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relay_stats,self._uniffi_clone_pointer(),)
        )





    def status(self, ) -> "RelayStatus":
        """
        Get status
        """

        return _UniffiConverterTypeRelayStatus.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relay_status,self._uniffi_clone_pointer(),)
        )




    async def subscribe(self, filter: "Filter",opts: "SubscribeOptions") -> "str":
        """
        Subscribe to filters

        Internally generate a new random subscription ID. Check `subscribe_with_id` method to use a custom subscription ID.

        ### Auto-closing subscription

        It's possible to automatically close a subscription by configuring the `SubscribeOptions`.

        Note: auto-closing subscriptions aren't saved in subscriptions map!
        """

        _UniffiConverterTypeFilter.check_lower(filter)
        
        _UniffiConverterTypeSubscribeOptions.check_lower(opts)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relay_subscribe(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeFilter.lower(filter),
        _UniffiConverterTypeSubscribeOptions.lower(opts)
            ),
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterString.lift,
            
    # Error FFI converter
_UniffiConverterTypeNostrSdkError,

        )



    async def subscribe_with_id(self, id: "str",filter: "Filter",opts: "SubscribeOptions") -> None:

        """
        Subscribe with custom subscription ID

        ### Auto-closing subscription

        It's possible to automatically close a subscription by configuring the `SubscribeOptions`.

        Note: auto-closing subscriptions aren't saved in subscriptions map!
        """

        _UniffiConverterString.check_lower(id)
        
        _UniffiConverterTypeFilter.check_lower(filter)
        
        _UniffiConverterTypeSubscribeOptions.check_lower(opts)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relay_subscribe_with_id(
                self._uniffi_clone_pointer(), 
        _UniffiConverterString.lower(id),
        _UniffiConverterTypeFilter.lower(filter),
        _UniffiConverterTypeSubscribeOptions.lower(opts)
            ),
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_poll_void,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_complete_void,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeNostrSdkError,

        )



    async def subscription(self, id: "str") -> "typing.Optional[typing.List[Filter]]":
        """
        Get filters by subscription ID
        """

        _UniffiConverterString.check_lower(id)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relay_subscription(
                self._uniffi_clone_pointer(), 
        _UniffiConverterString.lower(id)
            ),
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterOptionalSequenceTypeFilter.lift,
            
    # Error FFI converter

    None,

        )



    async def subscriptions(self, ) -> "dict[str, typing.List[Filter]]":
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relay_subscriptions(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterMapStringSequenceTypeFilter.lift,
            
    # Error FFI converter

    None,

        )



    async def sync(self, filter: "Filter",opts: "SyncOptions") -> "Reconciliation":
        """
        Sync events with relays (negentropy reconciliation)
        """

        _UniffiConverterTypeFilter.check_lower(filter)
        
        _UniffiConverterTypeSyncOptions.check_lower(opts)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relay_sync(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeFilter.lower(filter),
        _UniffiConverterTypeSyncOptions.lower(opts)
            ),
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeReconciliation.lift,
            
    # Error FFI converter
_UniffiConverterTypeNostrSdkError,

        )



    async def sync_with_items(self, filter: "Filter",items: "typing.List[NegentropyItem]",opts: "SyncOptions") -> "Reconciliation":
        """
        Sync events with relays (negentropy reconciliation)
        """

        _UniffiConverterTypeFilter.check_lower(filter)
        
        _UniffiConverterSequenceTypeNegentropyItem.check_lower(items)
        
        _UniffiConverterTypeSyncOptions.check_lower(opts)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relay_sync_with_items(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeFilter.lower(filter),
        _UniffiConverterSequenceTypeNegentropyItem.lower(items),
        _UniffiConverterTypeSyncOptions.lower(opts)
            ),
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeReconciliation.lift,
            
    # Error FFI converter
_UniffiConverterTypeNostrSdkError,

        )



    async def try_connect(self, timeout: "Duration") -> None:

        """
        Try to establish a connection with the relay.

        # Overview

        If the relays status is not [`RelayStatus::Initialized`] or [`RelayStatus::Terminated`],
        this method returns immediately without doing anything.
        Otherwise, attempts to establish a connection without spawning the connection task if it fails.
        This means that if the connection fails, no automatic retries are scheduled.
        Use [`Relay::connect`] if you want to immediately spawn a connection task,
        regardless of whether the initial connection succeeds.

        Returns an error if the connection fails.

        # Automatic reconnection

        By default, in case of disconnection (after a first successful connection),
        the connection task will automatically attempt to reconnect.
        This behavior can be disabled by changing [`RelayOptions::reconnect`] option.
        """

        _UniffiConverterDuration.check_lower(timeout)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relay_try_connect(
                self._uniffi_clone_pointer(), 
        _UniffiConverterDuration.lower(timeout)
            ),
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_poll_void,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_complete_void,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeNostrSdkError,

        )



    async def unsubscribe(self, id: "str") -> None:

        """
        Unsubscribe
        """

        _UniffiConverterString.check_lower(id)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relay_unsubscribe(
                self._uniffi_clone_pointer(), 
        _UniffiConverterString.lower(id)
            ),
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_poll_void,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_complete_void,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeNostrSdkError,

        )



    async def unsubscribe_all(self, ) -> None:

        """
        Unsubscribe from all subscriptions
        """

        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relay_unsubscribe_all(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_poll_void,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_complete_void,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeNostrSdkError,

        )




    def url(self, ) -> "RelayUrl":
        """
        Get relay url
        """

        return _UniffiConverterTypeRelayUrl.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relay_url,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeRelay:

    @staticmethod
    def lift(value: int):
        return Relay._make_instance_(value)

    @staticmethod
    def check_lower(value: Relay):
        if not isinstance(value, Relay):
            raise TypeError("Expected Relay instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: RelayProtocol):
        if not isinstance(value, Relay):
            raise TypeError("Expected Relay instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: RelayProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class RelayBuilderProtocol(typing.Protocol):
    """
    Relay builder
    """

    def addr(self, ip_addr: "str"):
        """
        Set IP address
        """

        raise NotImplementedError
    def auth_dm(self, enable: "bool"):
        """
        If enabled, NIP-42 will be used for DMs, returning GiftWrap events for
        the mentioned public key only.
        """

        raise NotImplementedError
    def database(self, database: "NostrDatabase"):
        """
        Set database
        """

        raise NotImplementedError
    def default_filter_limit(self, limit: "int"):
        """
        Sets the default filter limit when no limit is specified. Defaults 500.
        """

        raise NotImplementedError
    def max_connections(self, max: "int"):
        """
        Set number of max connections allowed
        """

        raise NotImplementedError
    def max_filter_limit(self, max: "int"):
        """
        Sets the maximum limit for the filter. If the filter's limit exceeds
        this value, it will fallback to this number.
        """

        raise NotImplementedError
    def max_subid_length(self, max: "int"):
        """
        Sets the maximum subscription ID length. Defaults 250.
        """

        raise NotImplementedError
    def min_pow(self, difficulty: "int"):
        """
        Sets the minimum Proof of Work difficulty.

        Only values `> 0` are accepted!
        """

        raise NotImplementedError
    def nip42(self, opts: "RelayBuilderNip42"):
        """
        Require NIP42 authentication
        """

        raise NotImplementedError
    def port(self, port: "int"):
        """
        Set port
        """

        raise NotImplementedError
    def query_policy(self, policy: "QueryPolicy"):
        """
        Add a query policy plugin
        """

        raise NotImplementedError
    def rate_limit(self, limit: "RateLimit"):
        """
        Set rate limit
        """

        raise NotImplementedError
    def write_policy(self, policy: "WritePolicy"):
        """
        Add a write policy plugin
        """

        raise NotImplementedError
# RelayBuilder is a Rust-only trait - it's a wrapper around a Rust implementation.
class RelayBuilder():
    """
    Relay builder
    """

    _pointer: ctypes.c_void_p
    def __init__(self, ):
        """
        Construct new default relay builder
        """

        self._pointer = _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_relaybuilder_new,)

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_relaybuilder, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_relaybuilder, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def addr(self, ip_addr: "str") -> "RelayBuilder":
        """
        Set IP address
        """

        _UniffiConverterString.check_lower(ip_addr)
        
        return _UniffiConverterTypeRelayBuilder.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeNostrSdkError,_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relaybuilder_addr,self._uniffi_clone_pointer(),
        _UniffiConverterString.lower(ip_addr))
        )





    def auth_dm(self, enable: "bool") -> "RelayBuilder":
        """
        If enabled, NIP-42 will be used for DMs, returning GiftWrap events for
        the mentioned public key only.
        """

        _UniffiConverterBool.check_lower(enable)
        
        return _UniffiConverterTypeRelayBuilder.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relaybuilder_auth_dm,self._uniffi_clone_pointer(),
        _UniffiConverterBool.lower(enable))
        )





    def database(self, database: "NostrDatabase") -> "RelayBuilder":
        """
        Set database
        """

        _UniffiConverterTypeNostrDatabase.check_lower(database)
        
        return _UniffiConverterTypeRelayBuilder.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relaybuilder_database,self._uniffi_clone_pointer(),
        _UniffiConverterTypeNostrDatabase.lower(database))
        )





    def default_filter_limit(self, limit: "int") -> "RelayBuilder":
        """
        Sets the default filter limit when no limit is specified. Defaults 500.
        """

        _UniffiConverterUInt64.check_lower(limit)
        
        return _UniffiConverterTypeRelayBuilder.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relaybuilder_default_filter_limit,self._uniffi_clone_pointer(),
        _UniffiConverterUInt64.lower(limit))
        )





    def max_connections(self, max: "int") -> "RelayBuilder":
        """
        Set number of max connections allowed
        """

        _UniffiConverterUInt64.check_lower(max)
        
        return _UniffiConverterTypeRelayBuilder.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relaybuilder_max_connections,self._uniffi_clone_pointer(),
        _UniffiConverterUInt64.lower(max))
        )





    def max_filter_limit(self, max: "int") -> "RelayBuilder":
        """
        Sets the maximum limit for the filter. If the filter's limit exceeds
        this value, it will fallback to this number.
        """

        _UniffiConverterUInt64.check_lower(max)
        
        return _UniffiConverterTypeRelayBuilder.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relaybuilder_max_filter_limit,self._uniffi_clone_pointer(),
        _UniffiConverterUInt64.lower(max))
        )





    def max_subid_length(self, max: "int") -> "RelayBuilder":
        """
        Sets the maximum subscription ID length. Defaults 250.
        """

        _UniffiConverterUInt64.check_lower(max)
        
        return _UniffiConverterTypeRelayBuilder.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relaybuilder_max_subid_length,self._uniffi_clone_pointer(),
        _UniffiConverterUInt64.lower(max))
        )





    def min_pow(self, difficulty: "int") -> "RelayBuilder":
        """
        Sets the minimum Proof of Work difficulty.

        Only values `> 0` are accepted!
        """

        _UniffiConverterUInt8.check_lower(difficulty)
        
        return _UniffiConverterTypeRelayBuilder.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relaybuilder_min_pow,self._uniffi_clone_pointer(),
        _UniffiConverterUInt8.lower(difficulty))
        )





    def nip42(self, opts: "RelayBuilderNip42") -> "RelayBuilder":
        """
        Require NIP42 authentication
        """

        _UniffiConverterTypeRelayBuilderNip42.check_lower(opts)
        
        return _UniffiConverterTypeRelayBuilder.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relaybuilder_nip42,self._uniffi_clone_pointer(),
        _UniffiConverterTypeRelayBuilderNip42.lower(opts))
        )





    def port(self, port: "int") -> "RelayBuilder":
        """
        Set port
        """

        _UniffiConverterUInt16.check_lower(port)
        
        return _UniffiConverterTypeRelayBuilder.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relaybuilder_port,self._uniffi_clone_pointer(),
        _UniffiConverterUInt16.lower(port))
        )





    def query_policy(self, policy: "QueryPolicy") -> "RelayBuilder":
        """
        Add a query policy plugin
        """

        _UniffiConverterTypeQueryPolicy.check_lower(policy)
        
        return _UniffiConverterTypeRelayBuilder.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relaybuilder_query_policy,self._uniffi_clone_pointer(),
        _UniffiConverterTypeQueryPolicy.lower(policy))
        )





    def rate_limit(self, limit: "RateLimit") -> "RelayBuilder":
        """
        Set rate limit
        """

        _UniffiConverterTypeRateLimit.check_lower(limit)
        
        return _UniffiConverterTypeRelayBuilder.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relaybuilder_rate_limit,self._uniffi_clone_pointer(),
        _UniffiConverterTypeRateLimit.lower(limit))
        )





    def write_policy(self, policy: "WritePolicy") -> "RelayBuilder":
        """
        Add a write policy plugin
        """

        _UniffiConverterTypeWritePolicy.check_lower(policy)
        
        return _UniffiConverterTypeRelayBuilder.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relaybuilder_write_policy,self._uniffi_clone_pointer(),
        _UniffiConverterTypeWritePolicy.lower(policy))
        )






class _UniffiConverterTypeRelayBuilder:

    @staticmethod
    def lift(value: int):
        return RelayBuilder._make_instance_(value)

    @staticmethod
    def check_lower(value: RelayBuilder):
        if not isinstance(value, RelayBuilder):
            raise TypeError("Expected RelayBuilder instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: RelayBuilderProtocol):
        if not isinstance(value, RelayBuilder):
            raise TypeError("Expected RelayBuilder instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: RelayBuilderProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class RelayConnectionStatsProtocol(typing.Protocol):
    def attempts(self, ):
        """
        The number of times a connection has been attempted
        """

        raise NotImplementedError
    def bytes_received(self, ):
        """
        Bytes received
        """

        raise NotImplementedError
    def bytes_sent(self, ):
        """
        Bytes sent
        """

        raise NotImplementedError
    def connected_at(self, ):
        """
        Get UNIX timestamp of the last connection
        """

        raise NotImplementedError
    def first_connection_timestamp(self, ):
        """
        Get UNIX timestamp of the first connection
        """

        raise NotImplementedError
    def latency(self, ):
        raise NotImplementedError
    def success(self, ):
        """
        The number of times a connection has been successfully established
        """

        raise NotImplementedError
    def success_rate(self, ):
        """
        Success rate
        """

        raise NotImplementedError
# RelayConnectionStats is a Rust-only trait - it's a wrapper around a Rust implementation.
class RelayConnectionStats():
    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_relayconnectionstats, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_relayconnectionstats, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def attempts(self, ) -> "int":
        """
        The number of times a connection has been attempted
        """

        return _UniffiConverterUInt64.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relayconnectionstats_attempts,self._uniffi_clone_pointer(),)
        )





    def bytes_received(self, ) -> "int":
        """
        Bytes received
        """

        return _UniffiConverterUInt64.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relayconnectionstats_bytes_received,self._uniffi_clone_pointer(),)
        )





    def bytes_sent(self, ) -> "int":
        """
        Bytes sent
        """

        return _UniffiConverterUInt64.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relayconnectionstats_bytes_sent,self._uniffi_clone_pointer(),)
        )





    def connected_at(self, ) -> "Timestamp":
        """
        Get UNIX timestamp of the last connection
        """

        return _UniffiConverterTypeTimestamp.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relayconnectionstats_connected_at,self._uniffi_clone_pointer(),)
        )





    def first_connection_timestamp(self, ) -> "Timestamp":
        """
        Get UNIX timestamp of the first connection
        """

        return _UniffiConverterTypeTimestamp.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relayconnectionstats_first_connection_timestamp,self._uniffi_clone_pointer(),)
        )





    def latency(self, ) -> "typing.Optional[Duration]":
        return _UniffiConverterOptionalDuration.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relayconnectionstats_latency,self._uniffi_clone_pointer(),)
        )





    def success(self, ) -> "int":
        """
        The number of times a connection has been successfully established
        """

        return _UniffiConverterUInt64.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relayconnectionstats_success,self._uniffi_clone_pointer(),)
        )





    def success_rate(self, ) -> "float":
        """
        Success rate
        """

        return _UniffiConverterDouble.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relayconnectionstats_success_rate,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeRelayConnectionStats:

    @staticmethod
    def lift(value: int):
        return RelayConnectionStats._make_instance_(value)

    @staticmethod
    def check_lower(value: RelayConnectionStats):
        if not isinstance(value, RelayConnectionStats):
            raise TypeError("Expected RelayConnectionStats instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: RelayConnectionStatsProtocol):
        if not isinstance(value, RelayConnectionStats):
            raise TypeError("Expected RelayConnectionStats instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: RelayConnectionStatsProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class RelayInformationDocumentProtocol(typing.Protocol):
    def as_json(self, ):
        """
        Serialize as JSON
        """

        raise NotImplementedError
    def contact(self, ):
        raise NotImplementedError
    def description(self, ):
        raise NotImplementedError
    def fees(self, ):
        raise NotImplementedError
    def icon(self, ):
        raise NotImplementedError
    def language_tags(self, ):
        raise NotImplementedError
    def limitation(self, ):
        raise NotImplementedError
    def name(self, ):
        raise NotImplementedError
    def payments_url(self, ):
        raise NotImplementedError
    def posting_policy(self, ):
        raise NotImplementedError
    def pubkey(self, ):
        raise NotImplementedError
    def relay_countries(self, ):
        raise NotImplementedError
    def retention(self, ):
        raise NotImplementedError
    def software(self, ):
        raise NotImplementedError
    def supported_nips(self, ):
        raise NotImplementedError
    def tags(self, ):
        raise NotImplementedError
    def version(self, ):
        raise NotImplementedError
# RelayInformationDocument is a Rust-only trait - it's a wrapper around a Rust implementation.
class RelayInformationDocument():
    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_relayinformationdocument, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_relayinformationdocument, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst
    @classmethod
    def from_json(cls, json: "str"):
        """
        Parse NIP-11 relay information document from JSON
        """

        _UniffiConverterString.check_lower(json)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeNostrSdkError,_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_relayinformationdocument_from_json,
        _UniffiConverterString.lower(json))
        return cls._make_instance_(pointer)



    def as_json(self, ) -> "str":
        """
        Serialize as JSON
        """

        return _UniffiConverterString.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeNostrSdkError,_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relayinformationdocument_as_json,self._uniffi_clone_pointer(),)
        )





    def contact(self, ) -> "typing.Optional[str]":
        return _UniffiConverterOptionalString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relayinformationdocument_contact,self._uniffi_clone_pointer(),)
        )





    def description(self, ) -> "typing.Optional[str]":
        return _UniffiConverterOptionalString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relayinformationdocument_description,self._uniffi_clone_pointer(),)
        )





    def fees(self, ) -> "typing.Optional[FeeSchedules]":
        return _UniffiConverterOptionalTypeFeeSchedules.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relayinformationdocument_fees,self._uniffi_clone_pointer(),)
        )





    def icon(self, ) -> "typing.Optional[str]":
        return _UniffiConverterOptionalString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relayinformationdocument_icon,self._uniffi_clone_pointer(),)
        )





    def language_tags(self, ) -> "typing.List[str]":
        return _UniffiConverterSequenceString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relayinformationdocument_language_tags,self._uniffi_clone_pointer(),)
        )





    def limitation(self, ) -> "typing.Optional[Limitation]":
        return _UniffiConverterOptionalTypeLimitation.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relayinformationdocument_limitation,self._uniffi_clone_pointer(),)
        )





    def name(self, ) -> "typing.Optional[str]":
        return _UniffiConverterOptionalString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relayinformationdocument_name,self._uniffi_clone_pointer(),)
        )





    def payments_url(self, ) -> "typing.Optional[str]":
        return _UniffiConverterOptionalString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relayinformationdocument_payments_url,self._uniffi_clone_pointer(),)
        )





    def posting_policy(self, ) -> "typing.Optional[str]":
        return _UniffiConverterOptionalString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relayinformationdocument_posting_policy,self._uniffi_clone_pointer(),)
        )





    def pubkey(self, ) -> "typing.Optional[str]":
        return _UniffiConverterOptionalString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relayinformationdocument_pubkey,self._uniffi_clone_pointer(),)
        )





    def relay_countries(self, ) -> "typing.List[str]":
        return _UniffiConverterSequenceString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relayinformationdocument_relay_countries,self._uniffi_clone_pointer(),)
        )





    def retention(self, ) -> "typing.List[Retention]":
        return _UniffiConverterSequenceTypeRetention.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relayinformationdocument_retention,self._uniffi_clone_pointer(),)
        )





    def software(self, ) -> "typing.Optional[str]":
        return _UniffiConverterOptionalString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relayinformationdocument_software,self._uniffi_clone_pointer(),)
        )





    def supported_nips(self, ) -> "typing.Optional[typing.List[int]]":
        return _UniffiConverterOptionalSequenceUInt16.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relayinformationdocument_supported_nips,self._uniffi_clone_pointer(),)
        )





    def tags(self, ) -> "typing.List[str]":
        return _UniffiConverterSequenceString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relayinformationdocument_tags,self._uniffi_clone_pointer(),)
        )





    def version(self, ) -> "typing.Optional[str]":
        return _UniffiConverterOptionalString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relayinformationdocument_version,self._uniffi_clone_pointer(),)
        )





    def __repr__(self, ) -> "str":
        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relayinformationdocument_uniffi_trait_debug,self._uniffi_clone_pointer(),)
        )



    def __eq__(self, other: object) -> bool:
        if not isinstance(other, RelayInformationDocument):
            return NotImplemented

        return _UniffiConverterBool.lift(_uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relayinformationdocument_uniffi_trait_eq_eq,self._uniffi_clone_pointer(),
        _UniffiConverterTypeRelayInformationDocument.lower(other)))

    def __ne__(self, other: object) -> bool:
        if not isinstance(other, RelayInformationDocument):
            return NotImplemented

        return _UniffiConverterBool.lift(_uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relayinformationdocument_uniffi_trait_eq_ne,self._uniffi_clone_pointer(),
        _UniffiConverterTypeRelayInformationDocument.lower(other)))


    def __hash__(self, ) -> "int":
        return _UniffiConverterUInt64.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relayinformationdocument_uniffi_trait_hash,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeRelayInformationDocument:

    @staticmethod
    def lift(value: int):
        return RelayInformationDocument._make_instance_(value)

    @staticmethod
    def check_lower(value: RelayInformationDocument):
        if not isinstance(value, RelayInformationDocument):
            raise TypeError("Expected RelayInformationDocument instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: RelayInformationDocumentProtocol):
        if not isinstance(value, RelayInformationDocument):
            raise TypeError("Expected RelayInformationDocument instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: RelayInformationDocumentProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class RelayLimitsProtocol(typing.Protocol):
    """
    Relay Limits
    """

    def event_max_num_tags(self, max_num_tags: "typing.Optional[int]"):
        """
        Maximum number of tags allowed (default: 2_000)
        """

        raise NotImplementedError
    def event_max_num_tags_per_kind(self, kind: "Kind",max_num_tags: "typing.Optional[int]"):
        """
        Maximum number of tags allowed per kind
        """

        raise NotImplementedError
    def event_max_size(self, max_size: "typing.Optional[int]"):
        """
        Maximum size of normalized JSON, in bytes (default: None)
        """

        raise NotImplementedError
    def event_max_size_per_kind(self, kind: "Kind",max_size: "typing.Optional[int]"):
        """
        Maximum size per kind of normalised JSON, in bytes.
        """

        raise NotImplementedError
    def message_max_size(self, max_size: "typing.Optional[int]"):
        """
        Maximum size of normalized JSON, in bytes (default: 5MB)
        """

        raise NotImplementedError
# RelayLimits is a Rust-only trait - it's a wrapper around a Rust implementation.
class RelayLimits():
    """
    Relay Limits
    """

    _pointer: ctypes.c_void_p
    def __init__(self, ):
        """
        Construct with default limits
        """

        self._pointer = _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_relaylimits_new,)

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_relaylimits, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_relaylimits, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst
    @classmethod
    def disable(cls, ):
        """
        Disable all limits
        """

        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_relaylimits_disable,)
        return cls._make_instance_(pointer)



    def event_max_num_tags(self, max_num_tags: "typing.Optional[int]") -> "RelayLimits":
        """
        Maximum number of tags allowed (default: 2_000)
        """

        _UniffiConverterOptionalUInt16.check_lower(max_num_tags)
        
        return _UniffiConverterTypeRelayLimits.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relaylimits_event_max_num_tags,self._uniffi_clone_pointer(),
        _UniffiConverterOptionalUInt16.lower(max_num_tags))
        )





    def event_max_num_tags_per_kind(self, kind: "Kind",max_num_tags: "typing.Optional[int]") -> "RelayLimits":
        """
        Maximum number of tags allowed per kind
        """

        _UniffiConverterTypeKind.check_lower(kind)
        
        _UniffiConverterOptionalUInt16.check_lower(max_num_tags)
        
        return _UniffiConverterTypeRelayLimits.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relaylimits_event_max_num_tags_per_kind,self._uniffi_clone_pointer(),
        _UniffiConverterTypeKind.lower(kind),
        _UniffiConverterOptionalUInt16.lower(max_num_tags))
        )





    def event_max_size(self, max_size: "typing.Optional[int]") -> "RelayLimits":
        """
        Maximum size of normalized JSON, in bytes (default: None)
        """

        _UniffiConverterOptionalUInt32.check_lower(max_size)
        
        return _UniffiConverterTypeRelayLimits.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relaylimits_event_max_size,self._uniffi_clone_pointer(),
        _UniffiConverterOptionalUInt32.lower(max_size))
        )





    def event_max_size_per_kind(self, kind: "Kind",max_size: "typing.Optional[int]") -> "RelayLimits":
        """
        Maximum size per kind of normalised JSON, in bytes.
        """

        _UniffiConverterTypeKind.check_lower(kind)
        
        _UniffiConverterOptionalUInt32.check_lower(max_size)
        
        return _UniffiConverterTypeRelayLimits.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relaylimits_event_max_size_per_kind,self._uniffi_clone_pointer(),
        _UniffiConverterTypeKind.lower(kind),
        _UniffiConverterOptionalUInt32.lower(max_size))
        )





    def message_max_size(self, max_size: "typing.Optional[int]") -> "RelayLimits":
        """
        Maximum size of normalized JSON, in bytes (default: 5MB)
        """

        _UniffiConverterOptionalUInt32.check_lower(max_size)
        
        return _UniffiConverterTypeRelayLimits.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relaylimits_message_max_size,self._uniffi_clone_pointer(),
        _UniffiConverterOptionalUInt32.lower(max_size))
        )





    def __repr__(self, ) -> "str":
        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relaylimits_uniffi_trait_debug,self._uniffi_clone_pointer(),)
        )



    def __eq__(self, other: object) -> bool:
        if not isinstance(other, RelayLimits):
            return NotImplemented

        return _UniffiConverterBool.lift(_uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relaylimits_uniffi_trait_eq_eq,self._uniffi_clone_pointer(),
        _UniffiConverterTypeRelayLimits.lower(other)))

    def __ne__(self, other: object) -> bool:
        if not isinstance(other, RelayLimits):
            return NotImplemented

        return _UniffiConverterBool.lift(_uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relaylimits_uniffi_trait_eq_ne,self._uniffi_clone_pointer(),
        _UniffiConverterTypeRelayLimits.lower(other)))



class _UniffiConverterTypeRelayLimits:

    @staticmethod
    def lift(value: int):
        return RelayLimits._make_instance_(value)

    @staticmethod
    def check_lower(value: RelayLimits):
        if not isinstance(value, RelayLimits):
            raise TypeError("Expected RelayLimits instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: RelayLimitsProtocol):
        if not isinstance(value, RelayLimits):
            raise TypeError("Expected RelayLimits instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: RelayLimitsProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class RelayMessageProtocol(typing.Protocol):
    def as_enum(self, ):
        """
        Clone `RelayMessage` and convert it to `RelayMessageEnum`
        """

        raise NotImplementedError
    def as_json(self, ):
        raise NotImplementedError
# RelayMessage is a Rust-only trait - it's a wrapper around a Rust implementation.
class RelayMessage():
    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_relaymessage, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_relaymessage, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst
    @classmethod
    def auth(cls, challenge: "str"):
        """
        Create new `AUTH` message
        """

        _UniffiConverterString.check_lower(challenge)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_relaymessage_auth,
        _UniffiConverterString.lower(challenge))
        return cls._make_instance_(pointer)

    @classmethod
    def closed(cls, subscription_id: "str",message: "str"):
        """
        Create new `CLOSED` message
        """

        _UniffiConverterString.check_lower(subscription_id)
        
        _UniffiConverterString.check_lower(message)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_relaymessage_closed,
        _UniffiConverterString.lower(subscription_id),
        _UniffiConverterString.lower(message))
        return cls._make_instance_(pointer)

    @classmethod
    def count(cls, subscription_id: "str",count: "float"):
        """
        Create new `EVENT` message
        """

        _UniffiConverterString.check_lower(subscription_id)
        
        _UniffiConverterDouble.check_lower(count)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_relaymessage_count,
        _UniffiConverterString.lower(subscription_id),
        _UniffiConverterDouble.lower(count))
        return cls._make_instance_(pointer)

    @classmethod
    def eose(cls, subscription_id: "str"):
        """
        Create new `EOSE` message
        """

        _UniffiConverterString.check_lower(subscription_id)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_relaymessage_eose,
        _UniffiConverterString.lower(subscription_id))
        return cls._make_instance_(pointer)

    @classmethod
    def event(cls, subscription_id: "str",event: "Event"):
        """
        Create new `EVENT` message
        """

        _UniffiConverterString.check_lower(subscription_id)
        
        _UniffiConverterTypeEvent.check_lower(event)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_relaymessage_event,
        _UniffiConverterString.lower(subscription_id),
        _UniffiConverterTypeEvent.lower(event))
        return cls._make_instance_(pointer)

    @classmethod
    def from_enum(cls, e: "RelayMessageEnum"):
        """
        Convert `RelayMessageEnum` to `RelayMessage`
        """

        _UniffiConverterTypeRelayMessageEnum.check_lower(e)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_relaymessage_from_enum,
        _UniffiConverterTypeRelayMessageEnum.lower(e))
        return cls._make_instance_(pointer)

    @classmethod
    def from_json(cls, json: "str"):
        """
        Deserialize `RelayMessage` from JSON string

        **This method NOT verify the event signature!**
        """

        _UniffiConverterString.check_lower(json)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeNostrSdkError,_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_relaymessage_from_json,
        _UniffiConverterString.lower(json))
        return cls._make_instance_(pointer)

    @classmethod
    def notice(cls, message: "str"):
        """
        Create new `NOTICE` message
        """

        _UniffiConverterString.check_lower(message)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_relaymessage_notice,
        _UniffiConverterString.lower(message))
        return cls._make_instance_(pointer)

    @classmethod
    def ok(cls, event_id: "EventId",status: "bool",message: "str"):
        """
        Create new `OK` message
        """

        _UniffiConverterTypeEventId.check_lower(event_id)
        
        _UniffiConverterBool.check_lower(status)
        
        _UniffiConverterString.check_lower(message)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_relaymessage_ok,
        _UniffiConverterTypeEventId.lower(event_id),
        _UniffiConverterBool.lower(status),
        _UniffiConverterString.lower(message))
        return cls._make_instance_(pointer)



    def as_enum(self, ) -> "RelayMessageEnum":
        """
        Clone `RelayMessage` and convert it to `RelayMessageEnum`
        """

        return _UniffiConverterTypeRelayMessageEnum.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relaymessage_as_enum,self._uniffi_clone_pointer(),)
        )





    def as_json(self, ) -> "str":
        return _UniffiConverterString.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeNostrSdkError,_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relaymessage_as_json,self._uniffi_clone_pointer(),)
        )





    def __repr__(self, ) -> "str":
        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relaymessage_uniffi_trait_debug,self._uniffi_clone_pointer(),)
        )



    def __eq__(self, other: object) -> bool:
        if not isinstance(other, RelayMessage):
            return NotImplemented

        return _UniffiConverterBool.lift(_uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relaymessage_uniffi_trait_eq_eq,self._uniffi_clone_pointer(),
        _UniffiConverterTypeRelayMessage.lower(other)))

    def __ne__(self, other: object) -> bool:
        if not isinstance(other, RelayMessage):
            return NotImplemented

        return _UniffiConverterBool.lift(_uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relaymessage_uniffi_trait_eq_ne,self._uniffi_clone_pointer(),
        _UniffiConverterTypeRelayMessage.lower(other)))


    def __hash__(self, ) -> "int":
        return _UniffiConverterUInt64.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relaymessage_uniffi_trait_hash,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeRelayMessage:

    @staticmethod
    def lift(value: int):
        return RelayMessage._make_instance_(value)

    @staticmethod
    def check_lower(value: RelayMessage):
        if not isinstance(value, RelayMessage):
            raise TypeError("Expected RelayMessage instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: RelayMessageProtocol):
        if not isinstance(value, RelayMessage):
            raise TypeError("Expected RelayMessage instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: RelayMessageProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class RelayOptionsProtocol(typing.Protocol):
    """
    `Relay` options
    """

    def adjust_retry_interval(self, adjust_retry_interval: "bool"):
        """
        Automatically adjust retry interval based on success/attempts (default: true)
        """

        raise NotImplementedError
    def ban_relay_on_mismatch(self, enable: "bool"):
        """
        If true, ban a relay when it sends an event that doesn't match the subscription filter.
        """

        raise NotImplementedError
    def connection_mode(self, mode: "ConnectionMode"):
        """
        Set connection mode
        """

        raise NotImplementedError
    def limits(self, limits: "RelayLimits"):
        """
        Set custom limits
        """

        raise NotImplementedError
    def max_avg_latency(self, max: "typing.Optional[Duration]"):
        """
        Set max latency (default: None)

        Relay with an avg. latency greater that this value will be skipped.
        """

        raise NotImplementedError
    def ping(self, ping: "bool"):
        """
        Set ping flag
        """

        raise NotImplementedError
    def read(self, read: "bool"):
        """
        Set read flag
        """

        raise NotImplementedError
    def reconnect(self, reconnect: "bool"):
        """
        Enable/disable auto reconnection (default: true)
        """

        raise NotImplementedError
    def retry_interval(self, interval: "Duration"):
        """
        Retry interval (default: 10 sec)

        Minimum allowed value is `5 secs`
        """

        raise NotImplementedError
    def verify_subscriptions(self, enable: "bool"):
        """
        Verify that received events belong to a subscription and match the filter.
        """

        raise NotImplementedError
    def write(self, write: "bool"):
        """
        Set write flag
        """

        raise NotImplementedError
# RelayOptions is a Rust-only trait - it's a wrapper around a Rust implementation.
class RelayOptions():
    """
    `Relay` options
    """

    _pointer: ctypes.c_void_p
    def __init__(self, ):
        """
        New default relay options
        """

        self._pointer = _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_relayoptions_new,)

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_relayoptions, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_relayoptions, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def adjust_retry_interval(self, adjust_retry_interval: "bool") -> "RelayOptions":
        """
        Automatically adjust retry interval based on success/attempts (default: true)
        """

        _UniffiConverterBool.check_lower(adjust_retry_interval)
        
        return _UniffiConverterTypeRelayOptions.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relayoptions_adjust_retry_interval,self._uniffi_clone_pointer(),
        _UniffiConverterBool.lower(adjust_retry_interval))
        )





    def ban_relay_on_mismatch(self, enable: "bool") -> "RelayOptions":
        """
        If true, ban a relay when it sends an event that doesn't match the subscription filter.
        """

        _UniffiConverterBool.check_lower(enable)
        
        return _UniffiConverterTypeRelayOptions.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relayoptions_ban_relay_on_mismatch,self._uniffi_clone_pointer(),
        _UniffiConverterBool.lower(enable))
        )





    def connection_mode(self, mode: "ConnectionMode") -> "RelayOptions":
        """
        Set connection mode
        """

        _UniffiConverterTypeConnectionMode.check_lower(mode)
        
        return _UniffiConverterTypeRelayOptions.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeNostrSdkError,_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relayoptions_connection_mode,self._uniffi_clone_pointer(),
        _UniffiConverterTypeConnectionMode.lower(mode))
        )





    def limits(self, limits: "RelayLimits") -> "RelayOptions":
        """
        Set custom limits
        """

        _UniffiConverterTypeRelayLimits.check_lower(limits)
        
        return _UniffiConverterTypeRelayOptions.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relayoptions_limits,self._uniffi_clone_pointer(),
        _UniffiConverterTypeRelayLimits.lower(limits))
        )





    def max_avg_latency(self, max: "typing.Optional[Duration]") -> "RelayOptions":
        """
        Set max latency (default: None)

        Relay with an avg. latency greater that this value will be skipped.
        """

        _UniffiConverterOptionalDuration.check_lower(max)
        
        return _UniffiConverterTypeRelayOptions.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relayoptions_max_avg_latency,self._uniffi_clone_pointer(),
        _UniffiConverterOptionalDuration.lower(max))
        )





    def ping(self, ping: "bool") -> "RelayOptions":
        """
        Set ping flag
        """

        _UniffiConverterBool.check_lower(ping)
        
        return _UniffiConverterTypeRelayOptions.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relayoptions_ping,self._uniffi_clone_pointer(),
        _UniffiConverterBool.lower(ping))
        )





    def read(self, read: "bool") -> "RelayOptions":
        """
        Set read flag
        """

        _UniffiConverterBool.check_lower(read)
        
        return _UniffiConverterTypeRelayOptions.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relayoptions_read,self._uniffi_clone_pointer(),
        _UniffiConverterBool.lower(read))
        )





    def reconnect(self, reconnect: "bool") -> "RelayOptions":
        """
        Enable/disable auto reconnection (default: true)
        """

        _UniffiConverterBool.check_lower(reconnect)
        
        return _UniffiConverterTypeRelayOptions.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relayoptions_reconnect,self._uniffi_clone_pointer(),
        _UniffiConverterBool.lower(reconnect))
        )





    def retry_interval(self, interval: "Duration") -> "RelayOptions":
        """
        Retry interval (default: 10 sec)

        Minimum allowed value is `5 secs`
        """

        _UniffiConverterDuration.check_lower(interval)
        
        return _UniffiConverterTypeRelayOptions.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relayoptions_retry_interval,self._uniffi_clone_pointer(),
        _UniffiConverterDuration.lower(interval))
        )





    def verify_subscriptions(self, enable: "bool") -> "RelayOptions":
        """
        Verify that received events belong to a subscription and match the filter.
        """

        _UniffiConverterBool.check_lower(enable)
        
        return _UniffiConverterTypeRelayOptions.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relayoptions_verify_subscriptions,self._uniffi_clone_pointer(),
        _UniffiConverterBool.lower(enable))
        )





    def write(self, write: "bool") -> "RelayOptions":
        """
        Set write flag
        """

        _UniffiConverterBool.check_lower(write)
        
        return _UniffiConverterTypeRelayOptions.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relayoptions_write,self._uniffi_clone_pointer(),
        _UniffiConverterBool.lower(write))
        )






class _UniffiConverterTypeRelayOptions:

    @staticmethod
    def lift(value: int):
        return RelayOptions._make_instance_(value)

    @staticmethod
    def check_lower(value: RelayOptions):
        if not isinstance(value, RelayOptions):
            raise TypeError("Expected RelayOptions instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: RelayOptionsProtocol):
        if not isinstance(value, RelayOptions):
            raise TypeError("Expected RelayOptions instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: RelayOptionsProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class RelayUrlProtocol(typing.Protocol):
    def is_local_addr(self, ):
        """
        Check if the host is a local network address.

        IPv4 address ranges:
        - `127.0.0.0/8`
        - `10.0.0.0/8`
        - `172.16.0.0/12`
        - `192.168.0.0/16`

        IPv6 address ranges:
        - `::1`
        """

        raise NotImplementedError
    def is_onion(self, ):
        """
        Check if the URL is a hidden onion service address
        """

        raise NotImplementedError
# RelayUrl is a Rust-only trait - it's a wrapper around a Rust implementation.
class RelayUrl():
    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_relayurl, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_relayurl, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst
    @classmethod
    def parse(cls, url: "str"):
        """
        Parse a relay URL
        """

        _UniffiConverterString.check_lower(url)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeNostrSdkError,_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_relayurl_parse,
        _UniffiConverterString.lower(url))
        return cls._make_instance_(pointer)



    def is_local_addr(self, ) -> "bool":
        """
        Check if the host is a local network address.

        IPv4 address ranges:
        - `127.0.0.0/8`
        - `10.0.0.0/8`
        - `172.16.0.0/12`
        - `192.168.0.0/16`

        IPv6 address ranges:
        - `::1`
        """

        return _UniffiConverterBool.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relayurl_is_local_addr,self._uniffi_clone_pointer(),)
        )





    def is_onion(self, ) -> "bool":
        """
        Check if the URL is a hidden onion service address
        """

        return _UniffiConverterBool.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relayurl_is_onion,self._uniffi_clone_pointer(),)
        )





    def __repr__(self, ) -> "str":
        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relayurl_uniffi_trait_debug,self._uniffi_clone_pointer(),)
        )





    def __str__(self, ) -> "str":
        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relayurl_uniffi_trait_display,self._uniffi_clone_pointer(),)
        )



    def __eq__(self, other: object) -> bool:
        if not isinstance(other, RelayUrl):
            return NotImplemented

        return _UniffiConverterBool.lift(_uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relayurl_uniffi_trait_eq_eq,self._uniffi_clone_pointer(),
        _UniffiConverterTypeRelayUrl.lower(other)))

    def __ne__(self, other: object) -> bool:
        if not isinstance(other, RelayUrl):
            return NotImplemented

        return _UniffiConverterBool.lift(_uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relayurl_uniffi_trait_eq_ne,self._uniffi_clone_pointer(),
        _UniffiConverterTypeRelayUrl.lower(other)))


    def __hash__(self, ) -> "int":
        return _UniffiConverterUInt64.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_relayurl_uniffi_trait_hash,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeRelayUrl:

    @staticmethod
    def lift(value: int):
        return RelayUrl._make_instance_(value)

    @staticmethod
    def check_lower(value: RelayUrl):
        if not isinstance(value, RelayUrl):
            raise TypeError("Expected RelayUrl instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: RelayUrlProtocol):
        if not isinstance(value, RelayUrl):
            raise TypeError("Expected RelayUrl instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: RelayUrlProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class RequestProtocol(typing.Protocol):
    """
    NIP47 Request
    """

    def method(self, ):
        raise NotImplementedError
    def params(self, ):
        raise NotImplementedError
# Request is a Rust-only trait - it's a wrapper around a Rust implementation.
class Request():
    """
    NIP47 Request
    """

    _pointer: ctypes.c_void_p
    def __init__(self, method: "Method",params: "RequestParams"):
        _UniffiConverterTypeMethod.check_lower(method)
        
        _UniffiConverterTypeRequestParams.check_lower(params)
        
        self._pointer = _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_request_new,
        _UniffiConverterTypeMethod.lower(method),
        _UniffiConverterTypeRequestParams.lower(params))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_request, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_request, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst
    @classmethod
    def parse(cls, json: "str"):
        _UniffiConverterString.check_lower(json)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeNostrSdkError,_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_request_parse,
        _UniffiConverterString.lower(json))
        return cls._make_instance_(pointer)



    def method(self, ) -> "Method":
        return _UniffiConverterTypeMethod.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_request_method,self._uniffi_clone_pointer(),)
        )





    def params(self, ) -> "RequestParams":
        return _UniffiConverterTypeRequestParams.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_request_params,self._uniffi_clone_pointer(),)
        )





    def __repr__(self, ) -> "str":
        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_request_uniffi_trait_debug,self._uniffi_clone_pointer(),)
        )



    def __eq__(self, other: object) -> bool:
        if not isinstance(other, Request):
            return NotImplemented

        return _UniffiConverterBool.lift(_uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_request_uniffi_trait_eq_eq,self._uniffi_clone_pointer(),
        _UniffiConverterTypeRequest.lower(other)))

    def __ne__(self, other: object) -> bool:
        if not isinstance(other, Request):
            return NotImplemented

        return _UniffiConverterBool.lift(_uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_request_uniffi_trait_eq_ne,self._uniffi_clone_pointer(),
        _UniffiConverterTypeRequest.lower(other)))


    def __hash__(self, ) -> "int":
        return _UniffiConverterUInt64.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_request_uniffi_trait_hash,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeRequest:

    @staticmethod
    def lift(value: int):
        return Request._make_instance_(value)

    @staticmethod
    def check_lower(value: Request):
        if not isinstance(value, Request):
            raise TypeError("Expected Request instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: RequestProtocol):
        if not isinstance(value, Request):
            raise TypeError("Expected Request instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: RequestProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class ResponseProtocol(typing.Protocol):
    """
    NIP47 Response
    """

    pass
# Response is a Rust-only trait - it's a wrapper around a Rust implementation.
class Response():
    """
    NIP47 Response
    """

    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_response, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_response, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def __repr__(self, ) -> "str":
        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_response_uniffi_trait_debug,self._uniffi_clone_pointer(),)
        )



    def __eq__(self, other: object) -> bool:
        if not isinstance(other, Response):
            return NotImplemented

        return _UniffiConverterBool.lift(_uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_response_uniffi_trait_eq_eq,self._uniffi_clone_pointer(),
        _UniffiConverterTypeResponse.lower(other)))

    def __ne__(self, other: object) -> bool:
        if not isinstance(other, Response):
            return NotImplemented

        return _UniffiConverterBool.lift(_uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_response_uniffi_trait_eq_ne,self._uniffi_clone_pointer(),
        _UniffiConverterTypeResponse.lower(other)))



class _UniffiConverterTypeResponse:

    @staticmethod
    def lift(value: int):
        return Response._make_instance_(value)

    @staticmethod
    def check_lower(value: Response):
        if not isinstance(value, Response):
            raise TypeError("Expected Response instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: ResponseProtocol):
        if not isinstance(value, Response):
            raise TypeError("Expected Response instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: ResponseProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class SaveEventStatusProtocol(typing.Protocol):
    """
    Save event status
    """

    def is_success(self, ):
        """
        The event has been successfully saved
        """

        raise NotImplementedError
    def rejection_reason(self, ):
        """
        Get rejection reason, if the event wasn't saved successfully
        """

        raise NotImplementedError
# SaveEventStatus is a Rust-only trait - it's a wrapper around a Rust implementation.
class SaveEventStatus():
    """
    Save event status
    """

    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_saveeventstatus, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_saveeventstatus, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst
    @classmethod
    def rejected(cls, reason: "RejectedReason"):
        _UniffiConverterTypeRejectedReason.check_lower(reason)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_saveeventstatus_rejected,
        _UniffiConverterTypeRejectedReason.lower(reason))
        return cls._make_instance_(pointer)

    @classmethod
    def success(cls, ):
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_saveeventstatus_success,)
        return cls._make_instance_(pointer)



    def is_success(self, ) -> "bool":
        """
        The event has been successfully saved
        """

        return _UniffiConverterBool.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_saveeventstatus_is_success,self._uniffi_clone_pointer(),)
        )





    def rejection_reason(self, ) -> "typing.Optional[RejectedReason]":
        """
        Get rejection reason, if the event wasn't saved successfully
        """

        return _UniffiConverterOptionalTypeRejectedReason.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_saveeventstatus_rejection_reason,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeSaveEventStatus:

    @staticmethod
    def lift(value: int):
        return SaveEventStatus._make_instance_(value)

    @staticmethod
    def check_lower(value: SaveEventStatus):
        if not isinstance(value, SaveEventStatus):
            raise TypeError("Expected SaveEventStatus instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: SaveEventStatusProtocol):
        if not isinstance(value, SaveEventStatus):
            raise TypeError("Expected SaveEventStatus instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: SaveEventStatusProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class SecretKeyProtocol(typing.Protocol):
    def encrypt(self, password: "str"):
        """
        Encrypt `SecretKey`

        By default, `LOG_N` is set to `16` and `KeySecurity` to `Unknown`.
        To use custom values check `EncryptedSecretKey` constructor.
        """

        raise NotImplementedError
    def to_bech32(self, ):
        raise NotImplementedError
    def to_hex(self, ):
        raise NotImplementedError
# SecretKey is a Rust-only trait - it's a wrapper around a Rust implementation.
class SecretKey():
    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_secretkey, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_secretkey, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst
    @classmethod
    def from_bytes(cls, bytes: "bytes"):
        _UniffiConverterBytes.check_lower(bytes)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeNostrSdkError,_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_secretkey_from_bytes,
        _UniffiConverterBytes.lower(bytes))
        return cls._make_instance_(pointer)

    @classmethod
    def generate(cls, ):
        """
        Generate random secret key
        """

        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_secretkey_generate,)
        return cls._make_instance_(pointer)

    @classmethod
    def parse(cls, secret_key: "str"):
        """
        Try to parse secret key from `hex` or `bech32`
        """

        _UniffiConverterString.check_lower(secret_key)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeNostrSdkError,_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_secretkey_parse,
        _UniffiConverterString.lower(secret_key))
        return cls._make_instance_(pointer)



    def encrypt(self, password: "str") -> "EncryptedSecretKey":
        """
        Encrypt `SecretKey`

        By default, `LOG_N` is set to `16` and `KeySecurity` to `Unknown`.
        To use custom values check `EncryptedSecretKey` constructor.
        """

        _UniffiConverterString.check_lower(password)
        
        return _UniffiConverterTypeEncryptedSecretKey.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeNostrSdkError,_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_secretkey_encrypt,self._uniffi_clone_pointer(),
        _UniffiConverterString.lower(password))
        )





    def to_bech32(self, ) -> "str":
        return _UniffiConverterString.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeNostrSdkError,_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_secretkey_to_bech32,self._uniffi_clone_pointer(),)
        )





    def to_hex(self, ) -> "str":
        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_secretkey_to_hex,self._uniffi_clone_pointer(),)
        )





    def __repr__(self, ) -> "str":
        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_secretkey_uniffi_trait_debug,self._uniffi_clone_pointer(),)
        )



    def __eq__(self, other: object) -> bool:
        if not isinstance(other, SecretKey):
            return NotImplemented

        return _UniffiConverterBool.lift(_uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_secretkey_uniffi_trait_eq_eq,self._uniffi_clone_pointer(),
        _UniffiConverterTypeSecretKey.lower(other)))

    def __ne__(self, other: object) -> bool:
        if not isinstance(other, SecretKey):
            return NotImplemented

        return _UniffiConverterBool.lift(_uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_secretkey_uniffi_trait_eq_ne,self._uniffi_clone_pointer(),
        _UniffiConverterTypeSecretKey.lower(other)))



class _UniffiConverterTypeSecretKey:

    @staticmethod
    def lift(value: int):
        return SecretKey._make_instance_(value)

    @staticmethod
    def check_lower(value: SecretKey):
        if not isinstance(value, SecretKey):
            raise TypeError("Expected SecretKey instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: SecretKeyProtocol):
        if not isinstance(value, SecretKey):
            raise TypeError("Expected SecretKey instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: SecretKeyProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class ShippingMethodProtocol(typing.Protocol):
    def get_shipping_cost(self, ):
        """
        Get the product shipping cost of the shipping method
        """

        raise NotImplementedError
    def name(self, name: "str"):
        """
        Set the name of the shipping method
        """

        raise NotImplementedError
    def regions(self, regions: "typing.List[str]"):
        """
        Add a region to the shipping method
        """

        raise NotImplementedError
# ShippingMethod is a Rust-only trait - it's a wrapper around a Rust implementation.
class ShippingMethod():
    _pointer: ctypes.c_void_p
    def __init__(self, id: "str",cost: "float"):
        """
        Create a new shipping method
        """

        _UniffiConverterString.check_lower(id)
        
        _UniffiConverterDouble.check_lower(cost)
        
        self._pointer = _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_shippingmethod_new,
        _UniffiConverterString.lower(id),
        _UniffiConverterDouble.lower(cost))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_shippingmethod, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_shippingmethod, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def get_shipping_cost(self, ) -> "ShippingCost":
        """
        Get the product shipping cost of the shipping method
        """

        return _UniffiConverterTypeShippingCost.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_shippingmethod_get_shipping_cost,self._uniffi_clone_pointer(),)
        )





    def name(self, name: "str") -> "ShippingMethod":
        """
        Set the name of the shipping method
        """

        _UniffiConverterString.check_lower(name)
        
        return _UniffiConverterTypeShippingMethod.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_shippingmethod_name,self._uniffi_clone_pointer(),
        _UniffiConverterString.lower(name))
        )





    def regions(self, regions: "typing.List[str]") -> "ShippingMethod":
        """
        Add a region to the shipping method
        """

        _UniffiConverterSequenceString.check_lower(regions)
        
        return _UniffiConverterTypeShippingMethod.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_shippingmethod_regions,self._uniffi_clone_pointer(),
        _UniffiConverterSequenceString.lower(regions))
        )






class _UniffiConverterTypeShippingMethod:

    @staticmethod
    def lift(value: int):
        return ShippingMethod._make_instance_(value)

    @staticmethod
    def check_lower(value: ShippingMethod):
        if not isinstance(value, ShippingMethod):
            raise TypeError("Expected ShippingMethod instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: ShippingMethodProtocol):
        if not isinstance(value, ShippingMethod):
            raise TypeError("Expected ShippingMethod instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: ShippingMethodProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class SingleLetterTagProtocol(typing.Protocol):
    def is_lowercase(self, ):
        raise NotImplementedError
    def is_uppercase(self, ):
        raise NotImplementedError
# SingleLetterTag is a Rust-only trait - it's a wrapper around a Rust implementation.
class SingleLetterTag():
    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_singlelettertag, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_singlelettertag, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst
    @classmethod
    def lowercase(cls, character: "Alphabet"):
        _UniffiConverterTypeAlphabet.check_lower(character)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_singlelettertag_lowercase,
        _UniffiConverterTypeAlphabet.lower(character))
        return cls._make_instance_(pointer)

    @classmethod
    def uppercase(cls, character: "Alphabet"):
        _UniffiConverterTypeAlphabet.check_lower(character)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_singlelettertag_uppercase,
        _UniffiConverterTypeAlphabet.lower(character))
        return cls._make_instance_(pointer)



    def is_lowercase(self, ) -> "bool":
        return _UniffiConverterBool.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_singlelettertag_is_lowercase,self._uniffi_clone_pointer(),)
        )





    def is_uppercase(self, ) -> "bool":
        return _UniffiConverterBool.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_singlelettertag_is_uppercase,self._uniffi_clone_pointer(),)
        )





    def __repr__(self, ) -> "str":
        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_singlelettertag_uniffi_trait_debug,self._uniffi_clone_pointer(),)
        )



    def __eq__(self, other: object) -> bool:
        if not isinstance(other, SingleLetterTag):
            return NotImplemented

        return _UniffiConverterBool.lift(_uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_singlelettertag_uniffi_trait_eq_eq,self._uniffi_clone_pointer(),
        _UniffiConverterTypeSingleLetterTag.lower(other)))

    def __ne__(self, other: object) -> bool:
        if not isinstance(other, SingleLetterTag):
            return NotImplemented

        return _UniffiConverterBool.lift(_uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_singlelettertag_uniffi_trait_eq_ne,self._uniffi_clone_pointer(),
        _UniffiConverterTypeSingleLetterTag.lower(other)))


    def __hash__(self, ) -> "int":
        return _UniffiConverterUInt64.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_singlelettertag_uniffi_trait_hash,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeSingleLetterTag:

    @staticmethod
    def lift(value: int):
        return SingleLetterTag._make_instance_(value)

    @staticmethod
    def check_lower(value: SingleLetterTag):
        if not isinstance(value, SingleLetterTag):
            raise TypeError("Expected SingleLetterTag instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: SingleLetterTagProtocol):
        if not isinstance(value, SingleLetterTag):
            raise TypeError("Expected SingleLetterTag instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: SingleLetterTagProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class StallDataProtocol(typing.Protocol):
    def as_json(self, ):
        raise NotImplementedError
    def as_record(self, ):
        raise NotImplementedError
    def currency(self, ):
        raise NotImplementedError
    def description(self, ):
        raise NotImplementedError
    def id(self, ):
        raise NotImplementedError
    def name(self, ):
        raise NotImplementedError
    def shipping(self, ):
        raise NotImplementedError
# StallData is a Rust-only trait - it's a wrapper around a Rust implementation.
class StallData():
    _pointer: ctypes.c_void_p
    def __init__(self, id: "str",name: "str",description: "typing.Optional[str]",currency: "str",shipping: "typing.List[ShippingMethod]"):
        _UniffiConverterString.check_lower(id)
        
        _UniffiConverterString.check_lower(name)
        
        _UniffiConverterOptionalString.check_lower(description)
        
        _UniffiConverterString.check_lower(currency)
        
        _UniffiConverterSequenceTypeShippingMethod.check_lower(shipping)
        
        self._pointer = _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_stalldata_new,
        _UniffiConverterString.lower(id),
        _UniffiConverterString.lower(name),
        _UniffiConverterOptionalString.lower(description),
        _UniffiConverterString.lower(currency),
        _UniffiConverterSequenceTypeShippingMethod.lower(shipping))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_stalldata, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_stalldata, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst
    @classmethod
    def from_json(cls, json: "str"):
        _UniffiConverterString.check_lower(json)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeNostrSdkError,_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_stalldata_from_json,
        _UniffiConverterString.lower(json))
        return cls._make_instance_(pointer)

    @classmethod
    def from_record(cls, r: "StallDataRecord"):
        _UniffiConverterTypeStallDataRecord.check_lower(r)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_stalldata_from_record,
        _UniffiConverterTypeStallDataRecord.lower(r))
        return cls._make_instance_(pointer)



    def as_json(self, ) -> "str":
        return _UniffiConverterString.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeNostrSdkError,_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_stalldata_as_json,self._uniffi_clone_pointer(),)
        )





    def as_record(self, ) -> "StallDataRecord":
        return _UniffiConverterTypeStallDataRecord.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_stalldata_as_record,self._uniffi_clone_pointer(),)
        )





    def currency(self, ) -> "str":
        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_stalldata_currency,self._uniffi_clone_pointer(),)
        )





    def description(self, ) -> "typing.Optional[str]":
        return _UniffiConverterOptionalString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_stalldata_description,self._uniffi_clone_pointer(),)
        )





    def id(self, ) -> "str":
        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_stalldata_id,self._uniffi_clone_pointer(),)
        )





    def name(self, ) -> "str":
        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_stalldata_name,self._uniffi_clone_pointer(),)
        )





    def shipping(self, ) -> "typing.List[ShippingMethod]":
        return _UniffiConverterSequenceTypeShippingMethod.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_stalldata_shipping,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeStallData:

    @staticmethod
    def lift(value: int):
        return StallData._make_instance_(value)

    @staticmethod
    def check_lower(value: StallData):
        if not isinstance(value, StallData):
            raise TypeError("Expected StallData instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: StallDataProtocol):
        if not isinstance(value, StallData):
            raise TypeError("Expected StallData instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: StallDataProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class SubscribeAutoCloseOptionsProtocol(typing.Protocol):
    """
    Auto-closing subscribe options
    """

    def exit_policy(self, policy: "ReqExitPolicy"):
        """
        Close subscription when the policy is satisfied
        """

        raise NotImplementedError
    def idle_timeout(self, timeout: "typing.Optional[Duration]"):
        """
        Automatically close subscription if no notifications/events are received within the duration.
        """

        raise NotImplementedError
    def timeout(self, timeout: "typing.Optional[Duration]"):
        """
        Automatically close subscription after duration.
        """

        raise NotImplementedError
# SubscribeAutoCloseOptions is a Rust-only trait - it's a wrapper around a Rust implementation.
class SubscribeAutoCloseOptions():
    """
    Auto-closing subscribe options
    """

    _pointer: ctypes.c_void_p
    def __init__(self, ):
        self._pointer = _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_subscribeautocloseoptions_new,)

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_subscribeautocloseoptions, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_subscribeautocloseoptions, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def exit_policy(self, policy: "ReqExitPolicy") -> "SubscribeAutoCloseOptions":
        """
        Close subscription when the policy is satisfied
        """

        _UniffiConverterTypeReqExitPolicy.check_lower(policy)
        
        return _UniffiConverterTypeSubscribeAutoCloseOptions.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_subscribeautocloseoptions_exit_policy,self._uniffi_clone_pointer(),
        _UniffiConverterTypeReqExitPolicy.lower(policy))
        )





    def idle_timeout(self, timeout: "typing.Optional[Duration]") -> "SubscribeAutoCloseOptions":
        """
        Automatically close subscription if no notifications/events are received within the duration.
        """

        _UniffiConverterOptionalDuration.check_lower(timeout)
        
        return _UniffiConverterTypeSubscribeAutoCloseOptions.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_subscribeautocloseoptions_idle_timeout,self._uniffi_clone_pointer(),
        _UniffiConverterOptionalDuration.lower(timeout))
        )





    def timeout(self, timeout: "typing.Optional[Duration]") -> "SubscribeAutoCloseOptions":
        """
        Automatically close subscription after duration.
        """

        _UniffiConverterOptionalDuration.check_lower(timeout)
        
        return _UniffiConverterTypeSubscribeAutoCloseOptions.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_subscribeautocloseoptions_timeout,self._uniffi_clone_pointer(),
        _UniffiConverterOptionalDuration.lower(timeout))
        )






class _UniffiConverterTypeSubscribeAutoCloseOptions:

    @staticmethod
    def lift(value: int):
        return SubscribeAutoCloseOptions._make_instance_(value)

    @staticmethod
    def check_lower(value: SubscribeAutoCloseOptions):
        if not isinstance(value, SubscribeAutoCloseOptions):
            raise TypeError("Expected SubscribeAutoCloseOptions instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: SubscribeAutoCloseOptionsProtocol):
        if not isinstance(value, SubscribeAutoCloseOptions):
            raise TypeError("Expected SubscribeAutoCloseOptions instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: SubscribeAutoCloseOptionsProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class SubscribeOptionsProtocol(typing.Protocol):
    """
    Subscribe options
    """

    def close_on(self, opts: "SubscribeAutoCloseOptions"):
        """
        Set auto-close conditions
        """

        raise NotImplementedError
# SubscribeOptions is a Rust-only trait - it's a wrapper around a Rust implementation.
class SubscribeOptions():
    """
    Subscribe options
    """

    _pointer: ctypes.c_void_p
    def __init__(self, ):
        self._pointer = _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_subscribeoptions_new,)

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_subscribeoptions, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_subscribeoptions, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def close_on(self, opts: "SubscribeAutoCloseOptions") -> "SubscribeOptions":
        """
        Set auto-close conditions
        """

        _UniffiConverterTypeSubscribeAutoCloseOptions.check_lower(opts)
        
        return _UniffiConverterTypeSubscribeOptions.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_subscribeoptions_close_on,self._uniffi_clone_pointer(),
        _UniffiConverterTypeSubscribeAutoCloseOptions.lower(opts))
        )






class _UniffiConverterTypeSubscribeOptions:

    @staticmethod
    def lift(value: int):
        return SubscribeOptions._make_instance_(value)

    @staticmethod
    def check_lower(value: SubscribeOptions):
        if not isinstance(value, SubscribeOptions):
            raise TypeError("Expected SubscribeOptions instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: SubscribeOptionsProtocol):
        if not isinstance(value, SubscribeOptions):
            raise TypeError("Expected SubscribeOptions instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: SubscribeOptionsProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class SyncOptionsProtocol(typing.Protocol):
    def direction(self, direction: "SyncDirection"):
        """
        Sync Sync direction (default: down)
        """

        raise NotImplementedError
    def dry_run(self, ):
        """
        Dry run

        Just check what event are missing: execute reconciliation but WITHOUT
        getting/sending full events.
        """

        raise NotImplementedError
    def initial_timeout(self, timeout: "Duration"):
        """
        Timeout to check if negentropy it's supported (default: 10 secs)
        """

        raise NotImplementedError
# SyncOptions is a Rust-only trait - it's a wrapper around a Rust implementation.
class SyncOptions():
    _pointer: ctypes.c_void_p
    def __init__(self, ):
        """
        New default options
        """

        self._pointer = _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_syncoptions_new,)

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_syncoptions, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_syncoptions, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def direction(self, direction: "SyncDirection") -> "SyncOptions":
        """
        Sync Sync direction (default: down)
        """

        _UniffiConverterTypeSyncDirection.check_lower(direction)
        
        return _UniffiConverterTypeSyncOptions.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_syncoptions_direction,self._uniffi_clone_pointer(),
        _UniffiConverterTypeSyncDirection.lower(direction))
        )





    def dry_run(self, ) -> "SyncOptions":
        """
        Dry run

        Just check what event are missing: execute reconciliation but WITHOUT
        getting/sending full events.
        """

        return _UniffiConverterTypeSyncOptions.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_syncoptions_dry_run,self._uniffi_clone_pointer(),)
        )





    def initial_timeout(self, timeout: "Duration") -> "SyncOptions":
        """
        Timeout to check if negentropy it's supported (default: 10 secs)
        """

        _UniffiConverterDuration.check_lower(timeout)
        
        return _UniffiConverterTypeSyncOptions.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_syncoptions_initial_timeout,self._uniffi_clone_pointer(),
        _UniffiConverterDuration.lower(timeout))
        )






class _UniffiConverterTypeSyncOptions:

    @staticmethod
    def lift(value: int):
        return SyncOptions._make_instance_(value)

    @staticmethod
    def check_lower(value: SyncOptions):
        if not isinstance(value, SyncOptions):
            raise TypeError("Expected SyncOptions instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: SyncOptionsProtocol):
        if not isinstance(value, SyncOptions):
            raise TypeError("Expected SyncOptions instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: SyncOptionsProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class TagProtocol(typing.Protocol):
    """
    Tag
    """

    def as_standardized(self, ):
        """
        Get standardized tag
        """

        raise NotImplementedError
    def as_vec(self, ):
        """
        Get array of strings
        """

        raise NotImplementedError
    def content(self, ):
        """
        Return the **first** tag value (index `1`), if exists.
        """

        raise NotImplementedError
    def is_protected(self, ):
        """
        Check if it's a protected event tag

        <https://github.com/nostr-protocol/nips/blob/master/70.md>
        """

        raise NotImplementedError
    def is_reply(self, ):
        """
        Check if is a standard event tag with `reply` marker
        """

        raise NotImplementedError
    def is_root(self, ):
        """
        Check if is a standard event tag with `root` marker
        """

        raise NotImplementedError
    def kind(self, ):
        """
        Get tag kind
        """

        raise NotImplementedError
    def kind_str(self, ):
        """
        Get tag kind as string
        """

        raise NotImplementedError
    def len(self, ):
        """
        Get tag len
        """

        raise NotImplementedError
    def single_letter_tag(self, ):
        """
        Get `SingleLetterTag`
        """

        raise NotImplementedError
# Tag is a Rust-only trait - it's a wrapper around a Rust implementation.
class Tag():
    """
    Tag
    """

    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_tag, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_tag, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst
    @classmethod
    def alt(cls, summary: "str"):
        """
        A short human-readable plaintext summary of what that event is about

        JSON: `["alt", "<summary>"]`

        <https://github.com/nostr-protocol/nips/blob/master/31.md>
        """

        _UniffiConverterString.check_lower(summary)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_tag_alt,
        _UniffiConverterString.lower(summary))
        return cls._make_instance_(pointer)

    @classmethod
    def client(cls, name: "str"):
        """
        Construct `["client", "<name>"]` tag

        <https://github.com/nostr-protocol/nips/blob/master/89.md>
        """

        _UniffiConverterString.check_lower(name)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_tag_client,
        _UniffiConverterString.lower(name))
        return cls._make_instance_(pointer)

    @classmethod
    def coordinate(cls, coordinate: "Coordinate",relay_url: "typing.Union[object, typing.Optional[RelayUrl]]" = _DEFAULT):
        """
        Compose `["a", "<coordinate>"]` tag

        <https://github.com/nostr-protocol/nips/blob/master/01.md>
        """

        _UniffiConverterTypeCoordinate.check_lower(coordinate)
        
        if relay_url is _DEFAULT:
            relay_url = None
        _UniffiConverterOptionalTypeRelayUrl.check_lower(relay_url)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_tag_coordinate,
        _UniffiConverterTypeCoordinate.lower(coordinate),
        _UniffiConverterOptionalTypeRelayUrl.lower(relay_url))
        return cls._make_instance_(pointer)

    @classmethod
    def custom(cls, kind: "TagKind",values: "typing.List[str]"):
        """
        Compose custom tag

        JSON: `["<kind>", "<value-1>", "<value-2>", ...]`
        """

        _UniffiConverterTypeTagKind.check_lower(kind)
        
        _UniffiConverterSequenceString.check_lower(values)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_tag_custom,
        _UniffiConverterTypeTagKind.lower(kind),
        _UniffiConverterSequenceString.lower(values))
        return cls._make_instance_(pointer)

    @classmethod
    def description(cls, description: "str"):
        """
        Compose `["description", "<description>"]` tag
        """

        _UniffiConverterString.check_lower(description)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_tag_description,
        _UniffiConverterString.lower(description))
        return cls._make_instance_(pointer)

    @classmethod
    def event(cls, event_id: "EventId"):
        """
        Compose `["e", "<event-id">]`

        <https://github.com/nostr-protocol/nips/blob/master/01.md>
        """

        _UniffiConverterTypeEventId.check_lower(event_id)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_tag_event,
        _UniffiConverterTypeEventId.lower(event_id))
        return cls._make_instance_(pointer)

    @classmethod
    def event_report(cls, event_id: "EventId",report: "Report"):
        """
        Compose `["e", "<event-id>", "<report>"]` tag

        <https://github.com/nostr-protocol/nips/blob/master/56.md>
        """

        _UniffiConverterTypeEventId.check_lower(event_id)
        
        _UniffiConverterTypeReport.check_lower(report)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_tag_event_report,
        _UniffiConverterTypeEventId.lower(event_id),
        _UniffiConverterTypeReport.lower(report))
        return cls._make_instance_(pointer)

    @classmethod
    def expiration(cls, timestamp: "Timestamp"):
        """
        Compose `["expiration", "<timestamp>"]` tag

        <https://github.com/nostr-protocol/nips/blob/master/40.md>
        """

        _UniffiConverterTypeTimestamp.check_lower(timestamp)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_tag_expiration,
        _UniffiConverterTypeTimestamp.lower(timestamp))
        return cls._make_instance_(pointer)

    @classmethod
    def from_standardized(cls, standardized: "TagStandard"):
        """
        Construct from standardized tag
        """

        _UniffiConverterTypeTagStandard.check_lower(standardized)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeNostrSdkError,_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_tag_from_standardized,
        _UniffiConverterTypeTagStandard.lower(standardized))
        return cls._make_instance_(pointer)

    @classmethod
    def hashtag(cls, hashtag: "str"):
        """
        Compose `["t", "<hashtag>"]` tag

        This will convert the hashtag to lowercase.
        """

        _UniffiConverterString.check_lower(hashtag)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_tag_hashtag,
        _UniffiConverterString.lower(hashtag))
        return cls._make_instance_(pointer)

    @classmethod
    def identifier(cls, identifier: "str"):
        """
        Compose `["d", "<identifier>"]` tag

        <https://github.com/nostr-protocol/nips/blob/master/01.md>
        """

        _UniffiConverterString.check_lower(identifier)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_tag_identifier,
        _UniffiConverterString.lower(identifier))
        return cls._make_instance_(pointer)

    @classmethod
    def image(cls, url: "str",dimensions: "typing.Union[object, typing.Optional[ImageDimensions]]" = _DEFAULT):
        """
        Compose image tag
        """

        _UniffiConverterString.check_lower(url)
        
        if dimensions is _DEFAULT:
            dimensions = None
        _UniffiConverterOptionalTypeImageDimensions.check_lower(dimensions)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeNostrSdkError,_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_tag_image,
        _UniffiConverterString.lower(url),
        _UniffiConverterOptionalTypeImageDimensions.lower(dimensions))
        return cls._make_instance_(pointer)

    @classmethod
    def parse(cls, data: "typing.List[str]"):
        """
        Parse tag

        Return error if the tag is empty!
        """

        _UniffiConverterSequenceString.check_lower(data)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeNostrSdkError,_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_tag_parse,
        _UniffiConverterSequenceString.lower(data))
        return cls._make_instance_(pointer)

    @classmethod
    def pow(cls, nonce: "int",difficulty: "int"):
        """
        Compose `["nonce", "<nonce>", "<difficulty>"]` tag

        <https://github.com/nostr-protocol/nips/blob/master/13.md>
        """

        _UniffiConverterUInt64.check_lower(nonce)
        
        _UniffiConverterUInt8.check_lower(difficulty)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_tag_pow,
        _UniffiConverterUInt64.lower(nonce),
        _UniffiConverterUInt8.lower(difficulty))
        return cls._make_instance_(pointer)

    @classmethod
    def protected(cls, ):
        """
        Protected event

        JSON: `["-"]`

        <https://github.com/nostr-protocol/nips/blob/master/70.md>
        """

        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_tag_protected,)
        return cls._make_instance_(pointer)

    @classmethod
    def public_key(cls, public_key: "PublicKey"):
        """
        Compose `["p", "<public-key>"]` tag

        <https://github.com/nostr-protocol/nips/blob/master/01.md>
        """

        _UniffiConverterTypePublicKey.check_lower(public_key)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_tag_public_key,
        _UniffiConverterTypePublicKey.lower(public_key))
        return cls._make_instance_(pointer)

    @classmethod
    def public_key_report(cls, public_key: "PublicKey",report: "Report"):
        """
        Compose `["p", "<public-key>", "<report>"]` tag

        <https://github.com/nostr-protocol/nips/blob/master/56.md>
        """

        _UniffiConverterTypePublicKey.check_lower(public_key)
        
        _UniffiConverterTypeReport.check_lower(report)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_tag_public_key_report,
        _UniffiConverterTypePublicKey.lower(public_key),
        _UniffiConverterTypeReport.lower(report))
        return cls._make_instance_(pointer)

    @classmethod
    def reference(cls, reference: "str"):
        """
        Compose `["r", "<value>"]` tag
        """

        _UniffiConverterString.check_lower(reference)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_tag_reference,
        _UniffiConverterString.lower(reference))
        return cls._make_instance_(pointer)

    @classmethod
    def relay_metadata(cls, relay_url: "RelayUrl",metadata: "typing.Optional[RelayMetadata]"):
        """
        Compose `["r", "<relay-url>", "<metadata>"]` tag

        <https://github.com/nostr-protocol/nips/blob/master/65.md>
        """

        _UniffiConverterTypeRelayUrl.check_lower(relay_url)
        
        _UniffiConverterOptionalTypeRelayMetadata.check_lower(metadata)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeNostrSdkError,_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_tag_relay_metadata,
        _UniffiConverterTypeRelayUrl.lower(relay_url),
        _UniffiConverterOptionalTypeRelayMetadata.lower(metadata))
        return cls._make_instance_(pointer)

    @classmethod
    def title(cls, title: "str"):
        """
        Compose `["title", "<title>"]` tag
        """

        _UniffiConverterString.check_lower(title)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_tag_title,
        _UniffiConverterString.lower(title))
        return cls._make_instance_(pointer)



    def as_standardized(self, ) -> "typing.Optional[TagStandard]":
        """
        Get standardized tag
        """

        return _UniffiConverterOptionalTypeTagStandard.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_tag_as_standardized,self._uniffi_clone_pointer(),)
        )





    def as_vec(self, ) -> "typing.List[str]":
        """
        Get array of strings
        """

        return _UniffiConverterSequenceString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_tag_as_vec,self._uniffi_clone_pointer(),)
        )





    def content(self, ) -> "typing.Optional[str]":
        """
        Return the **first** tag value (index `1`), if exists.
        """

        return _UniffiConverterOptionalString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_tag_content,self._uniffi_clone_pointer(),)
        )





    def is_protected(self, ) -> "bool":
        """
        Check if it's a protected event tag

        <https://github.com/nostr-protocol/nips/blob/master/70.md>
        """

        return _UniffiConverterBool.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_tag_is_protected,self._uniffi_clone_pointer(),)
        )





    def is_reply(self, ) -> "bool":
        """
        Check if is a standard event tag with `reply` marker
        """

        return _UniffiConverterBool.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_tag_is_reply,self._uniffi_clone_pointer(),)
        )





    def is_root(self, ) -> "bool":
        """
        Check if is a standard event tag with `root` marker
        """

        return _UniffiConverterBool.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_tag_is_root,self._uniffi_clone_pointer(),)
        )





    def kind(self, ) -> "TagKind":
        """
        Get tag kind
        """

        return _UniffiConverterTypeTagKind.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_tag_kind,self._uniffi_clone_pointer(),)
        )





    def kind_str(self, ) -> "str":
        """
        Get tag kind as string
        """

        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_tag_kind_str,self._uniffi_clone_pointer(),)
        )





    def len(self, ) -> "int":
        """
        Get tag len
        """

        return _UniffiConverterUInt64.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_tag_len,self._uniffi_clone_pointer(),)
        )





    def single_letter_tag(self, ) -> "typing.Optional[SingleLetterTag]":
        """
        Get `SingleLetterTag`
        """

        return _UniffiConverterOptionalTypeSingleLetterTag.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_tag_single_letter_tag,self._uniffi_clone_pointer(),)
        )





    def __repr__(self, ) -> "str":
        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_tag_uniffi_trait_debug,self._uniffi_clone_pointer(),)
        )



    def __eq__(self, other: object) -> bool:
        if not isinstance(other, Tag):
            return NotImplemented

        return _UniffiConverterBool.lift(_uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_tag_uniffi_trait_eq_eq,self._uniffi_clone_pointer(),
        _UniffiConverterTypeTag.lower(other)))

    def __ne__(self, other: object) -> bool:
        if not isinstance(other, Tag):
            return NotImplemented

        return _UniffiConverterBool.lift(_uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_tag_uniffi_trait_eq_ne,self._uniffi_clone_pointer(),
        _UniffiConverterTypeTag.lower(other)))


    def __hash__(self, ) -> "int":
        return _UniffiConverterUInt64.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_tag_uniffi_trait_hash,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeTag:

    @staticmethod
    def lift(value: int):
        return Tag._make_instance_(value)

    @staticmethod
    def check_lower(value: Tag):
        if not isinstance(value, Tag):
            raise TypeError("Expected Tag instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: TagProtocol):
        if not isinstance(value, Tag):
            raise TypeError("Expected Tag instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: TagProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class TagsProtocol(typing.Protocol):
    def coordinates(self, ):
        """
        Extract coordinates from `a` tags.

        This method extract ONLY supported standard variants
        """

        raise NotImplementedError
    def event_ids(self, ):
        """
        Extract event IDs from `e` tags.

        This method extract ONLY supported standard variants
        """

        raise NotImplementedError
    def expiration(self, ):
        """
        Get timestamp expiration, if set
        """

        raise NotImplementedError
    def filter(self, kind: "TagKind"):
        """
        Get first tag that match `TagKind`.
        """

        raise NotImplementedError
    def filter_standardized(self, kind: "TagKind"):
        """
        Get first tag that match `TagKind` and that is standardized.
        """

        raise NotImplementedError
    def find(self, kind: "TagKind"):
        """
        /// Get first tag that match `TagKind`.
        """

        raise NotImplementedError
    def find_standardized(self, kind: "TagKind"):
        """
        Get first tag that match `TagKind` and that is standardized.
        """

        raise NotImplementedError
    def first(self, ):
        """
        Get first tag
        """

        raise NotImplementedError
    def get(self, index: "int"):
        """
        Get tag at index
        """

        raise NotImplementedError
    def hashtags(self, ):
        """
        Extract hashtags from `t` tags.

        This method extract ONLY supported standard variants
        """

        raise NotImplementedError
    def identifier(self, ):
        """
        Extract identifier (`d` tag), if exists.
        """

        raise NotImplementedError
    def is_empty(self, ):
        """
        Check if contains no tags.
        """

        raise NotImplementedError
    def last(self, ):
        """
        Get last tag
        """

        raise NotImplementedError
    def len(self, ):
        """
        Get number of tags
        """

        raise NotImplementedError
    def public_keys(self, ):
        """
        Extract public keys from `p` tags.

        This method extract ONLY supported standard variants
        """

        raise NotImplementedError
    def to_vec(self, ):
        raise NotImplementedError
# Tags is a Rust-only trait - it's a wrapper around a Rust implementation.
class Tags():
    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_tags, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_tags, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst
    @classmethod
    def from_list(cls, list: "typing.List[Tag]"):
        _UniffiConverterSequenceTypeTag.check_lower(list)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_tags_from_list,
        _UniffiConverterSequenceTypeTag.lower(list))
        return cls._make_instance_(pointer)

    @classmethod
    def parse(cls, tags: "typing.List[typing.List[str]]"):
        _UniffiConverterSequenceSequenceString.check_lower(tags)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeNostrSdkError,_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_tags_parse,
        _UniffiConverterSequenceSequenceString.lower(tags))
        return cls._make_instance_(pointer)



    def coordinates(self, ) -> "typing.List[Coordinate]":
        """
        Extract coordinates from `a` tags.

        This method extract ONLY supported standard variants
        """

        return _UniffiConverterSequenceTypeCoordinate.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_tags_coordinates,self._uniffi_clone_pointer(),)
        )





    def event_ids(self, ) -> "typing.List[EventId]":
        """
        Extract event IDs from `e` tags.

        This method extract ONLY supported standard variants
        """

        return _UniffiConverterSequenceTypeEventId.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_tags_event_ids,self._uniffi_clone_pointer(),)
        )





    def expiration(self, ) -> "typing.Optional[Timestamp]":
        """
        Get timestamp expiration, if set
        """

        return _UniffiConverterOptionalTypeTimestamp.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_tags_expiration,self._uniffi_clone_pointer(),)
        )





    def filter(self, kind: "TagKind") -> "typing.List[Tag]":
        """
        Get first tag that match `TagKind`.
        """

        _UniffiConverterTypeTagKind.check_lower(kind)
        
        return _UniffiConverterSequenceTypeTag.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_tags_filter,self._uniffi_clone_pointer(),
        _UniffiConverterTypeTagKind.lower(kind))
        )





    def filter_standardized(self, kind: "TagKind") -> "typing.List[TagStandard]":
        """
        Get first tag that match `TagKind` and that is standardized.
        """

        _UniffiConverterTypeTagKind.check_lower(kind)
        
        return _UniffiConverterSequenceTypeTagStandard.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_tags_filter_standardized,self._uniffi_clone_pointer(),
        _UniffiConverterTypeTagKind.lower(kind))
        )





    def find(self, kind: "TagKind") -> "typing.Optional[Tag]":
        """
        /// Get first tag that match `TagKind`.
        """

        _UniffiConverterTypeTagKind.check_lower(kind)
        
        return _UniffiConverterOptionalTypeTag.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_tags_find,self._uniffi_clone_pointer(),
        _UniffiConverterTypeTagKind.lower(kind))
        )





    def find_standardized(self, kind: "TagKind") -> "typing.Optional[TagStandard]":
        """
        Get first tag that match `TagKind` and that is standardized.
        """

        _UniffiConverterTypeTagKind.check_lower(kind)
        
        return _UniffiConverterOptionalTypeTagStandard.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_tags_find_standardized,self._uniffi_clone_pointer(),
        _UniffiConverterTypeTagKind.lower(kind))
        )





    def first(self, ) -> "typing.Optional[Tag]":
        """
        Get first tag
        """

        return _UniffiConverterOptionalTypeTag.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_tags_first,self._uniffi_clone_pointer(),)
        )





    def get(self, index: "int") -> "typing.Optional[Tag]":
        """
        Get tag at index
        """

        _UniffiConverterUInt64.check_lower(index)
        
        return _UniffiConverterOptionalTypeTag.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_tags_get,self._uniffi_clone_pointer(),
        _UniffiConverterUInt64.lower(index))
        )





    def hashtags(self, ) -> "typing.List[str]":
        """
        Extract hashtags from `t` tags.

        This method extract ONLY supported standard variants
        """

        return _UniffiConverterSequenceString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_tags_hashtags,self._uniffi_clone_pointer(),)
        )





    def identifier(self, ) -> "typing.Optional[str]":
        """
        Extract identifier (`d` tag), if exists.
        """

        return _UniffiConverterOptionalString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_tags_identifier,self._uniffi_clone_pointer(),)
        )





    def is_empty(self, ) -> "bool":
        """
        Check if contains no tags.
        """

        return _UniffiConverterBool.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_tags_is_empty,self._uniffi_clone_pointer(),)
        )





    def last(self, ) -> "typing.Optional[Tag]":
        """
        Get last tag
        """

        return _UniffiConverterOptionalTypeTag.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_tags_last,self._uniffi_clone_pointer(),)
        )





    def len(self, ) -> "int":
        """
        Get number of tags
        """

        return _UniffiConverterUInt64.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_tags_len,self._uniffi_clone_pointer(),)
        )





    def public_keys(self, ) -> "typing.List[PublicKey]":
        """
        Extract public keys from `p` tags.

        This method extract ONLY supported standard variants
        """

        return _UniffiConverterSequenceTypePublicKey.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_tags_public_keys,self._uniffi_clone_pointer(),)
        )





    def to_vec(self, ) -> "typing.List[Tag]":
        return _UniffiConverterSequenceTypeTag.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_tags_to_vec,self._uniffi_clone_pointer(),)
        )





    def __repr__(self, ) -> "str":
        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_tags_uniffi_trait_debug,self._uniffi_clone_pointer(),)
        )



    def __eq__(self, other: object) -> bool:
        if not isinstance(other, Tags):
            return NotImplemented

        return _UniffiConverterBool.lift(_uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_tags_uniffi_trait_eq_eq,self._uniffi_clone_pointer(),
        _UniffiConverterTypeTags.lower(other)))

    def __ne__(self, other: object) -> bool:
        if not isinstance(other, Tags):
            return NotImplemented

        return _UniffiConverterBool.lift(_uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_tags_uniffi_trait_eq_ne,self._uniffi_clone_pointer(),
        _UniffiConverterTypeTags.lower(other)))


    def __hash__(self, ) -> "int":
        return _UniffiConverterUInt64.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_tags_uniffi_trait_hash,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeTags:

    @staticmethod
    def lift(value: int):
        return Tags._make_instance_(value)

    @staticmethod
    def check_lower(value: Tags):
        if not isinstance(value, Tags):
            raise TypeError("Expected Tags instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: TagsProtocol):
        if not isinstance(value, Tags):
            raise TypeError("Expected Tags instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: TagsProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class TimestampProtocol(typing.Protocol):
    def add_duration(self, duration: "Duration"):
        """
        Add duration to timestamp

        This sums the duration to the current timestamp and returns a new timestamp.
        """

        raise NotImplementedError
    def as_secs(self, ):
        """
        Get timestamp as [`u64`]
        """

        raise NotImplementedError
    def sub_duration(self, duration: "Duration"):
        """
        Subtract duration from timestamp

        This subtracts the duration from the current timestamp and returns a new timestamp.
        """

        raise NotImplementedError
    def to_human_datetime(self, ):
        """
        Convert [`Timestamp`] to human datetime
        """

        raise NotImplementedError
# Timestamp is a Rust-only trait - it's a wrapper around a Rust implementation.
class Timestamp():
    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_timestamp, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_timestamp, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst
    @classmethod
    def from_secs(cls, secs: "int"):
        _UniffiConverterUInt64.check_lower(secs)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_timestamp_from_secs,
        _UniffiConverterUInt64.lower(secs))
        return cls._make_instance_(pointer)

    @classmethod
    def max(cls, ):
        """
        The maximum representable timestamp
        """

        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_timestamp_max,)
        return cls._make_instance_(pointer)

    @classmethod
    def min(cls, ):
        """
        The minimum representable timestamp
        """

        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_timestamp_min,)
        return cls._make_instance_(pointer)

    @classmethod
    def now(cls, ):
        """
        Get UNIX timestamp
        """

        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_timestamp_now,)
        return cls._make_instance_(pointer)



    def add_duration(self, duration: "Duration") -> "Timestamp":
        """
        Add duration to timestamp

        This sums the duration to the current timestamp and returns a new timestamp.
        """

        _UniffiConverterDuration.check_lower(duration)
        
        return _UniffiConverterTypeTimestamp.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_timestamp_add_duration,self._uniffi_clone_pointer(),
        _UniffiConverterDuration.lower(duration))
        )





    def as_secs(self, ) -> "int":
        """
        Get timestamp as [`u64`]
        """

        return _UniffiConverterUInt64.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_timestamp_as_secs,self._uniffi_clone_pointer(),)
        )





    def sub_duration(self, duration: "Duration") -> "Timestamp":
        """
        Subtract duration from timestamp

        This subtracts the duration from the current timestamp and returns a new timestamp.
        """

        _UniffiConverterDuration.check_lower(duration)
        
        return _UniffiConverterTypeTimestamp.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_timestamp_sub_duration,self._uniffi_clone_pointer(),
        _UniffiConverterDuration.lower(duration))
        )





    def to_human_datetime(self, ) -> "str":
        """
        Convert [`Timestamp`] to human datetime
        """

        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_timestamp_to_human_datetime,self._uniffi_clone_pointer(),)
        )





    def __repr__(self, ) -> "str":
        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_timestamp_uniffi_trait_debug,self._uniffi_clone_pointer(),)
        )



    def __eq__(self, other: object) -> bool:
        if not isinstance(other, Timestamp):
            return NotImplemented

        return _UniffiConverterBool.lift(_uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_timestamp_uniffi_trait_eq_eq,self._uniffi_clone_pointer(),
        _UniffiConverterTypeTimestamp.lower(other)))

    def __ne__(self, other: object) -> bool:
        if not isinstance(other, Timestamp):
            return NotImplemented

        return _UniffiConverterBool.lift(_uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_timestamp_uniffi_trait_eq_ne,self._uniffi_clone_pointer(),
        _UniffiConverterTypeTimestamp.lower(other)))


    def __hash__(self, ) -> "int":
        return _UniffiConverterUInt64.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_timestamp_uniffi_trait_hash,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeTimestamp:

    @staticmethod
    def lift(value: int):
        return Timestamp._make_instance_(value)

    @staticmethod
    def check_lower(value: Timestamp):
        if not isinstance(value, Timestamp):
            raise TypeError("Expected Timestamp instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: TimestampProtocol):
        if not isinstance(value, Timestamp):
            raise TypeError("Expected Timestamp instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: TimestampProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class UnsignedEventProtocol(typing.Protocol):
    def add_signature(self, sig: "str"):
        """
        Add signature to unsigned event

        Internally verify the event.
        """

        raise NotImplementedError
    def as_json(self, ):
        raise NotImplementedError
    def as_pretty_json(self, ):
        raise NotImplementedError
    def author(self, ):
        raise NotImplementedError
    def content(self, ):
        raise NotImplementedError
    def created_at(self, ):
        raise NotImplementedError
    def id(self, ):
        raise NotImplementedError
    def kind(self, ):
        raise NotImplementedError
    def sign(self, signer: "NostrSigner"):
        """
        Sign an unsigned event
        """

        raise NotImplementedError
    def sign_with_keys(self, keys: "Keys"):
        """
        Sign an unsigned event with keys signer

        Internally: calculate event ID (if not set), sign it, compose and verify event.
        """

        raise NotImplementedError
    def tags(self, ):
        raise NotImplementedError
# UnsignedEvent is a Rust-only trait - it's a wrapper around a Rust implementation.
class UnsignedEvent():
    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_unsignedevent, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_unsignedevent, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst
    @classmethod
    def from_json(cls, json: "str"):
        _UniffiConverterString.check_lower(json)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeNostrSdkError,_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_unsignedevent_from_json,
        _UniffiConverterString.lower(json))
        return cls._make_instance_(pointer)



    def add_signature(self, sig: "str") -> "Event":
        """
        Add signature to unsigned event

        Internally verify the event.
        """

        _UniffiConverterString.check_lower(sig)
        
        return _UniffiConverterTypeEvent.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeNostrSdkError,_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_unsignedevent_add_signature,self._uniffi_clone_pointer(),
        _UniffiConverterString.lower(sig))
        )





    def as_json(self, ) -> "str":
        return _UniffiConverterString.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeNostrSdkError,_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_unsignedevent_as_json,self._uniffi_clone_pointer(),)
        )





    def as_pretty_json(self, ) -> "str":
        return _UniffiConverterString.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeNostrSdkError,_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_unsignedevent_as_pretty_json,self._uniffi_clone_pointer(),)
        )





    def author(self, ) -> "PublicKey":
        return _UniffiConverterTypePublicKey.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_unsignedevent_author,self._uniffi_clone_pointer(),)
        )





    def content(self, ) -> "str":
        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_unsignedevent_content,self._uniffi_clone_pointer(),)
        )





    def created_at(self, ) -> "Timestamp":
        return _UniffiConverterTypeTimestamp.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_unsignedevent_created_at,self._uniffi_clone_pointer(),)
        )





    def id(self, ) -> "typing.Optional[EventId]":
        return _UniffiConverterOptionalTypeEventId.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_unsignedevent_id,self._uniffi_clone_pointer(),)
        )





    def kind(self, ) -> "Kind":
        return _UniffiConverterTypeKind.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_unsignedevent_kind,self._uniffi_clone_pointer(),)
        )




    async def sign(self, signer: "NostrSigner") -> "Event":
        """
        Sign an unsigned event
        """

        _UniffiConverterTypeNostrSigner.check_lower(signer)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_nostr_sdk_ffi_fn_method_unsignedevent_sign(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeNostrSigner.lower(signer)
            ),
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_poll_pointer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_complete_pointer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_free_pointer,
            # lift function
            _UniffiConverterTypeEvent.lift,
            
    # Error FFI converter
_UniffiConverterTypeNostrSdkError,

        )




    def sign_with_keys(self, keys: "Keys") -> "Event":
        """
        Sign an unsigned event with keys signer

        Internally: calculate event ID (if not set), sign it, compose and verify event.
        """

        _UniffiConverterTypeKeys.check_lower(keys)
        
        return _UniffiConverterTypeEvent.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeNostrSdkError,_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_unsignedevent_sign_with_keys,self._uniffi_clone_pointer(),
        _UniffiConverterTypeKeys.lower(keys))
        )





    def tags(self, ) -> "Tags":
        return _UniffiConverterTypeTags.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_unsignedevent_tags,self._uniffi_clone_pointer(),)
        )





    def __repr__(self, ) -> "str":
        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_unsignedevent_uniffi_trait_debug,self._uniffi_clone_pointer(),)
        )



    def __eq__(self, other: object) -> bool:
        if not isinstance(other, UnsignedEvent):
            return NotImplemented

        return _UniffiConverterBool.lift(_uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_unsignedevent_uniffi_trait_eq_eq,self._uniffi_clone_pointer(),
        _UniffiConverterTypeUnsignedEvent.lower(other)))

    def __ne__(self, other: object) -> bool:
        if not isinstance(other, UnsignedEvent):
            return NotImplemented

        return _UniffiConverterBool.lift(_uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_unsignedevent_uniffi_trait_eq_ne,self._uniffi_clone_pointer(),
        _UniffiConverterTypeUnsignedEvent.lower(other)))


    def __hash__(self, ) -> "int":
        return _UniffiConverterUInt64.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_unsignedevent_uniffi_trait_hash,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeUnsignedEvent:

    @staticmethod
    def lift(value: int):
        return UnsignedEvent._make_instance_(value)

    @staticmethod
    def check_lower(value: UnsignedEvent):
        if not isinstance(value, UnsignedEvent):
            raise TypeError("Expected UnsignedEvent instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: UnsignedEventProtocol):
        if not isinstance(value, UnsignedEvent):
            raise TypeError("Expected UnsignedEvent instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: UnsignedEventProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class UnwrappedGiftProtocol(typing.Protocol):
    """
    Unwrapped Gift Wrap

    <https://github.com/nostr-protocol/nips/blob/master/59.md>
    """

    def none(self, ):
        raise NotImplementedError
    def rumor(self, ):
        """
        Get rumor
        """

        raise NotImplementedError
    def sender(self, ):
        """
        Get sender public key
        """

        raise NotImplementedError
# UnwrappedGift is a Rust-only trait - it's a wrapper around a Rust implementation.
class UnwrappedGift():
    """
    Unwrapped Gift Wrap

    <https://github.com/nostr-protocol/nips/blob/master/59.md>
    """

    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_unwrappedgift, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_unwrappedgift, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst
    @classmethod
    async def from_gift_wrap(cls, signer: "NostrSigner",gift_wrap: "Event"):
        """
        Unwrap Gift Wrap event

        Internally verify the `seal` event
        """

        _UniffiConverterTypeNostrSigner.check_lower(signer)
        
        _UniffiConverterTypeEvent.check_lower(gift_wrap)
        

        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_unwrappedgift_from_gift_wrap(
        _UniffiConverterTypeNostrSigner.lower(signer),
        _UniffiConverterTypeEvent.lower(gift_wrap)),
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_poll_pointer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_complete_pointer,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_free_pointer,
            _UniffiConverterTypeUnwrappedGift.lift,
            
    # Error FFI converter
_UniffiConverterTypeNostrSdkError,

        )


    async def none(self, ) -> None:

        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_nostr_sdk_ffi_fn_method_unwrappedgift__none(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_poll_void,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_complete_void,
            _UniffiLib.ffi_nostr_sdk_ffi_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter

    None,

        )




    def rumor(self, ) -> "UnsignedEvent":
        """
        Get rumor
        """

        return _UniffiConverterTypeUnsignedEvent.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_unwrappedgift_rumor,self._uniffi_clone_pointer(),)
        )





    def sender(self, ) -> "PublicKey":
        """
        Get sender public key
        """

        return _UniffiConverterTypePublicKey.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_unwrappedgift_sender,self._uniffi_clone_pointer(),)
        )





    def __repr__(self, ) -> "str":
        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_unwrappedgift_uniffi_trait_debug,self._uniffi_clone_pointer(),)
        )



    def __eq__(self, other: object) -> bool:
        if not isinstance(other, UnwrappedGift):
            return NotImplemented

        return _UniffiConverterBool.lift(_uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_unwrappedgift_uniffi_trait_eq_eq,self._uniffi_clone_pointer(),
        _UniffiConverterTypeUnwrappedGift.lower(other)))

    def __ne__(self, other: object) -> bool:
        if not isinstance(other, UnwrappedGift):
            return NotImplemented

        return _UniffiConverterBool.lift(_uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_unwrappedgift_uniffi_trait_eq_ne,self._uniffi_clone_pointer(),
        _UniffiConverterTypeUnwrappedGift.lower(other)))


    def __hash__(self, ) -> "int":
        return _UniffiConverterUInt64.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_unwrappedgift_uniffi_trait_hash,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeUnwrappedGift:

    @staticmethod
    def lift(value: int):
        return UnwrappedGift._make_instance_(value)

    @staticmethod
    def check_lower(value: UnwrappedGift):
        if not isinstance(value, UnwrappedGift):
            raise TypeError("Expected UnwrappedGift instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: UnwrappedGiftProtocol):
        if not isinstance(value, UnwrappedGift):
            raise TypeError("Expected UnwrappedGift instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: UnwrappedGiftProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class WebSocketAdapterWrapperProtocol(typing.Protocol):
    pass
# WebSocketAdapterWrapper is a Rust-only trait - it's a wrapper around a Rust implementation.
class WebSocketAdapterWrapper():
    _pointer: ctypes.c_void_p
    def __init__(self, adapter: "WebSocketAdapter"):
        _UniffiConverterTypeWebSocketAdapter.check_lower(adapter)
        
        self._pointer = _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_websocketadapterwrapper_new,
        _UniffiConverterTypeWebSocketAdapter.lower(adapter))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_websocketadapterwrapper, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_websocketadapterwrapper, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst



class _UniffiConverterTypeWebSocketAdapterWrapper:

    @staticmethod
    def lift(value: int):
        return WebSocketAdapterWrapper._make_instance_(value)

    @staticmethod
    def check_lower(value: WebSocketAdapterWrapper):
        if not isinstance(value, WebSocketAdapterWrapper):
            raise TypeError("Expected WebSocketAdapterWrapper instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: WebSocketAdapterWrapperProtocol):
        if not isinstance(value, WebSocketAdapterWrapper):
            raise TypeError("Expected WebSocketAdapterWrapper instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: WebSocketAdapterWrapperProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class ZapRequestDataProtocol(typing.Protocol):
    def amount(self, amount: "int"):
        raise NotImplementedError
    def event_id(self, event_id: "EventId"):
        raise NotImplementedError
    def lnurl(self, lnurl: "str"):
        raise NotImplementedError
    def message(self, message: "str"):
        raise NotImplementedError
# ZapRequestData is a Rust-only trait - it's a wrapper around a Rust implementation.
class ZapRequestData():
    _pointer: ctypes.c_void_p
    def __init__(self, public_key: "PublicKey",relays: "typing.List[RelayUrl]"):
        _UniffiConverterTypePublicKey.check_lower(public_key)
        
        _UniffiConverterSequenceTypeRelayUrl.check_lower(relays)
        
        self._pointer = _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_constructor_zaprequestdata_new,
        _UniffiConverterTypePublicKey.lower(public_key),
        _UniffiConverterSequenceTypeRelayUrl.lower(relays))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_free_zaprequestdata, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_clone_zaprequestdata, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def amount(self, amount: "int") -> "ZapRequestData":
        _UniffiConverterUInt64.check_lower(amount)
        
        return _UniffiConverterTypeZapRequestData.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_zaprequestdata_amount,self._uniffi_clone_pointer(),
        _UniffiConverterUInt64.lower(amount))
        )





    def event_id(self, event_id: "EventId") -> "ZapRequestData":
        _UniffiConverterTypeEventId.check_lower(event_id)
        
        return _UniffiConverterTypeZapRequestData.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_zaprequestdata_event_id,self._uniffi_clone_pointer(),
        _UniffiConverterTypeEventId.lower(event_id))
        )





    def lnurl(self, lnurl: "str") -> "ZapRequestData":
        _UniffiConverterString.check_lower(lnurl)
        
        return _UniffiConverterTypeZapRequestData.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_zaprequestdata_lnurl,self._uniffi_clone_pointer(),
        _UniffiConverterString.lower(lnurl))
        )





    def message(self, message: "str") -> "ZapRequestData":
        _UniffiConverterString.check_lower(message)
        
        return _UniffiConverterTypeZapRequestData.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_zaprequestdata_message,self._uniffi_clone_pointer(),
        _UniffiConverterString.lower(message))
        )





    def __repr__(self, ) -> "str":
        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_zaprequestdata_uniffi_trait_debug,self._uniffi_clone_pointer(),)
        )



    def __eq__(self, other: object) -> bool:
        if not isinstance(other, ZapRequestData):
            return NotImplemented

        return _UniffiConverterBool.lift(_uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_zaprequestdata_uniffi_trait_eq_eq,self._uniffi_clone_pointer(),
        _UniffiConverterTypeZapRequestData.lower(other)))

    def __ne__(self, other: object) -> bool:
        if not isinstance(other, ZapRequestData):
            return NotImplemented

        return _UniffiConverterBool.lift(_uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_zaprequestdata_uniffi_trait_eq_ne,self._uniffi_clone_pointer(),
        _UniffiConverterTypeZapRequestData.lower(other)))


    def __hash__(self, ) -> "int":
        return _UniffiConverterUInt64.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_method_zaprequestdata_uniffi_trait_hash,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeZapRequestData:

    @staticmethod
    def lift(value: int):
        return ZapRequestData._make_instance_(value)

    @staticmethod
    def check_lower(value: ZapRequestData):
        if not isinstance(value, ZapRequestData):
            raise TypeError("Expected ZapRequestData instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: ZapRequestDataProtocol):
        if not isinstance(value, ZapRequestData):
            raise TypeError("Expected ZapRequestData instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: ZapRequestDataProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))

# Async support# RustFuturePoll values
_UNIFFI_RUST_FUTURE_POLL_READY = 0
_UNIFFI_RUST_FUTURE_POLL_MAYBE_READY = 1

# Stores futures for _uniffi_continuation_callback
_UniffiContinuationHandleMap = _UniffiHandleMap()

_UNIFFI_GLOBAL_EVENT_LOOP = None

"""
Set the event loop to use for async functions

This is needed if some async functions run outside of the eventloop, for example:
    - A non-eventloop thread is spawned, maybe from `EventLoop.run_in_executor` or maybe from the
      Rust code spawning its own thread.
    - The Rust code calls an async callback method from a sync callback function, using something
      like `pollster` to block on the async call.

In this case, we need an event loop to run the Python async function, but there's no eventloop set
for the thread.  Use `uniffi_set_event_loop` to force an eventloop to be used in this case.
"""
def uniffi_set_event_loop(eventloop: asyncio.BaseEventLoop):
    global _UNIFFI_GLOBAL_EVENT_LOOP
    _UNIFFI_GLOBAL_EVENT_LOOP = eventloop

def _uniffi_get_event_loop():
    if _UNIFFI_GLOBAL_EVENT_LOOP is not None:
        return _UNIFFI_GLOBAL_EVENT_LOOP
    else:
        return asyncio.get_running_loop()

# Continuation callback for async functions
# lift the return value or error and resolve the future, causing the async function to resume.
@_UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK
def _uniffi_continuation_callback(future_ptr, poll_code):
    (eventloop, future) = _UniffiContinuationHandleMap.remove(future_ptr)
    eventloop.call_soon_threadsafe(_uniffi_set_future_result, future, poll_code)

def _uniffi_set_future_result(future, poll_code):
    if not future.cancelled():
        future.set_result(poll_code)

async def _uniffi_rust_call_async(rust_future, ffi_poll, ffi_complete, ffi_free, lift_func, error_ffi_converter):
    try:
        eventloop = _uniffi_get_event_loop()

        # Loop and poll until we see a _UNIFFI_RUST_FUTURE_POLL_READY value
        while True:
            future = eventloop.create_future()
            ffi_poll(
                rust_future,
                _uniffi_continuation_callback,
                _UniffiContinuationHandleMap.insert((eventloop, future)),
            )
            poll_code = await future
            if poll_code == _UNIFFI_RUST_FUTURE_POLL_READY:
                break

        return lift_func(
            _uniffi_rust_call_with_error(error_ffi_converter, ffi_complete, rust_future)
        )
    finally:
        ffi_free(rust_future)
def _uniffi_trait_interface_call_async(make_call, handle_success, handle_error):
    async def make_call_and_call_callback():
        try:
            handle_success(await make_call())
        except Exception as e:
            print("UniFFI: Unhandled exception in trait interface call", file=sys.stderr)
            traceback.print_exc(file=sys.stderr)
            handle_error(
                _UniffiRustCallStatus.CALL_UNEXPECTED_ERROR,
                _UniffiConverterString.lower(repr(e)),
            )
    eventloop = _uniffi_get_event_loop()
    task = asyncio.run_coroutine_threadsafe(make_call_and_call_callback(), eventloop)
    handle = _UNIFFI_FOREIGN_FUTURE_HANDLE_MAP.insert((eventloop, task))
    return _UniffiForeignFuture(handle, _uniffi_foreign_future_free)

def _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, error_type, lower_error):
    async def make_call_and_call_callback():
        try:
            try:
                handle_success(await make_call())
            except error_type as e:
                handle_error(
                    _UniffiRustCallStatus.CALL_ERROR,
                    lower_error(e),
                )
        except Exception as e:
            print("UniFFI: Unhandled exception in trait interface call", file=sys.stderr)
            traceback.print_exc(file=sys.stderr)
            handle_error(
                _UniffiRustCallStatus.CALL_UNEXPECTED_ERROR,
                _UniffiConverterString.lower(repr(e)),
            )
    eventloop = _uniffi_get_event_loop()
    task = asyncio.run_coroutine_threadsafe(make_call_and_call_callback(), eventloop)
    handle = _UNIFFI_FOREIGN_FUTURE_HANDLE_MAP.insert((eventloop, task))
    return _UniffiForeignFuture(handle, _uniffi_foreign_future_free)

_UNIFFI_FOREIGN_FUTURE_HANDLE_MAP = _UniffiHandleMap()

@_UNIFFI_FOREIGN_FUTURE_FREE
def _uniffi_foreign_future_free(handle):
    (eventloop, task) = _UNIFFI_FOREIGN_FUTURE_HANDLE_MAP.remove(handle)
    eventloop.call_soon(_uniffi_foreign_future_do_free, task)

def _uniffi_foreign_future_do_free(task):
    if not task.done():
        task.cancel()

def decrypt_received_private_zap_message(secret_key: "SecretKey",private_zap: "Event") -> "Event":
    _UniffiConverterTypeSecretKey.check_lower(secret_key)
    
    _UniffiConverterTypeEvent.check_lower(private_zap)
    
    return _UniffiConverterTypeEvent.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeNostrSdkError,_UniffiLib.uniffi_nostr_sdk_ffi_fn_func_decrypt_received_private_zap_message,
        _UniffiConverterTypeSecretKey.lower(secret_key),
        _UniffiConverterTypeEvent.lower(private_zap)))


def decrypt_sent_private_zap_message(secret_key: "SecretKey",public_key: "PublicKey",private_zap: "Event") -> "Event":
    _UniffiConverterTypeSecretKey.check_lower(secret_key)
    
    _UniffiConverterTypePublicKey.check_lower(public_key)
    
    _UniffiConverterTypeEvent.check_lower(private_zap)
    
    return _UniffiConverterTypeEvent.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeNostrSdkError,_UniffiLib.uniffi_nostr_sdk_ffi_fn_func_decrypt_sent_private_zap_message,
        _UniffiConverterTypeSecretKey.lower(secret_key),
        _UniffiConverterTypePublicKey.lower(public_key),
        _UniffiConverterTypeEvent.lower(private_zap)))


def extract_relay_list(event: "Event") -> "dict[RelayUrl, typing.Optional[RelayMetadata]]":
    """
    Extracts the relay info (url, optional read/write flag) from the event
    """

    _UniffiConverterTypeEvent.check_lower(event)
    
    return _UniffiConverterMapTypeRelayUrlOptionalTypeRelayMetadata.lift(_uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_func_extract_relay_list,
        _UniffiConverterTypeEvent.lower(event)))


def generate_shared_key(secret_key: "SecretKey",public_key: "PublicKey") -> "bytes":
    """
    Generate shared key

    **Important: use of a strong cryptographic hash function may be critical to security! Do NOT use
    unless you understand cryptographical implications.**
    """

    _UniffiConverterTypeSecretKey.check_lower(secret_key)
    
    _UniffiConverterTypePublicKey.check_lower(public_key)
    
    return _UniffiConverterBytes.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeNostrSdkError,_UniffiLib.uniffi_nostr_sdk_ffi_fn_func_generate_shared_key,
        _UniffiConverterTypeSecretKey.lower(secret_key),
        _UniffiConverterTypePublicKey.lower(public_key)))


def get_leading_zero_bits(bytes: "bytes") -> "int":
    """
    Gets the number of leading zero bits. Result is between 0 and 255.
    """

    _UniffiConverterBytes.check_lower(bytes)
    
    return _UniffiConverterUInt8.lift(_uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_func_get_leading_zero_bits,
        _UniffiConverterBytes.lower(bytes)))


def get_prefixes_for_difficulty(leading_zero_bits: "int") -> "typing.List[str]":
    """
    Returns all possible ID prefixes (hex) that have the specified number of leading zero bits.

    Possible values: 0-255
    """

    _UniffiConverterUInt8.check_lower(leading_zero_bits)
    
    return _UniffiConverterSequenceString.lift(_uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_func_get_prefixes_for_difficulty,
        _UniffiConverterUInt8.lower(leading_zero_bits)))

async def gift_wrap(signer: "NostrSigner",receiver_pubkey: "PublicKey",rumor: "UnsignedEvent",extra_tags: "typing.Union[object, typing.List[Tag]]" = _DEFAULT) -> "Event":

    """
    Build Gift Wrap

    <https://github.com/nostr-protocol/nips/blob/master/59.md>
    """

    _UniffiConverterTypeNostrSigner.check_lower(signer)
    
    _UniffiConverterTypePublicKey.check_lower(receiver_pubkey)
    
    _UniffiConverterTypeUnsignedEvent.check_lower(rumor)
    
    if extra_tags is _DEFAULT:
        extra_tags = []
    _UniffiConverterSequenceTypeTag.check_lower(extra_tags)
    
    return await _uniffi_rust_call_async(
        _UniffiLib.uniffi_nostr_sdk_ffi_fn_func_gift_wrap(
        _UniffiConverterTypeNostrSigner.lower(signer),
        _UniffiConverterTypePublicKey.lower(receiver_pubkey),
        _UniffiConverterTypeUnsignedEvent.lower(rumor),
        _UniffiConverterSequenceTypeTag.lower(extra_tags)),
        _UniffiLib.ffi_nostr_sdk_ffi_rust_future_poll_pointer,
        _UniffiLib.ffi_nostr_sdk_ffi_rust_future_complete_pointer,
        _UniffiLib.ffi_nostr_sdk_ffi_rust_future_free_pointer,
        # lift function
        _UniffiConverterTypeEvent.lift,
        
    # Error FFI converter
_UniffiConverterTypeNostrSdkError,

    )

def gift_wrap_from_seal(receiver: "PublicKey",seal: "Event",extra_tags: "typing.Union[object, typing.List[Tag]]" = _DEFAULT) -> "Event":
    """
    Build Gift Wrap from Seal

    <https://github.com/nostr-protocol/nips/blob/master/59.md>
    """

    _UniffiConverterTypePublicKey.check_lower(receiver)
    
    _UniffiConverterTypeEvent.check_lower(seal)
    
    if extra_tags is _DEFAULT:
        extra_tags = []
    _UniffiConverterSequenceTypeTag.check_lower(extra_tags)
    
    return _UniffiConverterTypeEvent.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeNostrSdkError,_UniffiLib.uniffi_nostr_sdk_ffi_fn_func_gift_wrap_from_seal,
        _UniffiConverterTypePublicKey.lower(receiver),
        _UniffiConverterTypeEvent.lower(seal),
        _UniffiConverterSequenceTypeTag.lower(extra_tags)))


def git_hash_version() -> "typing.Optional[str]":
    """
    Get git hash version of `rust-nostr` libraries
    """

    return _UniffiConverterOptionalString.lift(_uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_func_git_hash_version,))


def init_logger(level: "LogLevel") -> None:
    _UniffiConverterTypeLogLevel.check_lower(level)
    
    _uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_func_init_logger,
        _UniffiConverterTypeLogLevel.lower(level))

async def make_private_msg(signer: "NostrSigner",receiver: "PublicKey",message: "str",rumor_extra_tags: "typing.Union[object, typing.List[Tag]]" = _DEFAULT) -> "Event":

    """
    Private Direct message

    <https://github.com/nostr-protocol/nips/blob/master/17.md>
    """

    _UniffiConverterTypeNostrSigner.check_lower(signer)
    
    _UniffiConverterTypePublicKey.check_lower(receiver)
    
    _UniffiConverterString.check_lower(message)
    
    if rumor_extra_tags is _DEFAULT:
        rumor_extra_tags = []
    _UniffiConverterSequenceTypeTag.check_lower(rumor_extra_tags)
    
    return await _uniffi_rust_call_async(
        _UniffiLib.uniffi_nostr_sdk_ffi_fn_func_make_private_msg(
        _UniffiConverterTypeNostrSigner.lower(signer),
        _UniffiConverterTypePublicKey.lower(receiver),
        _UniffiConverterString.lower(message),
        _UniffiConverterSequenceTypeTag.lower(rumor_extra_tags)),
        _UniffiLib.ffi_nostr_sdk_ffi_rust_future_poll_pointer,
        _UniffiLib.ffi_nostr_sdk_ffi_rust_future_complete_pointer,
        _UniffiLib.ffi_nostr_sdk_ffi_rust_future_free_pointer,
        # lift function
        _UniffiConverterTypeEvent.lift,
        
    # Error FFI converter
_UniffiConverterTypeNostrSdkError,

    )

def nip04_decrypt(secret_key: "SecretKey",public_key: "PublicKey",encrypted_content: "str") -> "str":
    _UniffiConverterTypeSecretKey.check_lower(secret_key)
    
    _UniffiConverterTypePublicKey.check_lower(public_key)
    
    _UniffiConverterString.check_lower(encrypted_content)
    
    return _UniffiConverterString.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeNostrSdkError,_UniffiLib.uniffi_nostr_sdk_ffi_fn_func_nip04_decrypt,
        _UniffiConverterTypeSecretKey.lower(secret_key),
        _UniffiConverterTypePublicKey.lower(public_key),
        _UniffiConverterString.lower(encrypted_content)))


def nip04_encrypt(secret_key: "SecretKey",public_key: "PublicKey",content: "str") -> "str":
    _UniffiConverterTypeSecretKey.check_lower(secret_key)
    
    _UniffiConverterTypePublicKey.check_lower(public_key)
    
    _UniffiConverterString.check_lower(content)
    
    return _UniffiConverterString.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeNostrSdkError,_UniffiLib.uniffi_nostr_sdk_ffi_fn_func_nip04_encrypt,
        _UniffiConverterTypeSecretKey.lower(secret_key),
        _UniffiConverterTypePublicKey.lower(public_key),
        _UniffiConverterString.lower(content)))


def nip05_verify_from_json(public_key: "PublicKey",address: "Nip05Address",json: "str") -> "bool":
    """
    Verify a NIP-05 from JSON
    """

    _UniffiConverterTypePublicKey.check_lower(public_key)
    
    _UniffiConverterTypeNip05Address.check_lower(address)
    
    _UniffiConverterString.check_lower(json)
    
    return _UniffiConverterBool.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeNostrSdkError,_UniffiLib.uniffi_nostr_sdk_ffi_fn_func_nip05_verify_from_json,
        _UniffiConverterTypePublicKey.lower(public_key),
        _UniffiConverterTypeNip05Address.lower(address),
        _UniffiConverterString.lower(json)))


def nip22_extract_parent(event: "Event") -> "typing.Optional[CommentTarget]":
    """
    Extract NIP22 parent comment target
    """

    _UniffiConverterTypeEvent.check_lower(event)
    
    return _UniffiConverterOptionalTypeCommentTarget.lift(_uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_func_nip22_extract_parent,
        _UniffiConverterTypeEvent.lower(event)))


def nip22_extract_root(event: "Event") -> "typing.Optional[CommentTarget]":
    """
    Extract NIP22 root comment target
    """

    _UniffiConverterTypeEvent.check_lower(event)
    
    return _UniffiConverterOptionalTypeCommentTarget.lift(_uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_func_nip22_extract_root,
        _UniffiConverterTypeEvent.lower(event)))


def nip44_decrypt(secret_key: "SecretKey",public_key: "PublicKey",payload: "str") -> "str":
    _UniffiConverterTypeSecretKey.check_lower(secret_key)
    
    _UniffiConverterTypePublicKey.check_lower(public_key)
    
    _UniffiConverterString.check_lower(payload)
    
    return _UniffiConverterString.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeNostrSdkError,_UniffiLib.uniffi_nostr_sdk_ffi_fn_func_nip44_decrypt,
        _UniffiConverterTypeSecretKey.lower(secret_key),
        _UniffiConverterTypePublicKey.lower(public_key),
        _UniffiConverterString.lower(payload)))


def nip44_encrypt(secret_key: "SecretKey",public_key: "PublicKey",content: "str",version: "Nip44Version") -> "str":
    _UniffiConverterTypeSecretKey.check_lower(secret_key)
    
    _UniffiConverterTypePublicKey.check_lower(public_key)
    
    _UniffiConverterString.check_lower(content)
    
    _UniffiConverterTypeNip44Version.check_lower(version)
    
    return _UniffiConverterString.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeNostrSdkError,_UniffiLib.uniffi_nostr_sdk_ffi_fn_func_nip44_encrypt,
        _UniffiConverterTypeSecretKey.lower(secret_key),
        _UniffiConverterTypePublicKey.lower(public_key),
        _UniffiConverterString.lower(content),
        _UniffiConverterTypeNip44Version.lower(version)))


def nip57_anonymous_zap_request(data: "ZapRequestData") -> "Event":
    _UniffiConverterTypeZapRequestData.check_lower(data)
    
    return _UniffiConverterTypeEvent.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeNostrSdkError,_UniffiLib.uniffi_nostr_sdk_ffi_fn_func_nip57_anonymous_zap_request,
        _UniffiConverterTypeZapRequestData.lower(data)))


def nip57_private_zap_request(data: "ZapRequestData",keys: "Keys") -> "Event":
    _UniffiConverterTypeZapRequestData.check_lower(data)
    
    _UniffiConverterTypeKeys.check_lower(keys)
    
    return _UniffiConverterTypeEvent.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeNostrSdkError,_UniffiLib.uniffi_nostr_sdk_ffi_fn_func_nip57_private_zap_request,
        _UniffiConverterTypeZapRequestData.lower(data),
        _UniffiConverterTypeKeys.lower(keys)))


def tag_kind_to_string(kind: "TagKind") -> "str":
    """
    Convert tag kind to string
    """

    _UniffiConverterTypeTagKind.check_lower(kind)
    
    return _UniffiConverterString.lift(_uniffi_rust_call(_UniffiLib.uniffi_nostr_sdk_ffi_fn_func_tag_kind_to_string,
        _UniffiConverterTypeTagKind.lower(kind)))


__all__ = [
    "InternalError",
    "Alphabet",
    "ClientMessageEnum",
    "CommentTarget",
    "ConnectionMode",
    "ConnectionTarget",
    "DataVendingMachineStatus",
    "DatabaseEventStatus",
    "EncryptedSecretKeyVersion",
    "ErrorCode",
    "ExternalContentId",
    "ExternalIdentity",
    "GitPatchContent",
    "HttpMethod",
    "JsonValue",
    "KeySecurity",
    "KindStandard",
    "LiveEventMarker",
    "LiveEventStatus",
    "LogLevel",
    "Marker",
    "Method",
    "Nip19Enum",
    "Nip21Enum",
    "Nip44Version",
    "Nip73Kind",
    "NostrConnectMessage",
    "NostrConnectRequest",
    "NostrParserToken",
    "NostrSdkError",
    "PolicyResult",
    "PollType",
    "Protocol",
    "RejectedReason",
    "RelayBuilderNip42Mode",
    "RelayMessageEnum",
    "RelayMetadata",
    "RelayStatus",
    "Report",
    "ReqExitPolicy",
    "RequestParams",
    "ResponseResult",
    "RetentionKind",
    "SignerBackend",
    "SyncDirection",
    "TagKind",
    "TagStandard",
    "TransactionState",
    "TransactionType",
    "WebSocketMessage",
    "ZapType",
    "ArticlesCuration",
    "Bookmarks",
    "CancelHoldInvoiceRequest",
    "CancelHoldInvoiceResponse",
    "Contact",
    "EmojiInfo",
    "Emojis",
    "EventDeletionRequest",
    "FeeSchedule",
    "FeeSchedules",
    "FilterRecord",
    "GenericTag",
    "GetBalanceResponse",
    "GetInfoResponse",
    "GitIssue",
    "GitPatch",
    "GitPatchCommitter",
    "GitRepositoryAnnouncement",
    "GossipOptions",
    "GossipRelayLimits",
    "HttpData",
    "Identity",
    "Image",
    "ImageDimensions",
    "Interests",
    "KeysendTlvRecord",
    "Limitation",
    "ListTransactionsRequest",
    "LiveEvent",
    "LiveEventHost",
    "LookupInvoiceRequest",
    "LookupInvoiceResponse",
    "MakeHoldInvoiceRequest",
    "MakeHoldInvoiceResponse",
    "MakeInvoiceRequest",
    "MakeInvoiceResponse",
    "MetadataRecord",
    "MultiPayInvoiceRequest",
    "MultiPayKeysendRequest",
    "MuteList",
    "NegentropyItem",
    "Nip47Error",
    "NostrParserOptions",
    "Output",
    "PayInvoiceRequest",
    "PayInvoiceResponse",
    "PayKeysendRequest",
    "PayKeysendResponse",
    "Person",
    "PollOption",
    "ProductData",
    "RateLimit",
    "Reconciliation",
    "ReconciliationOutput",
    "ReconciliationSendFailureItem",
    "RelayBuilderNip42",
    "Retention",
    "SendEventOutput",
    "SettleHoldInvoiceRequest",
    "SettleHoldInvoiceResponse",
    "ShippingCost",
    "ShippingMethodRecord",
    "StallDataRecord",
    "SubscribeOutput",
    "TagClientAddress",
    "WebSocketCloseFrame",
    "decrypt_received_private_zap_message",
    "decrypt_sent_private_zap_message",
    "extract_relay_list",
    "generate_shared_key",
    "get_leading_zero_bits",
    "get_prefixes_for_difficulty",
    "gift_wrap",
    "gift_wrap_from_seal",
    "git_hash_version",
    "init_logger",
    "make_private_msg",
    "nip04_decrypt",
    "nip04_encrypt",
    "nip05_verify_from_json",
    "nip22_extract_parent",
    "nip22_extract_root",
    "nip44_decrypt",
    "nip44_encrypt",
    "nip57_anonymous_zap_request",
    "nip57_private_zap_request",
    "tag_kind_to_string",
    "AdmitPolicy",
    "AdmitStatus",
    "Client",
    "ClientBuilder",
    "ClientMessage",
    "ClientOptions",
    "Connection",
    "Coordinate",
    "CustomNostrDatabase",
    "CustomNostrSigner",
    "CustomWebSocketTransport",
    "EncryptedSecretKey",
    "Event",
    "EventBuilder",
    "EventId",
    "EventStream",
    "Events",
    "FileMetadata",
    "Filter",
    "HandleNotification",
    "JobFeedbackData",
    "Keys",
    "Kind",
    "LocalRelay",
    "Metadata",
    "Nwc",
    "Nip05Address",
    "Nip05Profile",
    "Nip19",
    "Nip19Coordinate",
    "Nip19Event",
    "Nip19Profile",
    "Nip21",
    "Nip96ServerConfig",
    "Nip96UploadRequest",
    "Nip96UploadResponse",
    "NostrConnect",
    "NostrConnectMetadata",
    "NostrConnectUri",
    "NostrDatabase",
    "NostrGossip",
    "NostrParser",
    "NostrSigner",
    "NostrWalletConnectOptions",
    "NostrWalletConnectUri",
    "PublicKey",
    "QueryPolicy",
    "Relay",
    "RelayBuilder",
    "RelayConnectionStats",
    "RelayInformationDocument",
    "RelayLimits",
    "RelayMessage",
    "RelayOptions",
    "RelayUrl",
    "Request",
    "Response",
    "SaveEventStatus",
    "SecretKey",
    "ShippingMethod",
    "SingleLetterTag",
    "StallData",
    "SubscribeAutoCloseOptions",
    "SubscribeOptions",
    "SyncOptions",
    "Tag",
    "Tags",
    "Timestamp",
    "UnsignedEvent",
    "UnwrappedGift",
    "WebSocketAdapter",
    "WebSocketAdapterWrapper",
    "WritePolicy",
    "ZapRequestData",
]

