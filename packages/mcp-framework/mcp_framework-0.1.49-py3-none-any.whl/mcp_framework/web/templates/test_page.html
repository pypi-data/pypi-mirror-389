<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MCP Server Test - {{server_name}}</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .header h1 {
            color: #4a5568;
            margin-bottom: 10px;
        }

        .status {
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            text-align: center;
            font-weight: 500;
            background: #c6f6d5;
            color: #2f855a;
            border: 1px solid #9ae6b4;
        }

        .tools-section, .resources-section {
            margin-bottom: 30px;
        }

        .section-title {
            font-size: 20px;
            font-weight: 600;
            color: #2d3748;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .tool-card, .resource-card {
            background: #f7fafc;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 15px;
        }

        .tool-name, .resource-name {
            font-weight: 600;
            color: #2d3748;
            margin-bottom: 5px;
        }

        .tool-description, .resource-description {
            color: #718096;
            margin-bottom: 15px;
        }

        .test-form {
            display: flex;
            gap: 10px;
            align-items: flex-end;
            flex-wrap: wrap;
        }

        .form-group {
            flex: 1;
            min-width: 200px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            color: #4a5568;
            font-weight: 500;
            font-size: 14px;
        }

        .param-info {
            font-size: 12px;
            color: #718096;
            margin-bottom: 3px;
        }

        .param-required {
            color: #e53e3e;
            font-weight: 600;
        }

        .param-optional {
            color: #38a169;
        }

        .param-type {
            background: #edf2f7;
            padding: 2px 6px;
            border-radius: 4px;
            font-family: monospace;
            font-size: 11px;
        }

        input, textarea, select {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #e2e8f0;
            border-radius: 6px;
            font-size: 14px;
            box-sizing: border-box;
        }

        button {
            padding: 10px 20px;
            background: #4299e1;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.2s;
            white-space: nowrap;
            min-width: 80px;
        }

        button:hover {
            background: #3182ce;
            transform: translateY(-1px);
        }

        button:active {
            transform: translateY(0);
        }

        /* åœæ­¢æŒ‰é’®æ ·å¼ */
        button[style*="background: rgb(245, 101, 101)"] {
            background: #f56565 !important;
        }

        button[style*="background: rgb(245, 101, 101)"]:hover {
            background: #e53e3e !important;
        }

        .result {
            margin-top: 15px;
            padding: 15px;
            background: #edf2f7;
            border-radius: 6px;
            border-left: 4px solid #4299e1;
            display: none;
        }

        .result.success {
            background: #f0fff4;
            border-left-color: #48bb78;
        }

        .result.error {
            background: #fff5f5;
            border-left-color: #f56565;
        }

        .navigation {
            text-align: center;
            margin-top: 30px;
        }

        .nav-link {
            color: #4299e1;
            text-decoration: none;
            margin: 0 15px;
            padding: 10px 20px;
            border: 1px solid #4299e1;
            border-radius: 6px;
            display: inline-block;
            transition: all 0.2s;
        }

        .nav-link:hover {
            background: #4299e1;
            color: white;
        }

        pre {
            background: #1a202c;
            color: #e2e8f0;
            padding: 15px;
            border-radius: 6px;
            overflow-x: auto;
            font-size: 13px;
            line-height: 1.4;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        .empty-state {
            text-align: center;
            padding: 40px;
            color: #718096;
        }

        .empty-state .icon {
            font-size: 48px;
            margin-bottom: 15px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ§ª MCP Server Test</h1>
            <p>æµ‹è¯• <strong>{{server_name}}</strong> v{{server_version}} çš„åŠŸèƒ½</p>
        </div>

        <div class="status">
            âœ… æœåŠ¡å™¨æ­£åœ¨è¿è¡Œ
        </div>

        <div class="tools-section">
            <div class="section-title">
                <span>ğŸ”§</span>
                å¯ç”¨å·¥å…·
            </div>
            <div id="tools-container">
                <div class="empty-state">
                    <div class="icon">â³</div>
                    <p>æ­£åœ¨åŠ è½½å·¥å…·...</p>
                </div>
            </div>
        </div>

        <div class="resources-section">
            <div class="section-title">
                <span>ğŸ“</span>
                å¯ç”¨èµ„æº
            </div>
            <div id="resources-container">
                <div class="empty-state">
                    <div class="icon">â³</div>
                    <p>æ­£åœ¨åŠ è½½èµ„æº...</p>
                </div>
            </div>
        </div>

        <div class="navigation">
            <a href="/setup" class="nav-link">âš™ï¸ æœåŠ¡å™¨è®¾ç½®</a>
            <a href="/config" class="nav-link">ğŸ”§ ç³»ç»Ÿé…ç½®</a>
            <a href="/health" class="nav-link">ğŸ’š å¥åº·æ£€æŸ¥</a>
            <a href="/info" class="nav-link">â„¹ï¸ æœåŠ¡å™¨ä¿¡æ¯</a>
        </div>
    </div>

    <script>
        // ç«¯ç‚¹é…ç½®
        const ENDPOINTS = {
            tools: '{{tools_endpoint}}',
            resources: '{{resources_endpoint}}',
            toolCall: '{{tool_call_endpoint}}',
            sse: '{{sse_endpoint}}',
            sseStop: '{{sse_stop_endpoint}}',
            openaiSSE: '{{openai_sse_endpoint}}',
            openaiSSEStop: '{{openai_sse_stop_endpoint}}'
        };
        
        // è°ƒè¯•ï¼šæ‰“å°ç«¯ç‚¹é…ç½®
        console.log('ENDPOINTSé…ç½®:', ENDPOINTS);
        
        // æµ‹è¯•ç½‘ç»œè¿æ¥
        async function testNetworkConnection() {
            try {
                console.log('Testing basic fetch to server...');
                const response = await fetch('/info');
                console.log('Basic fetch successful:', response.status);
                
                console.log('Testing OpenAI SSE endpoint availability...');
                const testResponse = await fetch(ENDPOINTS.openaiSSE, {
                    method: 'OPTIONS'
                });
                console.log('OPTIONS request result:', testResponse.status);
            } catch (error) {
                console.error('Network test failed:', error);
            }
        }
        
        // é¡µé¢åŠ è½½æ—¶æµ‹è¯•ç½‘ç»œè¿æ¥
        testNetworkConnection();

        // é¡µé¢åŠ è½½æ—¶åˆå§‹åŒ–
        document.addEventListener('DOMContentLoaded', async function() {
            await loadStreamingInfo();
            loadTools();
            loadResources();
        });

        // åŠ è½½å·¥å…·åˆ—è¡¨
        async function loadTools() {
            try {
                const response = await fetch('/mcp', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        jsonrpc: '2.0',
                        id: 1,
                        method: 'tools/list'
                    })
                });

                const result = await response.json();

                if (result.result && result.result.tools) {
                    renderTools(result.result.tools);
                } else {
                    showEmptyState('tools-container', 'ğŸ”§', 'æš‚æ— å¯ç”¨å·¥å…·');
                }
            } catch (error) {
                console.error('Failed to load tools:', error);
                showEmptyState('tools-container', 'âŒ', 'åŠ è½½å·¥å…·å¤±è´¥');
            }
        }

        // æ¸²æŸ“å·¥å…·
        function renderTools(tools) {
            const container = document.getElementById('tools-container');
            container.innerHTML = '';

            // å­˜å‚¨å·¥å…·ä¿¡æ¯åˆ°å…¨å±€å˜é‡
            window.mcpTools = tools;

            if (tools.length === 0) {
                showEmptyState('tools-container', 'ğŸ”§', 'æš‚æ— å¯ç”¨å·¥å…·');
                return;
            }

            tools.forEach(tool => {
                const toolCard = document.createElement('div');
                toolCard.className = 'tool-card';

                const toolName = document.createElement('div');
                toolName.className = 'tool-name';
                const supportsStreaming = streamingTools.includes(tool.name);
                const streamingBadge = supportsStreaming ? ' ğŸŒŠ' : ' ğŸ“„';
                const streamingTitle = supportsStreaming ? 'æ”¯æŒæµå¼è¾“å‡º' : 'ä»…æ”¯æŒHTTP';
                const streamingType = supportsStreaming ? 'SSE' : 'HTTP';
                toolName.innerHTML = tool.name + streamingBadge + ' <span style="font-size: 12px; color: #718096; font-weight: normal;" title="' + streamingTitle + '">(' + streamingType + ')</span>';

                const toolDescription = document.createElement('div');
                toolDescription.className = 'tool-description';
                toolDescription.textContent = tool.description;

                const testForm = document.createElement('div');
                testForm.className = 'test-form';

                // åˆ›å»ºå‚æ•°è¾“å…¥æ¡†
                const properties = tool.input_schema?.properties || {};
                const required = tool.input_schema?.required || [];
                
                Object.keys(properties).forEach(paramName => {
                    const formGroup = document.createElement('div');
                    formGroup.className = 'form-group';

                    const label = document.createElement('label');
                    const isRequired = required.includes(paramName);
                    label.innerHTML = paramName + (isRequired ? ' <span class="param-required">*</span>' : ' <span class="param-optional">(å¯é€‰)</span>');

                    const property = properties[paramName];
                    
                    // æ·»åŠ å‚æ•°ä¿¡æ¯
                    const paramInfo = document.createElement('div');
                    paramInfo.className = 'param-info';
                    let infoText = '';
                    if (property.type) {
                        infoText += '<span class="param-type">' + property.type + '</span> ';
                    }
                    if (property.description) {
                        infoText += property.description;
                    }
                    if (property.default !== undefined) {
                        infoText += ' (é»˜è®¤: ' + JSON.stringify(property.default) + ')';
                    }
                    if (property.minimum !== undefined || property.maximum !== undefined) {
                        infoText += ' (èŒƒå›´: ' + (property.minimum || '-âˆ') + ' ~ ' + (property.maximum || '+âˆ') + ')';
                    }
                    if (property.enum) {
                        infoText += ' (å¯é€‰å€¼: ' + property.enum.join(', ') + ')';
                    }
                    paramInfo.innerHTML = infoText;

                    const input = document.createElement('input');

                    // æ ¹æ®JSON Schemaç±»å‹è®¾ç½®æ­£ç¡®çš„è¾“å…¥ç±»å‹
                    switch (property.type) {
                        case 'integer':
                        case 'number':
                            input.type = 'number';
                            if (property.minimum !== undefined) {
                                input.min = property.minimum;
                            }
                            if (property.maximum !== undefined) {
                                input.max = property.maximum;
                            }
                            if (property.type === 'integer') {
                                input.step = '1';
                            }
                            if (property.default !== undefined) {
                                input.value = property.default;
                            }
                            break;
                        case 'boolean':
                            input.type = 'checkbox';
                            if (property.default !== undefined) {
                                input.checked = property.default;
                            }
                            break;
                        case 'array':
                            input.type = 'text';
                            input.placeholder = 'JSONæ•°ç»„æ ¼å¼ï¼Œå¦‚ ["item1", "item2"]';
                            if (property.default !== undefined) {
                                input.value = JSON.stringify(property.default);
                            }
                            break;
                        default:
                            input.type = 'text';
                            if (property.enum) {
                                // å¦‚æœæœ‰æšä¸¾å€¼ï¼Œåˆ›å»ºä¸‹æ‹‰é€‰æ‹©
                                const select = document.createElement('select');
                                select.name = paramName;
                                
                                // æ·»åŠ ç©ºé€‰é¡¹ï¼ˆå¦‚æœä¸æ˜¯å¿…éœ€çš„ï¼‰
                                if (!isRequired) {
                                    const emptyOption = document.createElement('option');
                                    emptyOption.value = '';
                                    emptyOption.textContent = '-- è¯·é€‰æ‹© --';
                                    select.appendChild(emptyOption);
                                }
                                
                                property.enum.forEach(enumValue => {
                                    const option = document.createElement('option');
                                    option.value = enumValue;
                                    option.textContent = enumValue;
                                    if (property.default === enumValue) {
                                        option.selected = true;
                                    }
                                    select.appendChild(option);
                                });
                                
                                formGroup.appendChild(label);
                                formGroup.appendChild(paramInfo);
                                formGroup.appendChild(select);
                                testForm.appendChild(formGroup);
                                return;
                            } else {
                                if (property.default !== undefined) {
                                    input.value = property.default;
                                }
                                input.placeholder = property.description || '';
                            }
                    }

                    input.name = paramName;
                    if (isRequired) {
                        input.required = true;
                    }

                    formGroup.appendChild(label);
                    formGroup.appendChild(paramInfo);
                    formGroup.appendChild(input);
                    testForm.appendChild(formGroup);
                });

                const buttonGroup = document.createElement('div');
                buttonGroup.style.display = 'flex';
                buttonGroup.style.gap = '10px';
                buttonGroup.style.alignItems = 'center';

                const testButton = document.createElement('button');
                testButton.textContent = 'æµ‹è¯•';
                testButton.id = 'test-btn-' + tool.name;
                testButton.onclick = () => handleTestButtonClick(tool.name, testForm, testButton);
                buttonGroup.appendChild(testButton);

                const openaiButton = document.createElement('button');
                openaiButton.textContent = 'OpenAIæ ¼å¼';
                openaiButton.id = 'openai-btn-' + tool.name;
                openaiButton.style.background = '#10b981';
                openaiButton.onclick = () => handleOpenAITestButtonClick(tool.name, testForm, openaiButton);
                buttonGroup.appendChild(openaiButton);

                testForm.appendChild(buttonGroup);

                const result = document.createElement('div');
                result.className = 'result';
                result.id = 'result-' + tool.name;

                toolCard.appendChild(toolName);
                toolCard.appendChild(toolDescription);
                toolCard.appendChild(testForm);
                toolCard.appendChild(result);
                container.appendChild(toolCard);
            });
        }

        // æ£€æŸ¥å·¥å…·æ˜¯å¦æ”¯æŒæµå¼è¾“å‡º
        let streamingTools = [];

        // è·Ÿè¸ªæ´»è·ƒçš„æµå¼ä¼šè¯
        let activeStreams = new Map(); // toolName -> { sessionId, reader, abortController }
        let activeOpenAIStreams = new Map(); // toolName -> { sessionId, reader, abortController }

        // è·å–æ”¯æŒæµå¼è¾“å‡ºçš„å·¥å…·åˆ—è¡¨
        async function loadStreamingInfo() {
            try {
                const response = await fetch('/info');
                const data = await response.json();
                streamingTools = data.streaming_tools || [];
            } catch (error) {
                console.warn('Failed to load streaming info:', error);
            }
        }

        // å¤„ç†æµ‹è¯•/åœæ­¢æŒ‰é’®ç‚¹å‡»
        async function handleTestButtonClick(toolName, formElement, buttonElement) {
            // æ£€æŸ¥æ˜¯å¦æœ‰æ´»è·ƒçš„æµå¼ä¼šè¯
            if (activeStreams.has(toolName)) {
                // åœæ­¢æµå¼è¾“å‡º
                await stopTool(toolName, buttonElement);
            } else {
                // å¼€å§‹æµ‹è¯•
                await testTool(toolName, formElement, buttonElement);
            }
        }

        // å¤„ç†OpenAIæ ¼å¼æµ‹è¯•/åœæ­¢æŒ‰é’®ç‚¹å‡»
        async function handleOpenAITestButtonClick(toolName, formElement, buttonElement) {
            // æ£€æŸ¥æ˜¯å¦æœ‰æ´»è·ƒçš„OpenAIæµå¼ä¼šè¯
            if (activeOpenAIStreams.has(toolName)) {
                // åœæ­¢OpenAIæµå¼è¾“å‡º
                await stopOpenAITool(toolName, buttonElement);
            } else {
                // å¼€å§‹OpenAIæ ¼å¼æµ‹è¯•
                await testToolWithOpenAI(toolName, formElement, buttonElement);
            }
        }

        // åœæ­¢å·¥å…·æµå¼è¾“å‡º
        async function stopTool(toolName, buttonElement) {
            const streamInfo = activeStreams.get(toolName);
            if (!streamInfo) return;

            try {
                // å–æ¶ˆæµå¼è¯»å–
                if (streamInfo.abortController) {
                    streamInfo.abortController.abort();
                }

                // è°ƒç”¨åœæ­¢APIï¼ˆå¦‚æœæœ‰session_idï¼‰
                if (streamInfo.sessionId) {
                    const response = await fetch('/api/streaming/stop', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            session_id: streamInfo.sessionId
                        })
                    });

                    const result = await response.json();
                    console.log('Stop API result:', result);
                }

                // æ¸…ç†ä¼šè¯
                activeStreams.delete(toolName);

                // æ›´æ–°æŒ‰é’®çŠ¶æ€
                buttonElement.textContent = 'æµ‹è¯•';
                buttonElement.style.background = '#4299e1';

                // æ˜¾ç¤ºåœæ­¢æ¶ˆæ¯
                const resultElement = document.getElementById('result-' + toolName);
                if (resultElement) {
                    resultElement.className = 'result';
                    resultElement.innerHTML = '<strong>ğŸ›‘ å·²åœæ­¢:</strong> æµå¼è¾“å‡ºå·²è¢«ç”¨æˆ·åœæ­¢';
                }

            } catch (error) {
                console.error('Stop failed:', error);
            }
        }

        // åœæ­¢OpenAIå·¥å…·æµå¼è¾“å‡º
        async function stopOpenAITool(toolName, buttonElement) {
            const streamInfo = activeOpenAIStreams.get(toolName);
            if (!streamInfo) return;

            try {
                // å–æ¶ˆæµå¼è¯»å–
                if (streamInfo.abortController) {
                    streamInfo.abortController.abort();
                }

                // æ¸…ç†ä¼šè¯
                activeOpenAIStreams.delete(toolName);

                // æ›´æ–°æŒ‰é’®çŠ¶æ€
                buttonElement.textContent = 'OpenAIæ ¼å¼';
                buttonElement.style.background = '#10b981';

                // æ˜¾ç¤ºåœæ­¢æ¶ˆæ¯
                const resultElement = document.getElementById('result-' + toolName);
                if (resultElement) {
                    resultElement.className = 'result';
                    resultElement.innerHTML = '<strong>ğŸ›‘ å·²åœæ­¢:</strong> OpenAIæ ¼å¼æµå¼è¾“å‡ºå·²è¢«ç”¨æˆ·åœæ­¢';
                }

            } catch (error) {
                console.error('OpenAI Stop failed:', error);
            }
        }

        // æµ‹è¯•å·¥å…·
        async function testTool(toolName, formElement, buttonElement) {
            const inputs = formElement.querySelectorAll('input, select');
            const arguments = {};

            // è·å–å·¥å…·çš„Schemaä¿¡æ¯
            const tool = window.mcpTools.find(t => t.name === toolName);
            const properties = tool?.inputSchema?.properties || {};

            inputs.forEach(input => {
                const value = input.type === 'checkbox' ? input.checked : input.value.trim();
                const property = properties[input.name] || {};

                if (value !== '' || input.type === 'checkbox') {
                    // æ ¹æ®è¾“å…¥ç±»å‹å¤„ç†å€¼
                    switch (input.type) {
                        case 'number':
                            if (value !== '') {
                                const numValue = parseFloat(value);
                                if (!isNaN(numValue)) {
                                    // æ£€æŸ¥æ˜¯å¦æ˜¯æ•´æ•°ç±»å‹ï¼ˆstepä¸º1è¡¨ç¤ºæ•´æ•°ï¼‰
                                    arguments[input.name] = input.step === '1' ? parseInt(value) : numValue;
                                }
                            }
                            break;
                        case 'checkbox':
                            arguments[input.name] = input.checked;
                            break;
                        case 'text':
                            if (value !== '') {
                                // å°è¯•è§£æJSONæ•°ç»„
                                if (value.startsWith('[') && value.endsWith(']')) {
                                    try {
                                        arguments[input.name] = JSON.parse(value);
                                    } catch (e) {
                                        arguments[input.name] = value;
                                    }
                                } else {
                                    arguments[input.name] = value;
                                }
                            }
                            break;
                        default:
                            if (value !== '') {
                                arguments[input.name] = value;
                            }
                    }
                } else if (property.default !== undefined) {
                    // å¦‚æœæ²¡æœ‰è¾“å…¥å€¼ä½†æœ‰é»˜è®¤å€¼ï¼Œä½¿ç”¨é»˜è®¤å€¼
                    arguments[input.name] = property.default;
                }
            });

            const resultElement = document.getElementById('result-' + toolName);
            resultElement.style.display = 'block';
            resultElement.className = 'result';

            // æ£€æŸ¥æ˜¯å¦æ”¯æŒæµå¼è¾“å‡º
            const supportsStreaming = streamingTools.includes(toolName);

            if (supportsStreaming) {
                // æ›´æ–°æŒ‰é’®ä¸ºåœæ­¢çŠ¶æ€
                buttonElement.textContent = 'åœæ­¢';
                buttonElement.style.background = '#f56565';

                resultElement.innerHTML = 'ğŸ”„ ä½¿ç”¨æµå¼è¾“å‡ºæµ‹è¯•ä¸­...';
                await testToolWithSSE(toolName, arguments, resultElement, buttonElement);
            } else {
                resultElement.innerHTML = 'ğŸ”„ ä½¿ç”¨HTTPæµ‹è¯•ä¸­...';
                await testToolWithHTTP(toolName, arguments, resultElement);
                // HTTPè°ƒç”¨å®Œæˆåæ¢å¤æŒ‰é’®çŠ¶æ€
                buttonElement.textContent = 'æµ‹è¯•';
                buttonElement.style.background = '#4299e1';
            }
        }

        // ä½¿ç”¨HTTPæµ‹è¯•å·¥å…·
        async function testToolWithHTTP(toolName, arguments, resultElement) {
            try {
                const response = await fetch('/mcp', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        jsonrpc: '2.0',
                        id: Date.now(),
                        method: 'tools/call',
                        params: {
                            name: toolName,
                            arguments: arguments
                        }
                    })
                });

                const result = await response.json();

                if (result.result) {
                    resultElement.className = 'result success';
                    const content = result.result.content?.[0]?.text || JSON.stringify(result.result, null, 2);
                    resultElement.innerHTML = '<strong>âœ… HTTPæˆåŠŸ:</strong><pre>' + content + '</pre>';
                } else if (result.error) {
                    resultElement.className = 'result error';
                    resultElement.innerHTML = '<strong>âŒ HTTPé”™è¯¯:</strong> ' + result.error.message;
                }
            } catch (error) {
                resultElement.className = 'result error';
                resultElement.innerHTML = '<strong>ğŸš« HTTPè¯·æ±‚å¤±è´¥:</strong> ' + error.message;
            }
        }

        // ä½¿ç”¨OpenAIæ ¼å¼æµ‹è¯•å·¥å…·
        async function testToolWithOpenAI(toolName, formElement, buttonElement) {
            const inputs = formElement.querySelectorAll('input, select');
            const arguments = {};

            // è·å–å·¥å…·çš„Schemaä¿¡æ¯
            const tool = window.mcpTools.find(t => t.name === toolName);
            const properties = tool?.inputSchema?.properties || {};

            inputs.forEach(input => {
                const value = input.type === 'checkbox' ? input.checked : input.value.trim();
                const property = properties[input.name] || {};

                if (value !== '' || input.type === 'checkbox') {
                    // æ ¹æ®è¾“å…¥ç±»å‹å¤„ç†å€¼
                    switch (input.type) {
                        case 'number':
                            if (value !== '') {
                                const numValue = parseFloat(value);
                                if (!isNaN(numValue)) {
                                    // æ£€æŸ¥æ˜¯å¦æ˜¯æ•´æ•°ç±»å‹ï¼ˆstepä¸º1è¡¨ç¤ºæ•´æ•°ï¼‰
                                    arguments[input.name] = input.step === '1' ? parseInt(value) : numValue;
                                }
                            }
                            break;
                        case 'checkbox':
                            arguments[input.name] = input.checked;
                            break;
                        case 'text':
                            if (value !== '') {
                                // å°è¯•è§£æJSONæ•°ç»„
                                if (value.startsWith('[') && value.endsWith(']')) {
                                    try {
                                        arguments[input.name] = JSON.parse(value);
                                    } catch (e) {
                                        arguments[input.name] = value;
                                    }
                                } else {
                                    arguments[input.name] = value;
                                }
                            }
                            break;
                        default:
                            if (value !== '') {
                                arguments[input.name] = value;
                            }
                    }
                } else if (property.default !== undefined) {
                    // å¦‚æœæ²¡æœ‰è¾“å…¥å€¼ä½†æœ‰é»˜è®¤å€¼ï¼Œä½¿ç”¨é»˜è®¤å€¼
                    arguments[input.name] = property.default;
                }
            });

            const resultElement = document.getElementById('result-' + toolName);
            resultElement.style.display = 'block';
            resultElement.className = 'result';

            // æ›´æ–°æŒ‰é’®ä¸ºåœæ­¢çŠ¶æ€
            buttonElement.textContent = 'åœæ­¢';
            buttonElement.style.background = '#f56565';

            resultElement.innerHTML = 'ğŸ”„ ä½¿ç”¨OpenAIæ ¼å¼æµå¼è¾“å‡ºæµ‹è¯•ä¸­...';
            await testToolWithOpenAISSE(toolName, arguments, resultElement, buttonElement);
        }

        // ä½¿ç”¨OpenAIæ ¼å¼SSEæµ‹è¯•å·¥å…·
        async function testToolWithOpenAISSE(toolName, arguments, resultElement, buttonElement) {
            try {
                console.log('Creating OpenAI SSE request for tool:', toolName, 'with arguments:', arguments);
                console.log('OpenAI SSE URL:', ENDPOINTS.openaiSSE);

                // åˆ›å»ºAbortControllerç”¨äºå–æ¶ˆè¯·æ±‚
                const abortController = new AbortController();

                const response = await fetch(ENDPOINTS.openaiSSE, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Accept': 'text/event-stream',
                        'Cache-Control': 'no-cache'
                    },
                    body: JSON.stringify({
                        tool_name: toolName,
                        arguments: arguments
                    }),
                    signal: abortController.signal
                }).catch(error => {
                    console.error('Fetch error details:', error);
                    console.error('Error name:', error.name);
                    console.error('Error message:', error.message);
                    throw error;
                });

                console.log('OpenAI SSE response status:', response.status);
                console.log('OpenAI SSE response headers:', Object.fromEntries(response.headers.entries()));

                if (!response.ok) {
                    throw new Error('HTTP ' + response.status + ': ' + response.statusText);
                }

                // è·å–ä¼šè¯ID
                const sessionId = response.headers.get('X-Session-ID');
                console.log('OpenAI Session ID:', sessionId);

                console.log('Starting to read OpenAI SSE stream...');
                const reader = response.body.getReader();
                const decoder = new TextDecoder();

                // æ³¨å†Œæ´»è·ƒOpenAIæµå¼ä¼šè¯
                activeOpenAIStreams.set(toolName, {
                    sessionId: sessionId,
                    reader: reader,
                    abortController: abortController
                });
                let buffer = '';
                let output = '';
                let eventLog = [];

                resultElement.innerHTML = '<strong>ğŸ”„ OpenAIæ ¼å¼SSEæµå¼è¾“å‡º:</strong><div id="openai-streaming-container"><pre id="openai-streaming-output"></pre><div id="openai-event-log"></div></div>';
                const outputElement = document.getElementById('openai-streaming-output');
                const eventLogElement = document.getElementById('openai-event-log');

                try {
                    while (true) {
                         const { done, value } = await reader.read();
                         console.log('OpenAI Stream read result:', { done, valueLength: value ? value.length : 0 });

                         if (done) {
                             console.log('OpenAI Stream reading completed');
                             break;
                         }

                         buffer += decoder.decode(value, { stream: true });
                         console.log('OpenAI Current buffer:', buffer);

                         const lines = buffer.split('\n');
                         buffer = lines.pop(); // ä¿ç•™ä¸å®Œæ•´çš„è¡Œ

                    for (const line of lines) {
                        console.log('Processing OpenAI line:', line);
                        if (line.trim() === '') continue;

                        if (line.startsWith('event:')) {
                            const eventType = line.substring(6).trim();
                            eventLog.push('[Event: ' + eventType + ']');
                            console.log('OpenAI SSE Event:', eventType);
                        } else if (line.startsWith('data:')) {
                            const data = line.substring(5).trim();
                            console.log('OpenAI SSE Raw Data:', data);
                            
                            // å¤„ç†OpenAIæ ¼å¼çš„ç‰¹æ®Šç»“æŸæ ‡è®°
                            if (data === '[DONE]') {
                                eventLog.push('[OpenAI DONE Signal]');
                                console.log('OpenAI stream completed with DONE signal');
                                break;
                            }
                            
                            try {
                                const eventData = JSON.parse(data);
                                console.log('OpenAI SSE Parsed Data:', eventData);
                                eventLog.push('[Data: ' + JSON.stringify(eventData) + ']');

                                // å¤„ç†OpenAIæ ¼å¼çš„æµå¼æ•°æ®
                                if (eventData.choices && eventData.choices[0] && eventData.choices[0].delta) {
                                    const delta = eventData.choices[0].delta;
                                    if (delta.content) {
                                        output += delta.content;
                                        outputElement.textContent = output;
                                        outputElement.scrollTop = outputElement.scrollHeight;
                                    }
                                    if (delta.tool_calls) {
                                        // å¤„ç†å·¥å…·è°ƒç”¨
                                        output += '\n[Tool Call: ' + JSON.stringify(delta.tool_calls, null, 2) + ']\n';
                                        outputElement.textContent = output;
                                        outputElement.scrollTop = outputElement.scrollHeight;
                                    }
                                } else if (eventData.chunk) {
                                    // å…¼å®¹åŸæœ‰æ ¼å¼
                                    output += eventData.chunk + '\n';
                                    outputElement.textContent = output;
                                    outputElement.scrollTop = outputElement.scrollHeight;
                                } else if (eventData.error) {
                                    resultElement.className = 'result error';
                                    resultElement.innerHTML = '<strong>âŒ OpenAI SSEé”™è¯¯:</strong> ' + eventData.error;
                                    return;
                                } else {
                                    // æ˜¾ç¤ºå…¶ä»–ç±»å‹çš„æ•°æ®
                                    output += JSON.stringify(eventData, null, 2) + '\n';
                                    outputElement.textContent = output;
                                    outputElement.scrollTop = outputElement.scrollHeight;
                                }
                            } catch (e) {
                                // å¦‚æœä¸æ˜¯JSONï¼Œç›´æ¥æ˜¾ç¤ºåŸå§‹æ•°æ®
                                output += data + '\n';
                                outputElement.textContent = output;
                                outputElement.scrollTop = outputElement.scrollHeight;
                                eventLog.push('[Raw Data: ' + data + ']');
                            }
                        }

                        // æ›´æ–°äº‹ä»¶æ—¥å¿—
                        eventLogElement.innerHTML = '<details><summary>OpenAIäº‹ä»¶æ—¥å¿— (' + eventLog.length + ')</summary><pre>' + eventLog.join('\\n') + '</pre></details>';
                    }
                }

                resultElement.className = 'result success';
                if (output.trim()) {
                    resultElement.innerHTML = '<strong>âœ… OpenAI SSEæˆåŠŸ:</strong><pre>' + output + '</pre>';
                } else {
                    resultElement.innerHTML = '<strong>âœ… OpenAI SSEå®Œæˆ:</strong> OpenAIæ ¼å¼æµå¼ä¼ è¾“å·²å®Œæˆï¼Œä½†æ²¡æœ‰æ¥æ”¶åˆ°æ•°æ®å†…å®¹ã€‚<br>' + eventLogElement.innerHTML;
                }

                // æ¸…ç†ä¼šè¯å¹¶æ¢å¤æŒ‰é’®çŠ¶æ€
                activeOpenAIStreams.delete(toolName);
                buttonElement.textContent = 'OpenAIæ ¼å¼';
                buttonElement.style.background = '#10b981';

            } catch (streamError) {
                    console.error('Error reading OpenAI SSE stream:', streamError);
                    resultElement.className = 'result error';

                    // æ£€æŸ¥æ˜¯å¦æ˜¯ç”¨æˆ·ä¸»åŠ¨å–æ¶ˆ
                    if (streamError.name === 'AbortError') {
                        resultElement.innerHTML = '<strong>ğŸ›‘ å·²åœæ­¢:</strong> OpenAIæ ¼å¼æµå¼è¾“å‡ºå·²è¢«ç”¨æˆ·åœæ­¢';
                    } else {
                        resultElement.innerHTML = '<strong>ğŸš« OpenAI SSEæµè¯»å–å¤±è´¥:</strong> ' + streamError.message;
                    }

                    // æ¸…ç†ä¼šè¯å¹¶æ¢å¤æŒ‰é’®çŠ¶æ€
                    activeOpenAIStreams.delete(toolName);
                    buttonElement.textContent = 'OpenAIæ ¼å¼';
                    buttonElement.style.background = '#10b981';
                }

            } catch (error) {
                console.error('OpenAI SSE request failed:', error);
                resultElement.className = 'result error';

                // æ£€æŸ¥æ˜¯å¦æ˜¯ç”¨æˆ·ä¸»åŠ¨å–æ¶ˆ
                if (error.name === 'AbortError') {
                    resultElement.innerHTML = '<strong>ğŸ›‘ å·²åœæ­¢:</strong> OpenAIæ ¼å¼æµå¼è¾“å‡ºå·²è¢«ç”¨æˆ·åœæ­¢';
                } else {
                    resultElement.innerHTML = '<strong>ğŸš« OpenAI SSEè¯·æ±‚å¤±è´¥:</strong> ' + error.message;
                }

                // æ¸…ç†ä¼šè¯å¹¶æ¢å¤æŒ‰é’®çŠ¶æ€
                activeOpenAIStreams.delete(toolName);
                buttonElement.textContent = 'OpenAIæ ¼å¼';
                buttonElement.style.background = '#10b981';
            }
        }

        // ä½¿ç”¨SSEæµ‹è¯•å·¥å…·
        async function testToolWithSSE(toolName, arguments, resultElement, buttonElement) {
            try {
                console.log('Creating SSE request for tool:', toolName, 'with arguments:', arguments);

                // åˆ›å»ºAbortControllerç”¨äºå–æ¶ˆè¯·æ±‚
                const abortController = new AbortController();

                const response = await fetch('/sse/tool/call', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Accept': 'text/event-stream',
                        'Cache-Control': 'no-cache'
                    },
                    body: JSON.stringify({
                        tool_name: toolName,
                        arguments: arguments
                    }),
                    signal: abortController.signal
                });

                console.log('SSE response status:', response.status);
                console.log('SSE response headers:', Object.fromEntries(response.headers.entries()));

                if (!response.ok) {
                    throw new Error('HTTP ' + response.status + ': ' + response.statusText);
                }

                // è·å–ä¼šè¯ID
                const sessionId = response.headers.get('X-Session-ID');
                console.log('Session ID:', sessionId);

                console.log('Starting to read SSE stream...');
                const reader = response.body.getReader();
                const decoder = new TextDecoder();

                // æ³¨å†Œæ´»è·ƒæµå¼ä¼šè¯
                activeStreams.set(toolName, {
                    sessionId: sessionId,
                    reader: reader,
                    abortController: abortController
                });
                let buffer = '';
                let output = '';
                let eventLog = [];

                resultElement.innerHTML = '<strong>ğŸ”„ SSEæµå¼è¾“å‡º:</strong><div id="streaming-container"><pre id="streaming-output"></pre><div id="event-log"></div></div>';
                const outputElement = document.getElementById('streaming-output');
                const eventLogElement = document.getElementById('event-log');

                try {
                    while (true) {
                         const { done, value } = await reader.read();
                         console.log('Stream read result:', { done, valueLength: value ? value.length : 0 });

                         if (done) {
                             console.log('Stream reading completed');
                             break;
                         }

                         buffer += decoder.decode(value, { stream: true });
                         console.log('Current buffer:', buffer);

                         const lines = buffer.split('\n');
                         buffer = lines.pop(); // ä¿ç•™ä¸å®Œæ•´çš„è¡Œ

                    for (const line of lines) {
                        console.log('Processing line:', line);
                        if (line.trim() === '') continue;

                        if (line.startsWith('event:')) {
                            const eventType = line.substring(6).trim();
                            eventLog.push('[Event: ' + eventType + ']');
                            console.log('SSE Event:', eventType);
                        } else if (line.startsWith('data:')) {
                            const data = line.substring(5).trim();
                            console.log('SSE Raw Data:', data);
                            try {
                                const eventData = JSON.parse(data);
                                console.log('SSE Parsed Data:', eventData);
                                eventLog.push('[Data: ' + JSON.stringify(eventData) + ']');

                                if (eventData.chunk) {
                                    output += eventData.chunk + '\n';
                                    outputElement.textContent = output;
                                    outputElement.scrollTop = outputElement.scrollHeight;
                                } else if (eventData.error) {
                                    resultElement.className = 'result error';
                                    resultElement.innerHTML = '<strong>âŒ SSEé”™è¯¯:</strong> ' + eventData.error;
                                    return;
                                } else if (eventData.type) {
                                    // å¤„ç†æµå¼å·¥å…·çš„ç»“æ„åŒ–æ•°æ®
                                    if (eventData.type === 'progress') {
                                        output += 'ğŸ”„ ' + eventData.message + '\n';
                                    } else if (eventData.type === 'data') {
                                        output += 'ğŸ“Š ' + eventData.field + ': ' + eventData.value + '\n';
                                    } else if (eventData.type === 'result') {
                                        output += 'âœ… æœ€ç»ˆç»“æœ:\n' + JSON.stringify(eventData.data, null, 2) + '\n';
                                    } else {
                                        output += '[' + eventData.type + '] ' + JSON.stringify(eventData, null, 2) + '\n';
                                    }
                                    outputElement.textContent = output;
                                    outputElement.scrollTop = outputElement.scrollHeight;
                                } else {
                                    // æ˜¾ç¤ºå…¶ä»–ç±»å‹çš„æ•°æ®
                                    output += JSON.stringify(eventData, null, 2) + '\n';
                                    outputElement.textContent = output;
                                    outputElement.scrollTop = outputElement.scrollHeight;
                                }
                            } catch (e) {
                                // å¦‚æœä¸æ˜¯JSONï¼Œç›´æ¥æ˜¾ç¤ºåŸå§‹æ•°æ®
                                output += data + '\n';
                                outputElement.textContent = output;
                                outputElement.scrollTop = outputElement.scrollHeight;
                                eventLog.push('[Raw Data: ' + data + ']');
                            }
                        }

                        // æ›´æ–°äº‹ä»¶æ—¥å¿—
                        eventLogElement.innerHTML = '<details><summary>äº‹ä»¶æ—¥å¿— (' + eventLog.length + ')</summary><pre>' + eventLog.join('\\n') + '</pre></details>';
                    }
                }

                resultElement.className = 'result success';
                if (output.trim()) {
                    resultElement.innerHTML = '<strong>âœ… SSEæˆåŠŸ:</strong><pre>' + output + '</pre>';
                } else {
                    resultElement.innerHTML = '<strong>âœ… SSEå®Œæˆ:</strong> æµå¼ä¼ è¾“å·²å®Œæˆï¼Œä½†æ²¡æœ‰æ¥æ”¶åˆ°æ•°æ®å†…å®¹ã€‚<br>' + eventLogElement.innerHTML;
                }

                // æ¸…ç†ä¼šè¯å¹¶æ¢å¤æŒ‰é’®çŠ¶æ€
                activeStreams.delete(toolName);
                buttonElement.textContent = 'æµ‹è¯•';
                buttonElement.style.background = '#4299e1';

            } catch (streamError) {
                    console.error('Error reading SSE stream:', streamError);
                    resultElement.className = 'result error';

                    // æ£€æŸ¥æ˜¯å¦æ˜¯ç”¨æˆ·ä¸»åŠ¨å–æ¶ˆ
                    if (streamError.name === 'AbortError') {
                        resultElement.innerHTML = '<strong>ğŸ›‘ å·²åœæ­¢:</strong> æµå¼è¾“å‡ºå·²è¢«ç”¨æˆ·åœæ­¢';
                    } else {
                        resultElement.innerHTML = '<strong>ğŸš« SSEæµè¯»å–å¤±è´¥:</strong> ' + streamError.message;
                    }

                    // æ¸…ç†ä¼šè¯å¹¶æ¢å¤æŒ‰é’®çŠ¶æ€
                    activeStreams.delete(toolName);
                    buttonElement.textContent = 'æµ‹è¯•';
                    buttonElement.style.background = '#4299e1';
                }

            } catch (error) {
                console.error('SSE request failed:', error);
                resultElement.className = 'result error';

                // æ£€æŸ¥æ˜¯å¦æ˜¯ç”¨æˆ·ä¸»åŠ¨å–æ¶ˆ
                if (error.name === 'AbortError') {
                    resultElement.innerHTML = '<strong>ğŸ›‘ å·²åœæ­¢:</strong> æµå¼è¾“å‡ºå·²è¢«ç”¨æˆ·åœæ­¢';
                } else {
                    resultElement.innerHTML = '<strong>ğŸš« SSEè¯·æ±‚å¤±è´¥:</strong> ' + error.message;
                }

                // æ¸…ç†ä¼šè¯å¹¶æ¢å¤æŒ‰é’®çŠ¶æ€
                activeStreams.delete(toolName);
                buttonElement.textContent = 'æµ‹è¯•';
                buttonElement.style.background = '#4299e1';
            }
        }

        // åŠ è½½èµ„æºåˆ—è¡¨
        async function loadResources() {
            try {
                const response = await fetch('/mcp', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        jsonrpc: '2.0',
                        id: 2,
                        method: 'resources/list'
                    })
                });

                const result = await response.json();

                if (result.result && result.result.resources) {
                    renderResources(result.result.resources);
                } else {
                    showEmptyState('resources-container', 'ğŸ“', 'æš‚æ— å¯ç”¨èµ„æº');
                }
            } catch (error) {
                console.error('Failed to load resources:', error);
                showEmptyState('resources-container', 'âŒ', 'åŠ è½½èµ„æºå¤±è´¥');
            }
        }

        // æ¸²æŸ“èµ„æº
        function renderResources(resources) {
            const container = document.getElementById('resources-container');
            container.innerHTML = '';

            if (resources.length === 0) {
                showEmptyState('resources-container', 'ğŸ“', 'æš‚æ— å¯ç”¨èµ„æº');
                return;
            }

            resources.forEach(resource => {
                const resourceCard = document.createElement('div');
                resourceCard.className = 'resource-card';

                const resourceName = document.createElement('div');
                resourceName.className = 'resource-name';
                resourceName.textContent = resource.name;

                const resourceDescription = document.createElement('div');
                resourceDescription.className = 'resource-description';
                resourceDescription.textContent = resource.description;

                const resourceUri = document.createElement('div');
                resourceUri.innerHTML = '<strong>URI:</strong> ' + resource.uri;

                const testButton = document.createElement('button');
                testButton.textContent = 'è¯»å–èµ„æº';
                testButton.onclick = () => testResource(resource.uri);

                const result = document.createElement('div');
                result.className = 'result';
                result.id = 'resource-result-' + resource.uri.replace(/[^a-zA-Z0-9]/g, '');

                resourceCard.appendChild(resourceName);
                resourceCard.appendChild(resourceDescription);
                resourceCard.appendChild(resourceUri);
                resourceCard.appendChild(testButton);
                resourceCard.appendChild(result);
                container.appendChild(resourceCard);
            });
        }

        // æµ‹è¯•èµ„æº
        async function testResource(uri) {
            const resultElement = document.getElementById('resource-result-' + uri.replace(/[^a-zA-Z0-9]/g, ''));
            resultElement.style.display = 'block';
            resultElement.className = 'result';
            resultElement.innerHTML = 'ğŸ”„ è¯»å–ä¸­...';

            try {
                const response = await fetch('/mcp', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        jsonrpc: '2.0',
                        id: Date.now(),
                        method: 'resources/read',
                        params: {
                            uri: uri
                        }
                    })
                });

                const result = await response.json();

                if (result.result) {
                    resultElement.className = 'result success';
                    resultElement.innerHTML = '<strong>âœ… æˆåŠŸ:</strong><pre>' + JSON.stringify(result.result, null, 2) + '</pre>';
                } else if (result.error) {
                    resultElement.className = 'result error';
                    resultElement.innerHTML = '<strong>âŒ é”™è¯¯:</strong> ' + result.error.message;
                }
            } catch (error) {
                resultElement.className = 'result error';
                resultElement.innerHTML = '<strong>ğŸš« è¯·æ±‚å¤±è´¥:</strong> ' + error.message;
            }
        }

        // æ˜¾ç¤ºç©ºçŠ¶æ€
        function showEmptyState(containerId, icon, message) {
            const container = document.getElementById(containerId);
            container.innerHTML = '<div class="empty-state"><div class="icon">' + icon + '</div><p>' + message + '</p></div>';
        }
    </script>
</body>
</html>