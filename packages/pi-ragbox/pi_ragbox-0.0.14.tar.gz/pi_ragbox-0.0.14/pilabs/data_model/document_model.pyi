from .feature_model import CrossEncoderPrompt as CrossEncoderPrompt, DocDerivedFeature as DocDerivedFeature, FeatureNotPopulatedError as FeatureNotPopulatedError, PiPrompt as PiPrompt
from .query_model import SearchQuery as SearchQuery
from .request_context_model import get_ctx as get_ctx
from _typeshed import Incomplete
from enum import Enum
from pydantic import BaseModel, GetCoreSchemaHandler as GetCoreSchemaHandler
from pydantic_core import core_schema
from typing import Any, Callable, Iterable, Mapping, Protocol, Sequence, TypeVar

class _PromptAccessor:
    _results: Incomplete
    _name: Incomplete
    def __init__(self, results: SearchResults, name: str) -> None: ...
    def _is_prompt(self) -> bool: ...
    def _get_from_doc(self, doc: Document): ...
    def __iter__(self): ...
    def __getitem__(self, key): ...
    def map(self) -> dict[PiDocId, Any]: ...
    def first(self, default=None): ...
    def __call__(self, doc: Document): ...

class _FeaturesFacade:
    def __init__(self, results: SearchResults) -> None: ...
    def __setitem__(self, name: str, value) -> None: ...
    def __getitem__(self, name: str) -> _PromptAccessor: ...
    def keys(self) -> Iterable[str]: ...
    def declared(self) -> dict[str, object]: ...
    async def populate(self, query, *, pi_input_builder: DocFunction[str] | None = None, pi_input_builder_kwargs: dict[str, Any] | None = None, overwrite: bool | None = None, cross_encoder_passage_builder: DocFunction[str] | None = None, cross_encoder_passage_builder_kwargs: dict[str, Any] | None = None, cross_encoder_hotswaps: str | None = None) -> SearchResults: ...

class PiDocId(str):
    @classmethod
    def __get_pydantic_core_schema__(cls, _source: type[Any], handler: GetCoreSchemaHandler) -> core_schema.CoreSchema: ...
    @classmethod
    def __get_pydantic_json_schema__(cls, core: core_schema.CoreSchema, handler): ...

class TraceOperation(str, Enum):
    NOTE = 'note'
    ADD_FEATURES = 'add_features'
    FILTER = 'filter'
    SCORE = 'score'

class TraceEntry(BaseModel):
    operation: TraceOperation
    data: dict[str, Any]
    model_config: Incomplete
TraceInput = TraceEntry | Mapping[str, Any] | str

class Document(BaseModel):
    docid: PiDocId
    content: dict
    score: float
    features: Mapping[str, Any]
    retrievals: list[SearchQuery]
    traces: list[TraceEntry]
    model_config: Incomplete
    def model_post_init(self, /, __context: Any) -> None: ...
    @classmethod
    def _ensure_mapping_proxy(cls, value: Any) -> Mapping[str, Any]: ...
    def _serialize_mapping_proxy(self, value: Mapping[str, Any]) -> dict[str, Any]: ...
    @classmethod
    def _ensure_traces(cls, value: Any) -> list[TraceEntry]: ...
    def _serialize_traces(self, value: list[TraceEntry]) -> list[dict[str, Any]]: ...
    def add_trace(self, trace: TraceInput | DocFunction[TraceInput] | None) -> Document: ...
    @staticmethod
    def _parse_trace_item(value: Any) -> TraceEntry: ...
R = TypeVar('R')

class DocFunction(Protocol[R]):
    def __call__(self, doc: Document, *args: Any, **kwargs: Any) -> R: ...

class DebugInfo(BaseModel):
    query: SearchQuery

def _predicate_expr_from_callsite() -> str | None: ...
def _predicate_debug_info(predicate: Callable[..., Any]) -> dict[str, Any]: ...
def _stringify_freevars(freevars: Mapping[str, Any]) -> dict[str, str]: ...

class SearchResults(BaseModel):
    results_data: list[Document]
    debug_info: DebugInfo | None
    _features: _FeaturesFacade | None
    model_config: Incomplete
    @property
    def features(self) -> _FeaturesFacade: ...
    async def _populate_pi_features_from_prompts(self, *, prompts: list[PiPrompt], pi_input_builder: DocFunction[str] | None = None, pi_input_builder_kwargs: dict[str, Any] | None = None, model_name: str | None = None, overwrite: bool = True) -> SearchResults: ...
    async def _populate_cross_encoder_features_from_prompts(self, *, prompts: list[CrossEncoderPrompt], query: str, passage_builder: DocFunction[str] | None = None, passage_builder_kwargs: dict[str, Any] | None = None, hotswaps: str | None = None, overwrite: bool = True) -> SearchResults: ...
    @property
    def results(self) -> list[Document]: ...
    def __setattr__(self, name, value) -> None: ...
    def add_trace(self, trace: TraceInput | DocFunction[TraceInput] | None) -> SearchResults: ...
    def filter(self, *args, predicate: DocFunction[bool] = None, fn_kwargs: dict[str, Any] | None = None, trace: TraceInput | DocFunction[TraceInput] | None = None) -> SearchResults: ...
    def score(self, scoring_fn: DocFunction[float], fn_kwargs: dict[str, Any] | None = None, trace: TraceInput | DocFunction[TraceInput] | None = None) -> SearchResults: ...
    async def add_pi_features(self, prompts: list[PiPrompt], pi_input_builder: DocFunction[str] | None = None, pi_input_builder_kwargs: dict[str, Any] | None = None, overwrite: bool = True) -> SearchResults: ...
    async def add_features(self, features: Sequence[DocDerivedFeature] | Mapping[str, Callable[[Document], Any]] = (), *, overwrite: bool = True, **named_features: Callable[[Document], Any]) -> SearchResults: ...
    def _add_retrieval_query(self, retrieval: SearchQuery) -> SearchResults: ...
    @staticmethod
    def _merge_doc_features_and_metadata(merge_into: Document, merge_from: Document) -> None: ...
    def merge(self, other: SearchResults) -> SearchResults: ...
