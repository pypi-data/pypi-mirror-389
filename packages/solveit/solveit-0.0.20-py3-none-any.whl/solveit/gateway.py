"""An ipykernel client replacement for execnb's `CaptureShell()`."""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/00_gateway.ipynb.

# %% auto 0
__all__ = ['first_port', 'port_names', 'skip_outs', 'output_types', 'AsyncLockedSocketChannel', 'AsyncLockedClient',
           'SolveitKernelManager', 'start_kernel', 'msg_short', 'print_short', 'msgs_short', 'msg2output',
           'EvalException', 'error2iopub', 'retr_outs', 'concat_streams', 'normalize_text_latex',
           'ClassyPygmentsRenderer', 'render_outputs']

# %% ../nbs/00_gateway.ipynb
from fasthtml.common import *
from ipykernel_helper import *
from fastcore.ansi import strip_ansi
from fastcore.meta import delegates
from fastcore.parallel import startthread
from html import escape
from mistletoe import markdown, HTMLRenderer
from mistletoe.contrib.pygments_renderer import PygmentsRenderer
from queue import Empty
from ast import literal_eval
from asyncio import TimeoutError as AsyncTimeoutError, create_task, Event as AsyncEvent, CancelledError, Lock
from threading import RLock
from time import monotonic
from pygments.formatters import HtmlFormatter

import asyncio, re, zmq.asyncio

from nbformat.v4 import output_from_msg
from nbformat.notebooknode import NotebookNode

from traitlets import Type
from jupyter_client import KernelClient, AsyncKernelClient
from jupyter_client.session import Session
from jupyter_client.channels import AsyncZMQSocketChannel
from zmq.error import ZMQError
from jupyter_client.kernelspec import KernelSpec
from jupyter_client import AsyncKernelManager,KernelManager

from ipykernel_helper import *

# %% ../nbs/00_gateway.ipynb
first_port = 9001
port_names = 'shell iopub stdin hb control'.split()

# %% ../nbs/00_gateway.ipynb
class AsyncLockedSocketChannel(AsyncZMQSocketChannel):
    def __init__(self, socket, session, loop = None):
        self.lock = RLock()
        super().__init__(socket, session=session, loop=loop)

    def send(self, msg):
        with self.lock: super().send(msg)

class AsyncLockedClient(AsyncKernelClient):
    shell_channel_class=AsyncLockedSocketChannel

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.lock = Lock()

# %% ../nbs/00_gateway.ipynb
class SolveitKernelManager(AsyncKernelManager):
    client_class = AsyncLockedClient
    client_factory = Type(AsyncLockedClient)

    def __init__(self, kernel_spec=None, username=None, startdir=None, **kwargs):
        super().__init__(**kwargs)
        if kernel_spec: self._kernel_spec = kernel_spec
        self.username = username

    async def _async_pre_start_kernel(self, **kw):
        kernel_cmd, kw = await super()._async_pre_start_kernel(**kw)
        if self.username:
            if os.path.exists(self.connection_file): os.chmod(self.connection_file, 0o644)
            kernel_cmd = ["sudo", "-n", "-E", "-u", self.username] + kernel_cmd
        return kernel_cmd, kw

# %% ../nbs/00_gateway.ipynb
async def start_kernel(chdir=None):
    de_path = Path('/.dockerenv')
    in_docker = de_path.exists()
    env = {
        "IN_SOLVEIT":'True',
        "TERM": "screen", "COLORTERM": "truecolor",  "FORCE_COLOR": "1",
        "PAGER": "cat", "MANPAGER": "cat",
        'PYTHONSAFEPATH':'1'
    }
    kw = {}
    path = os.getenv('PATH', '')
    if in_docker:
        env |= {"HOME": '/app/data', "PIP_USER": "True", "PATH": f"/home/solveit/.local/bin:{path}"}
        kw = {'cwd': '/app/data'}
    else:
        env |= os.environ
        kw = {'cwd': chdir}
    argv = "{prefix}/bin/python", "-Pm", "ipykernel_launcher", "-f", "{connection_file}"
    kernel_spec = KernelSpec(argv=argv, language="python", display_name="Solveit", **kw)
    username = 'solveit' if in_docker else None
    startdir = '/home/solveit' if in_docker else chdir
    km = SolveitKernelManager(kernel_spec=kernel_spec, session=Session(key=b'x'), username=username)
    await km.start_kernel(env=env, **kw)
    return km

# %% ../nbs/00_gateway.ipynb
@patch
async def get_pubs(self:AsyncKernelClient, timeout=0.2):
    "This is just used for quick tests"
    res = []
    try:
        while msg := await self.get_iopub_msg(timeout=timeout): res.append(msg)
    except Empty: pass
    return res

# %% ../nbs/00_gateway.ipynb
skip_outs = 'execute_input', 'status', 'update_display_data'

def _dict_without(d, skip):
    if not isinstance(skip, (dict,set,list,tuple)): rm = [skip]
    return {k: v for k, v in d.items() if k not in skip}

def msg_short(m): return _dict_without(m, ('header','parent_header'))
def print_short(m): print(msg_short(m))

# %% ../nbs/00_gateway.ipynb
def msgs_short(outs, msg_type=None):
    return [msg_short(o) for o in outs if msg_type is None or o['msg_type']==msg_type]

# %% ../nbs/00_gateway.ipynb
@patch
def jmsg(self:Session, cts, cts_typ, msg_id, msg_type="execute_request", user_expressions=None,
         store_history=True, silent=False, allow_stdin=True, stop_on_error=True):
    hdr = self.msg_header(msg_type)
    hdr['msg_id'] = msg_id
    content = {cts_typ: cts, 'silent': silent, 'store_history': store_history, 
               'allow_stdin': allow_stdin, 'stop_on_error': stop_on_error}
    if user_expressions is not None: content['user_expressions'] = user_expressions
    res = self.msg(msg_type, content, header=hdr)
    return res

@patch
@delegates(Session.jmsg)
async def send(self:KernelClient, cts, msg_id=None, cts_typ='code', **kwargs):
    if not msg_id: msg_id=unqid()
    jm = self.session.jmsg(cts, cts_typ, msg_id=msg_id, **kwargs)
    self.shell_channel.send(jm)
    return jm

# %% ../nbs/00_gateway.ipynb
@patch
@delegates(Session.jmsg)
async def send_wait(self:AsyncKernelClient, cts, msg_id=None, cts_typ='code', timeout=1, **kwargs):
    "Send a message and wait for the reply with matching msg_id"
    await asyncio.wait_for(self.lock.acquire(), timeout=timeout)
    try:
        msg_id = (await self.send(cts, msg_id, cts_typ=cts_typ, **kwargs))['msg_id']
        start = monotonic()
        while True:
            remaining = timeout - (monotonic()-start)
            if remaining<=0: raise TimeoutError()
            try: msg = await self.get_shell_msg(timeout=remaining)
            except Empty: raise TimeoutError() from None
            if msg.get('parent_header', {}).get('msg_id') == msg_id: return msg
    finally: self.lock.release()

# %% ../nbs/00_gateway.ipynb
def msg2output(o): return output_from_msg(o)

# %% ../nbs/00_gateway.ipynb
@patch
async def exec(self:AsyncKernelClient, func:str, *args, user_expressions=None, call=True, timeout=10, **kw):
    "Execute `func(*args, **kw)` using `send_wait()`"
    args_str = ", ".join(repr(arg) for arg in args)
    kwargs_str = ", ".join(f"{k}={v!r}" for k,v in kw.items())
    if call: params = '(' + args_str + (', ' if args and kw else '') + kwargs_str + ')'
    else: params = ''
    code = f'{func}{params}'
    return await self.send_wait(code, user_expressions=user_expressions, store_history=False, timeout=timeout)
#     except TimeoutError:
#         self.interrupt()
#         await self.get_shell_msg(timeout=5)
#         raise

# %% ../nbs/00_gateway.ipynb
class EvalException(Exception): pass

@patch
async def eval(self:AsyncKernelClient, func:str, *args, timeout=10, literal=True, **kw):
    "Result of running `func(*args, **kw)`"
    r = await self.exec(f'__res = {func}', *args, user_expressions={'__res': '__res'}, timeout=timeout, **kw)
    if not isinstance(r, Mapping) or 'content' not in r: raise EvalException(f"Eval failed: {r}")
    cts = r['content']
    if cts['status']!='ok': return f"{cts.get('ename')}: {cts.get('evalue')}"
    res = nested_idx(cts, 'user_expressions', '__res', 'data', 'text/plain')
    try: return literal_eval(res) if literal else res
    except Exception as e: return str(e)

# %% ../nbs/00_gateway.ipynb
@patch
def jmsg_loop(self:AsyncKernelClient, func:callable, exc:callable=noop, closed:callable=noop):
    async def f():
        running=True
        # setup listen for iopub and stdin similar to execute_interactive
        poller = zmq.asyncio.Poller()
        iopub_sock, stdin_sock = self.iopub_channel.socket, self.stdin_channel.socket
        poller.register(iopub_sock, zmq.POLLIN), poller.register(stdin_sock, zmq.POLLIN)

        while running:
            try:
                events = dict(await poller.poll(None))
                if stdin_sock in events and (jmsg := await self.get_stdin_msg()): func(jmsg)
                elif iopub_sock in events and (jmsg := await self.get_iopub_msg()): func(jmsg)
            except (RuntimeError,ZMQError) as e:
                closed(e)
                running=False
            except Exception as e: exc(str(e))
    return create_task(f())

# %% ../nbs/00_gateway.ipynb
@patch
def interrupt(self: KernelClient):
    "Manually sends an interrupt_request on the Control channel."
    msg = self.session.msg('interrupt_request', content={})
    @startthread  # separate thread needed to avoid blocking
    def f():
        self.control_channel.send(msg)
        if getattr(self.shell_channel, 'socket', None):
            # Needs some (any!) message to "wake up" the event q if cancelling async request
            self.execute('')
    return msg['header']['msg_id']

# %% ../nbs/00_gateway.ipynb
def error2iopub(jmsg):
    jmsg['header']['msg_type'] = 'error'
    return _dict_without(jmsg, ('parent_header',))

# %% ../nbs/00_gateway.ipynb
output_types = {'stream', 'execute_result', 'display_data', 'error', 'clear_output'}

def retr_outs(jmsgs):
    return [o for o in jmsgs if o['msg_type'] in output_types]

# %% ../nbs/00_gateway.ipynb
def _strip(s): return strip_ansi(escape(s))

# %% ../nbs/00_gateway.ipynb
def _mk_stream(name, text): return {'output_type': 'stream', 'name': name, 'text': text}

def concat_streams(outputs):
    "Concatenate stream outputs by name (stdout/stderr), preserving execute_result at end"
    streams,res,execute_results = {},[],[]
    
    for out in outputs:
        if out['output_type'] == 'stream':
            name, text = out['name'], out['text']
            streams[name] = streams.get(name, '') + text
        elif out['output_type'] == 'execute_result': execute_results.append(out)
        else: res.append(out)
    
    if 'stdout' in streams: res.append(_mk_stream('stdout', streams['stdout']))
    if 'stderr' in streams: res.append(_mk_stream('stderr', streams['stderr']))
    res.extend(execute_results)  # Add execute_results at the end
    return res

# %% ../nbs/00_gateway.ipynb
def normalize_text_latex(s:str):
    if not s: return s
    if re.match(r'^\\[\[(].*\\[\])]$', s, re.DOTALL): return s
    return re.sub(r'^\$\$(.*)\$\$$', r'\[\1\]', s, flags=re.DOTALL) if s[:2]=='$$' \
        else re.sub(  r'^\$(.*)\$$', r'\(\1\)', s, flags=re.DOTALL) if s[0]=='$'   \
        else rf'\({s}\)'

# %% ../nbs/00_gateway.ipynb
class ClassyPygmentsRenderer(PygmentsRenderer):
    formatter = HtmlFormatter()
    formatter.noclasses = False

# %% ../nbs/00_gateway.ipynb
def render_outputs(outputs, ansi_renderer=_strip, include_imgs=True, pygments=False, md_tfm=noop, html_tfm=noop):
    renderer = ClassyPygmentsRenderer if pygments else HTMLRenderer
    
    def _fmt(text, is_err=False):
        txt = ansi_renderer(text)
        xtra = "class='stderr'" if is_err else ''
        is_span = '<span class' in txt
        cls = 'nohighlight hljs' if is_span else ''
        return f"<pre {xtra}><code class='{cls}'>{txt}</code></pre>"
    
    def _r(out):
        otype = out['output_type']
        if otype == 'stream':
            return _fmt(out["text"], out['name']=='stderr')
        elif otype in ('display_data','execute_result'):
            _g = out['data'].get
            if d := _g('text/html'): return html_tfm(d)
            if d := _g('application/javascript'): return f'<script>{d}</script>'
            if d := _g('text/markdown'): return md_tfm(markdown(d, renderer=renderer))
            if d := _g('text/latex'): return f'<div>{normalize_text_latex(d)}</div>'
            if include_imgs:
                if d := _g('image/jpeg'): return f'<img src="data:image/jpeg;base64,{d}"/>'
                if d := _g('image/png'): return f'<img src="data:image/png;base64,{d}"/>'
                if d := _g('image/svg+xml'): return d
            if d := _g('text/plain'): return _fmt(d)
        elif otype == 'error': return _fmt('\n'.join(out.get('traceback', [])), True)
        return ''

    outputs = concat_streams(outputs)
    return '\n'.join(map(_r, outputs))

# %% ../nbs/00_gateway.ipynb
@patch
async def get_outs(self:AsyncKernelClient, code, timeout=5):
    msg = await self.send_wait(code, timeout=timeout)
    msgid = msg['parent_header']['msg_id']
    jmsgs = [o for o in await self.get_pubs() if o['parent_header'].get('msg_id')==msgid]
    return [msg2output(o) for o in retr_outs(jmsgs)]

# %% ../nbs/00_gateway.ipynb
@patch
async def xpush(self:AsyncKernelClient, **kwargs):
    await self.send(f'get_ipython().push({kwargs!r})')

# %% ../nbs/00_gateway.ipynb
@patch
async def ipy(self:AsyncKernelClient, meth, *args, **kwargs):
    return await self.eval('get_ipython().'+meth, *args, **kwargs)

def _mk_ipy(meth):
    async def f(self, *args, **kwargs): return await self.ipy(meth, *args, **kwargs)
    f.__name__ = meth
    patch_to(AsyncKernelClient)(f)

# %% ../nbs/00_gateway.ipynb
_ipy_funcs = ['ranked_complete', 'user_items', 'sig_help', 'get_vars', 'get_schemas', 'publish']
for o in _ipy_funcs: _mk_ipy(o)

# %% ../nbs/00_gateway.ipynb
@patch
async def retr(self: AsyncKernelClient, nm:str):
    "Retrieve a single variable value"
    return await self.eval(nm, call=False)

# %% ../nbs/00_gateway.ipynb
@patch
async def xenv(self: AsyncKernelClient, **kw):
    "Put all of `kw` in os.environ"
    code = 'import os as __os\n'
    code += '\n'.join(f'__os.environ[{k!r}]={str(v)!r}' for k,v in kw.items())
    return await self.send(code)
