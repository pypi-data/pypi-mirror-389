"""Create solveit in Fasthtml for course"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/08_core.ipynb.

# %% auto 0
__all__ = ['term', 'deps', 'data_store', 'Placements', 'dlg_domsel', 'edid', 'shift_key', 'SOLVERAG_URL', 'trigc_dlim', 'models',
           'nlines', 'mitem_cls', 'img_md_pat', 'data_kv', 'data_queues', 'dash_re', 'jupy_proxy', 'fl_ico',
           'ToggleButton', 'test_route', 'copy2clip', 'copy_msg_', 'uncollapse_msg_', 'toggle_header_collapse_',
           'toggle_skip_', 'toggle_pin_', 'copy_code_', 'split_code_', 'toggle_comment_', 'IconLink', 'vars_sidebar_',
           'MiniTerm', 'on_conn', 'on_disconn', 'on_message', 'terminal_', 'wsd_store', 'wsd_retrieve', 'cardify',
           'new_msgtype', 'add_runq', 'add_runq_', 'input_reply_', 'stop_', 'reset_', 'rm_msg_', 'msg_clipboard_',
           'put_msgs_seq', 'msg_paste_', 'run_all_', 'run_above_', 'run_below_', 'del_below_', 'set_md_header_',
           'set_mtyp_', 'continue_prompt_', 'curr_dialog_', 'add_html_', 'ChkException', 'chk_is', 'chk_isnt',
           'add_relative_', 'find_msgs', 'find_msgs_', 'msg_idx_', 'read_msg_', 'msg_insert_line_', 'msg_str_replace_',
           'msg_strs_replace_', 'msg_replace_lines_', 'complete_', 'sig_help_', 'collapse_', 'clamp_', 'chat_li',
           'ChatNavbar', 'copts', 'mk_editor', 'toggle_editor_default_', 'get_mode_options', 'ModeSelect',
           'update_dialog_mode_', 'ed_exp_btn_', 'msg2uri', 'editor_', 'upsert_msg_', 'split_msg_', 'add_above_',
           'add_below_', 'add_bottom_', 'dup_msg_', 'merge_msg_', 'chat_messages', 'chat_messages_', 'shift_up_',
           'shift_down_', 'fmt_contents_', 'search_', 'theme_switcher_', 'export_window_', 'claudec', 'ghost_',
           'superc_', 'supere_', 'write_secret_', 'SecretForm', 'rm_secret_', 'get_secrets_', 'relative_date',
           'Breadcrumbs', 'check_path', 'get_files', 'toggle_files_', 'settings_modal_', 'katex_script', 'toggle_btn',
           'info_', 'tips_', 'dialog2py', 'txt_outputs', 'dialog2md', 'dialog2py_all', 'sanitize_name', 'save_py_file',
           'toggle_export_', 'error_view', 'gistify', 'export_dialog_', 'show_card_', 'upload_url_', 'UploadZone_',
           'upload_file_', 'upload_attachment_', 'push_data_', 'pop_data_', 'push_data_blocking_', 'pop_data_blocking_',
           'delete_file_', 'duplicate_this_', 'overwrite_modal_', 'update_dialog_name_', 'DialogName', 'dlg2html',
           'html2blog', 'dialog2blog_md', 'publish_dlg_', 'LoaderButton', 'header_row', 'find_box', 'chat', 'get_dlg',
           'dialog_', 'create_dialog_', 'nbpath', 'rm_dialog_', 'duplicate_dialog_', 'duplicate_file_',
           'get_running_kernels_', 'stop_kernel_', 'restart_kernel_', 'dash_btn', 'Hyperlink', 'search_dlg_',
           'search_box', 'search_dlgs_', 'index', 'JupyProxy', 'ws_wildcard', 'wildcard']

# %% ../nbs/08_core.ipynb
from fasthtml.common import *
from fasthtml.components import Uk_input_tag
from fasthtml import ft
from fastcore.utils import *
from fastcore.ansi import strip_ansi
from fastcore.meta import delegates
from monsterui.all import *
from collections import defaultdict
from itertools import accumulate
from datetime import datetime
from ghapi.all import GhApi
from httpx import ConnectError
from zipfile import ZipFile
from datetime import datetime, date, UTC
from queue import Empty
from nbformat.v4 import new_code_cell
from itertools import starmap

from fastlucide.icons import spritesheet
import fasthtml.common as fh

import copy, json, httpx, shutil, os, pty, select, asyncio, html, signal, queue, nbformat, hashlib, regex, subprocess, tempfile, lxml

# %% ../nbs/08_core.ipynb
from . import __version__
from .setup_app import *
from .backend import *
from .ipynb import *
from .db import *
from .kernel import *
from .aimsg import *
from .cards import *
from .cmodes import *
from .texts import tips_text
from .gateway import *
from .app_xtras import *
from .file_editor import *

# %% ../nbs/08_core.ipynb
from fastlucide.icons import (
    Square_arrow_out_up_right, X, Menu, Download, Upload, Trash, Copy, Info, Power, Rotate_ccw,
    Arrow_left, Arrow_right, Message_circle_question, Maximize_2, Minimize_2, Loader_circle
)
from monsterui.foundations import stringify
import monsterui, fastlucide.icons as _ico
import git

# %% ../nbs/08_core.ipynb
def fl_ico(icon:str,cls=(),width=22,link=False,**kwargs):
    "Override UkIcon internal usage with fastlucide"
    fmt_ico = icon.capitalize().replace('-', '_')
    icon = getattr(_ico, fmt_ico, _ico.X)
    if not link: return icon(sz=width, cls=stringify(cls))
    return A(icon(sz=width), cls=(f"uk-icon-{'button' if button else 'link'}", stringify(cls)), **kwargs)

monsterui.franken.UkIcon = fl_ico
monsterui.franken.UkIconLink = partial(fl_ico, link=True)

# %% ../nbs/08_core.ipynb
def ToggleButton(*c, uk_tooltip='', cls='', **kwargs):
    return ToggleBtn(*c, checked_cls='bg-blue-500/80', cls=f'uk-btn-xs toggle-button {cls}',
                               label_kw=dict(tabindex="0", uk_tooltip=uk_tooltip), **kwargs)

# %% ../nbs/08_core.ipynb
@patch(cls_method=True)
async def __from_request__(cls:Dialog, data, req):
    nm = data['dlg_name']
    dlg = g_dlgs.get(nm)
    if dlg: write_perms(dlg)
    return dlg

# %% ../nbs/08_core.ipynb
@patch(cls_method=True)
async def __from_request__(cls:Message, data, req):
    dlg = await Dialog.__from_request__(data, req)
    if not dlg: return
    if not (msgid := data.get('msgid')): return print("msgid not found")
    return get_msg(msgid, dlg)

# %% ../nbs/08_core.ipynb
@rt
async def test_route(): return 'here'

# %% ../nbs/08_core.ipynb
def copy2clip(s):
    "Wrap clipboard op in timeout for safari compat"
    s = dumps(s)
    return Js(f'setTimeout(() => navigator.clipboard.writeText({s}), 0)')

@rt
def copy_msg_(msg:Message, is_input:int=1):
    if not msg: return
    cts = msg.content
    if not is_input:
        cts = msg.output
        if msg.msg_type==scode: cts = txt_outputs(cts)
    return copy2clip(cts)

# %% ../nbs/08_core.ipynb
@rt
def uncollapse_msg_(msg:Message): msg.uncollapse()

# %% ../nbs/08_core.ipynb
@rt
def toggle_header_collapse_(dlg:Dialog, msg:Message):
    "Toggle the heading_collapsed state of a message"
    if not msg: return
    msg.heading_collapsed = not msg.heading_collapsed
    dlg.enq(msg.toggle_hidden())

# %% ../nbs/08_core.ipynb
def _toggle_(msg, attr:str):
    val = not getattr(msg,attr)
    setattr(msg, attr, val)
    if msg.heading_collapsed and attr in ('skipped', 'pinned', 'is_exported'):
        for child in msg.children(): setattr(child, attr, val)
    msg.dlg.enq(msg)

# %% ../nbs/08_core.ipynb
@rt
def toggle_skip_(msg:Message):
    if not msg: return
    return _toggle_(msg, 'skipped'), hxrh("hide", msg.id)

# %% ../nbs/08_core.ipynb
@rt
def toggle_pin_(msg:Message):
    if not msg: return
    return _toggle_(msg, 'pinned'), hxrh("pin", msg.id)

# %% ../nbs/08_core.ipynb
def _mdcode(lang, o):
    o = o.strip()
    if lang in ('bash','sh') and o[0] != '!': return ('%%bash\n' if '\n' in o else '!') + o
    if lang in code_types + ('markdown','md'): return o
    return f'%%{lang}\n{o}'

# %% ../nbs/08_core.ipynb
@rt
def copy_code_(msg:Message):
    "Copy all python fenced blocks in an AI response into user's clipboard"
    if not msg: return
    cts = '\n'.join(_mdcode(*o) for o in get_md_blocks(msg.output, code=False))
    return copy2clip(cts)

# %% ../nbs/08_core.ipynb
def _lang2mt(lang): return snote if lang in ('markdown','md') else scode

@rt
def split_code_(msg:Message):
    "Split a message containing fenced blocks into separate messages for each block."
    msgs = [Message(content=_mdcode(l,c), msg_type=_lang2mt(l)) for l,c in get_md_blocks(msg.output, code=False)]
    msg.insert_after(msgs)
    mcs = [MessageCard(md, scroll=last) for last,md in loop_last(msgs)]
    msg.dlg.enq(Div(*mcs, hx_swap_oob=f'afterend:#{msg.id}'))
    return '', hxrh('extract-code-fences', msgs[0].id) if msgs else None

# %% ../nbs/08_core.ipynb
def _uncomment(l): return l[2:] if l.startswith('# ') else l[1:] if l.startswith('#') else l

@rt
def toggle_comment_(msg:Message):
    "Toggle comments on all lines in a code message based on current state"
    if not msg or msg.msg_type != scode: return
    lines = msg.content.splitlines()
    has_uncommented = any(line.strip() and not line.lstrip().startswith('#') for line in lines)
    if has_uncommented: msg.content = '\n'.join('# ' + l for l in lines)
    else: msg.content = '\n'.join(_uncomment(l) for l in lines)
    msg.dlg.enq(msg)

# %% ../nbs/08_core.ipynb
def IconLink(
    icon:callable,  # Icon from fastlucide
    sz:int=None, 
    cls='', # Additional classes on the icon
    button:bool=False, # Whether to use a button (defaults to a link)
    **kwargs # Additional args for `A` or `Button` tag
)->FT: # a lucide icon  button or link of the specified size
    "Creates an icon link using lucide icons"
    fn = fh.Button if button else fh.A
    return fn(cls=f"uk-icon-{'button' if button else 'link'} {cls}", **kwargs)(icon(sz=sz))

# %% ../nbs/08_core.ipynb
@rt
async def vars_sidebar_(dlg: Dialog, oob: bool = True, is_closed: bool = True, reset: bool = False):
    "Sidebar showing variables, functions, and headings"
    if not dlg or not is_closed: return ()
    try: vs, fs = ({}, {}) if reset else (await dlg.kc.user_items())
    except (TimeoutError, Empty, ValueError, EvalException): return HtmxResponseHeaders(reswap='none')
    sections = sb_data(dlg.messages, vs, fs)
    close_btn = IconLink(X, target_id="vars_cont", button=True, hx_get=vars_sidebar_.to(is_closed=False),
                                            cls='uk-btn uk-btn-default uk-btn-xs absolute top-2 right-2')
    
    # Trigger sidebar update after OOB message returned from ws - delay + hx_sync enables network debounce
    updt = dict(hx_trigger='htmx:wsAfterMessage[detail.message.includes("editable")] from:body delay:250ms')
    return Aside(close_btn, DivVStacked(*[sb_block(k,v) for k,v in sections.items()], cls="gap-2", id='sb_blocks'), 
                 hx_get=vars_sidebar_, hx_select='#sb_blocks', hx_target='#sb_blocks',
                 id='vars-sb', hx_swap_oob="innerHTML" if oob else None, hx_sync="this:drop", 
                 cls='h-full py-3 pr-4 w-[20vw] space-y-4 uk-overflow-auto relative', **updt)

# %% ../nbs/08_core.ipynb
def _clean_env():
    return {
        'PATH': os.environ.get('PATH', '/usr/local/bin:/usr/bin:/bin'),
        'HOME': '/app/data' if cfg_solveit['prod'] else os.environ['HOME'],
        'TERM': 'xterm', 'LANG': 'en_US.UTF-8', 'PAGER': 'less',
        'PYTHONPATH': os.environ.get('PYTHONPATH', ''),
        'PYTHONUNBUFFERED': '1',
        'AAI_USER_KEY': os.getenv('AAI_USER_KEY'),
        **get_secrets()
    }

# %% ../nbs/08_core.ipynb
class MiniTerm:
    def __init__(self, folder): self.fd,self.pid,self.folder = None,None,folder
    def read_pty(self): 
        "Read from PTY and return raw bytes"
        try:
            r,*_ = select.select([self.fd], [], [], 0.01)
            if r: return os.read(self.fd, 1024)
        except OSError as e: print(e)

    async def stream(self, send):
        'Continuously read from PTY and send to WebSocket'
        while True:
            if (o := self.read_pty()): await send(o)
            await asyncio.sleep(0.01)

    def spawn(self, send):
        "Fork process and replace child with solveit login shell"
        if self.fd: return
        env = _clean_env()
        self.pid,self.fd = pty.fork()
        if self.pid==0:
            os.chdir(self.folder)
            usera = ["-u", uname or "solveit"] if cfg_solveit['prod'] else []
            os.execvpe("/usr/bin/sudo", ["sudo", "-E"] + usera + ["bash", "-l"], env=env)
        self.task = asyncio.create_task(self.stream(send))

    def stop(self):
        if self.fd: self.task.cancel()
        if self.pid:
            try: os.killpg(os.getpgid(self.pid), signal.SIGTERM)
            except (OSError,ProcessLookupError): pass  # Process may have already terminated
        os.close(self.fd)
        self.fd = None

    def write(self, msg:str):
        'Write incoming message to existing PTY - stream handles output'
        if self.fd: os.write(self.fd, msg.encode())

# %% ../nbs/08_core.ipynb
term = None

# %% ../nbs/08_core.ipynb
import fcntl, termios, struct

# %% ../nbs/08_core.ipynb
async def on_conn(sock:WebSocket, send):
    global term
    term = MiniTerm(folder=datapath/sock.query_params.get('folder','.'))
    term.spawn(send)

async def on_disconn(**kw): term.stop()

@app.ws('/wst', conn=on_conn, disconn=on_disconn)
async def on_message(msg:str='', cols:int=0, rows:int=0):
    if msg: term.write(msg)
    elif cols and term.fd:
        fcntl.ioctl(term.fd, termios.TIOCSWINSZ, struct.pack('HHHH', rows, cols, 0, 0))

# %% ../nbs/08_core.ipynb
deps = (Script(src="assets/terminal.js", type="module"),
        Link(href='https://cdn.jsdelivr.net/npm/@xterm/xterm@5.5.0/css/xterm.min.css', rel='stylesheet'))

@rt
async def terminal_():
    return (
        Title('Solveit - Terminal'),
        Div(
            Div(id='terminal', cls="flex-1 bg-black text-white"),
            cls="flex flex-col h-screen"),
        deps)

# %% ../nbs/08_core.ipynb
data_store = {}

@rt
def wsd_store(key: str, data: dict):
    "Store data for websocket retrieval via wsd/."
    data_store[key] = data
    return {"status": "stored", "key": key}

@app.ws('/wsd')
async def wsd_retrieve(data: dict, send):
    try:
        res = {"status": "found", "data": data_store.pop(data['key'])} if data['key'] in data_store \
            else {"status": "not_found"}
        await send(dumps(res))
    except Exception as e: await send(dumps({"error": str(e)}))

# %% ../nbs/08_core.ipynb
def cardify(m):
    return MessageCard(m, scroll=True) if isinstance(m, Message) else Safe(m) if isinstance(m, str) else m

# %% ../nbs/08_core.ipynb
def new_msgtype(msg_type): return scode if get_setting('default_code') else msg_type

# %% ../nbs/08_core.ipynb
def add_runq(msg, cmd:str='run', api:bool=False):
    msg.clear_output()
    msg.oob,msg.run = 'true',True
    dlg = msg.dlg
    dlg.enq(msg)
    dlg.run_enq(msg.id)
    if api: return {'status':'queued'}
    if cmd != 'alt-run': return "", hxrh(cmd, msg.id)
    msg_type = new_msgtype(msg.msg_type)
    msgb = dlg.mk_message('', after=msg, msg_type=msg_type, oob=f'afterend:#{msg.id}', run=False)
    dlg.enq(msgb)
    return editor_(dlg, msg_type=msgb.msg_type, msgid=msgb.id), hxrh(cmd, msgb.id)

# %% ../nbs/08_core.ipynb
@rt
def add_runq_(msg:Message, cmd:str='run', api:bool=False):
    if not msg: return
    return add_runq(msg, cmd=cmd, api=api)

# %% ../nbs/08_core.ipynb
@rt
def input_reply_(msg:Message, user_input:str):
    if not msg: return
    msg.clear_output()
    msg.oob = 'true'
    dlg = msg.dlg
    dlg.enq(msg)
    dlg.kc.stdin_channel.send(dlg.kc.session.msg('input_reply', {'value': user_input}))

# %% ../nbs/08_core.ipynb
@rt
async def stop_(dlg:Dialog):
    if not dlg: return
    dlg.empty_runq()
    dlg.kc.interrupt()
    write_perms(dlg)

# %% ../nbs/08_core.ipynb
@rt
async def reset_(dlg:Dialog):
    if not dlg: return Redirect('/')
    await stop_(dlg)
    await asyncio.sleep(0.02)
    try: await dlg.restart()
    except Exception as e: print('XXXXX ', e)
    return Span(hx_swap_oob='innerHTML:.time-el'), await vars_sidebar_(dlg, oob=True, reset=True)

# %% ../nbs/08_core.ipynb
@rt
async def rm_msg_(dlg:Dialog, msid:str, msgid:str=None):
    if not(msg:=get_msg(msid, dlg)): return Redirect('/')
    if msg.heading_collapsed: [dlg.messages.remove(o) for o in msg.children()]
    m2select = msg.next_vis() or msg.previous_vis()
    dlg.messages.remove(msg)
    dlg.enq(Div(hx_swap_oob=f'delete:#{msid}'))
    _hxrh = hxrh('delete', m2select.id if m2select else None)
    # Only clear the editor msgid value if it matches msg being deleted (msid)
    if msgid==msid:
        dlg.enq(Hidden(value='', id='msgid'))
        return editor_(dlg), _hxrh
    return "", _hxrh

# %% ../nbs/08_core.ipynb
_msg_clipboard = []

@rt
def msg_clipboard_(msg:Message, cmd:str):
    "Add msg with `msgid` to clipboard."
    if not msg: return print('no clip msg')
    dlg = msg.dlg
    _msg_clipboard.clear()
    msg.run,msg.scroll=None,None
    _msg_clipboard.append(copy.copy(msg))
    if msg.heading_collapsed: _msg_clipboard.extend([copy.copy(o) for o in msg.children()])
    if cmd == 'copy': return ''
    # for the `cut` command we need to delete the message + its children
    target = msg.next_vis() or msg.previous_vis()
    if msg.heading_collapsed: [dlg.messages.remove(o) for o in msg.children()]
    dlg.messages.remove(msg)
    dlg.enq(Div(hx_swap_oob=f'delete:#{msg.id}'))
    return hxrh(cmd, target.id if target else None)

# %% ../nbs/08_core.ipynb
def put_msgs_seq(msgs, oob):
    "Put `msgs` sequentially into the DOM starting at `oob` (e.g. afterend:#xxx)."
    def _process_msg(oob, m):
        m.is_hidden = any([p.heading_collapsed for p in m.parents()])
        r = Div(Div(id=m.id, hidden=True), hx_swap_oob=oob) if m.is_hidden else MessageCard(m,oob=oob,scroll=True)
        m.dlg.enq(r)
        return f'afterend:#{m.id}'
    list(accumulate(msgs, _process_msg, initial=oob))

# %% ../nbs/08_core.ipynb
@rt
async def msg_paste_(dlg: Dialog, msg:Message, after:bool=True):
    "Paste clipboard msg(s) after/before the current selected msg (msgid)."
    if not _msg_clipboard or not dlg: return
    if after and getattr(msg, 'heading_collapsed', None): msg = last(msg.children())
    
    kw = {}
    if after: kw['after']  = msg
    else:     kw['before'] = msg
    msgs = dlg.mk_messages(_msg_clipboard, **kw)
    swap = 'afterend' if after else 'beforebegin'
    put_msgs_seq(msgs, f'{swap}:#{msg.id}' if msg else f'afterbegin:{dlg_domsel}')
    return hxrh('paste', last(m.id for m in msgs if m.is_visible()))

# %% ../nbs/08_core.ipynb
def _run_msgs(msgs):
    "Run all msgs"
    for m in listify(msgs):
        if m.msg_type==scode: add_runq(m)

# %% ../nbs/08_core.ipynb
@rt
async def run_all_(dlg:Dialog):
    if not dlg: return Redirect('/')
    _run_msgs(dlg.messages)

@rt
async def run_above_(msg:Message):
    if not msg: return
    msgs = msg.dlg.messages
    idx = msgs.index(msg)
    _run_msgs(msgs[:idx+1])
    return "", hxrh("run-above", msg.id)

@rt
async def run_below_(msg:Message):
    if not msg: return
    msgs = msg.dlg.messages
    idx = msgs.index(msg)
    _run_msgs(msgs[idx:])
    return "", hxrh("run-below", msg.id)

@rt
async def del_below_(msg:Message):
    "Delete all messages after message 'msgid' in the list"
    if not msg: return
    msgs = msg.dlg.messages
    idx = msgs.index(msg)
    to_del = msgs[idx+1:]
    msg.dlg.messages = msgs[:idx+1]
    msg.dlg.enq([Div(hx_swap_oob=f'delete:#{delmsg.id}') for delmsg in to_del])

# %% ../nbs/08_core.ipynb
_head_re = re.compile(r'^(#{1,6})\s')

@rt
async def set_md_header_(msg:Message, level:int):
    if getattr(msg, 'msg_type', None) != 'note': msg.msg_type = 'note'
    content = (msg.content or '')
    content = _head_re.sub('', content)
    content = f"{'#'*level} {content}"
    msg.content = content
    msg.dlg.enq(msg)

# %% ../nbs/08_core.ipynb
@rt
async def set_mtyp_(msg:Message, mtyp:str):
    if not msg: return
    msg.msg_type,msg._rcts,msg._rout = mtyp,None,None
    msg.dlg.enq(msg)

# %% ../nbs/08_core.ipynb
@rt
async def continue_prompt_(msg:Message, think:bool):
    if not msg: return
    dlg = msg.dlg
    res = dlg.mk_message(after=msg, content='.', msg_type=sprompt, use_thinking=think, oob=f'afterend:#{msg.id}')
    res.run,res.scroll = True,True
    dlg.enq(res)
    dlg.run_enq(res.id)
    return res.id

# %% ../nbs/08_core.ipynb
Placements = str_enum('Placements', 'add_after', 'add_before', 'update', 'at_start', 'at_end')
dlg_domsel = '#dialog-container'

# %% ../nbs/08_core.ipynb
@rt
async def curr_dialog_(dlg:Dialog, with_messages:bool=False):
    "Get the current dialog info."
    if not dlg: return
    res = dlg.todict()
    msgs = res.pop('messages')
    if with_messages: res['messages'] = [o.todict() for o in msgs]
    return res

# %% ../nbs/08_core.ipynb
@rt
async def add_html_(dlg:Dialog, content:str):
    "Send HTML through the web socket."
    dlg.enq(content)

# %% ../nbs/08_core.ipynb
class ChkException(Exception):
    @property
    def info(self): return self.args[0]
def chk_is(pred, msg, extype=ChkException):
    if not pred: raise extype(msg)
def chk_isnt(pred, msg, extype=ChkException):
    if pred: raise extype(msg)

# %% ../nbs/08_core.ipynb
def _chk_output(msg_type, output):
    if output is UNSET: return output if msg_type !=sprompt else ''
    chk_is(msg_type in smsg_types, "msg_type must be 'code', 'note', 'raw' or 'prompt'.")
    chk_isnt(msg_type in (snote, sraw) and output, "note and raw messages cannot have an output.")
    if msg_type==scode:
        output = output or '[]'
        try:
            output = json.loads(output)
            outkw = {'outputs':[nbformat.from_dict(o) for o in output]}
            c = new_code_cell("1", id="1", metadata={}, **outkw)
        except: raise ChkException("Code output must be valid notebook output json")
    return output

# %% ../nbs/08_core.ipynb
def _msg_kw(
    time_run:str=UNSET, is_exported:bool=UNSET, skipped:bool=UNSET,
    i_collapsed:bool=UNSET, o_collapsed:bool=UNSET, heading_collapsed:bool=UNSET, pinned:bool=UNSET): pass

# %% ../nbs/08_core.ipynb
@rt
@delegates(_msg_kw)
async def add_relative_(
    dlg:Dialog, msgid:str, content:str=UNSET, msg_type:str=UNSET, output:str=UNSET,
    placement:Placements=Placements.add_after, run:bool=False, **kwargs):
    "Add a new message to the queue."
    if not dlg: return 'err: No dialog'
    if placement!=Placements.update and msg_type not in smsg_types: return f"err: Unknown type: {msg_type}"
    if not (msg := get_msg(msgid, dlg)) and placement not in ['at_start', 'at_end']: return
    if not msg and placement=='update': return "err: Message to update not found"
    if msg_type is UNSET and msg: msg_type=msg.msg_type
    try: output = _chk_output(msg_type, output)
    except ChkException as e: return f'err: {e.info}'
    kwargs |= dict(content=content, msg_type=msg_type, output=output)
    mk = partial(dlg.mk_message, **kwargs)
    match placement:
        case Placements.update:
            res = msg.update(**kwargs)
            res.oob = 'true'
        case Placements.add_after: res = mk(after=msg, oob=f'afterend:#{msgid}')
        case Placements.add_before: res = mk(before=msg, oob=f'beforebegin:#{msgid}')
        case Placements.at_start: res = mk(idx=0, oob=f'afterbegin:{dlg_domsel}')
        case Placements.at_end: res = mk(idx=-1, oob=f'beforeend:{dlg_domsel}')
        case _: raise Exception('Unknown placement')
    res.run,res.scroll = run,run
    dlg.enq(res)
    if run: dlg.run_enq(res.id)
    return res.id

# %% ../nbs/08_core.ipynb
def find_msgs(messages: list[Message], pat:str='', msg_types=None, use_case:bool=False, use_regex:bool=True):
    pat = pat if use_regex or not pat else regex.escape(pat) # escape pat to do literal match if not using regex
    def _contains(attr, m):
        # TODO: handle searching code outputs
        if (cnt := getattr(m, attr)) and isinstance(cnt, str):
            flags = 0 if use_case else regex.IGNORECASE
            return regex.search(pat, cnt, flags)
    pats = []
    if pat:
        pats.append(partial(_contains, 'content'))
        pats.append(partial(_contains, 'output'))
    if pats: messages = L(messages).filter(lambda x: any(f(x) for f in pats))

    def _mtype(m): return m.msg_type in listify(msg_types)
    if msg_types: messages = L(messages).filter(_mtype)
    return messages

# %% ../nbs/08_core.ipynb
@rt
async def find_msgs_(dlg:Dialog, re_pattern:str='', msg_type:str=None, limit:int=None):
    "Find `list[dict]` of messages in current specific dialog that contain the given information."
    if not dlg: return {'msgs': []}
    res = [o.todict() for o in find_msgs(dlg.messages, pat=re_pattern, msg_types=msg_type)]
    return {'msgs': res[:limit] if limit else res}

# %% ../nbs/08_core.ipynb
@rt
async def msg_idx_(dlg:Dialog, msgid:str):
    "Find index of msgid in dialog."
    if not dlg: return {'msgid': ''}
    return {'msgid': dlg.messages.index(msgid)}

# %% ../nbs/08_core.ipynb
@rt
async def read_msg_(dlg:Dialog, msgid:str='', n:int=-1, relative:bool=True, view_range:list[int,int]=None, nums:bool=False):
    "Get the `Message` object indexed in the current dialog."
    if not dlg: return {'msg': ''}
    if msgid and not relative: return {'error': 'A `msgid` provided while `relative=False`'}
    msgs = dlg.messages
    if relative:
        idx = (await msg_idx_(dlg, msgid))['msgid']+n
        if not 0<=idx<len(msgs): return {'msg':None}
    else: idx = n
    msg = msgs[idx]
    res,lines = msg.todict(), msg.content.splitlines()
    s, e = view_range or (1,len(lines))
    if view_range:
        if not (1<=s<=len(lines)):            return {'error': f'Invalid start line {s}'}
        if e!=-1 and not (s<=e<=len(lines)):  return {'error': f'Error: Invalid end line {e}'}
        lines = lines[s-1:None if e==-1 else e]
    if nums: lines = [f'{i+s:6d} â”‚ {l}' for i, l in enumerate(lines)]
    res['content'] = '\n'.join(lines)
    return {'msg': res}

# %% ../nbs/08_core.ipynb
@rt
async def msg_insert_line_(dlg:Dialog, msgid:str, insert_line:int, new_str:str):
    "Insert new_str at specified location in message content"
    if not dlg: return {'error': 'Dialog not found'}
    if not (msg := get_msg(msgid, dlg)): return {'error': f'Message not found: {msgid}'}
    try:
        lines = msg.content.splitlines()
        if not (0 <= insert_line <= len(lines)): 
            return {'error': f'Invalid line number {insert_line}. Valid range: 0-{len(lines)}'}
        lines.insert(insert_line, new_str)
        msg.content, msg.oob = '\n'.join(lines), 'true'; dlg.enq(msg)
        return {'success': f'Inserted text after line {insert_line} in message {msgid}'}
    except Exception as e: return {'error': f'Error inserting text: {str(e)}'}

# %% ../nbs/08_core.ipynb
@rt
async def msg_str_replace_(dlg:Dialog, msgid:str, old_str:str, new_str:str):
    "Replace first occurrence of old_str with new_str in message content"
    if not dlg: return {'error': 'Dialog not found'}
    if not (msg := get_msg(msgid, dlg)): return {'error': f'Message not found: {msgid}'}
    try:
        content = msg.content
        count = content.count(old_str)
        if count == 0: return {'error': f"Text not found in message: {repr(old_str)}"}
        if count > 1:  return {'error': f"Multiple matches found ({count}) for text: {repr(old_str)}"}
        msg.content, msg.oob = content.replace(old_str, new_str, 1), 'true'; dlg.enq(msg)
        return {'success': f'Replaced text in message {msgid}'}
    except Exception as e: return {'error': f'Error replacing text: {str(e)}'}

# %% ../nbs/08_core.ipynb
@rt
async def msg_strs_replace_(dlg:Dialog, msgid:str, old_strs:list[str], new_strs:list[str]):
    "Replace multiple strings in message content - each old_str with corresponding new_str"
    if not dlg: return {'error': 'Dialog not found'}
    if not (msg := get_msg(msgid, dlg)): return {'error': f'Message not found: {msgid}'}

    if not isinstance(old_strs, list): return {'error': f"`old_strs` should be a list[str] but got {type(old_strs)}"}
    if not isinstance(new_strs, list): return {'error': f"`new_strs` should be a list[str] but got {type(new_strs)}"}
    if len(old_strs) != len(new_strs): return {'error': f"Length mismatch: {len(old_strs)} old_strs vs {len(new_strs)} new_strs"}
    try:
        content = msg.content        
        for idx, (old_str, new_str) in enumerate(zip(old_strs, new_strs)):
            count = content.count(old_str)
            if count == 0: return {'error': f"Text not found in message at index {idx}: {repr(old_str)}"}
            if count > 1:  return {'error': f"Multiple matches ({count}) found at index {idx} for: {repr(old_str)}"}
            content = content.replace(old_str, new_str, 1)
        msg.content, msg.oob = content, 'true'; dlg.enq(msg)
        return {'success': f'Successfully replaced all the strings in message {msgid}'}
    except Exception as e: return {'error': f'Error replacing strings: {str(e)}'}

# %% ../nbs/08_core.ipynb
@rt
async def msg_replace_lines_(dlg:Dialog, msgid:str, start_line:int, end_line:int, new_content:str):
    "Replace lines in message content using start and end line numbers (1-based indexing, inclusive)"
    if not dlg: return {'error': 'Dialog not found'}
    if not (msg := get_msg(msgid, dlg)): return {'error': f'Message not found: {msgid}'}
    try:
        lines = msg.content.splitlines(keepends=True)
        if not (1 <= start_line <= len(lines)): 
            return {'error': f'Invalid start line {start_line}. Valid range: 1-{len(lines)}'}
        if not (start_line <= end_line <= len(lines)):
            return {'error': f'Invalid end line {end_line}. Valid range: {start_line}-{len(lines)}'}
        if lines and not new_content.endswith('\n'): new_content += '\n'
        lines[start_line-1:end_line] = [new_content]
        msg.content, msg.oob = ''.join(lines), 'true'; dlg.enq(msg)        
        return {'success': f'Replaced lines {start_line} to {end_line} in message {msgid}'}
    except Exception as e: return {'error': f'Error replacing lines: {str(e)}'}

# %% ../nbs/08_core.ipynb
def _kind(jct):
    "Convert a jedi completion type `jct` to an appropriate `monaco.languages.CompletionItemKind`."
    if jct is None: return 'Text'
    if jct == 'instance': return 'Variable'
    if jct == 'param': return 'TypeParameter'
    if jct == 'path': return 'File'
    return jct.title()

# %% ../nbs/08_core.ipynb
@rt
async def complete_(dlg:Dialog, code:str, line_no:int, col_no:int):
    "Route for generating code completions for the monaco editor"
    if not dlg: return {'completions': []}
    def _range(start, end): 
        lines = code[:start].split('\n')
        start_line, start_col = len(lines) - 1, len(lines[-1])
        end_lines = code[:end].split('\n')
        end_line, end_col = len(end_lines) - 1, len(end_lines[-1])
        return dict(startLineNumber=start_line + 1, startColumn=start_col + 1, endLineNumber=end_line + 1, endColumn=end_col + 1)

    def _c(c):
        if isinstance(c, str): return {'text':c}
        return {'text':c['text'], 'kind':_kind(c['type']), 'detail':c['signature'], 'rank':c['rank'], 'range': _range(c['start'], c['end'])}

    try: res = await dlg.kc.ranked_complete(code=code, line_no=line_no, col_no=col_no)
    except TimeoutError: res = [] # This can happen 'cos user has long running message, which is OK
    except Exception as e:
        print('completion err: ', e)
        res = []
    if res and isinstance(res[0], str): return {'completions': res}
    return {'completions': [_c(c) for c in res if c is not Ellipsis and c['type'] != '<unknown>']}

# %% ../nbs/08_core.ipynb
@rt
async def sig_help_(dlg:Dialog, code:str, line_no:int, col_no:int):
    if not dlg: return {'values': []}
    try: res = await dlg.kc.sig_help(code=code, line_no=line_no, col_no=col_no)
    except TimeoutError: res = {} # This can happen 'cos user has long running message, which is OK
    return {'values': res or {}}

# %% ../nbs/08_core.ipynb
@rt
async def collapse_(msg:Message, is_input:int):
    "Update the collapsed state of message `msgid`"
    if not msg: return
    cf = 'i_collapsed' if is_input else 'o_collapsed'
    setattr(msg, cf, not getattr(msg, cf))
    msg.dlg.enq(msg)
    return "", hxrh("collapse", msg.id)

# %% ../nbs/08_core.ipynb
@rt
async def clamp_(msg:Message, is_input:int):
    "Clamp input or output card height"
    if not msg: return
    cf = 'i_clamp' if is_input else 'o_clamp'
    setattr(msg, cf, not getattr(msg, cf))
    msg.dlg.enq(msg)
    return "", hxrh("clamp", msg.id)

# %% ../nbs/08_core.ipynb
def chat_li(msg_type:str, is_active:bool):
    "Create editor navbar and add JS for handling keyboard shortcuts"
    k = {scode: 'J', snote: 'K', sprompt: 'L', sraw: ';'}[msg_type]
    lang = 'python' if msg_type==scode else 'plaintext' if msg_type==sraw else 'markdown'
    id = f"tabh-{msg_type}"
    js = f"clickEdTab('{id}', '{msg_type}', '{lang}');"
    cls = 'tabh uk-active' if is_active else 'tabh'
    return Li(cls=cls, id=id, uk_tooltip=f'C-â‡§-{k}', hx_on_click=js)(
        A(msg_type.capitalize()))

# %% ../nbs/08_core.ipynb
def ChatNavbar(msg_type:str=scode, is_input=True):
    btns = [scode, snote, sprompt, sraw] if is_input else [sprompt]
    lis = [chat_li(o, o==msg_type) for o in btns]
    return TabContainer(*lis, data_uk_tab=True)

# %% ../nbs/08_core.ipynb
def _mode(dlg):
    "Completion mode for dialog `did`."
    return LearningMode if dlg.mode == 'learning' else DevMode

def copts(dlg, mtype, caller='browser'):
    "Completion options (e.g. trigger characters) for the current dialog message and caller."
    def _usep(k): return k.startswith(mpfx) and k[2:] in cmps[caller]
    mpfx = 'c_' if mtype == 'code' else 'p_'
    mode = _mode(dlg)
    return {k[2:]:v for k,v in mode.items() if _usep(k)}

# %% ../nbs/08_core.ipynb
edid='myeditor'

def _should_log_completions(): return not cfg_solveit['prod'] and os.environ.get('LOG_COMPLETIONS',False)

def mk_editor(lang, content='', copts=None, msgid='', oob=True):
    "Create a monaco editor"
    opts = "{'language': '%s', 'autoClosingBrackets': false, 'value': %s}" % (lang, dumps(content).replace('</', '<\\/'))
    copts = dumps(copts or {})
    logcomp = str(_should_log_completions()).lower()
    enter_comp = 'true' if feature_enabled('ENTER_COMPLETION') else 'false'
    vim = str(bool(feature_enabled('USE_VIM'))).lower()
    return Script(f"createMonacoEditor('{edid}', {opts}, {copts}, {logcomp}, {enter_comp}, '{msgid}', {str(oob).lower()}, {vim})",
                  type='module', id='ed-script')

# %% ../nbs/08_core.ipynb
@rt
async def toggle_editor_default_(): set_setting('default_code', not get_setting('default_code'))

# %% ../nbs/08_core.ipynb
def get_mode_options(dlg):
    opts = ['standard', 'learning', 'concise']
    return tuple([ft.Option(o, selected=o==dlg.mode, cls='bg-background', value=o)
                  for o in opts])

def ModeSelect(dlg=None):
    if not dlg: return print('no mode dlg')
    return Div(cls="flex items-center space-x-2 mr-3")(
        ft.Select(*get_mode_options(dlg),
            cls="border rounded px-2 py-1 bg-transparent text-sm w-auto",
            hx_post=update_dialog_mode_, hx_trigger="change", name='mode')
        )

# %% ../nbs/08_core.ipynb
@rt
async def update_dialog_mode_(dlg:Dialog, mode:str):
    "Update dialog mode in DB and recreate editor with current content and mode settings"
    dlg.mode = mode
    write_perms(dlg)
    return get_mode_options(dlg)

# %% ../nbs/08_core.ipynb
@rt
def ed_exp_btn_(exp:bool=False):
    "Expand/Minimize editor button - `expandEd()` function moved to monedit.js"
    cls = "uk-btn-default uk-btn-icon uk-btn-sm"
    if exp: cls += ' ring'
    icon,tip = ((Maximize_2, "Maximize Editor (cmd/ctrl-â‡§-x)"), (Minimize_2, "Minimize Editor (cmd/ctrl-â‡§-x)"))[exp]
    return Button(icon(), hx_swap="outerHTML",   value=str(int(not exp)),
               name='exp', hx_post=ed_exp_btn_, cls=cls,   uk_tooltip=tip,
               hx_on__before_swap=f"expandEd(event, {str(exp).lower()})")

# %% ../nbs/08_core.ipynb
shift_key = 'â‡§'

def msg2uri(dlg_name, msgid, is_input):
    mstr = f"{msgid}-{is_input}" if msgid else "temp"
    return uri(f"{dlg_name}/{mstr}").rstrip('/')

@rt
def editor_(dlg:Dialog, msg_type:str=scode, content:str='', msgid:str='', oob:bool=True,
            is_input:int=1, output:str='', thinking:bool=None):
    "Create an editor with tab strip for code/text/ai"
    assert msgid or is_input, 'editor requires msgid or is_input'
    if not dlg: return Redirect('/')
    ico_cls = 'uk-btn-sm uk-btn-icon uk-btn-default '
    ed = mk_editor('python' if msg_type==scode else 'markdown', 
                   content=output if output and not is_input else content, copts=copts(dlg, msg_type), 
                   msgid=msg2uri(dlg.name, msgid, is_input), oob=oob)
    if msg:=get_msg(msgid, dlg): thinking=msg.use_thinking
    ups_kw = dict(hx_swap='none', hx_post='/upsert_msg_', hx_include=f'inherit, #{full_editor}')
    btns = DivRAligned(
        Button("Submit", uk_tooltip='C-Enter', cls=ButtonT.primary+'uk-btn-sm', id='submit_btn', **ups_kw),
        Button("âŒ", cls=ico_cls, id="cancel_btn", uk_tooltip='Escape',
               hx_vals={'cancel':'true'}, **ups_kw), ed_exp_btn_(), cls="gap-1.5 grow")

    top = DivHStacked(cls="flex-wrap gap-3")(
        ChatNavbar(msg_type, is_input=is_input),
        (ToggleButton("ðŸ§  Use Thinking", uk_tooltip=f'C-{shift_key}-d', id='use_thinking', checked=bool(thinking)) 
            if reasoning_effort() else None), btns)
    vimbar = Div(Div(id='vi-status'), hx_preserve=True, id='vi-ctn')
    return Card(ed, Div(id=edid, cls='monaco-editor-container', hx_preserve=True),
                vimbar if feature_enabled('USE_VIM') else None,
                Hidden(msg_type, 'msg_type'), Hidden(msgid, 'msgid'), Hidden(is_input, 'is_input'),
                Hidden('', 'content'), header=top, id=full_editor, hx_swap_oob='true' if oob else False,
                cls="p-1 space-y-1", body_cls="p-0", header_cls="p-0")

# %% ../nbs/08_core.ipynb
@rt
async def upsert_msg_(dlg:Dialog, content:str, msg_type:str='', msgid:str='',
                is_input:int=1, use_thinking:bool=False, cancel:bool=False, cmd:str='run'):
    "Insert or update a message in a dialog"
    if not dlg: return Redirect('/')
    assert msgid or is_input, 'upsert requires msgid or is_input'
    oob = 'true'
    if not msgid: msgid,oob = UNSET,f'beforeend:{dlg_domsel}'
    msg = get_msg(msgid, dlg) if msgid else dlg.mk_message('')
    if not msg: return print('no message')
    msgb = dlg.mk_message('', after=msg, msg_type=msg_type) if cmd == "alt-run" else None
    smode_id = msgb.id if msgb else msg.id
    editor = editor_(dlg, msg_type=new_msgtype(msg_type), msgid=msgb.id if msgb else '')
    if not is_input: # editing prompt output, so the content is the output
        msg.output=content
        dlg.enq(msg)
        return editor, hxrh(cmd, smode_id) # early return so we don't rerun when editing output
    if msg.msg_type != msg_type: msg._rcts,msg._rout = None,None
    msg.use_thinking,msg.msg_type,msg.content = use_thinking,msg_type,content
    if not cancel: msg.clear_output()
    if msg_type==scode and msg.is_exported: save_py_file(msg.dlg)
    run = (msg.msg_type!=snote) and not cancel
    msg.oob,msg.run,msg.scroll = oob, run, False
    dlg.enq(msg)
    if run: dlg.run_enq(msg.id)
    if msgb: dlg.enq(MessageCard(msgb, oob=f'afterend:#{msg.id}' if msgid else oob, scroll=True, run=False))
    return editor, hxrh(cmd, smode_id)

# %% ../nbs/08_core.ipynb
@rt
async def split_msg_(dlg:Dialog, prefix:str, suffix:str, msg_type:str='', msgid:str=''):
    "Split a message into two parts, handling positioning correctly"
    if not dlg: return Redirect('/')
    if not msgid: 
        msg = dlg.mk_message(prefix+suffix, msg_type=msg_type)
        msg.oob = 'beforeend:#dialog-container'
    elif not (msg := get_msg(msgid, dlg)): return
    msg.update(content=prefix.strip('\n'), msg_type=msg_type)
    suffix_msg = dlg.mk_message(content=suffix.strip('\n'), msg_type=msg_type, after=msg)
    # If HTMX ever adds an option to always strip on OOB, we can return both elements together here
    dlg.enq(msg)
    dlg.enq(MessageCard(suffix_msg, oob=f'afterend:#{msg.id}', scroll=True))
    return editor_(dlg, msg_type=scode if get_setting('default_code') else msg_type), hxrh("split",msg.id)

# %% ../nbs/08_core.ipynb
def _new_msg(msg, swap, dup=False, cmd=None, **kwargs):
    msg_type = scode if not dup and get_setting('default_code') else msg.msg_type
    dlg = msg.dlg
    nmsg = dlg.mk_message(msg.content if dup else '', msg_type=msg_type, **kwargs)
    dlg.enq(MessageCard(nmsg, is_selected=True, oob=f'{swap}:#{msg.id}'))
    return editor_(dlg, nmsg.msg_type, nmsg.content, msgid=nmsg.id), hxrh(cmd, nmsg.id)

def _calc_after(msg):
    "msg.mid or after last child"
    children = msg.children()
    return msg if not msg.heading_collapsed or not children else children[-1]

@rt
async def add_above_(msg:Message):
    if not msg: return
    return _new_msg(msg, cmd='add', swap='beforebegin', before=msg)

@rt
async def add_below_(msg:Message):
    if not msg: return
    return _new_msg(msg, cmd='add', swap='afterend', after=_calc_after(msg))

@rt
async def add_bottom_(dlg:Dialog):
    if not dlg: return Redirect('/')
    nmsg = dlg.mk_message('', msg_type=scode, idx=-1)
    dlg.enq(MessageCard(nmsg, is_selected=True, oob=f'beforeend:{dlg_domsel}'))
    return editor_(dlg, scode, nmsg.content, msgid=nmsg.id), hxrh('add', nmsg.id)

@rt
async def dup_msg_(msg:Message):
    if not msg: return
    return _new_msg(msg, cmd='add', swap='afterend', dup=True, after=_calc_after(msg))

# %% ../nbs/08_core.ipynb
def _aimsg_fmt(m): return f'## AI Prompt\n{m.content}\n## AI Response\n{m.output}'

@rt
async def merge_msg_(msg:Message, is_input: int):
    if not msg: return
    next_msg = msg.next()
    if not next_msg: return
    msg.dlg.messages.remove(next_msg)
    msg.dlg.enq(Div(hx_swap_oob=f'delete:#{next_msg.id}'))
    def c2md(m):
        lang = {snote: None, sprompt: None, scode: 'python', sraw: 'plaintext'}[m.msg_type]
        if m.msg_type == sprompt: return _aimsg_fmt(m)
        elif lang: return f'```{lang}\n{m.content}\n```'
        else: return m.content

    new_type = snote
    if msg.msg_type == next_msg.msg_type: new_type = msg.msg_type
    else: msg.content, next_msg.content = c2md(msg), c2md(next_msg)
    msg.update(content=msg.content + '\n' + next_msg.content, output=None, msg_type=new_type)
    msg.dlg.enq(msg)
    return "", hxrh("merge", msg.id)

# %% ../nbs/08_core.ipynb
def chat_messages(dlg:Dialog, oob:bool=None, uncollapse:bool=False, search:str='', msg_types=[], use_case=False, use_regex=True, hxsel=False):
    if not dlg: return Redirect('/')
    msgs = find_msgs(dlg.messages, search, msg_types, use_case, use_regex)
    if uncollapse: map(lambda m: m.uncollapse, msgs)
    selid = msgs[0].id if msgs and (search or msg_types) else '' # Select first message if filtered & msgs >= 1
    res = Div(map(MessageCard, msgs), hx_swap_oob=oob, id='dialog-container',
                      cls='flex flex-col grow overflow-y-scroll border px-3')
    return (res, hxrh('noop', selid)) if hxsel else res

# %% ../nbs/08_core.ipynb
@rt
async def chat_messages_(dlg:Dialog, oob:bool=None, uncollapse:bool=False, search:str=None, use_case:bool=None,
                         use_regex:bool=None, msg_types:list[str]=[]):
    return chat_messages(dlg, oob, uncollapse=uncollapse, search=search, msg_types=msg_types, use_case=use_case, use_regex=use_regex, hxsel=True)

# %% ../nbs/08_core.ipynb
def _shift_msg(msg:Message, is_up:bool):
    if not msg: return Redirect('/')
    dlg = msg.dlg
    adj_msg = msg.rel_msg(is_up)
    if adj_msg is None: return
    dlg.enq(Div(hx_swap_oob=f'delete:#{msg.id}'))
    next_msg = adj_msg.rel_msg(is_up)
    next_mid = next_msg.id if next_msg else None
    dlg.messages.remove(msg)
    adj_idx = dlg.messages.index(adj_msg)
    new_idx = adj_idx if is_up else adj_idx+1
    dlg.messages.insert(new_idx, msg)
    swap = 'beforebegin' if is_up else 'afterend'
    dlg.enq(MessageCard(msg, oob=f'{swap}:#{adj_msg.id}'))

@rt
async def shift_up_(msg:Message): return _shift_msg(msg, True)

@rt
async def shift_down_(msg:Message): return _shift_msg(msg, False)

# %% ../nbs/08_core.ipynb
@rt
async def fmt_contents_(r: dict):
    # remove .md and /md suffix from url
    url = r['doc_id']
    if url.endswith('html.md') or url.endswith('/md'): url = url[:-3]
    url = to_xml(A(r['description'], href=url, target='_blank'))
    return f'Score: {r["_relevance_score"]:.2f} -- {url}\n\n---\n\n{r["content"]}'

# %% ../nbs/08_core.ipynb
SOLVERAG_URL = os.environ.get('SOLVERAG_URL', 'http://172.17.0.1:5005')

@rt
async def search_(msg:Message, limit:int=5):
    try:
        if not msg: return
        res = httpx.post(f"{SOLVERAG_URL}/search", json={'content': msg.content, 'limit': limit},
                         headers={"Content-Type": "application/json"}, timeout=20.0).json()
        res = [MessageCard(dlg.mk_message(content=fmt_contents_(r), msg_type=snote, after=msg.mid, i_collapsed=True))
               for r in reversed(res)]
        return list(reversed(res))
    except Exception as e: return print('*** Search error: ', e)

# %% ../nbs/08_core.ipynb
def _custom_theme_guide():
    return Div(cls='m-8 lg:mx-64 lg:my-16')(
        P("You have enabled custom themes but haven't added a custom theme file!", cls='mb-4'),
        P(
            "Here's what you need to do:",
        ),
        Li(f"create a `solveit-theme.css` file in your static dir (i.e. {cfg_solveit['static_dir']})"),
        Li(
            "populate it with the contents of this starter ",
            A("theme", cls='text-blue-500 underline',
              href='https://raw.githubusercontent.com/AnswerDotAI/MonsterUI/refs/heads/main/docs/custom_theme.css',
              target="_blank"),
        ),
        Li("in your `solveit-theme.css` file replace `.uk-theme-grass` with `uk-theme-custom` and `.dark.uk-theme-grass` with `.dark.uk-theme-custom`"),
        Li("restart your solveit instance"),
        Li("revisit this theme picker and select the `Custom` theme"),
        P("Any further edits you make to `solveit-theme.css` will be immediately visible after you do a hard refresh in your browser (Windows: Ctrl+F5, Mac: Shift+Command+R).", cls='mt-4')
    )

@rt
def theme_switcher_():
    custom_themes = [('Custom', '#FFFFFF')] if has_custom_theme() else []
    return Div(_custom_theme_guide() if custom_theme_enabled() and not has_custom_theme() else None,
        ThemePicker(radii=True, shadows=False, custom_themes=custom_themes, cls='p-0')
    )

# %% ../nbs/08_core.ipynb
@rt
def export_window_(dlg:Dialog):
    "Route for exporting a dialog locally or gist as a python file or ipynb notebook"
    if not dlg: return Redirect('/')
    def _has_exported_msgs(): return bool(first(o for o in dlg.messages if o.is_exported))

    def _a(ext, text, enabled=True, dl=False, full=False):
        fname = f"{sanitize_name(dlg.name)}.{ext}"
        icon = Download(cls='ml-1.5 min-w-max') if dl else None
        btn_text = fname if dl else text
        cls = 'uk-btn-primary uk-btn-sm w-full'
        if full and dl: btn_text += ' (full)'
        return A(Button(P(btn_text,cls='uk-text-truncate'),icon,cls=cls,disabled=not enabled),
                href=export_dialog_.to(dlg_name=dlg.name, fname=fname, full=full, dl=dl),
                target="_blank" if not dl else None, download=fname if dl else None)
    
    def _grid(title, dl):
        return Div(H4(title),
             _a('ipynb', "Notebook (.ipynb)", dl=dl),
             _a('md', "Markdown (.md)", dl=dl),
             _a('py', "Full Script (.py)", dl=dl, full=True),
             _a('py', "Exported Code (.py)", enabled=_has_exported_msgs(), dl=dl),
             cls="grid gap-2 grid-cols-1 auto-cols-fr md:grid-cols-5")

    return Div(cls="grid gap-1.5 [&_hr]:my-0")(
        H3("Export Dialog", cls='text-center'), DividerLine(),
        _grid("Create Gist:", False), DividerLine(), _grid("Download File:", True))

# %% ../nbs/08_core.ipynb
trigc_dlim = '&;&'

def _tag_script():
    src = """
    function initTagInput(e) {
        const tags = e.querySelectorAll('uk-input-tag');
        tags.forEach(function(t) {
            Object.getPrototypeOf(t).initializeDefaults = function() {
                this.$tags = this.value === '' ? [] : this.value.split('%s');
            };
            t.initializeDefaults();
            t.addEventListener('keydown', (e) => { if (e.key === ',') {e.stopPropagation()}}, true);
        });
    }
    """
    return Script(src % (trigc_dlim,))

# %% ../nbs/08_core.ipynb
_ttips = {
    'model': 'Model used to generate the completion',
    'nlines': 'No. of lines to include in the completion',
    'temp': 'Control the variability of your completions. Range is 0 -> 1. Lower values produce more consistent completions, while higher values will increase variability.',
    'mftp': 'Only show completions that exceed a confidence threshold set by the slider below. Range is 0 -> 1, where 0 will show all completions and higher values will only show high confidence completions.',
    'acceptichars': 'Do you want to auto-accept completions that only contain invisible characters like `""` and `   \n`?',
    'scon': 'Do you want to see shell completions?',
    'triggeronaccept': 'Do you want to trigger another inline completion after accepting the current completion?',
    'triggerc': 'List of characters and keywords that will trigger a completion.'
}

def _cm_ttip(t): return f'title:{_ttips[t]};pos:top-left'

# %% ../nbs/08_core.ipynb
models = ('experimental-medium','gemini',)
nlines = [{'v': 'sline', 'n': 'single line'}, {'v': 'mline', 'n': 'multiple lines'}]

def _cmode_msg_fields(cm, mtype):
    m = 'c' if mtype == scode else 'p'
    def _v(a): return getattr(cm, f'{m}_{a}') if cm else None
    def _n(a): return f'{m}_{a}'
    def _tc(n): return f'{trigc_dlim}'.join(json.loads(_v(n)))
    
    return Div(cls='m-12 space-y-8')(
        LabelSelect(*[Option(o, selected=o == _v('model')) for o in models], label='Model', name=f'{m}_model', uk_tooltip=_cm_ttip('model')),
        LabelSelect(*[Option(o['n'], value=o['v'], selected=o['v'] == _v('nlines')) for o in nlines], label="No. of Lines", name=f'{m}_nlines', uk_tooltip=_cm_ttip('nlines')),
        LabelRange(name=_n('temp'), label='Temperature (0 -> 1)', min='0', max='1', step='0.01', value=str(_v('temp')) if cm else '0', uk_tooltip=_cm_ttip('temp')),
        LabelRange(name=_n('mftp'), label='Confidence Threshold (0 -> 1)', min='0', max='1', step='0.01', value=str(_v('mftp')) if cm else '0', uk_tooltip=_cm_ttip('mftp')),
        LabelSwitch(id=_n('acceptichars'), label='Auto accept invisible completions', input_cls='align-bottom', value=_v('acceptichars'), checked=_v('acceptichars'), uk_tooltip=_cm_ttip('acceptichars')),
        LabelSwitch(id=_n('scon'), label='Enable shell completions', input_cls='align-bottom', value=_v('scon'), checked=_v('scon'), uk_tooltip=_cm_ttip('scon')),
        LabelSwitch(id=_n('triggeronaccept'), label='Trigger new completion on acceptance', input_cls='align-bottom', checked=_v('triggeronaccept'), uk_tooltip=_cm_ttip('triggeronaccept')),
        Div(
            Div(cls='pb-2')(FormLabel('Trigger Characters/Keywords', fr=_n('triggerc'), uk_tooltip=_cm_ttip('triggerc'))),
            Uk_input_tag(name=_n('triggerc'), state="primary", value=_tc('triggerc') if cm else 'ret', uk_cloak=True, id=_n('triggerc')),
        ),
    )

# %% ../nbs/08_core.ipynb
_empty_completion = {"completions":[]}

# %% ../nbs/08_core.ipynb
def claudec(msg, pfx):
    try: res = run_ai(msg, prefill=pfx)
    except Exception as e: return print('*** Super completion error: ', e)
    return {'completions': [{'text': res.removeprefix(pfx)}]}

# %% ../nbs/08_core.ipynb
def _cout(c):
    "Only include `text` in completions."
    try: c = json.loads(c)
    except: return c
    return {'completions': [{'text': o.get('text', '')} for o in c['completions']]}

# %% ../nbs/08_core.ipynb
@rt
def ghost_(dlg:Dialog, msgid:str, mtype:str, pfx:str, sfx:str, req_id:str):
    "Proxy ghost completion requests to the AI server."
    r,ctx = run_ghost(dlg, get_msg(msgid, dlg), mt=7000, pfx=pfx, sfx=sfx, mtype=mtype, req_id=req_id)
    if 'completions' in r and r['completions']:
        r['completions'][0]['text'] = html.unescape(r['completions'][0]['text'])
    return _cout(r)

# %% ../nbs/08_core.ipynb
@rt
def superc_(dlg:Dialog, msgid:str, mtype:str, pfx:str, sfx:str):
    "Proxy super completion requests to the AI server."
    msg = get_msg(msgid, dlg)
    if mtype=="note" and msgid and msg.msg_type=="prompt": return claudec(msgid,pfx)
    r,_ = run_ghost(dlg, msg, mt=32_000, pfx=pfx, sfx=sfx, mtype=mtype, model='gpt41', nlines='mline',req_id='')
    return _cout(r)

# %% ../nbs/08_core.ipynb
@rt
def supere_(dlg:Dialog, msgid:str, mtype:str, pfx:str, sfx:str, hl:str, instr:str):
    "Proxy super edit requests to the AI server."
    r,_ = run_edit(dlg, get_msg(msgid, dlg), mt=32_000, pfx=pfx, sfx=sfx, mtype=mtype, model='gpt41',
                   hl=hl, instr=instr, nlines='mline', req_id='')
    return _cout(r)

# %% ../nbs/08_core.ipynb
@rt
async def write_secret_(s_name:str, secret:str):
    add_secret(s_name, secret)
    return SecretForm(),  Div(get_secrets_(), id='secrets', hx_swap_oob='true')

# %% ../nbs/08_core.ipynb
def SecretForm():
    return Form(
        LabelInput("Name", id='s_name', autocomplete="off",cls="space-y-0", required=True, input_cls='border-2'),
        LabelInput("Secret", id='secret', cls="space-y-0", required=True, type="password", input_cls='border-2'),
        Button("Save Secret", cls=ButtonT.primary + " w-full", submit=True),
        hx_post=write_secret_, hx_swap="outerHTML", id='secret_form')

# %% ../nbs/08_core.ipynb
@rt
async def rm_secret_(name:str):
    "remove a secret from the db and environment variables"
    delete_secret(name)

# %% ../nbs/08_core.ipynb
@rt
def get_secrets_():
    def _mk_secret(o):
        safe_id = hashlib.md5(o.encode()).hexdigest()[:12] # Prevent spaces etc from breaking the id
        del_btn = Button(X(uk_tooltip='Delete'), cls=icon_cls, hx_post=rm_secret_.to(name=o),
                         hx_target=f'#secret_{safe_id}', hx_swap='outerHTML')
        return Code(id=f'secret_{safe_id}', cls='uk-codespan truncate')(DivFullySpaced(o, del_btn))
    return Div(*map(_mk_secret, sorted(get_secrets().keys())), cls=(FlexT.block,FlexT.wrap,"gap-2 pt-3"))

# %% ../nbs/08_core.ipynb
def relative_date(dt):
    "Format datetime to show relative/concise dates"
    if isinstance(dt, float): dt = datetime.fromtimestamp(dt)
    if dt.date()==date.today(): return dt.strftime("%-I:%M %p")
    if dt.year==datetime.now().year: return dt.strftime("%b %d %-I%p")
    return dt.strftime("%Y-%m-%d")

# %% ../nbs/08_core.ipynb
def _dialog2row(path):
    nm = path.with_suffix('').name
    try: Dialog(name=nm, mode=read_mode(nm, path.parent))
    except: return Tr(Td(f"Couldn't parse {nm}"))
    last_modified = path.stat().st_mtime
    formatted_date = relative_date(last_modified)
    relpath = path.relative_to(datapath).with_suffix('')

    return Tr(
        Td(A(nm, href=dialog_.to(name=relpath), #hx_boost='true',
             cls='uk-btn uk-btn-secondary uk-width-1')),
        Td(formatted_date, cls="text-sm text-muted-foreground text-nowrap"),
        Td(Button(Trash(), uk_tooltip='Delete',
            cls='uk-btn uk-btn-destructive', hx_swap='outerHTML', hx_target='#dialogs',
            hx_post=qp('/rm_dialog_', name=relpath),
            hx_confirm=f"Are you sure you want to delete the dialog '{nm}'?")),
        Td(Button(Copy(), uk_tooltip='Duplicate',
            cls='uk-btn uk-btn-secondary',  hx_swap='outerHTML', hx_target='#dialogs',
            hx_get=qp('/duplicate_dialog_', name=relpath))),
        Td(A(Button(Download(), uk_tooltip='Download'), href=f'/static/{relpath}.ipynb', download=True)))

# %% ../nbs/08_core.ipynb
def _folder2row(path):
    nm = path.name
    last_modified = path.stat().st_mtime
    formatted_date = relative_date(last_modified)
    relpath = path.relative_to(datapath)

    return Tr(
        Td(Button(f"ðŸ“ {nm}", hx_get=index.to(at=relpath),
                  hx_target="body", hx_push_url="true",
                  cls=(ButtonT.secondary,'uk-width-1'))),
        Td(formatted_date, cls="text-sm text-muted-foreground text-nowrap"),
        Td(Button(Trash(), uk_tooltip='Delete',
            cls='uk-btn uk-btn-destructive', hx_swap='outerHTML', hx_target='#dialogs',
            hx_post=qp('/rm_dialog_', name=relpath),
            hx_confirm=f"Are you sure you want to delete the folder '{nm}'?")),
        Td(), id=f'dlg-{nm}')

# %% ../nbs/08_core.ipynb
def _file2row(path):
    nm = path.name
    last_mod = path.stat().st_mtime
    fm_date = relative_date(last_mod)
    relpath = path.relative_to(datapath)

    return Tr(
            Td(B(nm, cls='uk-text-truncate max-w-[400px]')) if path.suffix in not_editable else Td(A(nm, href=f"/file_editor_?fp={path}", cls='underline')),
            Td(fm_date, cls="text-sm text-muted-foreground text-nowrap"),
            Td(Button(Trash(), uk_tooltip='Delete',
                cls='uk-btn uk-btn-destructive', hx_swap='outerHTML', hx_target='#dialogs',
                hx_post=delete_file_, name='filename', value=nm,
                hx_confirm=f"Are you sure you want to delete the file '{nm}'?")),
            Td(Button(Copy(), uk_tooltip='Duplicate',
                cls='uk-btn uk-btn-secondary',  hx_swap='outerHTML', hx_target='#dialogs',
                hx_get=qp('/duplicate_file_', path=relpath))),
            Td(A(Button(Download(), uk_tooltip='Download'), href=f'/static/{relpath}', download=True)))

# %% ../nbs/08_core.ipynb
def _head(title, desc): return (H4(title), P(desc, cls=TextPresets.muted_sm))

# %% ../nbs/08_core.ipynb
def Breadcrumbs(at):
    if at == '.': return Ul(Li(Span('Home', aria_current='page')), cls='uk-breadcrumb')
    def _link(path):
        name = path.name or 'Home'
        if str(path) == at: return Li(Span(name, aria_current='page'))
        return Li(AX(name, index.to(at=path), hx_target='body', hx_push_url="true"))
    return Ul(map(_link, list(reversed(Path(at).parents))+[Path(at)]), cls='uk-breadcrumb')

# %% ../nbs/08_core.ipynb
def check_path(path):
    if (cfg_solveit['prod']) and not (path.resolve().is_relative_to(datapath.resolve())): raise ValueError("Path traversal detected")

# %% ../nbs/08_core.ipynb
def get_files(at:str='.'):
    path = datapath/at
    check_path(path)
    files = [o for o in path.ls() if o.name[0] not in ('_','.') and o.name not in ('tmp_modules','static','dev-static')]
    show_all = get_setting('show_all_files')
    def file_type(p):
        if p.is_dir(): return 'dirs'
        return 'dlgs' if p.suffix == '.ipynb' else 'files'
    
    groups = groupby(files, file_type)
    dirs = sorted(groups.get('dirs', []), key=lambda o: o.name)
    dlgs = sorted(groups.get('dlgs', []), key=lambda o: o.stat().st_mtime, reverse=True)
    files = sorted(groups.get('files', []), key=lambda o: o.stat().st_mtime, reverse=True) if show_all else []
    _th = partial(Th, cls='py-1 text-nowrap')
    tbl = Table(cls='uk-table-sm uk-table-justify uk-table-divider uk-table-middle', id='dlg-table')(
        Thead(Tr(map(_th, ['Name', 'Last Modified', 'Delete', 'Dupe', 'Down'])),
            cls="[&_th:first-child]:w-full"),
        Tbody(*map(_folder2row, dirs), *map(_file2row, files), *map(_dialog2row, dlgs))
    )
    file_tgl = LabelSwitch('Show all files?', name='toggle_files', id='toggle_files', hx_trigger='change',
                   hx_post=toggle_files_, checked=show_all, hx_target='#dlg-table',
                       hx_select='#dlg-table', hx_swap='outerHTML', cls='flex gap-1.5 items-center text-nowrap')
    return Card(tbl, header=DivFullySpaced(H4(Breadcrumbs(at)), DivHStacked(file_tgl, git_btn(path))),
                header_cls='p-3', cls='row-span-2 order-last md:order-first', id='dialogs')

@rt
async def toggle_files_(folder:str, toggle_files:bool=False):
    set_setting('show_all_files', toggle_files)
    return get_files(at=folder)

# %% ../nbs/08_core.ipynb
@rt
async def settings_modal_(dlg:Dialog, oob:bool=False):
    content_id = 'settings_content'  
    if not dlg: return Redirect('/')
    def _mk_Li(name, get, cls=''):
        return Li(A(name, hx_get=get, cls=cls, hx_target=f'#{content_id}'))

    nav_tabs = TabContainer(alt=True, uk_switcher=True)(
        _mk_Li('Export', export_window_),
        _mk_Li('Theme', theme_switcher_))
    
    header = Div(cls="relative")(
        ModalTitle(f"{dlg.name}: Settings", cls="text-2xl font-semibold text-center mb-4"),
        ModalCloseButton(cls=ButtonT.default+' absolute top-0 right-0'), nav_tabs)

    return Modal(header, Div(export_window_(dlg), id=content_id),
            body_cls="space-y-2 p-2", dialog_cls="uk-overflow-auto max-h-full",
            hx_swap_oob="true" if oob else None, hx_include='#dlg_name',
            style="z-index:1;", # this z-index makes our toasts and loaders visible
            id="settings-modal", hx_open=True)

# %% ../nbs/08_core.ipynb
def katex_script(force=False):
    if not force and not get_math_mode(): return None
    "Returns Script supplying katex"
    lnk = Link(rel="stylesheet", href="https://cdn.jsdelivr.net/npm/katex@0.16.22/dist/katex.min.css")
    imps = r'''import katex from 'https://cdn.jsdelivr.net/npm/katex@0.16.22/dist/katex.mjs';
import autoRender from 'https://cdn.jsdelivr.net/npm/katex@0.16.22/dist/contrib/auto-render.mjs';
const options = { 
    delimiters: [{left: "\\(", right: "\\)", display: false},{left: "\\[", right: "\\]", display: true}],
    ignoredClasses: ['nomath'], minRuleThickness: 0.06
};autoRender(document.body,options);'''
    if not force: imps+='''
if (!window.katex_loaded) {
    htmx.onLoad(o=>autoRender(o,options));
    window.katex_loaded = true;
}'''
    return lnk,Script(imps,type="module")

# %% ../nbs/08_core.ipynb
mitem_cls = ('uk-btn', 'uk-btn-icon','uk-btn-sm', 'text-lg', 'uk-btn-ghost', 'cursor-pointer')

def toggle_btn():
    "Toggle the variable sidebar"
    return Button(
        "ðŸ“–",
        hx_get=vars_sidebar_.to(oob=False),
        target_id="vars_cont", uk_tooltip='Contents (Ctrl-â‡§-V)',
        hx_vals='js:{is_closed: !document.getElementById("vars-sb")}',
        hx_trigger="click, keyup[ctrlKey&&shiftKey&&key=='V'] from:body",
        hx_sync='.toggle-btn:drop', cls=("toggle-btn",)+mitem_cls)

# %% ../nbs/08_core.ipynb
def _keyboard_shortcuts(osys="mac"):
    "List of keyboard shortcuts to be displayed in the info modal."
    def _sh(ks):
        sep = ' ' if 'or' in ks else ' + '
        return Td(Kbd(sep.join(ks), cls='font-geist-mono'),cls='text-nowrap')
    def _tbl(cap, items):
        return (H5(cap, cls='text-center'), 
                Table(Thead(Tr(Th('Command'), Th('Trigger', cls='w-44'))),
                      Tbody(*[(Tr(Td(l),_sh(k))) for l,k in items]),
                    cls='uk-table-justify uk-table-sm uk-table uk-table-divider w-[90%] mx-auto'))
    cmd = 'âŒ˜' if osys == 'mac' else 'Ctrl'
    opt = 'âŒ¥' if osys == 'mac' else 'Alt'
    
    navigation = [
        ('Select Message Above', ('â–²', 'or' ,'k'),),
        ('Select Message Below', ('â–¼', 'or', 'j'),),
        ('Jump to Top (alternate)', ('Fn', 'â—€')),
        ('Jump to Bottom (alternate)', ('Fn', 'â–¶')),
        ('Go to Start of Section', ('â—€',)),
        ('Go to End of Section', ('â–¶',)),
        ('Open Symbol Browser', ('Ctrl', shift_key, 'v')),
        ('Open Find Tool', ('f',)),
        ('Close Find Tool', (shift_key, 'f')),
    ]
    
    execution = [
        ('Run Message', (cmd, 'Enter')),
        ('Run Message & Insert Message Below', (opt, 'Enter')),
        ('Run Message & Select Message Below', (shift_key, 'Enter')),
        ('Run Messages Above', (shift_key, 'a')),
        ('Run Messages Below', (shift_key, 'b')),
        ('Run All Messages', ('r',)),
        ('Restart Kernel', (shift_key,'r')),
        ('Stop Execution/AI Stream', (shift_key,'s')),
        ('Save & Refresh', ('s',)),
    ]
    
    smode = [
        ('Edit Input', ('Enter',)),
        ('Edit Output', (']',)),
        ('Exit Edit Mode', ('Escape',)),
        ('Add Message Above', ('a',)),
        ('Add Message Below', ('b',)),
        ('Add Message to Bottom of Dialog', ('/'),),
        ('Delete Message', (shift_key,'d')),
        ('Cut Message', ('x',)),
        ('Copy Message', ('c',)),
        ('Paste Message', ('v',)),
        ('Duplicate Message', ('q',)),
        ('Duplicate Dialog', ('d',)),
        ('Export Message to Module', ('e',)),
        ('Extract Code Fences', ('w',)),
        ('Merge With Message Below', (shift_key, 'm')),
        ('Open Message in Tab', ('t',)),
        ('Open Message Output in Tab', ('y',)),
        ('Copy Input to Clipboard', (',',)),
        ('Copy Output to Clipboard', ('.',)),
        ('Copy Output Code to Clipboard', ('[',)),
    ]
    
    formatting = [
        ('Convert to Heading Level 1', ('1',)),
        ('Convert to Heading Level 2', ('2',)),
        ('Convert to Heading Level 3', ('3',)),
        ('Convert to Heading Level 4', ('4',)),
        ('Convert to Heading Level 5', ('5',)),
        ('Convert to Heading Level 6', ('6',)),
        ('Collapse Section', ('â—€',)),
        ('Expand Section', ('â–¶',)),
        ('Collapse/Expand Message Input', ('i',)),
        ('Collapse/Expand Message Output', ('o',)),
        ('Clamp Input Message Height', (shift_key, 'i')),
        ('Clamp Output Message Height', (shift_key, 'o')),
    ]
    
    context_mgmt = [
        ('Hide Message from AI', ('h',)),
        ('Pin Message to Context', ('p',)),
    ]
    
    edits = [
        ('Submit Message', (cmd, 'Enter')),
        ('Cancel Message', ('Escape',)),
        ('Copy Last Message', ('Ctrl', shift_key, 'â–²')),
        ('Split Message', ('Ctrl', shift_key, 'Minus')),
        ('Undo', (cmd, 'z')),
        ('Redo', (cmd, shift_key, 'z')),
    ]
    
    types = [
        ('Code Message', (cmd, shift_key, 'j')),
        ('Note Message', (cmd, shift_key, 'k')),
        ('Prompt Message', (cmd, shift_key, 'l')),
        ('Raw Message', (cmd, shift_key, ';')),
        ('Toggle Expanded View', (cmd, shift_key, 'x')),
    ]
    
    ai_features = [
        ('Trigger Inline Completion', (opt, '.')),
        ('Trigger Super Completion', (cmd, shift_key, '.')),
        ('Trigger Super Edit', (cmd, shift_key, '.')),
        ('Accept Inline Completion', ('Right',)),
        ('Continue (Standard Mode)', (cmd, shift_key, '.')),
        ('Continue (Thinking Mode)', (cmd, shift_key, '/')),
        ('Toggle Thinking Mode', (cmd, shift_key, 'd')),
        ('Capture Screenshot', (cmd, shift_key, ',')),
    ]
    
    completions = [
        ('Accept Shell Completion', ('Tab',)),
    ]
    
    editings = [
        ('Command Palette (expand view first)', ('F1',)),
        ('Select All Occurrences', (cmd, shift_key, 'b')),
        ('Move Line (or Selection) Up/Down', (opt, 'â–²/â–¼')),
        ('Copy Line Up/Down (Duplicate)', (opt, shift_key, 'â–²/â–¼')),
        ('Select Current Line', (cmd, 'l')),
        ('Add Cursors to Line Ends', (opt, shift_key, 'i')),
        ('Undo Last Cursor Operation', (cmd, 'u')),
        ('Jump to Matching Bracket', (cmd, shift_key, '\\')),
        ('Indent/Outdent Line', (cmd, ']/[')),
        ('Column Selection', (cmd, shift_key, opt, 'arrows')),
    ]
    
    system = [
        ('Open Terminal', (shift_key, 't')),
    ]
    
    _all = {
        'Navigation': navigation,
        'Code Execution': execution,
        'Selection Mode': smode,
        'Formatting & Layout': formatting,
        'Context Management': context_mgmt,
        'Message Editing': edits,
        'Message Types': types,
        'AI Features': ai_features,
        'Completions': completions,
        'Editor Operations': editings,
        'System': system
    }
    return Div(*starmap(_tbl,_all.items()), cls='grid gap-2 mx-auto')

# %% ../nbs/08_core.ipynb
@rt
async def info_(user_agent:str):
    "Information modal displaying a list of keyboard shortcuts."
    osys = 'mac' if 'Mac' in user_agent else 'windows'
    header = (ModalTitle('Keyboard Shortcuts', cls='uk-text-center text-2xl pb-4'), ModalCloseButton())
    
    return Modal(_keyboard_shortcuts(osys=osys),
        header=header, hx_open=True, body_cls="p-4 md:p-8 max-w-4xl mx-auto", footer=Br())

def _info_btn():
    return Button(cls=mitem_cls, id='info-btn', hx_get='/info_', hx_sync="this:drop", hx_target='body', hx_swap='beforeend')(
        Info(uk_tooltip='list of keyboard shortcuts')
    )

# %% ../nbs/08_core.ipynb
@rt
async def tips_():
    """Display a standalone documentation page with tips and documentation from info_tips.md"""
    back_button = A(href="/", cls=f"{ButtonT.primary} flex items-center px-4 py-2 text-base font-medium transition-colors hover:bg-opacity-90")(
        Arrow_left(cls="mr-2"), "Back to SolveIT")

    navbar = NavBar(back_button, brand=H1("SolveIT Tips", cls="text-2xl font-bold"))
    header = Div(navbar, cls="mb-8")
    
    info_tips_md = render_md(tips_text)
    content = Div(info_tips_md, cls="prose prose-slate max-w-3xl mx-auto")
    
    return Title("SolveIT Tips"), Container(header, content, cls="py-8")

# %% ../nbs/08_core.ipynb
def dialog2py(dlg):
    "Converts dialog to a string of python code "
    return '\n'.join([o.content for o in dlg.messages if o.is_exported])

# %% ../nbs/08_core.ipynb
def txt_outputs(output):
    "Convert ipython execution result to plain text"
    def txt_output(out):
        otype = out['output_type']
        if otype == 'stream': return strip_ansi(out['text']).strip()
        elif otype in ('display_data','execute_result'):
            data = out['data']
            for mt in ('text/html', 'application/javascript', 'text/markdown', 'image/svg+xml',
                       'text/latex', 'text/plain'):
                if d:=data.get(mt): return d
        return ''

    return '\n'.join(map(txt_output, output or []))

# %% ../nbs/08_core.ipynb
def dialog2md(dlg):
    "Converts dialog to a markdown file string"
    nb = get_ipynb(dlg)
    md_parts = []
    for cell in nb['cells']:
        source = cell['source']
        if cell['cell_type']=='markdown': md_parts.append(source)
        elif cell['cell_type']==scode:
            md_parts.append(f"```python\n{source}\n```")
            if cell.get('outputs'):
                output_str = txt_outputs(cell['outputs'])
                if output_str: md_parts.append(f"```\n{output_str}\n```")
    return '\n\n'.join(md_parts)

# %% ../nbs/08_core.ipynb
def dialog2py_all(dlg):
    "Converts all dialog messages to a string of python code, with non-code cells as comments"
    msgs = dlg.messages
    py_parts = []

    def comment_out(text, prefix="#"):
        if not text: return ""
        return '\n'.join(f'{prefix} {line}' for line in text.strip().splitlines())

    for msg in msgs:
        py_parts.append(f"# --- Cell: {msg.id} ({msg.msg_type}) ---")
        if msg.msg_type == scode:
            py_parts.append(msg.content)
            if msg.output:
                output_str = txt_outputs(msg.output)
                # Use '#>' to distinguish output comments
                if output_str: py_parts.append(comment_out(output_str, prefix="#>"))
        else: # snote or sprompt
            py_parts.append(comment_out(msg.content))
            if msg.output: # AI response
                py_parts.append(f"\n# --- Assistant Response ---")
                py_parts.append(comment_out(msg.output))
    return '\n\n'.join(py_parts)

# %% ../nbs/08_core.ipynb
def sanitize_name(name:str, ext:str='')->str:
    "Convert a dialog name into a valid Python module name."
    name = name.split('/')[-1]
    name = re.sub(r'\W+', '_', name)
    name = name.strip('_')
    if not name: name = 'untitled'
    if name[0].isdigit(): name = '_' + name # Is this allowed?
    return name + ext

# %% ../nbs/08_core.ipynb
def save_py_file(dlg):
    "Save exported messages as a .py file with the same dialog name."
    fpath = (datapath / Path(dlg.name).parent / sanitize_name(f"{dlg.name}", '.py')).expanduser().resolve()
    if Config.find('settings.ini', fpath.parent): return
    if code:=dialog2py(dlg).strip(): fpath.mk_write(code,'utf-8',uid=cfg_solveit['uid'],gid=cfg_solveit['gid'])
    else: fpath.unlink(missing_ok=True)

# %% ../nbs/08_core.ipynb
@rt
async def toggle_export_(msg:Message):
    if not msg: return
    res = _toggle_(msg, 'is_exported')
    save_py_file(msg.dlg)
    return res, hxrh("export", msg.id)

# %% ../nbs/08_core.ipynb
def error_view(err:str='', msg:str='', code_err:str=''):
    "A full-page error component - until notifications are sorted"
    base_cls = "uk-text-center h-screen flex flex-col items-center justify-center w-3/4 mx-auto gap-10 antialiased"
    def_title = 'Something went wrong.'
    def_msg = 'An unexpected error occurred. Please post on Discord and include the snippet below if shown.'
    error = Pre(Code(code_err))
    
    return Div(cls=base_cls)(
        H1(err if err else def_title, cls="font-semibold"),
        DividerLine(),
        H3(msg if msg else def_msg),
        error if code_err else None,
        Button(Arrow_left(sz=20),
                "Go back",
                cls=ButtonT.primary+' uk-text-large h-11 space-x-2',
                submit=False, onclick='window.close()'))

# %% ../nbs/08_core.ipynb
img_md_pat = re.compile(r'!\[(?P<alt>.*?)\]\((?P<url>[^\s]+)\)')

# %% ../nbs/08_core.ipynb
def gistify(fname, content):
    "Create gist and open new tab to the newly created gist, or error Response if no token"
    token_txt = Span('GITHUB_TOKEN', cls="uk-codespan text-lg")
    err_title = "No Github Token Found"
    err_msg = "You need to have a ",token_txt , " secret set to create a Gist."
    
    token = get_secret('GITHUB_TOKEN') or os.getenv('GITHUB_TOKEN', None)
    if not token: return error_view(err_title, err_msg)
    try:
        api = GhApi(token=token)
        res = api.create_gist(description='My Dialog', content=content, filename=fname, public=False)
        return Redirect(res.html_url)
    except Exception as e: return error_view(code_err=e)

# %% ../nbs/08_core.ipynb
def _safe_static_nm(md_url, nm_cnt):
    'Return safe names while avoiding name collisions from different folder paths'
    nm = Path(md_url.split('#')[0]).name
    nm_cnt[nm] = nm_cnt.get(nm, -1) + 1
    return f"{Path(nm).stem}_{nm_cnt[nm]}{Path(nm).suffix}" if nm_cnt[nm] else nm

# %% ../nbs/08_core.ipynb
def _repl_static_fn(m, nm_cnt, atts, dname):
    'Replace static image path and add as an attachment'
    if m['url'].startswith('attachment:'): return m.group(0)
    fp = img_static_path(m['url'].split('#')[0], dname)
    if not fp.exists(): return m.group(0)
    nm = _safe_static_nm(m['url'], nm_cnt)
    atts.append(Attachment(fp.read_bytes(), f"image/{fp.suffix[1:]}", nm))
    return f"![{m['alt']}](attachment:{nm})"

# %% ../nbs/08_core.ipynb
def _prep_img_export(msgs, dname):
    nm_cnt = {}
    for msg in msgs:
        if msg.msg_type == scode: continue
        msg.content = img_md_pat.sub(lambda m: _repl_static_fn(m, nm_cnt, msg.attachments, dname), msg.content)
    return msgs

# %% ../nbs/08_core.ipynb
@rt
async def export_dialog_(dlg:Dialog, sess, full:bool=False, dl:bool=False, fname:str=''):
    "Export dialog as file download or gist URL"
    ext = Path(fname).suffix
    if ext=='.ipynb':
        old_msgs = copy.deepcopy(dlg.messages)
        _prep_img_export(dlg.messages, dlg.name)
        content = write_ipynb(dlg, pinned=False)
        dlg.messages = old_msgs
    elif ext=='.md':  content = dialog2md(dlg)
    elif ext=='.py':  content = dialog2py_all(dlg) if full else dialog2py(dlg)
    else: content = ""
    if dl: return content
    return gistify(fname, content)

# %% ../nbs/08_core.ipynb
def _ws_div(dname, oob=False):
    kw = {'hx_swap_oob':'true'} if oob else {}
    return Div(ws_connect=qp('/ws', dlg_name=dname), hx_ext='ws', id='ws-div', **kw)

def _hidden_elems(nm):
    return Hidden(nm, 'dlg_name'), Span(id='js-script', hidden=True), spritesheet, _ws_div(nm), katex_script()

@rt
async def show_card_(msg:Message, with_input:bool=True):
    if not msg: return
    attrs = ['i_collapsed', 'o_collapsed']
    for i in attrs: setattr(msg, i, False)
    dname = msg.dlg.name
    cls = '' if with_input else 'out-only'
    return (
        Div(MessageCard(msg), cls=cls, id="popout-container", hx_include='#dlg_name'),
        *_hidden_elems(msg.dlg.name),
        hxrh("open-tab", msg.id)
    )

# %% ../nbs/08_core.ipynb
_share_solveit_url = 'https://share.solve.it.com'

# %% ../nbs/08_core.ipynb
def _upload_area(folder:str):
    kw = dict(hx_target='#upload-zone', hx_swap='outerHTML')
    btn_load = LoaderButton('Submit', hx_post=upload_url_.to(folder=folder), hx_include='#file_url',
                            cls='uk-btn-primary', **kw)
    lbl_cls = 'flex flex-col w-full gap-4 h-64 rounded-lg cursor-pointer hover:bg-zinc-400/10 \
                       items-center justify-center border-2 border-dashed text-muted-foreground'
    lbl_js = "event.preventDefault();htmx.find('#files').files = event.dataTransfer.files;"
    return Div(cls='grid gap-2 w-4/5 mx-auto')(
        ft_hx('label', cls=lbl_cls, ondragover="event.preventDefault()", ondrop=lbl_js)(
            Upload(sz=28),
            P("Click to upload, or drag files here", cls='text-lg'),
            Input(type="file", multiple=True, id='files', cls='hidden', hx_include='#files',
                  hx_trigger='change, drop from:closest label', hx_encoding="multipart/form-data",
                  hx_post=upload_file_.to(folder=folder), **kw)
        ),
        DividerSplit('or'),
        ft_hx('label', 'Upload via URL', _for='file_url', cls='uk-form-label'),
        DivHStacked(
            Input(id="file_url", type='url', placeholder="https://fastht.ml/docs/llms-ctx.txt"),
            btn_load)
    )

# %% ../nbs/08_core.ipynb
@rt
async def upload_url_(sess, folder:str, file_url:str):
    if not file_url: return add_toast(sess, f'invalid URL provided: {file_url}', 'error', dismiss=True)
    if file_url.startswith(f'{_share_solveit_url}/d/'): file_url = file_url.removesuffix('.html') + '.ipynb'
    try: res = httpx.get(file_url).raise_for_status()
    except Exception as e:
        print(e)
        return add_toast(sess, f'Error processing URL: {e}', 'error', dismiss=True)
    fn = regex.search(r'filename="([^"]+)"', res.headers.get('content-disposition', ''))
    fn = fn.group(1) if fn else file_url.split('/')[-1]
    check_path(fpath:=datapath/folder/fn)
    if fpath.exists(): return add_toast(sess, f'Error processing URL: {fn} already exists.', 'error', dismiss=True)
    fpath.write_text(res.text)
    add_toast(sess, f'Url saved to {fpath.name}', 'success', dismiss=True)
    return Div(get_files(at=folder), hx_swap_oob='outerHTML:#dialogs')

# %% ../nbs/08_core.ipynb
@rt
async def UploadZone_(folder:str):
    "Styled upload zone modal for users to drag/drop files into using MonsterUI modal"
    return Modal(_upload_area(folder), header=(H3('Upload'),ModalCloseButton()), footer=Nbsp(), id='upload-zone', hx_open=True)

# %% ../nbs/08_core.ipynb
@rt
async def upload_file_(sess, folder:str, files:list[UploadFile]=[]):
    "Save file to disk and insert image into db/UI"
    if not files: return add_toast(sess, "no file provided", 'error', dismiss=True)
    for file in files:
        contents = file.file.read()
        filename = datapath/folder/file.filename
        check_path(filename)
        filename.write_bytes(contents)
        uid,gid = cfg_solveit['uid'],cfg_solveit['gid']
        if uid>-1 or gid>-1: os.chown(filename, uid, gid)
        _msg = f'File saved to {filename}'
        add_toast(sess, _msg, 'success', dismiss=True)
    return Div(get_files(at=folder), hx_swap_oob='outerHTML:#dialogs')

# %% ../nbs/08_core.ipynb
@rt
async def upload_attachment_(dlg:Dialog, file:UploadFile, msgid:str, msg_type:str):
    if not (m := re.match(r"(?:pasted_image|last_output)_([0-9a-f-]{36})", file.filename)): return
    if not dlg: return Redirect('/')
    msg = get_msg(msgid, dlg) if msgid else dlg.mk_message('', msg_type=msg_type)
    if not msg: return
    if file.filename.startswith('last_output'):
        if old_match := re.search(r'<!-- last_output:([0-9a-f-]{36}) -->', msg.content):
            msg.attachments = [att for att in msg.attachments if att.id != old_match.group(1)]
    msg.attachments.append(Attachment(file.file.read(), file.content_type, id=m[1]))
    if not msgid: dlg.enq(MessageCard(msg, oob=f'beforeend:{dlg_domsel}'))
    # we return id so that when the user hits submit any changes will be saved to this message.
    return JSONResponse({'id': msg.id})

# %% ../nbs/08_core.ipynb
data_kv = {}

@rt
async def push_data_(data_id: str, data: dict): data_kv[data_id] = data

@rt
async def pop_data_(data_id: str): return data_kv.pop(data_id, None)

# %% ../nbs/08_core.ipynb
data_queues = defaultdict(queue.Queue)

@rt
async def push_data_blocking_(data_id: str, data: dict): data_queues[data_id].put(data)

@rt
async def pop_data_blocking_(data_id: str, timeout: int=5):
    try: return data_queues[data_id].get(timeout=timeout)
    except queue.Empty: return {'js_status':'timeout', 'error':"Timed out"}

# %% ../nbs/08_core.ipynb
def _delete_file(fn):
    fp = Path(fn)
    if fp.exists(): 
        if fp.is_dir(): shutil.rmtree(fp)
        else:           fp.unlink()

@rt
async def delete_file_(filename:str, folder:str):
    "Delete an uploaded file or directory"
    _delete_file(datapath/folder/filename)
    return Div(get_files(at=folder), hx_swap_oob='outerHTML:#dialogs')

# %% ../nbs/08_core.ipynb
@patch
def path(self:Dialog, basepath):
    return Path(basepath)/f'{self.name}.ipynb'

# %% ../nbs/08_core.ipynb
@rt
async def duplicate_this_(name:str):
    "Duplicate current dialog"
    dlg = _duplicate(name)
    return Redirect(dialog_.to(name=dlg.name))

# %% ../nbs/08_core.ipynb
@rt
def overwrite_modal_(new_name: str, route_path: str, **route_params):
    "Helper to create a confirmation modal for overwriting dialogs"
    return Modal(
        Div(P(f"A dialog named ", Strong(new_name), " already exists. Do you want to overwrite it?")),
        header = ModalCloseButton(cls=ButtonT.default+' absolute top-0 right-0'),
        footer=(Button("Overwrite", cls=ButtonT.destructive,
                   hx_post=qp(route_path, **route_params),
                   hx_target="body", hx_swap="innerHTML"),
        ),
        id="confirm-overwrite",
        hx_open=True,
    ), HtmxResponseHeaders(reswap='beforeend')

# %% ../nbs/08_core.ipynb
@rt
async def update_dialog_name_(dlg:Dialog, dname:str, force:bool=False):
    "Update dialog name"
    if not dname or dname == "<br>": dname = 'Untitled'
    if not dlg: return Redirect('/')
    if nbpath(dname).exists() and not force:
        return overwrite_modal_(dname, update_dialog_name_.to(), force=True, dname=dname, dlg_name=dlg.name)
    await dlg.rename(dname, datapath, uid=cfg_solveit['uid'], gid=cfg_solveit['gid'])
    await asyncio.sleep(0.01)
    if force: return Redirect(dialog_.to(name=dname))
    return Hidden(dname, 'dlg_name'), HtmxResponseHeaders(replace_url=dialog_.to(name=dname))

# %% ../nbs/08_core.ipynb
def DialogName(nm):
    nm_cls = "tracking-tighter md:text-3xl truncate focus-within:text-clip hover:underline decoration-dashed decoration-2 font-semibold underline-offset-4 text-2xl hover:focus-within:no-underline p-1 focus-within:bg-[hsl(var(--muted))]"
    return P(
        nm, id='dlg-name', contenteditable="plaintext-only",          hx_swap='outerHTML',
        hx_target="#dlg_name", cls=nm_cls, hx_get=update_dialog_name_, spellcheck="false",
        # Need js here since we're using contenteditable
        hx_vals="js:{dname:htmx.find('#dlg-name').textContent.trim()}",
        hx_trigger="blur consume", onkeydown="handleRenameKey(event)")

# %% ../nbs/08_core.ipynb
def dlg2html(dlg:Dialog):
    spy = Aside(ScrollSpy(), cls='sticky top-2 h-fit w-[15rem] hidden lg:block [&:has(ul:empty)]:hidden')
    head=Head(
        Meta(name="viewport", content="width=device-width, initial-scale=1, viewport-fit=cover"),
        *Theme.blue.headers(daisy=False, icons=False),
        Style(Path('./assets/styles.css').read_text()),
        Link(rel="stylesheet", href="https://cdn.jsdelivr.net/gh/fastai/fastcore@master/examples/ansi.css"),
        *katex_script(force=True))

    body = Body(cls='bg-background text-foreground [&_.uk-card-header_*:is(p,.uk-btn-ghost)]:hidden [&_.uk-card-header]:h-2 [&_.cursor-alias]:cursor-auto')(
        Main(cls='grid gap-1 h-full max-w-6xl mx-auto p-1')(
            Div(cls="bg-green-600 text-white py-3")(
                P("Try an interactive version of this dialog: Sign up at ", 
                  A("solve.it.com", href="https://solve.it.com", target="_blank", cls="underline"),
                  ", click Upload, and pass this URL.",
                  cls="text-center text-sm md:text-base"
            )),
            fh.Section(id='chat-box', cls='relative !px-1.5 flex min-w-0 gap-2')(
                Div(cls='grid flex-1 [&_pre]:w-fit [&_div]:min-w-0 [&_.relative]:grid [&_.highlight]:overflow-auto [&>div.space-y-3]:my-1.5 [&_.uk-card]:w-[95%]')(
                    *map(MessageCard, dlg.messages)), spy
            )
        ))
    return to_xml(Html(head, body))

# %% ../nbs/08_core.ipynb
def _rm(elem): elem.getparent().remove(elem)
    
def _proc_note(card): 
    "Remove card wrapper"
    card.getparent().replace(card, card.xpath('.//div[@class="space-y-3"]')[0])
    
def _proc_ai(card):
    "Remove card wrapper, keep output only, remove tool and thinking markers."
    card_out=card.xpath('.//div[contains(@class, "card-out")]')
    if not card_out: return _rm(card)
    card_out = card_out[0]
    for tool_detail in card_out.xpath('.//details[@class="tool-usage-details"]'): _rm(tool_detail)
    content = card_out.xpath('.//div[@class="space-y-3"]')[0]
    if (fp:=content.xpath('./p[1]')) and set(fp[0].text_content())=={'ðŸ§ '}: _rm(fp[0])
    for cf in content.xpath('.//div[@class="highlight"]'):
        cf.addprevious(newc:=lxml.html.fromstring('<div class="editable uk-card msg-card !pb-0 card-in" style="border-left-color:#4a90e2; border-left-width:5px"><div class="uk-card-body p-1.5 pt-1 flex-col"></div></div>'))
        newc[0].append(cf)
    card.getparent().replace(card, content)

# %% ../nbs/08_core.ipynb
def html2blog(html):
    "Turn note and ai response cells into main text"
    tree = lxml.html.fromstring(html)
    for card in tree.xpath('//div[contains(@class, "editable")]'):
        if card.xpath('.//input[@name="msg_type"][@value="note"]'): _proc_note(card)
        elif card.xpath('.//input[@name="msg_type"][@value="prompt"]'): _proc_ai(card)
    return lxml.html.tostring(tree, encoding='unicode', doctype='<!DOCTYPE html>')

# %% ../nbs/08_core.ipynb
def dialog2blog_md(dlg):
    "Convert dialog to markdown for blog publishing - note messages and prompt outputs only"
    return '\n\n'.join(
        (msg.content if msg.msg_type==snote else msg.output).strip() for msg in dlg.messages
        if msg.msg_type in (snote,sprompt))

# %% ../nbs/08_core.ipynb
@rt
def publish_dlg_(sess, dlg:Dialog):
    old_msgs = copy.deepcopy(dlg.messages)
    dlg.messages = [m for m in dlg.messages if not m.pinned]
    for m in dlg.messages: m.heading_collapsed,m.hidden = False,False
    dlg_html = dlg2html(dlg)
    _prep_img_export(dlg.messages, dlg.name)
    exported = [m for m in dlg.messages if m.is_exported]
    if exported: dlg.messages = exported
    blog_html = html2blog(dlg2html(dlg))
    blog_md= dialog2blog_md(dlg)
    dlg.messages = old_msgs
    res = httpx.post(
        f'{_share_solveit_url}/upload',headers={"Auth": os.environ['AAI_USER_KEY']},
        data=dict(
            name=dlg.name, version=__version__,
            dlg_html=dlg_html, blog_html= blog_html, blog_md=blog_md,
            ipynb=json.dumps(get_ipynb(dlg, pinned=False))
        ), follow_redirects=True)
    return res.url

# %% ../nbs/08_core.ipynb
def LoaderButton(*c, **kwargs):
    return Button(Span(*c, cls='group-disabled:opacity-0'), 
                  Loader_circle(cls='group-disabled:animate-spin group-enabled:hidden htmx-indicator absolute'), 
                  cls='relative group disabled:cursor-not-allowed '+kwargs.pop('cls','uk-btn-default'),
                  hx_disabled_elt='this', **kwargs)

# %% ../nbs/08_core.ipynb
def header_row(dlg):
    nm = dlg.name
    syncd = dict(hx_swap='none', hx_sync='body:queue all')
    kwchat = dict(hx_target=dlg_domsel, hx_swap='outerHTML', hx_sync='body:queue all')
    mitems = {
        "â¹ï¸": dict(hx_get=stop_, id='stop', uk_tooltip="Stop (â‡§-s)", **syncd),
        "â–¶ï¸": dict(hx_get=run_all_, id='run-all', uk_tooltip="Run all (r)", hx_ext="debug", **syncd),
        "ðŸ”„": dict(hx_post=reset_, id='reset', uk_tooltip="Restart (â‡§-r)", **syncd),
        "âš™ï¸": dict(hx_get=settings_modal_, id='settings', hx_target='body', hx_swap='beforeend', uk_tooltip="Settings"),
    }
    return NavBar(
        Div(cls='flex gap-1.5 items-center')(
            LoaderButton(
                "Publish", uk_tooltip='Share your dialog with your friends.',
                 cls=ButtonT.primary+'uk-btn-sm', id='publish_btn', 
                 hx_get=publish_dlg_, hx_swap='none',
                 hx_on__after_request='if(event.detail.successful) open(event.detail.xhr.response,"_blank")'),
            ToggleButton(
                'Default Code', uk_tooltip='Default new message type', id='default_code',
                checked=bool(get_setting('default_code')),hx_swap='none',
                hx_trigger='change', hx_post=toggle_editor_default_),
            ModeSelect(dlg),
            _info_btn()
        ),
        Button("â¬†ï¸", cls=mitem_cls, hx_get=UploadZone_.to(folder=Path(nm).parent), hx_target='body',
               hx_sync="this:drop", hx_swap='beforeend', uk_tooltip="Upload File"),
        *[Button(k, cls=mitem_cls, **v) for k,v in mitems.items()],
        A("ðŸ“‹", id='duplicate', href=duplicate_this_.to(name=nm),
          cls=mitem_cls, target='_blank', uk_tooltip="Duplicate Dialog (d)"),
        A('ðŸ–¥ï¸', id='terminal',  href=terminal_.to(folder=Path(nm).parent),
          cls=mitem_cls, target='_blank', uk_tooltip='Open Terminal (â‡§-t)'),
        toggle_btn(),
        brand=Div(cls='flex items-center gap-1 min-w-0')(
            A(H1("ðŸ“š solveit", cls='text-nowrap pr-1.5'),
              hx_get=index.to(at=Path(nm).parent, shutdown=nm),
              hx_target="body", hx_push_url=index.to(at=Path(nm).parent)),
            Span(cls="size-[16px] border rounded-full min-w-[16px]", id='ws-indicator',
                 hx_get=chat_messages_, **kwchat),
            DialogName(nm)),
        right_cls='items-center gap-0.5',
        cls="py-0")

# %% ../nbs/08_core.ipynb
def find_box(is_hidden=True):
    cls = 'flex flex-col absolute top-2 right-2 gap-2 items-center max-w-xl z-50 bg-background border rounded-lg p-2 shadow-lg'
    if is_hidden: cls += ' hidden'
    return Form(hx_post=chat_messages_.to(uncollapse=True), hx_select=dlg_domsel, hx_target=dlg_domsel, hx_trigger='input delay:400ms,submit',
                hx_swap='outerHTML', cls=cls, id='find-box')(
                Div(cls='uk-btn-group')(
                    ToggleButton(".*", uk_tooltip="Regex", id='use_regex'),
                    ToggleButton("Aa", uk_tooltip="Case Sensitive", id='use_case'),
                    ToggleButton("ðŸ”µ", uk_tooltip="Filter for Code Messages", name='msg_types', value=scode),
                    ToggleButton("ðŸŸ¢", uk_tooltip="Filter for Note Messages", name='msg_types', value=snote),
                    ToggleButton("ðŸ”´", uk_tooltip="Filter for Prompt Messages", name='msg_types', value=sprompt),
                    ToggleButton("ðŸŸ¡", uk_tooltip="Filter for Raw Messages", name='msg_types', value=sraw),
                    Button(X(sz=14), cls='uk-btn-xs', id="find_exit", uk_tooltip='Escape', onclick='closeFind();')
                ),
                Input(id='search', placeholder="Find...", cls='w-auto h-7 rounded-sm', 
                onkeydown="if(event.key==='Escape') this.blur()"))

# %% ../nbs/08_core.ipynb
def chat(dlg):
    top = header_row(dlg)
    return Div(id='chat-box',cls='relative flex flex-col grow min-w-0 gap-1 justify-between uk-container py-1 pb-2')(
               top, find_box(), chat_messages(dlg), editor_(dlg, oob=False))

# %% ../nbs/08_core.ipynb
async def get_dlg(nm):
    res = g_dlgs.get(nm)
    if res: write_perms(res)
    else:
        if not (res := read_ipynb(nm, datapath)): return
        await s_dlg(res, conv_func=cardify)
    return res

# %% ../nbs/08_core.ipynb
@rt
async def dialog_(name:str):
    "Primary chat interface"
    if not (dlg := await get_dlg(name)):
        return Titled(f'Dialog {name} Not Found', A('Return to Home', href='/', cls=(ButtonT.secondary, 'uk-btn')))
    dtitle = dlg.name.split('.')
    return (
        Title(cfg_solveit['title_prefix']+dlg.name.split('/')[-1]),
        Main(cls="flex h-screen", hx_include='#dlg_name')(
            chat(dlg),
            Div(id='vars_cont', cls="h-full", hx_on__after_settle='editor?.layout()')),
        *_hidden_elems(dlg.name),
        HtmxResponseHeaders(replace_url=dialog_.to(name=name))
    )

# %% ../nbs/08_core.ipynb
@rt
async def create_dialog_(name:str, folder:str, force:bool=False):
    "Create a new dialog"
    if not force:
        if folder and folder!='.': name = f'{folder}/{name}'
        if nbpath(name).exists():  return overwrite_modal_(name, create_dialog_.to(), force=True, name=name, folder=folder)
    dlg = Dialog(name=name)
    write_perms(dlg)
    return await dialog_(name=name)

# %% ../nbs/08_core.ipynb
def nbpath(nm:str): return datapath/f'{nm}.ipynb'

# %% ../nbs/08_core.ipynb
@rt
async def rm_dialog_(sess, name:str, folder:str='.'):
    "Delete dialog (or folder) and associated records"
    dest = datapath/name
    try:
        if dest.is_dir(): dest.rmdir()
        else:
            nbpath(name).unlink()
            await clear_dlg(name)
    except OSError as e:  add_toast(sess, f"Failed to delete: {e}", 'error', dismiss=True)
    return get_files(at=folder)

# %% ../nbs/08_core.ipynb
def _duplicate(name:str):
    "Duplicate a dialog with all its messages"
    orig = read_ipynb(name, datapath)
    base_name = re.sub(r'_dup\d+$', '', orig.name)
    n = 1
    while nbpath(f"{base_name}_dup{n}").exists(): n += 1
    dlg = Dialog(name=f"{base_name}_dup{n}", mode=orig.mode, messages=copy.deepcopy(orig.messages))
    for m in dlg.messages: m.dlg = dlg
    write_perms(dlg)
    return dlg

# %% ../nbs/08_core.ipynb
@rt
async def duplicate_dialog_(name:str, folder:str='.'):
    "Duplicate a dialog with all its messages"
    _duplicate(name)
    return get_files(at=folder)

# %% ../nbs/08_core.ipynb
@rt
async def duplicate_file_(path:Path):
    "Duplicate a dialog with all its messages"
    cnt = path.read_text()
    new_path = path.parent / (path.name + '(copy)')
    new_path.write_text(cnt)
    return get_files(at=path.parent)

# %% ../nbs/08_core.ipynb
@rt
def get_running_kernels_():
    bcls = 'uk-btn-xs w-full'
    def _kernel_row(name, dlg):
        stop_btn =    Button(Power(), cls=f'{bcls} uk-btn-destructive', hx_post=stop_kernel_.to(name=name),
                             hx_target='#running-kernels', hx_swap='outerHTML', uk_tooltip="Stop kernel")
        restart_btn = Button(Rotate_ccw(), cls=f'{bcls} uk-btn-default', hx_post=restart_kernel_.to(name=name), hx_target='#running-kernels', hx_swap='outerHTML', uk_tooltip="Restart kernel") 
        return Tr(Td(A(name, href=dialog_.to(name=name), cls='[all:revert]')), Td(Output("Ready" if dlg.ready else "...")),
                  Td(restart_btn), Td(stop_btn))
    kernels = g_dlgs.items() or {}
    caption = H4(f"Running Kernels: {len(kernels)}")
    thead = Thead(Tr(Th('Name', cls='w-full'), Th('Status'), Th('Restart'), Th('Shutdown'),
                     cls='[&_th:not(:nth-child(1))]:w-20'))
    content = Table(thead, Tbody(*[_kernel_row(name, dlg) for name, dlg in kernels]), cls="uk-table-hover uk-table-middle uk-table-divider uk-table-sm uk-table-justify [&_th]:!py-0")
    return Card(content, header=caption, footer=None,
            id='running-kernels', hx_get=get_running_kernels_, hx_swap="outerHTML",
            hx_trigger="every 2s [document.visibilityState === 'visible'] intersect")  # Polling to keep updated

@rt
async def stop_kernel_(name:str):
    await clear_dlg(name)
    return get_running_kernels_()

@rt
async def restart_kernel_(name:str):
    await g_dlgs[name].restart()
    return get_running_kernels_()

# %% ../nbs/08_core.ipynb
dash_re = re.compile(r'^[^.]+\.(?=.+\.)')
def dash_btn(req):
    "Dashboard button that maps to origin correctly"
    host, proto = req.headers['host'], req.headers.get('x-forwarded-proto', 'http')
    href = f"{proto}://{dash_re.sub('', host)}/dashboard"
    return A(Arrow_left(cls='mr-1'), "Dashboard", href=href, cls='uk-btn uk-btn-secondary')

# %% ../nbs/08_core.ipynb
def Hyperlink(*args, size='sm', **kwargs):
    return A(*args, cls=f'text-blue-500 hover:text-blue-700 underline text-{size}', **kwargs)

# %% ../nbs/08_core.ipynb
@rt
def search_dlg_(folder:str, file_glob:str, folder_re:str=None):
    def li(root,nm):
        x = Path(root)/nm
        name = x.absolute().relative_to(datapath).with_suffix('')
        return Li(Hyperlink(name, href=dialog_.to(name=name), target='_blank'))
    try:
        res = globtastic(datapath/folder, file_glob=f'{file_glob}.ipynb', folder_re=folder_re, func=li)
        return Ul(*res)
    except re.error as e: pass # ignore regex syntax errors

# %% ../nbs/08_core.ipynb
def search_box(folder:str):
    return Form(hx_post=search_dlg_.to(folder=folder), hx_trigger="keyup[key!='Tab'] changed delay:500ms", hx_target='#search_results', 
                id='search-box')(
                DivVStacked(cls="items-center gap-2")(
                    Input(id='file_glob', placeholder="File globâ€¦", autofocus=True, cls="px-2 h-8 text-sm border rounded"),
                    Input(id='folder_re', placeholder="Folder regexâ€¦", cls="px-2 h-8 text-sm border rounded")),
                Div(id='search_results'))

# %% ../nbs/08_core.ipynb
@rt
def search_dlgs_(folder:str):
    return Modal(search_box(folder), header=(H3('Search Dialogs'), ModalCloseButton()), footer=Nbsp(), id='search-dlgs', hx_open=True)

# %% ../nbs/08_core.ipynb
@rt
async def index(req, at:str='.', shutdown:str=''):
    "Main settings page to create and continue dialogs"
    if shutdown and (dlg:=g_dlgs.get(shutdown)):
        await stop_(dlg)
        await clear_dlg(shutdown, dlg)

    return Title('solveit'), Container(hx_include='inherit, #folder', id='root-container', cls='uk-container-xl')(
        Hidden(at, 'folder'),
        NavBar(
#             A(href="/tips_", target="_blank", uk_tooltip="Tips for using SolveIT", cls=icon_cls)(
#                 Message_circle_question(cls="w-5 h-5")),
            Button("Upload File", cls=ButtonT.secondary, hx_get=UploadZone_.to(folder=at), hx_target='body', hx_sync="this:drop", hx_swap='beforeend'),
            A('Terminal', href=terminal_.to(folder=at), cls=('uk-btn', ButtonT.secondary), target='_blank'),
            Button("ðŸ”", id='search_dlg', cls=ButtonT.secondary, hx_get=search_dlgs_.to(folder=at), hx_target='body', hx_sync="this:drop", hx_swap='beforeend'),
            brand=DivLAligned(dash_btn(req), H1("SolveIT"))
        ),
        Grid(
            get_files(at=at),
            Div(cls='space-y-3')(
                Card(Form(
                    LabelInput("Dialog Name", id='name', autocomplete="off", required=True, input_cls='border-2'),
                    Button("Create", cls=ButtonT.primary+" w-full"),
                    hx_post='/create_dialog_', hx_target="body"),
                    header=_head("Create New Dialog", "Enter a name and click `Create` to confirm.")),
                Card(SecretForm(),
                    Div(get_secrets_(), id='secrets'),
                    header=_head("Secrets", "Create & store a new secret.")),
                get_running_kernels_()),
        max_cols=2, cls='gap-4 md:!grid-cols-[3fr_2fr]'),
        P('Your feedback and dialogs will be used to help us improve SolveIt.',
          cls=(TextPresets.muted_sm, 'text-center', 'py-6')),
        spritesheet, Script(src='./assets/kb_shortcuts.js'))

# %% ../nbs/08_core.ipynb
import websockets,asyncio,httpx
from starlette.responses import StreamingResponse
from starlette.websockets import WebSocket
from starlette.endpoints import WebSocketEndpoint

# %% ../nbs/08_core.ipynb
class JupyProxy:
    "A proxy to forward requests to a local Jupyter-run server."
    def __init__(self, app:FastHTML, target_host:str="localhost", target_port:int=8000):
        self.target_base_url = f"http://{target_host}:{target_port}"
        self.target_ws_url = f"ws://{target_host}:{target_port}"
        self.client = httpx.AsyncClient(base_url=self.target_base_url)
        app.on_event("startup")(self.startup)
        app.on_event("shutdown")(self.shutdown)

    async def startup(self): await self.client.__aenter__()
    async def shutdown(self): await self.client.__aexit__()

    async def _proxy(self, request: Request, path: str):
        "The core proxy logic using a streaming response."
        url = httpx.URL(path=f"/{path}", query=request.url.query.encode("utf-8"))
        headers = dict(request.headers)
        headers.pop("host", None)
        rp = self.client.build_request(method=request.method, url=url, headers=headers, content=await request.body())
        r = await self.client.send(rp, stream=True)
        headers_to_exclude = ["content-encoding", "content-length", "transfer-encoding"]
        response_headers = {k:v for k,v in r.headers.items() if k.lower() not in headers_to_exclude}
        return StreamingResponse(content=r.aiter_bytes(), status_code=r.status_code,
            headers=response_headers, media_type=r.headers.get("content-type"))

# %% ../nbs/08_core.ipynb
@patch
async def _proxy_websocket(self:JupyProxy, websocket: WebSocket, path: str):
    "Proxy WebSocket connections to the target server."
    target_url = f"{self.target_ws_url}{path}"
    async with websockets.connect(target_url) as target_ws:
        async def forward_to_target():
            while True:
                message = await websocket.receive()
                if message["type"] == "websocket.receive":
                    if "text" in message: await target_ws.send(message["text"])
                    elif "bytes" in message: await target_ws.send(message["bytes"])
                        
        async def forward_to_client():
            async for message in target_ws:
                if isinstance(message, str): await websocket.send_text(message)
                else: await websocket.send_bytes(message)
                    
        await asyncio.gather(forward_to_target(), forward_to_client(), return_exceptions=True)

# %% ../nbs/08_core.ipynb
jupy_proxy = JupyProxy(app, target_port=8000)

# %% ../nbs/08_core.ipynb
async def ws_wildcard(websocket):
    await websocket.accept()
    path = websocket.url.path
    try: await jupy_proxy._proxy_websocket(websocket, path)
    except Exception as e:
        print('ws proxy err: ', e)
        await websocket.close(code=1011, reason="Connection failed")

app.add_websocket_route("/ws_{path:path}", ws_wildcard)

# %% ../nbs/08_core.ipynb
@rt("/{path:path}", methods=["GET", "POST", "PUT", "DELETE"])
async def wildcard(path:str, request):
    err404 = HTMLResponse(content=f'404 {path} not found', status_code=404)
    if path.endswith('_') or path.startswith('/.') or path.startswith('.'): return err404
    try: return await jupy_proxy._proxy(request, path)
    except ConnectError: return err404
