"""Create solveit in Fasthtml for course"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/02_backend.ipynb.

# %% auto 0
__all__ = ['var_pat', 'im_max', 'Chunk', 'mk_chunks', 'extract_output', 'msg_tag', 'msgs_tag', 'ctx_tags', 'get_vars', 'vars_tag',
           'important_tag', 'task_tags', 'mk_first_prompt', 'get_tools', 'read_imgb', 'get_img_files',
           'img_static_path', 'mk_img_ctx', 'chunk_xml', 'mk_final_prompt', 'mk_history', 'insert_icl', 'qwen_prompt',
           'edit_prompt']

# %% ../nbs/02_backend.ipynb
from .db import sprompt,scode,cfg_solveit,Message

from itertools import chain
import re, base64, hashlib, httpx
from itertools import chain
from io import BytesIO
from PIL import Image as PImg
from fastcore import imghdr
from fastcore.utils import *
from fastcore.test import *
from fastcore.xml import (
    to_xml, Context, Image, Instructions, Output, Outputs, Prompt, Variable, Variables, CellSource,
    Context, Important, Variables, Variable,
    Message as XMLMessage, Messages as XMLMessages)

# %% ../nbs/02_backend.ipynb
class Chunk(BasicRepr):
    def __init__(self, context:list, prompt): store_attr()
    @property
    def messages(self): return self.context+[self.prompt]
    @property
    def attachments(self): return [p for o in self.messages for p in o.attachments]

type Chunks = list[Chunk]

# %% ../nbs/02_backend.ipynb
def mk_chunks(msgs: list[Message]):
    "Slice message list into `Chunk`s. when a `prompt` row is seen -> emit Chunk."
    ctx,chunks = [],[]
    for m in msgs:
        if m.msg_type=="prompt":
            chunks.append(Chunk(prompt=m, context=ctx))
            ctx = []
        else: ctx.append(m)
    if len(ctx) > 0: chunks.append(Chunk(prompt=Message(content='', output=''), context=ctx))
    return chunks

# %% ../nbs/02_backend.ipynb
def extract_output(out):
    output_type = out['output_type']
    if output_type == 'stream': text = out.get('text', "")
    elif output_type == 'error':
        text = f"{out.get('ename', 'Error')}: {out.get('evalue', '')}"
        if 'traceback' in out: text += '\n' + '\n'.join(out['traceback'])
    elif output_type in ('execute_result', 'display_data'):
        data = out.get('data', {})
        text = data['text/plain'] if 'text/plain' in data else ''
    else: text = 'Error: Failed to parse unknown output type for a code cell.'
    return Output(text, type=output_type)

# %% ../nbs/02_backend.ipynb
def msg_tag(m):
    elems = [CellSource(m.content)]
    if m.msg_type=='code' and m.output: 
        elems.append(Outputs(extract_output(out) for out in m.output if out))
    return XMLMessage(*elems, type=m.msg_type, id=m.id)

# %% ../nbs/02_backend.ipynb
def msgs_tag(msgs: list[dict]):
    "Return a <messages>â€¦ element or None when msgs==[]."    
    return XMLMessages("*NB:* These messages have been executed since the last prompt.", *[msg_tag(o) for o in msgs]) if msgs else None

# %% ../nbs/02_backend.ipynb
def ctx_tags(chunks: list[Chunk]): return [msgs_tag(chunk.context) for chunk in chunks]

# %% ../nbs/02_backend.ipynb
var_pat = re.compile(r'\$`(\w+)`')

def get_vars(msgs):
    cts = ' '.join((m.content or '') for m in msgs if m.msg_type=='prompt')
    return set(var_pat.findall(cts))

# %% ../nbs/02_backend.ipynb
def vars_tag(ns=None):
    "<Variables> element for this chunk"
    if not ns: return None    
    lead = f"The 'variables' section provides values of: {', '.join(f'$`{v}`' for v in ns)}"
    vs = [Variable(v, name=k, type=type(v).__name__) for k,v in ns.items()]
    return Variables(lead, *vs)

# %% ../nbs/02_backend.ipynb
def important_tag(important_prompt: str): return Important('**NB**: ' + important_prompt) if important_prompt else None

# %% ../nbs/02_backend.ipynb
def task_tags(task: str, sid=None):
    kw = {'sid':sid} if sid else {}
    return Instructions('Respond to the request in the `prompt` below.'), Prompt(task, **kw)

# %% ../nbs/02_backend.ipynb
def mk_first_prompt(important_prompt: str, ns=None):
    vt = vars_tag(ns) if ns else None
    if not vt and not important_prompt: return ['','']
    pre_instr, pre_task = task_tags("The user has provided context that is important for the task they are "
                "looking to complete.  Pay special attention to this context information when you respond.")
    xml_parts = []
    if vt: xml_parts.append(to_xml(Context(vt), do_escape=False))
    if imp_tag := important_tag(important_prompt): xml_parts.append(to_xml(imp_tag, do_escape=False))
    xml_parts.append(to_xml(pre_instr, do_escape=False))
    xml_parts.append(to_xml(pre_task, do_escape=False))    
    pre_xml = '\n'.join(xml_parts)
    return [[pre_xml], "I have carefully read the contexts of each context provided and will pay special attention when responding to the user."]

# %% ../nbs/02_backend.ipynb
def get_tools(msgs):
    "Return the set of tool names referenced (via &`tool`) in a single `Chunk`."
    cts = ' '.join(m.content for m in msgs if m.msg_type in ('prompt','note'))
    ms = re.findall(r'&`(.*?)`', cts) # get content between &``
    return set(t for m in ms for t in re.findall(r'(\w+)', m)) # split tool names within &`[foo, bar]`

# %% ../nbs/02_backend.ipynb
im_max = 512**2

def _resize_img(data: bytes, max_im_sz=im_max):
    "Resize `data` so that it's area is <= `max_im_sz`."
    img = PImg.open(BytesIO(data))
    w,h = img.size;
    if w*h <= max_im_sz: return data
    scale = (max_im_sz/(w*h))**0.5; rw,rh = int(w*scale),int(h*scale)
    img_r = img.resize((rw, rh), PImg.Resampling.LANCZOS)
    img_b = BytesIO()
    img_r.save(img_b, format=img.format)
    return img_b.getvalue()

# %% ../nbs/02_backend.ipynb
def read_imgb(data): return PImg.open(BytesIO(data))

# %% ../nbs/02_backend.ipynb
def get_img_files(o):
    img_exts = '.jpg .jpeg .png .gif .bmp .webp'.split()
    return L(Path(o).iterdir()).filter(lambda x: x.suffix.lower() in (img_exts))

# %% ../nbs/02_backend.ipynb
def _is_img(v):
    "Check if `v` is an image."
    return isinstance(v, bytes) and bool(imghdr.what(None, h=v))

# %% ../nbs/02_backend.ipynb
def _img_xml(img_type, img_id):
    "Create an image tag."
    return to_xml(Image(id=img_id, type=img_type))

# %% ../nbs/02_backend.ipynb
def _img_atts(atts: list[dict], max_im_sz=512*512):
    "Build image context from attachments, including resize and encoding."
    def _tag(a): return [to_xml(_img_xml('content', a.id)), _resize_img(a.data, max_im_sz)]
    return list(chain.from_iterable(_tag(o) for o in atts if _is_img(o.data)))

# %% ../nbs/02_backend.ipynb
def _img_id(im_bytes):
    "Generate a deterministic 8 char id from `im_bytes`"
    h = hashlib.md5(im_bytes)
    return base64.b32encode(h.digest()).decode('utf-8')[:8]

# %% ../nbs/02_backend.ipynb
def _img_output(m, max_im_sz):
    "Extract any image outputs from `m` and return a list of encoded images and their xml tags."
    def _tag(img): return [_img_xml('output', _img_id(img)), img]
    outs = []
    for o in m.output or []:
        for dtype, data in o.get('data', {}).items():
            if dtype in {'image/jpeg', 'image/png'}:
                outs += _tag(_resize_img(base64.b64decode(data),max_im_sz=max_im_sz))
    return outs

def _img_outputs(msgs, max_im_sz):
    "Extract image outputs from `msgs` and return a list of encoded images and their xml tags."
    return list(chain.from_iterable(_img_output(m, max_im_sz) for m in msgs if m.msg_type==scode))

# %% ../nbs/02_backend.ipynb
@flexicache(time_policy(24*3600))
def _fetch_web_img(url): 
    try: return None if (r := httpx.get(url, follow_redirects=True)).status_code != 200 else r.content
    except: return 

# %% ../nbs/02_backend.ipynb
def img_static_path(fp, dname):
    fp = fp.removeprefix("/static/") if fp.startswith("/static") else f"{Path(dname).parent}/{fp}"
    return Path(cfg_solveit['static_dir']) / fp

def _mk_img_tag(fp,nm):
    if nm.startswith('http://') or nm.startswith('https://'): imgb = _fetch_web_img(nm)
    elif fp.exists(): imgb = fp.read_bytes()
    else: imgb = None
    return [to_xml(_img_xml('content', nm)), _resize_img(imgb)] if _is_img(imgb) else []

def _img_static(msgs, max_im_sz=im_max):
    "Extract static images from message content"
    pat = r'!\[[^\]]*\]\(([^)#]+)#ai\)'
    msgs = L(msgs).filter(lambda o: '#ai' in o.content)
    if not msgs: return []
    nms = msgs.map(lambda o: re.findall(pat, o.content)).concat()
    fps = nms.map(partial(img_static_path, dname=msgs[-1].dlg.name))
    return list(chain.from_iterable(_mk_img_tag(fp,nm) for fp,nm in zip(fps, nms)))

# %% ../nbs/02_backend.ipynb
def mk_img_ctx(chunk, ns, max_im_sz=im_max):
    "Aggregate all images from attachments, code outputs, vars."
    atts = chunk.attachments
    img_ctx = []
    if img_atts:= _img_atts(atts): img_ctx += img_atts
    if img_static := _img_static(chunk.messages, max_im_sz): img_ctx += img_static
    if img_outputs := _img_outputs(chunk.context, max_im_sz): img_ctx += img_outputs
    if img_ctx: img_ctx.insert(0, _imgs_d)
    return img_ctx

# %% ../nbs/02_backend.ipynb
_imgs_d = '''The following images are found in this dialog. Each image has an id and type. Images of type `content` are embedded in the content of a markdown message. Images of type `output` are the output of a code message. Images of type `variable` are code variables. Each image has an unique id which you can use to figure out which message or variable generated the image.'''

# %% ../nbs/02_backend.ipynb
def chunk_xml(chunk: Chunk, msg_tag):
    "Convert a single chunk to XML format with context and task."
    ctx = Context(msg_tag) if msg_tag else None
    instr, task_elem = task_tags(chunk.prompt.content, chunk.prompt.id)
    return (to_xml(ctx, do_escape=False) + '\n' + 
            to_xml(instr, do_escape=False) + '\n' + 
            to_xml(task_elem, do_escape=False))

# %% ../nbs/02_backend.ipynb
def mk_final_prompt(chunk: Chunk, ns: dict, important_prompt: str):
    "Build the final prompt with context, important magic, and task."
    final_msg_tag = msgs_tag(chunk.context)
    final_ctx_parts = []
    if imp_tag := important_tag(important_prompt): final_ctx_parts.append(imp_tag)
    if final_msg_tag: final_ctx_parts.append(final_msg_tag)
    final_ctx = Context(*final_ctx_parts) if final_ctx_parts else Context()
    instr, task_elem = task_tags(chunk.prompt.content, chunk.prompt.id)
    return (to_xml(final_ctx, do_escape=False) + '\n' +
            to_xml(instr, do_escape=False) + '\n' +
            to_xml(task_elem, do_escape=False))

# %% ../nbs/02_backend.ipynb
def mk_history(chunks: list[Chunk], ns: dict, important_prompt: str, include_sp=True, include_img=True, warning=''):
    "Build conversation history from chunks for LLM API call."
    if not chunks: return [],[]
    msg_tags = ctx_tags(chunks)
    if warning: important_prompt += f" WARNING -- notify user of this information: {warning}"
    hist = mk_first_prompt(important_prompt=important_prompt, ns=ns) if include_sp else []
    for chunk, msg_tag in zip(chunks[:-1], msg_tags[:-1]):
        prompt_xml = chunk_xml(chunk, msg_tag)
        img_ctx = mk_img_ctx(chunk, ns) if include_img else []
        response = chunk.prompt.output_hist or "[]"
        hist.extend([img_ctx + [prompt_xml], response])
    final_chunk = chunks[-1]
    final_prompt_xml = mk_final_prompt(final_chunk, ns, important_prompt)
    img_ctx = mk_img_ctx(final_chunk, ns) if include_img else []
    return hist, img_ctx + [final_prompt_xml]

# %% ../nbs/02_backend.ipynb
def insert_icl(hist: list, icl_hist: list):
    if len(hist) < 2: return hist
    return hist[:2] + icl_hist + hist[2:]

# %% ../nbs/02_backend.ipynb
def qwen_prompt(pre, suf, mtype):
    'Creates Qwen FIM prompt that is consistent with the backend XML messages'
    c = ifnone(pre,'') + '<|fim_suffix|>' + ifnone(suf,'')
    pr_msg = Message(content=c, msg_type=mtype, output='')
    content = task_tags(c) if mtype==sprompt else Context(msg_tag(pr_msg))
    return '<|fim_prefix|>'  + to_xml(content, do_escape=False) + '<|fim_middle|>'

# %% ../nbs/02_backend.ipynb
def edit_prompt(pre, suf, hl, instr, mtype):
    'Creates LLM edit prompt with highlight that is consistent with the backend XML messages'
    c = ifnone(pre,'') + f'<highlight>{hl}</highlight>' + ifnone(suf,'') + f'<user_instruction>{instr}</user_instruction>'
    pr_msg = Message(content=c, msg_type=mtype, output='')
    content = task_tags(c) if mtype==sprompt else Context(msg_tag(pr_msg))
    return to_xml(content, do_escape=False)
