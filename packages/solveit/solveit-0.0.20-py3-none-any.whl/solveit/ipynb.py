# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/05_ipynb.ipynb.

# %% auto 0
__all__ = ['reply_sep', 'dlg_mode_lu', 'mode_key', 'ver_key', 'att2dict', 'msg2cell', 'get_ipynb', 'write_ipynb', 'write_perms',
           'shutdown_all', 'dict2att', 'cell2msg', 'read_ipynb', 'read_mode']

# %% ../nbs/05_ipynb.ipynb
from fastcore.utils import *
import nbformat,json
from nbformat.v4 import new_markdown_cell as new_md, new_code_cell as new_code, new_raw_cell as new_raw, new_notebook
from base64 import b64encode,b64decode
from .db import Dialog,Message,Attachment,rtoken_hex
from nbformat.validator import NotebookValidationError
from PIL import Image as PILImage

from .db import *
from .gateway import *
from .kernel import g_dlgs

# %% ../nbs/05_ipynb.ipynb
def att2dict(att):
    return {att.content_type: b64encode(att.data).decode('ascii')
            if isinstance(att.data, bytes) else att.data}

# %% ../nbs/05_ipynb.ipynb
reply_sep = "\n\n##### ðŸ¤–ReplyðŸ¤–<!-- SOLVEIT_SEPARATOR_7f3a9b2c -->\n\n"

def msg2cell(msg, version=2):
    "Convert message row to nbformat cell(s)"
    keeps = set(['heading_collapsed', 'skipped', 'pinned', 'use_thinking', 'time_run', 'hidden'])
    b = {k:getattr(msg,k) for k in keeps}
    boolitms = ['skipped','i_collapsed','pinned','use_thinking']
    base_meta = {k: (bool(v) if isinstance(v,int) and k in boolitms else v)
                 for k,v in b.items() if v}
    if msg.o_collapsed: base_meta['collapsed'] = bool(msg.o_collapsed)
    if msg.i_collapsed: base_meta['hide_input'] = bool(msg.i_collapsed)
    content = ('#| export\n' + msg.content) if msg.is_exported else msg.content
    f = new_md if msg.msg_type in ('note','prompt') else new_code if msg.msg_type == 'code' else new_raw
    if msg.msg_type=='prompt':
        base_meta['solveit_ai'] = True
        if msg.output: content = content + reply_sep + msg.output
    outkw = {}
    if msg.msg_type=='code' and msg.output:
        outputs = msg.output
        if version==1: outputs = json.loads(outputs)
        outkw['outputs'] = [nbformat.from_dict(o) for o in outputs]
    atts = {att.id: att2dict(att) for att in (msg.attachments or [])}
    if atts and msg.msg_type in ('prompt','note'): outkw['attachments'] = atts
    msgid = msg.id[1:] if version>1 else msg.sid
    try: return f(content, id=msgid, metadata=base_meta, **outkw)
    except NotebookValidationError as e:
        print(f"NB validation err: {e}")
        outkw['outputs'] = [] if msg.msg_type == 'code' else ''
        return f(content, id=msgid, metadata=base_meta, **outkw)

# %% ../nbs/05_ipynb.ipynb
dlg_mode_lu = {1:'standard', 2:'learning', 3:'concise'}
mode_key,ver_key = 'solveit_dialog_mode','solveit_ver'

def get_ipynb(dlg:Dialog, version=2, pinned=True):
    mode = dlg.mode if version>1 else dlg_mode_lu[dlg.mode]
    return new_notebook(
        cells=[msg2cell(m, version=version) for m in dlg.messages
               if pinned or not getattr(m,'pinned',False)],
        metadata={mode_key: mode, ver_key:version})

# %% ../nbs/05_ipynb.ipynb
@patch
def mkdir_perms(self:Path, mode=0o777, parents=False, exist_ok=False, uid=-1, gid=-1):
    "Create directory like Path.mkdir but optionally set uid/gid on newly created dirs"
    created = []
    p = self
    while not p.exists():
        created.append(p)
        if parents: p = p.parent
        else: break
    self.mkdir(parents=parents, mode=mode, exist_ok=exist_ok)
    if uid>-1 or gid>-1:
        for d in created: os.chown(d, uid, gid)

# %% ../nbs/05_ipynb.ipynb
def write_ipynb(dlg:Dialog, fname=None, version=2, uid=-1, gid=-1, pinned=True):
    nb = get_ipynb(dlg, version=version, pinned=pinned)
    if fname:
        fname = Path(fname)
        fname.parent.mkdir_perms(parents=True, exist_ok=True, uid=uid, gid=gid)
        with open(fname, 'w', encoding='utf-8') as f: nbformat.write(nb, f)
        if uid>-1 or gid>-1: os.chown(fname, uid, gid)
    else: return nbformat.writes(nb, indent=2)

# %% ../nbs/05_ipynb.ipynb
@patch
def write(self:Dialog, base_path, version=2, uid=-1, gid=-1, pinned=True):
    write_ipynb(self, Path(base_path)/f'{self.name}.ipynb', version=version, uid=uid, gid=gid, pinned=pinned)

# %% ../nbs/05_ipynb.ipynb
def write_perms(dlg):
    if dlg: dlg.write(datapath, uid=cfg_solveit['uid'], gid=cfg_solveit['gid'])

# %% ../nbs/05_ipynb.ipynb
async def shutdown_all():
    for dlg in g_dlgs.values():
        write_perms(dlg)
        await dlg.shutdown()

# %% ../nbs/05_ipynb.ipynb
def dict2att(att_id, att_data):
    "Convert attachment dict to Attachment object"
    content_type, data = first(att_data.items())
    if content_type.startswith('image/') or content_type=='application/octet-stream': data = b64decode(data)
    return Attachment(data, content_type, att_id)

def _output_from_cell(cell):
    if cell.cell_type!='code': return ''
    return [nbformat.from_dict(o) for o in getattr(cell, 'outputs', [])]

# %% ../nbs/05_ipynb.ipynb
def cell2msg(cell, dlg):
    "Convert single notebook cell to message object"
    meta = cell.metadata.copy()
    for o in ('order','oob','run','scrolled','id'): meta.pop(o,None)
    for f in ['skipped','pinned','use_thinking','hidden']: meta[f] = int(meta.get(f,0))
    meta['o_collapsed'] = int(meta.pop('collapsed', 0))
    meta['i_collapsed'] = int(meta.pop('hide_input', 0))
    content = cell.source
    meta['is_exported'] = 0
    if content.startswith('#| export\n'): content,meta['is_exported'] = content[10:],1
    msg_type = 'note' if cell.cell_type == 'markdown' else cell.cell_type # handle raw and code
    if meta.pop('solveit_ai', 0):
        msg_type = 'prompt'
        content,*reply = content.split(reply_sep)
        output = reply[0] if reply else ''
    elif msg_type=='code': output = _output_from_cell(cell)
    else: output=''
    atts = [dict2att(att_id, att_data) for att_id, att_data in cell.get('attachments', {}).items()]
    id = '_' + (getattr(cell, 'id', None) or rtoken_hex(4))
    return Message(content, id=id, output=output, msg_type=msg_type, dlg=dlg, attachments=atts, **meta)

# %% ../nbs/05_ipynb.ipynb
def read_ipynb(fname, base_path='.'):
    if not (f := Path(base_path)/f'{fname}.ipynb').exists(): return
    nb = nbformat.read(f, as_version=nbformat.NO_CONVERT)
    mode = nb.metadata.get(mode_key, 'learning')
    res = Dialog(fname, mode=mode)
    res.messages=[cell2msg(c, res) for c in nb.cells]
    
    # Check if hidden metadata is missing, and apply to all cells once
    if (hcols:=filter_ex(res.messages, attrgetter('heading_collapsed'))) and not getattr(hcols[0].next(), 'hidden', True):
        for c in hcols: c.toggle_hidden()
    return res

# %% ../nbs/05_ipynb.ipynb
def read_mode(fname, base_path='.'):
    p = Path(base_path)/f'{fname}.ipynb'
    js = p.read_json()
    return nested_idx(js, 'metadata', 'solveit_dialog_mode') or 'learning'
