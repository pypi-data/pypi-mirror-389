"""Create solveit in Fasthtml for course"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/04_kernel.ipynb.

# %% auto 0
__all__ = ['g_dlgs', 'time_now', 's_dlg', 'setup_test_dlg', 'clear_dlg']

# %% ../nbs/04_kernel.ipynb
from fasthtml.common import *
from fastcore.utils import *
from urllib.parse import quote,unquote
from datetime import datetime
from jupyter_client import AsyncKernelClient
from queue import Empty

import copy,io,json,random,asyncio,pickle,traceback

from .gateway import *
from .db import *
from .aimsg import *
from .app_xtras import server_error

# %% ../nbs/04_kernel.ipynb
@patch
async def send(self:Dialog, s, safe=False):
    if not safe: s = to_xml(s)
    for ws in list(self.conns):
        try: await ws.send_text(s)
        except (WebSocketDisconnect,RuntimeError): self.conns.discard(ws)

# %% ../nbs/04_kernel.ipynb
@patch
def oob_loop(self:Dialog, conv_func=noop):
    async def f():
        while True:
            try:
                cts = await self.oobq.get()
                itms = L(cts).filter(lambda o: not isinstance(o, Message) or o in self.messages).map(conv_func)
                await self.send(tuplify(itms))
            except Exception as e:
                server_error(None, e)
                await sleep(0.2)

    return asyncio.create_task(f())

# %% ../nbs/04_kernel.ipynb
@patch
def enq(self:Dialog, to_q):
    "Enqueue on the OOB queue"
    self.oobq.put_nowait(to_q)

# %% ../nbs/04_kernel.ipynb
g_dlgs = {}

# %% ../nbs/04_kernel.ipynb
@patch(as_prop=True)
def ready(self:Dialog): return hasattr(self, 'kc') and self.evt_started.is_set()

# %% ../nbs/04_kernel.ipynb
@patch
def process_jmsg(self:Dialog, jmsg):
    "Process a jupyter message -- for now that just means updating message outputs from output messages"
    if jmsg['msg_type'] not in listify(output_types) + ['input_request']: return
    if not (msg:=get_msg(nested_idx(jmsg, 'parent_header', 'msg_id'), self)): return
    if jmsg['msg_type'] == 'clear_output': msg.clear_output(nested_idx(jmsg,'content','wait'))
    else: msg.add_output(jmsg)
    self.enq(msg)

# %% ../nbs/04_kernel.ipynb
def time_now(): return datetime.now().strftime('%-I:%M:%S%p').lower()[:-1]

# %% ../nbs/04_kernel.ipynb
@patch
def empty_runq(self:Dialog):
    while not self.runq.empty(): self.runq.get_nowait()
    for m in self.messages: m.run,m.scroll = None,None # clear out msg run/scroll states
    self.enq(Div(hx_swap_oob='delete:.animate-spin'))

# %% ../nbs/04_kernel.ipynb
@patch
async def exec(self:Message, timeout:Optional[int]=120, time_run=None):
    kc = self.dlg.kc
    try: res = await kc.send_wait(self.content, msg_id=self.id, timeout=timeout)
    except TimeoutError:
        kc.interrupt()
        res = await kc.get_shell_msg(timeout=min(5,timeout))
    status = nested_idx(res, 'content', 'status')
    if not status or (status=='error'): self.dlg.empty_runq()
    self.time_run = time_run or time_now()

# %% ../nbs/04_kernel.ipynb
@patch
async def run_me(self:Message):
    dlg = self.dlg
    await dlg.evt_started.wait()
    await dlg.kc.xpush(__msg_id=self.id)
    if self.msg_type==sprompt: self.output=await run_ai(self, dlg.kc)
    elif self.msg_type==scode:
        await self.exec(cfg_solveit['timeout'])
        # Uncollapse headings of msg if error
        if any(o['output_type'] == 'error' for o in self.output): self.uncollapse()
    update_msg_counts(self, count_input=False)
    self.scroll = bool(self.output)
    self.run = False
    dlg.enq(self)

# %% ../nbs/04_kernel.ipynb
@patch
async def run_msg(self:Dialog, msgid:str):
    if not (msg := get_msg(msgid, self)): return print('missing msg', msgid, dname)
    await msg.run_me()

# %% ../nbs/04_kernel.ipynb
@patch
def run_loop(self:Dialog):
    async def f():
        while True:
            msgid = await self.runq.get()
            try: await self.run_msg(msgid)
            except Exception as e:
                warn(traceback.format_exc())
                await asyncio.sleep(0.2)
    return asyncio.create_task(f())

@patch
def run_enq(self:Dialog, to_q):
    "Enqueue on the run queue"
    self.runq.put_nowait(to_q)

# %% ../nbs/04_kernel.ipynb
@patch
async def set_vars(self:Dialog):
    await self.kc.xenv(**get_secrets())
    await self.kc.xenv(AAI_USER_KEY=os.getenv('AAI_USER_KEY'))
    await self.kc.send(f'import os as __os;__os.chdir("{(datapath/self.name).parent}")')
    await self.kc.xpush(__dialog_name=self.name)

@patch
async def startup(self:Dialog, conv_func=None, pause=0.01):
    if conv_func is None: conv_func = getattr(self, 'conv_func', noop)
    self.conv_func = conv_func
    if getattr(self, 'jloop', None): return # already running
    await self.start_kc()
    await asyncio.sleep(pause)
    await self.set_vars()
    self.jloop = self.kc.jmsg_loop(self.process_jmsg, warn)
    self.rloop = self.run_loop()
    self.oloop = self.oob_loop(conv_func=conv_func)
    self.evt_started.set()

# %% ../nbs/04_kernel.ipynb
async def s_dlg(dlg, conv_func=noop):
    await dlg.startup(conv_func=conv_func)
    g_dlgs[dlg.name]=dlg

# %% ../nbs/04_kernel.ipynb
async def setup_test_dlg():
    dlg,*rest = create_test_dlg()
    await s_dlg(dlg)
    return dlg,*rest

# %% ../nbs/04_kernel.ipynb
@patch
async def shutdown(self:Dialog):
    if not self.ready or not hasattr(self, 'jloop'): return
    self.evt_started.clear()
    for loop in self.jloop,self.rloop,self.oloop: loop.cancel()
    self.oloop = self.rloop = self.jloop = None
    self.kc.interrupt()
    self.kc.stop_channels()
    await self.km.shutdown_kernel()

@patch
async def restart(self:Dialog):
    await self.shutdown()
    await asyncio.sleep(1)
    for m in self.messages: m.time_run = ''
    await self.startup()

# %% ../nbs/04_kernel.ipynb
async def clear_dlg(nm, dlg=None):
    if not dlg: dlg=g_dlgs.get(nm)
    if nm in g_dlgs: del(g_dlgs[nm])
    if not dlg: return
    if dlg: await dlg.shutdown()

# %% ../nbs/04_kernel.ipynb
@patch
async def rename(self:Dialog, newname:str, basepath, uid, gid):
    g_dlgs[newname] = g_dlgs.pop(self.name)
    dest = Path(basepath)/f'{newname}.ipynb'
    dest.parent.mkdir_perms(parents=True, exist_ok=True, uid=uid, gid=gid)
    self.path(basepath).replace(dest)
    self.name = newname
    await self.set_vars()
