"""Create solveit in Fasthtml for course"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/01_db.ipynb.

# %% auto 0
__all__ = ['logger', 'base_dir', 'start_dir', 'uid', 'gid', 'uname', 'gname', 'cfg_solveit', 'dataparent', 'app_prod', 'datapath',
           'smsg_types', 'scode', 'snote', 'sprompt', 'sraw', 'settings_fn', 'settings_file', 'pkl_pth',
           'shell_trunc_limit', 'get_setting', 'set_setting', 'del_setting', 'set_default_settings', 'reset_settings',
           'add_secret', 'get_secrets', 'get_secret', 'delete_secret', 'feature_enabled', 'n_tokens', 'Dialog',
           'rtoken_hex', 'Message', 'update_msg_counts', 'Attachment', 'trunc_data', 'trunc_output1', 'trunc_output',
           'mk_output', 'mk_displayobj', 'displayobj', 'mk_code_output', 'code_output', 'get_msg', 'create_test_dlg']

# %% ../nbs/01_db.ipynb
from fasthtml.common import *
from monsterui.all import *
from fastcore.utils import *
from execnb.shell import render_outputs
from PIL import Image as PILImage
from urllib.parse import quote,unquote
from asyncio import Event as AsyncEvent
from tiktoken_ext import openai_public

import pwd,grp,copy,io,json,random,tiktoken,logging,asyncio,secrets,weakref,pickle

from .gateway import *

# %% ../nbs/01_db.ipynb
logger = logging.getLogger(__name__)
logger.setLevel(logging.INFO)

# %% ../nbs/01_db.ipynb
base_dir = Path(__file__).absolute().parent.parent
start_dir = os.getcwd()

if IN_NOTEBOOK or os.getenv('IN_TEST'):
    import nbdev
    repo_path = nbdev.config.get_config().config_path
    os.chdir(repo_path)
else: os.chdir(base_dir)

# %% ../nbs/01_db.ipynb
try: env = parse_env(fn=base_dir/'.env')
except FileNotFoundError: env = {}
os.environ.update(env)
uid,gid = -1,-1
uname = env.get('uname', None)
gname = env.get('gname', None)
if uname: uid = pwd.getpwnam(uname).pw_uid
if gname: gid = grp.getgrnam(gname).gr_gid

cfg_solveit = dict(
    timeout=int(env.get('timeout', 120)),
    prod=str2bool(env.get('is_prod', False)),
    dev=str2bool(env.get('is_dev', False)),
    think_mdl=env.get('think_mdl',  'claude-sonnet-4-20250514'),
    title_prefix=env.get('title_prefix', ''),
    debug_delay=float(env.get('DEBUG_DELAY', 0)),
    logger_url=env.get('logger_url', None),
    solvelp_url=env.get('solvelp_url', None),
    curdir=start_dir,
    uid=uid, gid=gid
)
cfg_solveit['static_dir'] = '/app/data' if cfg_solveit['prod'] else start_dir

# %% ../nbs/01_db.ipynb
dataparent = Path('/app')
app_prod = True
datapath = (dataparent/'data').resolve()
if not dataparent.exists():
    app_prod = False
    dataparent = Path(cfg_solveit['curdir'])
    datapath = (dataparent/'data').resolve() if IN_NOTEBOOK or os.getenv('IN_TEST') else dataparent.resolve()
datapath.mkdir(exist_ok=True)

# `msg_type` is "code", "note", "prompt".
smsg_types = scode,snote,sprompt,sraw = "code","note","prompt","raw"

# %% ../nbs/01_db.ipynb
settings_fn = 'solveit_settings.json'
settings_file = (datapath if app_prod else Path('data') if IN_NOTEBOOK else Path('.'))/settings_fn

def _save_settings(settings):
    "Save settings to JSON file."
    settings_file.parent.mkdir(parents=True, exist_ok=True)
    with open(settings_file, 'w') as f: json.dump(settings, f, indent=2)

@flexicache(mtime_policy(settings_file))
def _load_settings_cached():
    "Load settings from JSON file, creating default if it doesn't exist."
    with open(settings_file, 'r') as f: return json.load(f)

def _load_settings():
    "Load settings from JSON file, creating default if it doesn't exist."
    if not settings_file.exists(): _save_settings({})
    return _load_settings_cached()

# %% ../nbs/01_db.ipynb
def get_setting(k):
    "Get a setting value by key."
    return _load_settings().get(k)

def set_setting(k, v):
    "Set a setting value by key."
    settings = _load_settings()
    settings[k] = v
    _save_settings(settings)

def del_setting(k):
    "Delete a setting by key."
    settings = _load_settings()
    if k in settings:
        del settings[k]
        _save_settings(settings)

def set_default_settings():
    "Set default settings if they don't exist."
    if get_setting('default_code') is None: set_setting('default_code', True)
        
def reset_settings():
    "Reset all settings to defaults."
    _save_settings({})
    set_default_settings()

# %% ../nbs/01_db.ipynb
def add_secret(name, value):
    "Add or update a secret in the settings."
    settings = _load_settings()
    if 'secrets' not in settings: settings['secrets'] = {}
    settings['secrets'][name] = value
    _save_settings(settings)

def get_secrets():
    "Get a secret value by name."
    return _load_settings().get('secrets', {})

def get_secret(name):
    "Get a secret value by name."
    return get_secrets().get(name)

def delete_secret(name):
    "Delete a secret by name."
    settings = _load_settings()
    if 'secrets' in settings and name in settings['secrets']:
        del settings['secrets'][name]
        _save_settings(settings)
        return True
    return False

# %% ../nbs/01_db.ipynb
def feature_enabled(nm): return get_secret(nm) is not None

# %% ../nbs/01_db.ipynb
pkl_pth = Path('o200k.pkl')
if not pkl_pth.exists():
    with pkl_pth.open('wb') as f: 
        pickle.dump(openai_public.o200k_base(), f)
        
with pkl_pth.open('rb') as f: 
    o200k = pickle.load(f)
_enc = tiktoken.Encoding(**o200k)

# %% ../nbs/01_db.ipynb
def _is_img(o): return o['output_type']=='display_data' and any(k in o['data'] for k in ('image/png','image/jpeg'))
def _count_imgs(output)->int: return sum(map(_is_img, output))

def n_tokens(o, sf=1.5):
    "Estimates approx number of tokens for determining cost/user limits"
    if not o: o=''
    o_str = o if isinstance(o,str) else render_outputs(o, include_imgs=False)
    tks = int(len(_enc.encode(o_str, disallowed_special=())) * sf)
    if not isinstance(o,str): tks += 60 * _count_imgs(o)
    return tks

# %% ../nbs/01_db.ipynb
class Dialog(BasicRepr):
    def __init__(self, name, mode:str='learning', messages=None):
        self.name,self.mode,self.messages = str(name),mode,listify(messages)
        self.runq,self.oobq = asyncio.Queue(),asyncio.Queue()
        self.conns = set()
        self.evt_started = AsyncEvent()

    def __eq__(self, a):
        if a is None: return False
        if isinstance(a, Dialog): return self.name==a.name
        if isinstance(a, str): return self.name==a
        return False

    def _repr_markdown_(self):
        msgs = ''
        if self.messages:
            msgr = '\n'.join(f'- {o.summ}' for o in self.messages)
            msgs = f'''
<details>

{msgr}

</details>'''
        return f'''
**{self.name}**: *{self.mode}*

{msgs}'''

# %% ../nbs/01_db.ipynb
def rtoken_hex(
    nbytes:int=16 # Number of bytes to generate
)->str: # hex string of length nbytes*2
    "Generate a random hex string using Python's random module."
    return ''.join(f'{random.randint(0, 255):02x}' for _ in range(nbytes))

# %% ../nbs/01_db.ipynb
class Message:
    def __init__(self, content='', dlg=None, output='', id=None, input_tokens=0, output_tokens=0, 
                 msg_type='code', time_run='', is_exported=False, skipped=False,    hidden=False,
                 i_collapsed=False, o_collapsed=False, heading_collapsed=False,    i_clamp=False,
                 o_clamp=False, pinned=False, use_thinking=False, attachments=None,     **xtras):
        # Prepend `_` to ensure it is a valid DOM id too
        if id is None: id = '_'+rtoken_hex(4)
        attachments = listify(attachments)
        self._dlg,self._cts, self._out, self._msg_type = None, content, output, msg_type
        self._rcts = self._rout = None
        if dlg: self._dlg = weakref.ref(dlg) # weakref to avoid circular ref
        store_attr(but=['dlg', 'content', 'output', 'msg_type'])

    @property
    def output(self): return self._out
    @output.setter
    def output(self, v):
        if v!=self._out: self._rout = None
        self._out = v

    @property
    def content(self): return self._cts
    @content.setter
    def content(self, v):
        if v!=self._cts: self._rcts = None
        self._cts = v

    @property
    def msg_type(self): return self._msg_type
    @msg_type.setter
    def msg_type(self, v):
        if v!=self._msg_type: self.output = [] if v==scode else ''
        self._msg_type = v

    @property
    def dlg(self): return self._dlg() if self._dlg else None
    @dlg.setter
    def dlg(self, v): self._dlg = weakref.ref(v)
    @property
    def __flds__(self): return vars_pub(self) + ['content', 'output', 'msg_type']
    @property
    def flds(self): return [o for o in self.__flds__ if o not in ('content', 'output', 'attachments')]
    @property
    def token_count(self): return self.input_tokens+self.output_tokens
    @property
    def summ(self): return self.content + (f" â‡’ {self.output}" if self.output else '')
    __repr__ = basic_repr('id,content,output,input_tokens,output_tokens,msg_type,time_run,is_exported,'\
                      'skipped,i_collapsed,o_collapsed,heading_collapsed,pinned,use_thinking')

# %% ../nbs/01_db.ipynb
@patch
def _repr_markdown_(self:Message):
    detls = '\n'.join(f'- {k}: {getattr(self, k)}' for k in self.flds)
    return f'''{self.summ}

<details>

{detls}

</details>'''

# %% ../nbs/01_db.ipynb
@patch
def __eq__(self:Message, a):
    if a is None: return False
    if isinstance(a, Message): return self.id==a.id
    if isinstance(a, str): return self.id==a
    return False

@patch
def __hash__(self:Message): return hash(self.id)

# %% ../nbs/01_db.ipynb
@patch(as_prop=True)
def output_hist(self:Message):
    "Output as it will be attached to the chat history"
    if self.msg_type != sprompt: return self.output
    return self.output.lstrip("ðŸ§ \n").removesuffix("\n\n*[Response interrupted]*")

# %% ../nbs/01_db.ipynb
def update_msg_counts(msg, count_input=True):
    "Calculate number of input and output tokens for `msg`"
    if count_input: msg.input_tokens = n_tokens(msg.content)
    msg.output_tokens = n_tokens(msg.output_hist)
    return msg

# %% ../nbs/01_db.ipynb
@patch
def mk_message(self:Dialog, content:str, idx=-1, after=None, before=None, counts=False,
               msg_type=scode, output='', run=None, oob=None, **kwargs):
    "Make new message and insert it into notebook before/after specified cell, or start of list (idx=0) by default"
    if msg_type==scode and isinstance(output,str): output = loads(output or '[]')
    msg = Message(content, self, msg_type=msg_type, output=output, **kwargs)
    if isinstance(after,  Message): after =after.id
    if isinstance(before, Message): before=before.id
    if counts: update_msg_counts(msg)
    if run is not None: msg.run = run
    if oob is not None: msg.oob = oob
    if after is not None:
        idx = next((i for i,c in enumerate(self.messages) if c.id==after ), -1)+1
    elif before is not None:
        idx = next((i for i,c in enumerate(self.messages) if c.id==before), -1)
    if idx==-1: idx=len(self.messages)
    self.messages.insert(idx, msg)
    return msg

# %% ../nbs/01_db.ipynb
@patch
def mk_messages(self:Dialog, msgs, after=None, before=None):
    "Make new messages and insert them sequentially into the notebook after/before a specific message."
    def _kws(m): return {o: getattr(m,o) for o in m.flds if o not in {'id','is_hidden'}}
    return [after:=self.mk_message(m.content,output=m.output,attachments=m.attachments,after=after, before=before, **_kws(m)) for m in msgs]

# %% ../nbs/01_db.ipynb
@patch
def update(self:Message, **kwargs):
    "Update message attributes with provided keyword arguments"
    for k, v in kwargs.items():
        if v is not UNSET: setattr(self, k, v)
    return self

# %% ../nbs/01_db.ipynb
@patch
def insert_after(self:Message, msgs):
    curr = self.dlg.messages
    idx = curr.index(self)
    curr[idx+1:idx+1] = msgs
    for m in msgs: m.dlg = self.dlg

# %% ../nbs/01_db.ipynb
@patch
def next(self:Message):
    "Return the next message in the dialog, or None if this is the last message"
    idx = self.dlg.messages.index(self)
    if idx<len(self.dlg.messages)-1: return self.dlg.messages[idx + 1]
    return None

@patch
def previous(self:Message):
    "Return the previous message in the dialog, or None if this is the first message"
    idx = self.dlg.messages.index(self)
    if idx > 0: return self.dlg.messages[idx - 1]
    return None

@patch
def rel_msg(self:Message, is_up:bool):
    return (self.previous if is_up else self.next)()

# %% ../nbs/01_db.ipynb
def _header_level(content):
    if not content: return 0
    m = re.match(r'^(#{1,6})\s+', content)
    return len(m.group(1)) if m else 0

def _get_collapse_deps(levels):
    deps, stack = [], []
    for i, level in enumerate(levels):
        if level > 0: 
            while stack and stack[-1][1] >= level: stack.pop()
            stack.append((i,level))
        end = len(stack) if level == 0 else -1
        deps.append(stack[:end])
    return deps

@patch
def header_level(self:Message): return _header_level(self.content) if self.msg_type==snote else 0

# %% ../nbs/01_db.ipynb
@patch
def parents(self:Message):
    all_msgs = self.dlg.messages
    levels = [m.header_level() for m in all_msgs]
    parent_state = _get_collapse_deps(levels)[all_msgs.index(self)]
    return [all_msgs[ind] for ind, level in parent_state]

@patch
def children(self:Message):
    # TODO: Make this faster, eg by only grabbing heading notes
    if self.header_level() == 0: return []
    all_msgs = self.dlg.messages
    after_msgs = all_msgs[all_msgs.index(self)+1:]
    next_sibling = first(msg for msg in after_msgs
                         if msg.header_level()>0 and msg.header_level()<=self.header_level())
    return after_msgs if next_sibling is None else after_msgs[:after_msgs.index(next_sibling)]

# %% ../nbs/01_db.ipynb
@patch
def parent(self:Message):
    idx = self.dlg.messages.index(self)
    lev = self.header_level()
    def _is_parent(m): return m.header_level()>0 and (lev==0 or m.header_level()<lev) 
    return next(filter(_is_parent, reversed(self.dlg.messages[:idx])), None)

@patch
def toggle_hidden(self:Message):
    "Toggle msg children hidden state based on heading_collapsed attr"
    for m in self.children():
        if not m.input_tokens: update_msg_counts(m)
        m.hidden = self.heading_collapsed or m.parent().heading_collapsed
    return [*self.children(), self]

# %% ../nbs/01_db.ipynb
@patch
def uncollapse(self:Message):
    for p in self.parents():
        if p.heading_collapsed:
            p.heading_collapsed = False
            p.scroll = False
            self.dlg.enq(p.toggle_hidden())
    self.scroll = True
    self.dlg.enq(self)

# %% ../nbs/01_db.ipynb
@patch
def is_visible(self:Message): return all([not p.heading_collapsed for p in self.parents()])

@patch
def next_vis(self:Message):
    "Return the next visible message in the dialog, or None if this is the last message"
    idx = self.dlg.messages.index(self)
    return first(m for m in self.dlg.messages[idx+1:] if m.is_visible())

@patch
def previous_vis(self:Message):
    "Return the previous visible message in the dialog, or None if this is the first message"
    idx = self.dlg.messages.index(self)
    return first(m for m in reversed(self.dlg.messages[:idx]) if m.is_visible())

# %% ../nbs/01_db.ipynb
@patch
def todict(self:Dialog):
    return {k:v for k,v in asdict(self).items() if k[0]!='_'}

# %% ../nbs/01_db.ipynb
@patch
def todict(self:Message):
    return {k:v for k,v in asdict(self).items() if k[0]!='_'}

# %% ../nbs/01_db.ipynb
class Attachment(BasicRepr):
    def __init__(self, data:bytes, content_type:str, id:str=''):
        if not id: id=rtoken_hex(4)
        store_attr()

# %% ../nbs/01_db.ipynb
@patch
def mk_attachment(self:Message, data:bytes, content_type:str, id:str=''):
    att = Attachment(data=data, content_type=content_type, id=id)
    return self.attachments.append(att)

# %% ../nbs/01_db.ipynb
def _trunc_indexes(n, limit):
    "Get the indexes where truncation will start and finish."
    i=limit//2
    return i, n-(limit-i)

# %% ../nbs/01_db.ipynb
def _needs_leading_quote(out:list)->bool: return out and not out[0]=="'" and out[-1]=="'"
def _needs_trailing_quote(out:list)->bool: return out and out[0]=="'" and not out[-1]=="'"

def _enclose_string(s:str, split_dir:str="left"):
    if split_dir=="left" and _needs_trailing_quote(s): return f"{s}'"
    if split_dir=="right" and _needs_leading_quote(s): return f"'{s}"
    return s

# %% ../nbs/01_db.ipynb
shell_trunc_limit=65536
def trunc_data(o:list, limit:int=shell_trunc_limit)->list:
    "Apply middle out truncation to `o`."
    trunc_msg = '\n========== TRUNCATED ==========\n'
    n = len(o)
    if n <= limit: return o
    i,j = _trunc_indexes(n, limit)
    count=0; trunc=[]
    for s in o.splitlines(True):
        if count+len(s) <= i: trunc.append(s)
        elif count <= i: 
            st = _enclose_string(s[:i-count], split_dir="left"); trunc.append(st); trunc.append(trunc_msg)
        if count >= j:trunc.append(s)
        elif count+len(s) >=j and s[j-count:]: st=_enclose_string(s[j-count:], split_dir="right"); trunc.append(st)
        count += len(s)
    trunc.append('\n========== MIDDLE OF OUTPUT TRUNCATED ==========\n')
    return ''.join(trunc)

# %% ../nbs/01_db.ipynb
def trunc_output1(o:dict, limit:int=shell_trunc_limit):
    exec_dtype = 'text/plain'
    otype = o['output_type']
    if otype=='stream': o['text'] = trunc_data(o['text'], limit=limit)
    if otype=='error': o['traceback'] = trunc_data('\n'.join(o['traceback']), limit=limit).splitlines(False)
    if otype=='execute_result' and exec_dtype in o.get('data', {}): 
        o['data'][exec_dtype] = trunc_data(o['data'][exec_dtype], limit=limit)
    return o

# %% ../nbs/01_db.ipynb
def trunc_output(output:list, limit:int=shell_trunc_limit):
    out = copy.deepcopy(output)
    exec_dtype = 'text/plain'
    for o in out: trunc_output1(o, limit)
    return out

# %% ../nbs/01_db.ipynb
@patch
def find_msg(self:Dialog, content): return first(m for m in self.messages if m.content==content)

# %% ../nbs/01_db.ipynb
@patch
def clear_output(self:Message, wait=False):
    self._clear_pending=wait
    if not wait: self.output = [] if self.msg_type==scode else ''

# %% ../nbs/01_db.ipynb
def mk_output(typ, d, meta=None, **kw): return dict(output_type=typ, metadata=meta or {}, data=d, **kw)
def mk_displayobj(d): return mk_output('display_data', d)
def displayobj(data='', subtype='plain', mimetype='text'): return mk_displayobj({f'{mimetype}/{subtype}': data})
def mk_code_output(d): return [mk_output('execute_result', d, execution_count=1)]
def code_output(result='', subtype='plain', mimetype='text'):
    return mk_code_output({f'{mimetype}/{subtype}': result})

# %% ../nbs/01_db.ipynb
@patch
def add_output(self:Message, jmsg):
    if getattr(self, '_clear_pending', False): self.clear_output()
    if jmsg['msg_type'] == 'input_request':
        lbl, is_pass = jmsg['content']['prompt'], jmsg['content']['password']
        inp = LabelInput(lbl, id='user_input', autofocus=True, type='password' if is_pass else 'text')
        out = mk_output('display_data', {'text/html': to_xml(Form(inp, hx_post=qp('/input_reply_', msgid=self.id)))})
    else: out = trunc_output1(msg2output(jmsg), limit=shell_trunc_limit)

    if not self.output: self.output=[]
    self._rout = None # invalidate cache
    self.output.append(out)

# %% ../nbs/01_db.ipynb
def get_msg(msgid, dlg):
    if not dlg or not msgid: return
    return first(o for o in dlg.messages if o.id==msgid)

# %% ../nbs/01_db.ipynb
@patch
async def start_kc(self:Dialog):
    self.km = await start_kernel(chdir=cfg_solveit['curdir'])
    self.kc = self.km.client()
    self.kc.start_channels()
    await self.kc.wait_for_ready()

# %% ../nbs/01_db.ipynb
def _mk_ntmsg(dlg, after):
    img = PILImage.new('RGB', (5, 5), color='red')
    img_bytes = io.BytesIO()
    img.save(img_bytes, format='PNG')
    img_data = img_bytes.getvalue()
    att = Attachment(data=img_data, content_type='image/png', id='image.png')

    nt = '*Hello* to the **world**!\n![image.png](attachment:image.png)'
    return dlg.mk_message(nt, after=after, msg_type=snote, attachments=[att], counts=True)

# %% ../nbs/01_db.ipynb
def create_test_dlg():
    import nbdev.config
    dlg = Dialog('test dialog')
    pr = "Concisely, what is *one* simple way to reverse a list?"
    ai_resp = 'You can reverse a list using the slice notation with a step of -1:\n\n```python\nmy_list[::-1]\n```\n\nWould you like me to explain how this works?'
    ai_msg = dlg.mk_message(pr, output=ai_resp, msg_type=sprompt, counts=True)
    msg =    dlg.mk_message('hello world', msg_type=snote, counts=True)
    nt_msg = _mk_ntmsg(dlg, after=msg)
    nt_msg.skipped=True
    code = '1+1 / 12'
    out = code_output(str(1+1/12))
    code_msg = dlg.mk_message(output=out, content=code, msg_type=scode, counts=True)
    raw = '''\n---\ntitle: Hi there!\n---'''
    raw_msg = dlg.mk_message(content=raw, msg_type=sraw, counts=True)
    repo_path = nbdev.config.get_config().config_path
    os.chdir(repo_path)
    return dlg,msg,ai_msg,code_msg,nt_msg,raw_msg
