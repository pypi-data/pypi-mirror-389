# Copyright (c) 2023-2025 Arista Networks, Inc.
# Use of this source code is governed by the Apache License 2.0
# that can be found in the LICENSE file.
"""Factory functions used by PyAVD for ANTA."""

from __future__ import annotations

from logging import getLogger
from typing import TYPE_CHECKING, Any

from anta.catalog import AntaCatalog, AntaTestDefinition
from anta.models import AntaTest

from pyavd._eos_cli_config_gen.schema import EosCliConfigGen
from pyavd._utils import get_v2

from .constants import StructuredConfigKey
from .logs import LogMessage, TestLoggerAdapter
from .models import DeviceTestContext

if TYPE_CHECKING:
    from pyavd.api._anta import AvdFabricData, InputFactorySettings, TestSpec


def create_catalog(
    hostname: str,
    structured_config: dict[str, Any],
    fabric_data: AvdFabricData,
    input_factory_settings: InputFactorySettings,
    test_specs: list[TestSpec],
) -> AntaCatalog:
    """Create an ANTA catalog for a device from the provided test specs."""
    device_context = DeviceTestContext(
        hostname=hostname,
        structured_config=EosCliConfigGen._load(structured_config),
        fabric_data=fabric_data,
        input_factory_settings=input_factory_settings,
    )
    tests: list[AntaTestDefinition] = []
    for test in test_specs:
        test_definitions = create_test_definitions(test, device_context)

        # Skip the test if we couldn't create the test definitions. Logging is done when creating the test definitions
        if test_definitions is None:
            continue

        # Tag the test with the device name for the final catalog and add metadata
        for test_def in test_definitions:
            test_def.inputs.filters = AntaTest.Input.Filters(tags={hostname})
            if test_def.inputs.result_overwrite is None:
                test_def.inputs.result_overwrite = AntaTest.Input.ResultOverwrite(custom_field="Generated by AVD")
            else:
                test_def.inputs.result_overwrite.custom_field = "Generated by AVD"

        tests.extend(test_definitions)

    # Sort by module and test name for consistent output
    tests.sort(key=lambda x: (x.test.__module__, x.test.name))
    return AntaCatalog(tests=tests)


def create_test_definitions(test_spec: TestSpec, device_context: DeviceTestContext) -> list[AntaTestDefinition] | None:
    """Create the AntaTestDefinition's from this TestSpec instance."""
    logger_adapter = TestLoggerAdapter(logger=getLogger(__name__), extra={"device": device_context.hostname, "test": test_spec.test_class.name})

    # Skip the test if the conditional keys are not present in the structured config
    if test_spec.conditional_keys and not all(get_v2(device_context.structured_config, key.value) for key in test_spec.conditional_keys):
        keys = StructuredConfigKey.to_string_list(test_spec.conditional_keys)
        logger_adapter.debug(LogMessage.INPUT_NO_DATA_MODELS, data_models=", ".join(keys))
        return None

    # Create the test definitions from the input factory if provided
    if test_spec.input_factory is not None:
        factory = test_spec.input_factory(device_context, test_spec.test_class.name)
        results = factory.create()
        if results is None:
            logger_adapter.debug(LogMessage.INPUT_NONE_FOUND)
            return None
        return [AntaTestDefinition(test=test_spec.test_class, inputs=inputs) for inputs in results]

    # Otherwise AntaTestDefinition takes `inputs=None` if the test does not require any inputs
    return [AntaTestDefinition(test=test_spec.test_class, inputs=None)]
