"""
Production-Ready Neural Architecture Search Pipeline
This module contains the functions for the new, production-ready NAS pipeline,
which was designed and generated by OrchestratorAI itself.
"""
import random
import numpy as np
from typing import Dict, Any, List
from sklearn.gaussian_process import GaussianProcessRegressor
from sklearn.gaussian_process.kernels import Matern

class BayesianNAS:
    """
    Implements Bayesian Optimization for Neural Architecture Search.
    """
    def __init__(self, search_space: Dict[str, List[Any]]):
        self.search_space = search_space
        self.kernel = Matern(nu=2.5)
        self.gp = GaussianProcessRegressor(kernel=self.kernel, n_restarts_optimizer=10)
        self.X_observed = []
        self.y_observed = []
        self._param_to_int = {param: {val: i for i, val in enumerate(values)} for param, values in search_space.items()}
        self._int_to_param = {param: {i: val for i, val in enumerate(values)} for param, values in search_space.items()}

    def _encode(self, arch: Dict[str, Any]) -> List[int]:
        """Encodes an architecture dictionary into a numerical vector."""
        encoded = []
        for param, value in arch.items():
            encoded.append(self._param_to_int[param][value])
        return encoded

    def _decode(self, encoded_arch: List[int]) -> Dict[str, Any]:
        """Decodes a numerical vector back into an architecture dictionary."""
        decoded = {}
        for i, param in enumerate(self.search_space.keys()):
            decoded[param] = self._int_to_param[param][encoded_arch[i]]
        return decoded

    def suggest_next(self) -> Dict[str, Any]:
        """
        Suggests the next architecture to evaluate using the UCB acquisition function.
        """
        if len(self.X_observed) < 5: # Start with random samples
            return sample_architecture(self.search_space)

        # Generate a large number of candidate architectures
        candidates = [sample_architecture(self.search_space) for _ in range(100)]
        encoded_candidates = np.array([self._encode(c) for c in candidates])

        mu, sigma = self.gp.predict(encoded_candidates, return_std=True)
        # Upper Confidence Bound (UCB) acquisition function
        ucb = mu + 1.96 * sigma

        # We are minimizing the score, so we select the minimum UCB
        best_idx = np.argmin(ucb)
        return candidates[best_idx]

    def update(self, arch: Dict[str, Any], score: float):
        """
        Updates the Gaussian Process model with the latest observation.
        """
        encoded_arch = self._encode(arch)
        self.X_observed.append(encoded_arch)
        self.y_observed.append(score)

        # We negate the score because GP maximizes, but we want to minimize
        self.gp.fit(np.array(self.X_observed), -np.array(self.y_observed))

def sample_architecture(search_space: Dict[str, List[Any]]) -> Dict[str, Any]:
    """
    Randomly samples an architecture from the defined search space.
    """
    arch = {key: random.choice(values) for key, values in search_space.items()}
    print(f"  [NAS Pipeline] Sampled architecture: {arch}")
    return arch

def evaluate_architecture(architecture: Dict[str, Any]) -> float:
    """
    Simulates the evaluation of a sampled architecture.
    """
    score = 0.0
    if 'learning_rate' in architecture:
        score += architecture['learning_rate'] * 10
    if 'num_layers' in architecture:
        score += architecture['num_layers']
    print(f"  [NAS Pipeline] Evaluated score: {score:.2f}")
    return score

def select_best_architecture(search_space: Dict[str, List[Any]], num_samples: int) -> Dict[str, Any]:
    """
    Performs Bayesian Optimization to find the best architecture.
    """
    optimizer = BayesianNAS(search_space)
    best_architecture = None
    best_score = float('inf')

    for i in range(num_samples):
        print(f"  [NAS Pipeline] --- Sample {i+1}/{num_samples} ---")
        arch = optimizer.suggest_next()
        score = evaluate_architecture(arch)
        optimizer.update(arch, score)

        if score < best_score:
            best_score = score
            best_architecture = arch

    print(f"  [NAS Pipeline] Best architecture found: {best_architecture} (Score: {best_score:.2f})")
    return best_architecture
