# --- Practical 2: Geometric Transformation ---
!pip install opencv-python numpy matplotlib

import cv2, numpy as np, matplotlib.pyplot as plt, os

# --- Step 1: Load your image if present, else create base image ---
path = "road.jpg"
if os.path.exists(path):
    print("‚úÖ Custom image found! Using your image.")
    img = cv2.imread(path)
else:
    print("‚ö†Ô∏è No image found. Using synthetic 'CV' image instead.")
    img = np.zeros((200,200,3), np.uint8)
    cv2.putText(img, 'CV', (40,120), cv2.FONT_HERSHEY_SIMPLEX, 3, (255,255,255), 5)

h, w = img.shape[:2]

# --- Step 2: Apply Geometric Transformations ---
T = cv2.warpAffine(img, np.float32([[1,0,40],[0,1,30]]), (w+80,h+80))               # Translation
R = cv2.warpAffine(img, cv2.getRotationMatrix2D((w//2,h//2), 45, 1), (w,h))         # Rotation
F = cv2.warpAffine(img, np.float32([[-1,0,w],[0,1,0]]), (w,h))                      # Reflection
S = cv2.warpAffine(img, np.float32([[1,0.5,0],[0,1,0]]), (int(w*1.5), h))           # Shearing

# --- Step 3: Display Results ---
titles = ['Original', 'Translated', 'Rotated', 'Reflected', 'Sheared']
images = [img, T, R, F, S]

plt.figure(figsize=(10,8))
for i, (t, p) in enumerate(zip(titles, images), 1):
    plt.subplot(2,3,i)
    plt.imshow(cv2.cvtColor(p, cv2.COLOR_BGR2RGB))
    plt.title(t)
    plt.axis('off')
plt.tight_layout()
plt.show()


# -------------------------------------------------------------
# üîπ THEORY & EXPLANATION FOR VIVA üîπ
# -------------------------------------------------------------

# üéØ AIM:
# To perform various geometric transformations on an image using OpenCV.
# These transformations modify the image's position, orientation, or shape.

# -------------------------------------------------------------
# üß† CONCEPTS:
# A geometric transformation changes the spatial relationship between
# pixels in an image using a transformation matrix.

# The general affine transformation equation:
# [x']   [a11 a12 tx] [x]
# [y'] = [a21 a22 ty] [y]
# [1 ]   [ 0   0   1 ] [1]
#
# Here:
#  (x, y)  ‚Üí Original coordinates
#  (x', y') ‚Üí Transformed coordinates
#  tx, ty ‚Üí translation (shift)
#  a11, a12, a21, a22 ‚Üí scaling, rotation, shearing parameters

# -------------------------------------------------------------
# üî∏ 1. Translation:
# Moves the image from one place to another without rotation.
# Formula:
# x' = x + tx
# y' = y + ty
# Used to reposition objects in an image.
# Example: cv2.warpAffine(img, [[1,0,40],[0,1,30]], ...)

# üî∏ 2. Rotation:
# Rotates the image around a given center by Œ∏ degrees.
# Formula:
# x' = x*cosŒ∏ - y*sinŒ∏
# y' = x*sinŒ∏ + y*cosŒ∏
# Example: cv2.getRotationMatrix2D(center, angle, scale)

# üî∏ 3. Reflection (Flipping):
# Creates a mirror image of the original.
# Reflection matrix (about Y-axis):
# [[-1, 0, w],
#  [ 0, 1, 0]]
# Example: Flips horizontally.

# üî∏ 4. Shearing:
# Distorts the image along an axis.
# Formula:
# x' = x + ky
# y' = y
# Used for perspective distortion.
# Example: [[1, 0.5, 0], [0, 1, 0]]

# -------------------------------------------------------------
# üß© CODE EXPLANATION:

# 1Ô∏è‚É£ Image loading:
#   - If custom image (road.jpg) exists, it‚Äôs used.
#   - Else, a synthetic "CV" text image is created.
#
# 2Ô∏è‚É£ Translation:
#   - Moves image 40 px right, 30 px down.
#
# 3Ô∏è‚É£ Rotation:
#   - Rotates image 45¬∞ around its center.
#
# 4Ô∏è‚É£ Reflection:
#   - Flips image horizontally by reversing X-coordinates.
#
# 5Ô∏è‚É£ Shearing:
#   - Tilts the image sideways for skew effect.
#
# 6Ô∏è‚É£ Display:
#   - Shows all results using matplotlib in a 2x3 grid.

# -------------------------------------------------------------
# üìò OUTPUT DESCRIPTION:
# ‚û§ Original: Base or custom image.
# ‚û§ Translated: Shifted position.
# ‚û§ Rotated: Tilted 45¬∞ view.
# ‚û§ Reflected: Mirrored version.
# ‚û§ Sheared: Skewed image (horizontal distortion).

# -------------------------------------------------------------
# üí° APPLICATIONS:
# - Image registration and alignment.
# - Robotics vision and motion correction.
# - Object tracking and rotation correction.
# - Augmented reality (image overlaying).

# -------------------------------------------------------------
# üó£Ô∏è VIVA QUESTIONS:
# Q1. What is an affine transformation?
#     ‚Üí A linear mapping that preserves points, straight lines, and planes.
#
# Q2. What is the difference between affine and perspective transform?
#     ‚Üí Affine keeps parallel lines parallel; perspective can converge them.
#
# Q3. Which function is used for affine transformations?
#     ‚Üí cv2.warpAffine()
#
# Q4. What is the role of getRotationMatrix2D()?
#     ‚Üí It creates a 2x3 rotation matrix for rotating around a center.
#
# Q5. What is shearing used for?
#     ‚Üí To tilt or distort an image along one axis.

# -------------------------------------------------------------
# ‚úÖ RESULT:
# Successfully performed translation, rotation, reflection, and shearing
# on both real and synthetic images using OpenCV geometric transformations.
