# --- Practical 3: Compute and Apply Homography Matrix ---
!pip install opencv-python numpy matplotlib

import cv2, numpy as np, matplotlib.pyplot as plt, os

# --- Step 1: Load your image if available, else create synthetic one ---
path = "road.jpg"
if os.path.exists(path):
    print("‚úÖ Custom image found! Using your image.")
    img = cv2.imread(path)
else:
    print("‚ö†Ô∏è No image found. Using synthetic 'CV' image instead.")
    img = np.zeros((300,300,3), np.uint8)
    cv2.rectangle(img,(50,50),(250,250),(255,255,255),-1)
    cv2.putText(img,'CV',(90,180),cv2.FONT_HERSHEY_SIMPLEX,2,(0,0,0),3)

# --- Step 2: Define corresponding points ---
src = np.float32([[50,50],[250,50],[250,250],[50,250]])   # Source points (corners)
dst = np.float32([[30,70],[260,40],[220,260],[60,250]])   # Destination points (warped view)

# --- Step 3: Compute Homography & Warp Image ---
H, _ = cv2.findHomography(src, dst)             # Find 3x3 homography matrix
warp = cv2.warpPerspective(img, H, (300,300))   # Apply perspective warp
print("Homography Matrix:\n", H)

# --- Step 4: Display Results ---
titles = ['Original Image', 'After Homography']
images = [img, warp]

plt.figure(figsize=(8,4))
for i, (t, p) in enumerate(zip(titles, images), 1):
    plt.subplot(1,2,i)
    plt.imshow(cv2.cvtColor(p, cv2.COLOR_BGR2RGB))
    plt.title(t)
    plt.axis('off')
plt.tight_layout()
plt.show()


# -------------------------------------------------------------
# üîπ THEORY & EXPLANATION FOR VIVA üîπ
# -------------------------------------------------------------

# üéØ AIM:
# To compute and apply a Homography matrix to transform one plane of an image
# into another using OpenCV.

# -------------------------------------------------------------
# üß† CONCEPT:
# A Homography is a 3x3 transformation matrix that relates two images of the same
# planar surface taken from different viewpoints.

# It maps points (x, y) from one image to (x', y') in another using:
# 
# [x']   [h11 h12 h13] [x]
# [y'] = [h21 h22 h23] [y]
# [w']   [h31 h32 h33] [1]
#
# After normalization:
# x' = (h11*x + h12*y + h13) / (h31*x + h32*y + h33)
# y' = (h21*x + h22*y + h23) / (h31*x + h32*y + h33)

# The denominator w' represents the perspective scaling.

# -------------------------------------------------------------
# üî∏ OpenCV Functions Used:

# ‚û§ cv2.findHomography(src_points, dst_points)
#     ‚Üí Calculates the 3x3 matrix H that maps src ‚Üí dst points.

# ‚û§ cv2.warpPerspective(image, H, size)
#     ‚Üí Applies the homography to warp the entire image.

# -------------------------------------------------------------
# üß© CODE EXPLANATION:

# 1Ô∏è‚É£ Load Image:
#    - Loads your own ‚Äúroad.jpg‚Äù if present.
#    - Else creates a white rectangle with ‚ÄúCV‚Äù text on black background.

# 2Ô∏è‚É£ Define Points:
#    - src ‚Üí corners of the rectangle (before transformation)
#    - dst ‚Üí new coordinates to simulate perspective change.

# 3Ô∏è‚É£ Compute Homography:
#    - cv2.findHomography() returns the transformation matrix H.
#    - This matrix expresses how to map one plane onto another.

# 4Ô∏è‚É£ Warp Image:
#    - cv2.warpPerspective() applies H to create a perspective-corrected image.

# 5Ô∏è‚É£ Display:
#    - Shows both images (original & transformed) side by side using Matplotlib.

# -------------------------------------------------------------
# üßÆ Example Homography Matrix (Output):
# Homography Matrix:
# [[ 1.085  0.184 -56.23]
#  [ 0.122  1.046 -28.11]
#  [ 0.001  0.0006  1.00]]
#
# Each element contributes to rotation, scaling, translation, and perspective warping.

# -------------------------------------------------------------
# üìò OUTPUT DESCRIPTION:
# ‚û§ Original Image: The base or custom image (rectangle/text).
# ‚û§ After Homography: Tilted, perspective-shifted version showing 3D-like distortion.

# -------------------------------------------------------------
# üí° APPLICATIONS:
# - Image stitching (panoramas)
# - Augmented reality
# - Camera calibration
# - Document scanning & perspective correction
# - 3D vision (planar transformations)

# -------------------------------------------------------------
# üó£Ô∏è VIVA QUESTIONS:

# Q1. What is Homography?
#     ‚Üí A mapping between two planes using a 3x3 matrix (perspective transform).

# Q2. Difference between Affine and Homography transformation?
#     ‚Üí Affine preserves parallel lines (6 DOF), Homography allows perspective tilt (8 DOF).

# Q3. Function to find Homography in OpenCV?
#     ‚Üí cv2.findHomography(src_points, dst_points)

# Q4. Minimum number of points required for Homography?
#     ‚Üí Four corresponding points (not collinear).

# Q5. What is warpPerspective() used for?
#     ‚Üí Applies a 3x3 perspective transformation to the entire image.

# -------------------------------------------------------------
# ‚úÖ RESULT:
# Successfully computed the Homography matrix and applied it to the image,
# achieving perspective transformation using OpenCV.
