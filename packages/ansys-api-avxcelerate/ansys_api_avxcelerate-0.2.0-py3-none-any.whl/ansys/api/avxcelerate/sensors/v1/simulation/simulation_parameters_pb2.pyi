"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""
import ansys.api.avxcelerate.sensors.v1.sensor_data_format_pb2
import ansys.api.avxcelerate.sensors.v1.tag_colors_pb2
import builtins
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import google.protobuf.wrappers_pb2
import typing
import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor = ...

class _DataDirectMemoryAccessTarget:
    ValueType = typing.NewType('ValueType', builtins.int)
    V: typing_extensions.TypeAlias = ValueType
class _DataDirectMemoryAccessTargetEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_DataDirectMemoryAccessTarget.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
    GPU: DataDirectMemoryAccessTarget.ValueType = ...  # 0
    """Stream data from GPU accessible memory (default)."""

    CPU: DataDirectMemoryAccessTarget.ValueType = ...  # 1
    """Stream data from CPU addressable memory."""

class DataDirectMemoryAccessTarget(_DataDirectMemoryAccessTarget, metaclass=_DataDirectMemoryAccessTargetEnumTypeWrapper):
    """Target memory domain for Data Direct Memory Access.

    Default value: GPU.
    """
    pass

GPU: DataDirectMemoryAccessTarget.ValueType = ...  # 0
"""Stream data from GPU accessible memory (default)."""

CPU: DataDirectMemoryAccessTarget.ValueType = ...  # 1
"""Stream data from CPU addressable memory."""

global___DataDirectMemoryAccessTarget = DataDirectMemoryAccessTarget


class _Qualities:
    ValueType = typing.NewType('ValueType', builtins.int)
    V: typing_extensions.TypeAlias = ValueType
class _QualitiesEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_Qualities.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
    UNDEFINED: Qualities.ValueType = ...  # 0
    """Undefined value. (The default value will apply.)"""

    LOW: Qualities.ValueType = ...  # 1
    """Low quality."""

    MEDIUM: Qualities.ValueType = ...  # 2
    """Medium quality. (Default value for fields in the 
    `LightPropagationEngineSimulationParameters` message.)
    """

    HIGH: Qualities.ValueType = ...  # 3
    """High quality."""

    EXTREME: Qualities.ValueType = ...  # 4
    """Extreme quality. (Default value for fields in the
    `RealTimeParameters` message.)
    """

class Qualities(_Qualities, metaclass=_QualitiesEnumTypeWrapper):
    """The possible values for quality factors."""
    pass

UNDEFINED: Qualities.ValueType = ...  # 0
"""Undefined value. (The default value will apply.)"""

LOW: Qualities.ValueType = ...  # 1
"""Low quality."""

MEDIUM: Qualities.ValueType = ...  # 2
"""Medium quality. (Default value for fields in the 
`LightPropagationEngineSimulationParameters` message.)
"""

HIGH: Qualities.ValueType = ...  # 3
"""High quality."""

EXTREME: Qualities.ValueType = ...  # 4
"""Extreme quality. (Default value for fields in the
`RealTimeParameters` message.)
"""

global___Qualities = Qualities


class _ColorMode:
    ValueType = typing.NewType('ValueType', builtins.int)
    V: typing_extensions.TypeAlias = ValueType
class _ColorModeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_ColorMode.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
    BLACKWHITE: ColorMode.ValueType = ...  # 0
    """Color in shades of gray by the angle of incidence between the 
    surface and viewing direction. (Default value.)
    """

    COATING: ColorMode.ValueType = ...  # 1
    """Color by the dielectric properties of the materials.

    Note: Color assignment is determined by the material indices of each 
    radar simulation instance and is not deterministic.

    Optionally shaded (when `enable_material_shading` is set to `true` 
    in `RadarDebugViewParameters`).
    """

    VELOCITY: ColorMode.ValueType = ...  # 2
    """Color by the relative velocities. 

    The R, G and B values correspond respectively to the velocities in the 
    X, Y and Z direction.
    """

    NORMAL: ColorMode.ValueType = ...  # 3
    """Color by the normal of the surfaces converted to RGB."""

class ColorMode(_ColorMode, metaclass=_ColorModeEnumTypeWrapper):
    """The available color modes for the radar's debug view output."""
    pass

BLACKWHITE: ColorMode.ValueType = ...  # 0
"""Color in shades of gray by the angle of incidence between the 
surface and viewing direction. (Default value.)
"""

COATING: ColorMode.ValueType = ...  # 1
"""Color by the dielectric properties of the materials.

Note: Color assignment is determined by the material indices of each 
radar simulation instance and is not deterministic.

Optionally shaded (when `enable_material_shading` is set to `true` 
in `RadarDebugViewParameters`).
"""

VELOCITY: ColorMode.ValueType = ...  # 2
"""Color by the relative velocities. 

The R, G and B values correspond respectively to the velocities in the 
X, Y and Z direction.
"""

NORMAL: ColorMode.ValueType = ...  # 3
"""Color by the normal of the surfaces converted to RGB."""

global___ColorMode = ColorMode


class _RadarOutputSplittingLevel:
    ValueType = typing.NewType('ValueType', builtins.int)
    V: typing_extensions.TypeAlias = ValueType
class _RadarOutputSplittingLevelEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_RadarOutputSplittingLevel.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
    DEFAULT: RadarOutputSplittingLevel.ValueType = ...  # 0
    """Default value. Output data is not split."""

    MODE: RadarOutputSplittingLevel.ValueType = ...  # 1
    """Split by radar mode."""

    TRANSMITTER: RadarOutputSplittingLevel.ValueType = ...  # 2
    """Split by transmitter."""

class RadarOutputSplittingLevel(_RadarOutputSplittingLevel, metaclass=_RadarOutputSplittingLevelEnumTypeWrapper):
    """The available radar output splitting levels."""
    pass

DEFAULT: RadarOutputSplittingLevel.ValueType = ...  # 0
"""Default value. Output data is not split."""

MODE: RadarOutputSplittingLevel.ValueType = ...  # 1
"""Split by radar mode."""

TRANSMITTER: RadarOutputSplittingLevel.ValueType = ...  # 2
"""Split by transmitter."""

global___RadarOutputSplittingLevel = RadarOutputSplittingLevel


class _RtaoDownscaleFactor:
    ValueType = typing.NewType('ValueType', builtins.int)
    V: typing_extensions.TypeAlias = ValueType
class _RtaoDownscaleFactorEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_RtaoDownscaleFactor.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
    FULL: RtaoDownscaleFactor.ValueType = ...  # 0
    """Default value. No downscale.
    The LPE rendering resolution is used.
    """

    HALF: RtaoDownscaleFactor.ValueType = ...  # 1
    """Downscale the resolution by a factor of 2."""

    QUARTER: RtaoDownscaleFactor.ValueType = ...  # 2
    """Downscale the resolution by a factor of 4."""

class RtaoDownscaleFactor(_RtaoDownscaleFactor, metaclass=_RtaoDownscaleFactorEnumTypeWrapper):
    """Scale values for the resolution at which the raytraced ambient
    occlusion is computed.
    """
    pass

FULL: RtaoDownscaleFactor.ValueType = ...  # 0
"""Default value. No downscale.
The LPE rendering resolution is used.
"""

HALF: RtaoDownscaleFactor.ValueType = ...  # 1
"""Downscale the resolution by a factor of 2."""

QUARTER: RtaoDownscaleFactor.ValueType = ...  # 2
"""Downscale the resolution by a factor of 4."""

global___RtaoDownscaleFactor = RtaoDownscaleFactor


class SimulationParameters(google.protobuf.message.Message):
    """Contains the general simulation parameters and simulation parameters 
    per sensor.

    These parameters define the accuracy of the simulation, the types of output 
    each sensor generates, as well as the output data generation and storage 
    methods.

    Note: Simulation parameters may have an impact on the performance.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    SENSOR_SIMULATION_PARAMETERS_FIELD_NUMBER: builtins.int
    LIGHTING_SYSTEM_PARAMETERS_FIELD_NUMBER: builtins.int
    PIXEL_SEGMENTATION_MAPPING_FIELD_NUMBER: builtins.int
    @property
    def sensor_simulation_parameters(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___SensorParameters]:
        """List of simulation parameters per sensor."""
        pass
    @property
    def lighting_system_parameters(self) -> global___LightingSystemParameters:
        """Lighting system parameters.

        Note: The Lighting System parameters apply to all the Lighting Systems 
        associated to the the ego vehicle.
        """
        pass
    @property
    def pixel_segmentation_mapping(self) -> ansys.api.avxcelerate.sensors.v1.tag_colors_pb2.PixelSegmentationMapping:
        """Configuration of the tag-color mapping used for the pixel segmentation 
        camera ground truth data.
        """
        pass
    def __init__(self,
        *,
        sensor_simulation_parameters : typing.Optional[typing.Iterable[global___SensorParameters]] = ...,
        lighting_system_parameters : typing.Optional[global___LightingSystemParameters] = ...,
        pixel_segmentation_mapping : typing.Optional[ansys.api.avxcelerate.sensors.v1.tag_colors_pb2.PixelSegmentationMapping] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["lighting_system_parameters",b"lighting_system_parameters","pixel_segmentation_mapping",b"pixel_segmentation_mapping"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["lighting_system_parameters",b"lighting_system_parameters","pixel_segmentation_mapping",b"pixel_segmentation_mapping","sensor_simulation_parameters",b"sensor_simulation_parameters"]) -> None: ...
global___SimulationParameters = SimulationParameters

class SensorParameters(google.protobuf.message.Message):
    """Contains the simulation parameters for a given sensor defined by its identifier.

    Note: If the type of sensor is not consistent with the sensor 
    configuration, it will cause an error.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    IDENTIFIER_FIELD_NUMBER: builtins.int
    DISPLAY_FIELD_NUMBER: builtins.int
    RADAR_SIMULATION_FIELD_NUMBER: builtins.int
    LIDAR_SIMULATION_FIELD_NUMBER: builtins.int
    PB_CAM_SIMULATION_FIELD_NUMBER: builtins.int
    THERMAL_CAM_SIMULATION_FIELD_NUMBER: builtins.int
    OUTPUT_SPLITTING_FIELD_NUMBER: builtins.int
    SERIALIZE_DATA_FIELD_NUMBER: builtins.int
    DEPLOY_NODE_ID_FIELD_NUMBER: builtins.int
    DATA_ACCESS_SETTINGS_FIELD_NUMBER: builtins.int
    START_OFFSET_FIELD_NUMBER: builtins.int
    identifier: typing.Text = ...
    """The unique identifier of the sensor as defined in the sensor 
    configuration.
    """

    @property
    def display(self) -> global___DisplayInformation:
        """Field indicating whether or not the camera sensor's outputs are displayed 
        on screen in a dedicated rendering window.

        The resolution of the rendering window is the Native Resolution defined 
        in the Imager parameters of the camera sensor model.

        Note: Optional field. If not set, the camera outputs 
        are not displayed on the screen.

        Note: This parameter applies to physics-based camera sensors only.
        If it is set for any other type of sensors, it is ignored.

        Note: Lens output without custom post-processing, as well as any output 
        with custom post-processing whose encoding format is different than 
        Gray8 or RGB24 are not supported for display. For those unsupported 
        formats, a black image is displayed in the rendering window and a warning 
        is raised in the logs.

        Note: If the fragment shared used for custom post-processing is 
        configured to produce multiple outputs, the Display takes into account 
        only the first output defined in the fragment shader.
        """
        pass
    @property
    def radar_simulation(self) -> global___RadarSimulation:
        """Specific parameters for a radar sensor."""
        pass
    @property
    def lidar_simulation(self) -> global___LidarSimulation:
        """Specific parameters for a lidar sensor."""
        pass
    @property
    def pb_cam_simulation(self) -> global___PbCameraSimulation:
        """Specific parameters for a physics-based camera sensor."""
        pass
    @property
    def thermal_cam_simulation(self) -> global___ThermalCameraSimulation:
        """Specific parameters for a thermal camera sensor."""
        pass
    @property
    def output_splitting(self) -> global___OutputSplitting:
        """Sensor's output data splitting configuration.

        Note: This parameter only applies to radar sensor data. 

        Note: Optional field. If not set, the output data is not split.
        """
        pass
    @property
    def serialize_data(self) -> google.protobuf.wrappers_pb2.BoolValue:
        """Activation of serialization of the output data in shared memory.

        When this parameter is set to `true`, the data is serialized. 
        When this parameter is set to `false`, the data is unserialized.

        Note: Only Camera Output (Image) and Imager Output (Injection) data of 
        physics-based camera sensors can be unserialized. 
        Camera Lens Output (Light), thermal camera, lidar and radar output data 
        are always serialized.

        Default value: true
        """
        pass
    deploy_node_id: typing.Text = ...
    """The identifier of the deploy node on which the sensor is spawned, 
    as defined in the deploy configuration.

    Note: Optional field. If not set, the sensor process is executed 
    on the local host.
    """

    @property
    def data_access_settings(self) -> global___DataAccessSettings:
        """Configuration of the output data generation and storage 
        methods.
        """
        pass
    start_offset: builtins.float = ...
    """Delay between the start of the simulation and the 
    sensor's frame cycle.

    Unit: millisecond (ms)

    Range: Positive
    """

    def __init__(self,
        *,
        identifier : typing.Text = ...,
        display : typing.Optional[global___DisplayInformation] = ...,
        radar_simulation : typing.Optional[global___RadarSimulation] = ...,
        lidar_simulation : typing.Optional[global___LidarSimulation] = ...,
        pb_cam_simulation : typing.Optional[global___PbCameraSimulation] = ...,
        thermal_cam_simulation : typing.Optional[global___ThermalCameraSimulation] = ...,
        output_splitting : typing.Optional[global___OutputSplitting] = ...,
        serialize_data : typing.Optional[google.protobuf.wrappers_pb2.BoolValue] = ...,
        deploy_node_id : typing.Text = ...,
        data_access_settings : typing.Optional[global___DataAccessSettings] = ...,
        start_offset : builtins.float = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["data_access_settings",b"data_access_settings","display",b"display","lidar_simulation",b"lidar_simulation","output_splitting",b"output_splitting","pb_cam_simulation",b"pb_cam_simulation","radar_simulation",b"radar_simulation","sensor_parameter",b"sensor_parameter","serialize_data",b"serialize_data","thermal_cam_simulation",b"thermal_cam_simulation"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["data_access_settings",b"data_access_settings","deploy_node_id",b"deploy_node_id","display",b"display","identifier",b"identifier","lidar_simulation",b"lidar_simulation","output_splitting",b"output_splitting","pb_cam_simulation",b"pb_cam_simulation","radar_simulation",b"radar_simulation","sensor_parameter",b"sensor_parameter","serialize_data",b"serialize_data","start_offset",b"start_offset","thermal_cam_simulation",b"thermal_cam_simulation"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal["sensor_parameter",b"sensor_parameter"]) -> typing.Optional[typing_extensions.Literal["radar_simulation","lidar_simulation","pb_cam_simulation","thermal_cam_simulation"]]: ...
global___SensorParameters = SensorParameters

class DisplayInformation(google.protobuf.message.Message):
    """Settings for the Display of a camera sensor."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    TOP_LEFT_CORNER_POSITION_FIELD_NUMBER: builtins.int
    DISPLAY_ONLY_FIELD_NUMBER: builtins.int
    @property
    def top_left_corner_position(self) -> global___TopLeftCornerPosition:
        """Position of the top left corner of the rendering window."""
        pass
    display_only: builtins.bool = ...
    """Activation of the Display Only mode.

    When the Display Only mode is activated (value set to `true`), 
    the camera output is only displayed in the rendering window. No data 
    is recorded (neither in the shared memory nor dumped on disk) 
    and the `recording_format` parameter is ignored.

    When the Display Only mode is deactivated (value set to `false`, which is 
    the default value), the camera output data are both generated in 
    shared memory and displayed in the rendering window.

    Default value: false
    """

    def __init__(self,
        *,
        top_left_corner_position : typing.Optional[global___TopLeftCornerPosition] = ...,
        display_only : builtins.bool = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["top_left_corner_position",b"top_left_corner_position"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["display_only",b"display_only","top_left_corner_position",b"top_left_corner_position"]) -> None: ...
global___DisplayInformation = DisplayInformation

class DataAccessSettings(google.protobuf.message.Message):
    """Selection of the output data generation method.
    Only one data generation method should be set.

    Note: If no data generation method is set, the default 
    behavior is to activate output data production in shared memory.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    RECORDING_FORMAT_FIELD_NUMBER: builtins.int
    SHARED_MEMORY_ACCESS_FIELD_NUMBER: builtins.int
    REMOTE_DIRECT_MEMORY_ACCESS_FIELD_NUMBER: builtins.int
    DATA_DIRECT_MEMORY_ACCESS_FIELD_NUMBER: builtins.int
    @property
    def recording_format(self) -> global___RecordingFormat:
        """Activation of output data saving to disk, and 
        configuration of the type of data and file format.
        Refer to the `RecordingFormat` message for more information.
        """
        pass
    @property
    def shared_memory_access(self) -> google.protobuf.wrappers_pb2.BoolValue:
        """Activation of output data production in shared memory.

        The data stored in shared memory can be accessed via a notification-based 
        mechanism.

        Default value: true
        """
        pass
    @property
    def remote_direct_memory_access(self) -> global___RemoteDirectMemoryAccess:
        """Activation and configuration of output data production for 
        Remote Direct Memory Access using the pre-build RDMA sender.

        Note: This parameter only applies to camera output data.

        Note: Data access using Remote Direct Memory Access (RDMA) technology 
        is delivered as a beta feature in the current release.
        """
        pass
    @property
    def data_direct_memory_access(self) -> global___DataDirectMemoryAccess:
        """Configuration of output data production using
        Data Direct Memory Access (DDMA).

        Data can be streamed directly from GPU or CPU memory using the
        DDMA extension.

        Note: When this field is set, the DDMA extension must be properly configured.

        Note: This feature is only available for camera and radar.
        For camera output, DDMA is only supported when using
        `LightPropagationEngineSimulationParameters`.

        Note: Data access using Direct Memory Access (DDMA)
        is delivered as a beta feature in the current release.
        """
        pass
    def __init__(self,
        *,
        recording_format : typing.Optional[global___RecordingFormat] = ...,
        shared_memory_access : typing.Optional[google.protobuf.wrappers_pb2.BoolValue] = ...,
        remote_direct_memory_access : typing.Optional[global___RemoteDirectMemoryAccess] = ...,
        data_direct_memory_access : typing.Optional[global___DataDirectMemoryAccess] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["data_access_settings",b"data_access_settings","data_direct_memory_access",b"data_direct_memory_access","recording_format",b"recording_format","remote_direct_memory_access",b"remote_direct_memory_access","shared_memory_access",b"shared_memory_access"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["data_access_settings",b"data_access_settings","data_direct_memory_access",b"data_direct_memory_access","recording_format",b"recording_format","remote_direct_memory_access",b"remote_direct_memory_access","shared_memory_access",b"shared_memory_access"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal["data_access_settings",b"data_access_settings"]) -> typing.Optional[typing_extensions.Literal["recording_format","shared_memory_access","remote_direct_memory_access","data_direct_memory_access"]]: ...
global___DataAccessSettings = DataAccessSettings

class RemoteDirectMemoryAccess(google.protobuf.message.Message):
    """Configuration of Remote Direct Memory Access.

    Note: Data access using Remote Direct Memory Access (RDMA) technology
    is delivered as a beta feature in the current release.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    TRANSFER_CHUNK_SIZE_FIELD_NUMBER: builtins.int
    SENDER_ADDRESS_FIELD_NUMBER: builtins.int
    SENDER_PORT_FIELD_NUMBER: builtins.int
    SENDER_BACKCHANNEL_PORT_FIELD_NUMBER: builtins.int
    POST_EMBEDDED_DATA_LINE_COUNT_FIELD_NUMBER: builtins.int
    POST_EMBEDDED_DATA_LINE_PAYLOAD_SIZE_FIELD_NUMBER: builtins.int
    PRE_EMBEDDED_DATA_LINE_COUNT_FIELD_NUMBER: builtins.int
    PRE_EMBEDDED_DATA_LINE_PAYLOAD_SIZE_FIELD_NUMBER: builtins.int
    transfer_chunk_size: builtins.int = ...
    """Size of the RDMA data chunk in bytes."""

    sender_address: typing.Text = ...
    """Sender's IPv4 address."""

    @property
    def sender_port(self) -> google.protobuf.wrappers_pb2.Int32Value:
        """Sender's TCP port."""
        pass
    @property
    def sender_backchannel_port(self) -> google.protobuf.wrappers_pb2.Int32Value:
        """Sender's back-channel port."""
        pass
    @property
    def post_embedded_data_line_count(self) -> google.protobuf.wrappers_pb2.Int32Value:
        """Number of expected post-embedded data lines."""
        pass
    @property
    def post_embedded_data_line_payload_size(self) -> google.protobuf.wrappers_pb2.Int32Value:
        """Total size in bytes of the post-embedded data lines."""
        pass
    @property
    def pre_embedded_data_line_count(self) -> google.protobuf.wrappers_pb2.Int32Value:
        """Number of expected pre-embedded data lines."""
        pass
    @property
    def pre_embedded_data_line_payload_size(self) -> google.protobuf.wrappers_pb2.Int32Value:
        """Total size in bytes of the pre-embedded data lines."""
        pass
    def __init__(self,
        *,
        transfer_chunk_size : builtins.int = ...,
        sender_address : typing.Text = ...,
        sender_port : typing.Optional[google.protobuf.wrappers_pb2.Int32Value] = ...,
        sender_backchannel_port : typing.Optional[google.protobuf.wrappers_pb2.Int32Value] = ...,
        post_embedded_data_line_count : typing.Optional[google.protobuf.wrappers_pb2.Int32Value] = ...,
        post_embedded_data_line_payload_size : typing.Optional[google.protobuf.wrappers_pb2.Int32Value] = ...,
        pre_embedded_data_line_count : typing.Optional[google.protobuf.wrappers_pb2.Int32Value] = ...,
        pre_embedded_data_line_payload_size : typing.Optional[google.protobuf.wrappers_pb2.Int32Value] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["post_embedded_data_line_count",b"post_embedded_data_line_count","post_embedded_data_line_payload_size",b"post_embedded_data_line_payload_size","pre_embedded_data_line_count",b"pre_embedded_data_line_count","pre_embedded_data_line_payload_size",b"pre_embedded_data_line_payload_size","sender_backchannel_port",b"sender_backchannel_port","sender_port",b"sender_port"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["post_embedded_data_line_count",b"post_embedded_data_line_count","post_embedded_data_line_payload_size",b"post_embedded_data_line_payload_size","pre_embedded_data_line_count",b"pre_embedded_data_line_count","pre_embedded_data_line_payload_size",b"pre_embedded_data_line_payload_size","sender_address",b"sender_address","sender_backchannel_port",b"sender_backchannel_port","sender_port",b"sender_port","transfer_chunk_size",b"transfer_chunk_size"]) -> None: ...
global___RemoteDirectMemoryAccess = RemoteDirectMemoryAccess

class DataDirectMemoryAccess(google.protobuf.message.Message):
    """Configuration of Data Direct Memory Access (DDMA)."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    TARGET_FIELD_NUMBER: builtins.int
    target: global___DataDirectMemoryAccessTarget.ValueType = ...
    """Target memory domain for DDMA.

    Default value: GPU.
    """

    def __init__(self,
        *,
        target : global___DataDirectMemoryAccessTarget.ValueType = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["target",b"target"]) -> None: ...
global___DataDirectMemoryAccess = DataDirectMemoryAccess

class TopLeftCornerPosition(google.protobuf.message.Message):
    """Position of the top left corner of the rendering window relative to
    the top left corner of the monitor.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    X_FIELD_NUMBER: builtins.int
    Y_FIELD_NUMBER: builtins.int
    x: builtins.int = ...
    """The horizontal offset (in pixels) of the rendering window from the 
    top left corner of the monitor.

    Default value: 1
    """

    y: builtins.int = ...
    """The vertical offset (in pixels) of the rendering window from the 
    top left corner of the monitor.

    Default value: 1
    """

    def __init__(self,
        *,
        x : builtins.int = ...,
        y : builtins.int = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["x",b"x","y",b"y"]) -> None: ...
global___TopLeftCornerPosition = TopLeftCornerPosition

class PbCameraSimulation(google.protobuf.message.Message):
    """Simulation parameters for a physics-based camera."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    RENDERING_PARAMETERS_FIELD_NUMBER: builtins.int
    GPU_NAME_FIELD_NUMBER: builtins.int
    @property
    def rendering_parameters(self) -> global___RenderingParameters:
        """The rendering engine parameters."""
        pass
    gpu_name: typing.Text = ...
    """The GPU name that must be used for the simulation of this 
    camera sensor.

    Note: The GPU name must correspond to an existing name set in 
    the GpuIdentifier in a deploy or local host in the deploy configuration.

    Note: Optional field. If not set, the default GPU (whose index is 0) 
    will be used.
    """

    def __init__(self,
        *,
        rendering_parameters : typing.Optional[global___RenderingParameters] = ...,
        gpu_name : typing.Text = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["rendering_parameters",b"rendering_parameters"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["gpu_name",b"gpu_name","rendering_parameters",b"rendering_parameters"]) -> None: ...
global___PbCameraSimulation = PbCameraSimulation

class CameraGroundTruthParameters(google.protobuf.message.Message):
    """Types of ground truth output data generated by the 
    physics-based camera.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    GENERATE_DEPTH_MAP_FIELD_NUMBER: builtins.int
    GENERATE_OPTICAL_FLOW_FIELD_NUMBER: builtins.int
    GENERATE_PIXEL_SEGMENTATION_FIELD_NUMBER: builtins.int
    GENERATE_2D_BOUNDING_BOXES_FIELD_NUMBER: builtins.int
    generate_depth_map: builtins.bool = ...
    """Activation of the depth map production.

    A depth map indicates for each pixel the distance of the associated point 
    relative to the camera sensor's mounting position.

    Default value: false
    """

    generate_optical_flow: builtins.bool = ...
    """Activation of the optical flow production.

    The optical flow indicates for each pixel the linear speed of the 
    associated point relative to the camera sensor's mounting position.

    Default value: false
    """

    generate_pixel_segmentation: builtins.bool = ...
    """Activation of the pixel segmentation production.

    The pixel segmentation gives a color to each pixel based on the object 
    it belongs to.

    Default value: false
    """

    generate_2d_bounding_boxes: builtins.bool = ...
    """Activation of the bounding boxes production.

    This parameter activates the generation of 2D and 3D bounding boxes.

    For more details on the bounding box data generated in shared memory, 
    refer to the `BoundingBox2D` and `BoundingBox3D` messages.

    For more details on the file generated on disk, 
    refer to AVxcelerate Sensors Simulator User's Guide.

    Default value: false
    """

    def __init__(self,
        *,
        generate_depth_map : builtins.bool = ...,
        generate_optical_flow : builtins.bool = ...,
        generate_pixel_segmentation : builtins.bool = ...,
        generate_2d_bounding_boxes : builtins.bool = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["generate_2d_bounding_boxes",b"generate_2d_bounding_boxes","generate_depth_map",b"generate_depth_map","generate_optical_flow",b"generate_optical_flow","generate_pixel_segmentation",b"generate_pixel_segmentation"]) -> None: ...
global___CameraGroundTruthParameters = CameraGroundTruthParameters

class ThermalCameraSimulation(google.protobuf.message.Message):
    """Simulation parameters for a thermal camera."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    RENDERING_PARAMETERS_FIELD_NUMBER: builtins.int
    GPU_NAME_FIELD_NUMBER: builtins.int
    @property
    def rendering_parameters(self) -> global___RenderingParameters:
        """The rendering engine parameters."""
        pass
    gpu_name: typing.Text = ...
    """The GPU name that must be used for the simulation of this 
    thermal camera sensor.

    Note: The GPU name must correspond to a GpuIdentifier name specified in 
    the deploy parameters.

    Note: Optional field. If not set, the default GPU (whose index is 0) 
    will be used.
    """

    def __init__(self,
        *,
        rendering_parameters : typing.Optional[global___RenderingParameters] = ...,
        gpu_name : typing.Text = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["rendering_parameters",b"rendering_parameters"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["gpu_name",b"gpu_name","rendering_parameters",b"rendering_parameters"]) -> None: ...
global___ThermalCameraSimulation = ThermalCameraSimulation

class RenderingParameters(google.protobuf.message.Message):
    """Rendering engine parameters for the camera sensor."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class RealTimeParameters(google.protobuf.message.Message):
        """Camera simulation parameters for real time rendering."""
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        CAMERA_NEAR_PLANE_FIELD_NUMBER: builtins.int
        CAMERA_FAR_PLANE_FIELD_NUMBER: builtins.int
        SHADOW_QUALITY_FIELD_NUMBER: builtins.int
        TEXTURE_QUALITY_FIELD_NUMBER: builtins.int
        ANTIALIASING_FACTOR_FIELD_NUMBER: builtins.int
        CAMERA_GROUND_TRUTH_PARAMETERS_FIELD_NUMBER: builtins.int
        @property
        def camera_near_plane(self) -> google.protobuf.wrappers_pb2.FloatValue:
            """The camera near plane value.

            Unit: meters (m)

            Range: ]0, `camera_far_plane`[

            Default value:  0.1
            """
            pass
        @property
        def camera_far_plane(self) -> google.protobuf.wrappers_pb2.FloatValue:
            """The camera far plane.

            Unit: meters (m)

            Range: ]`CameraNearPlane`, float max]

            Default value: 10000.0
            """
            pass
        shadow_quality: global___Qualities.ValueType = ...
        """The camera shadow quality.

        Default value: EXTREME
        """

        texture_quality: global___Qualities.ValueType = ...
        """The camera texture quality.

        Default value: EXTREME
        """

        @property
        def antialiasing_factor(self) -> google.protobuf.wrappers_pb2.FloatValue:
            """The camera antialiasing factor.

            Range: [1.0, 4.0]

            Default value: 1.0
            """
            pass
        @property
        def camera_ground_truth_parameters(self) -> global___CameraGroundTruthParameters:
            """Activation of ground truth output production.

            Ground truth output data can be used to test or train a perception 
            algorithms.

            Note: Optional field. If not set, no ground truth output is generated.
            """
            pass
        def __init__(self,
            *,
            camera_near_plane : typing.Optional[google.protobuf.wrappers_pb2.FloatValue] = ...,
            camera_far_plane : typing.Optional[google.protobuf.wrappers_pb2.FloatValue] = ...,
            shadow_quality : global___Qualities.ValueType = ...,
            texture_quality : global___Qualities.ValueType = ...,
            antialiasing_factor : typing.Optional[google.protobuf.wrappers_pb2.FloatValue] = ...,
            camera_ground_truth_parameters : typing.Optional[global___CameraGroundTruthParameters] = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["antialiasing_factor",b"antialiasing_factor","camera_far_plane",b"camera_far_plane","camera_ground_truth_parameters",b"camera_ground_truth_parameters","camera_near_plane",b"camera_near_plane"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["antialiasing_factor",b"antialiasing_factor","camera_far_plane",b"camera_far_plane","camera_ground_truth_parameters",b"camera_ground_truth_parameters","camera_near_plane",b"camera_near_plane","shadow_quality",b"shadow_quality","texture_quality",b"texture_quality"]) -> None: ...

    BORDERLESS_FIELD_NUMBER: builtins.int
    VERTICAL_SYNC_FIELD_NUMBER: builtins.int
    ENABLE_ALPHA_CHANNEL_FIELD_NUMBER: builtins.int
    ENABLE_ASYNCHRONOUS_READBACK_FIELD_NUMBER: builtins.int
    REAL_TIME_PARAMETERS_FIELD_NUMBER: builtins.int
    LPE_PARAMETERS_FIELD_NUMBER: builtins.int
    @property
    def borderless(self) -> google.protobuf.wrappers_pb2.BoolValue:
        """Field indicating whether or not the rendering window is borderless.

        Default value: false
        """
        pass
    @property
    def vertical_sync(self) -> google.protobuf.wrappers_pb2.BoolValue:
        """Activation of the vertical synchronization between the rendering 
        frequency of the Display and the frame rate of the screen where the 
        rendering window is located.

        Default value: false
        """
        pass
    @property
    def enable_alpha_channel(self) -> google.protobuf.wrappers_pb2.BoolValue:
        """Activation of the alpha channel in the camera output.

        Default value: true

        Note: The values for the alpha channel are not used and are filled with 
        default values.
        """
        pass
    enable_asynchronous_readback: builtins.bool = ...
    """Activation of the asynchronous GPU readback.

    Default value: false

    Note: Asynchronous GPU readback is delivered 
    as a beta feature in the current release.
    """

    @property
    def real_time_parameters(self) -> global___RenderingParameters.RealTimeParameters:
        """Camera simulation parameters for real time rendering."""
        pass
    @property
    def lpe_parameters(self) -> global___LightPropagationEngineSimulationParameters:
        """Camera simulation parameters for the Light Propagation Engine.

        Note: The Light Propagation Engine is delivered as a beta feature in the
        current release.
        """
        pass
    def __init__(self,
        *,
        borderless : typing.Optional[google.protobuf.wrappers_pb2.BoolValue] = ...,
        vertical_sync : typing.Optional[google.protobuf.wrappers_pb2.BoolValue] = ...,
        enable_alpha_channel : typing.Optional[google.protobuf.wrappers_pb2.BoolValue] = ...,
        enable_asynchronous_readback : builtins.bool = ...,
        real_time_parameters : typing.Optional[global___RenderingParameters.RealTimeParameters] = ...,
        lpe_parameters : typing.Optional[global___LightPropagationEngineSimulationParameters] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["borderless",b"borderless","enable_alpha_channel",b"enable_alpha_channel","lpe_parameters",b"lpe_parameters","real_time_parameters",b"real_time_parameters","specific_parameters",b"specific_parameters","vertical_sync",b"vertical_sync"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["borderless",b"borderless","enable_alpha_channel",b"enable_alpha_channel","enable_asynchronous_readback",b"enable_asynchronous_readback","lpe_parameters",b"lpe_parameters","real_time_parameters",b"real_time_parameters","specific_parameters",b"specific_parameters","vertical_sync",b"vertical_sync"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal["specific_parameters",b"specific_parameters"]) -> typing.Optional[typing_extensions.Literal["real_time_parameters","lpe_parameters"]]: ...
global___RenderingParameters = RenderingParameters

class RadarSimulation(google.protobuf.message.Message):
    """Simulation parameters for a radar and, optionally, 
    the type of execution batching method.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class MaxRayPathLengthByModeEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: builtins.int = ...
        value: builtins.float = ...
        def __init__(self,
            *,
            key : builtins.int = ...,
            value : builtins.float = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["key",b"key","value",b"value"]) -> None: ...

    class MaxVelocityByModeEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: builtins.int = ...
        value: builtins.float = ...
        def __init__(self,
            *,
            key : builtins.int = ...,
            value : builtins.float = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["key",b"key","value",b"value"]) -> None: ...

    NUMBER_OF_RAY_REFLECTIONS_FIELD_NUMBER: builtins.int
    NUMBER_OF_RAY_TRANSMISSIONS_FIELD_NUMBER: builtins.int
    GRID_SAMPLING_FIELD_NUMBER: builtins.int
    MANUAL_BATCHING_FIELD_NUMBER: builtins.int
    AUTOMATIC_BATCHING_FIELD_NUMBER: builtins.int
    TX_WAVEFORM_REPORT_FIELD_NUMBER: builtins.int
    EGO_VEHICLE_EMISSION_BLOCKAGE_FIELD_NUMBER: builtins.int
    DEBUG_VIEW_PARAMETERS_FIELD_NUMBER: builtins.int
    MAX_RAY_PATH_LENGTH_BY_MODE_FIELD_NUMBER: builtins.int
    MAX_VELOCITY_BY_MODE_FIELD_NUMBER: builtins.int
    USE_CURVATURE_FIELD_NUMBER: builtins.int
    number_of_ray_reflections: builtins.int = ...
    """The maximum number of ray bounces (reflections) on the scene's objects 
    before the ray is forced to return to the sensor.

    Note: The limit applies to each individual ray.
    """

    number_of_ray_transmissions: builtins.int = ...
    """The maximum number of transmissions on the scene's objects before 
    the ray is forced to return to the sensor.

    Note: The limit applies to each individual ray.
    """

    @property
    def grid_sampling(self) -> global___RadarGridSampling:
        """The sampling of the grid."""
        pass
    @property
    def manual_batching(self) -> global___ManualBatching:
        """Configuration of the manual batching.

        Note: Optional field. By default, the sensor execution is not batched.
        """
        pass
    @property
    def automatic_batching(self) -> global___AutomaticBatching:
        """Configuration of the automatic batching.

        Note: Optional field. By default, the sensor execution is not batched.
        """
        pass
    tx_waveform_report: builtins.bool = ...
    """Activation of the tx waveform output generation by the radar.

    Default value: false
    """

    ego_vehicle_emission_blockage: builtins.bool = ...
    """Field indicating whether or not the Ego vehicle geometry will be 
    considered in calculations upon the emission of the ray's first bounce.

    When this parameter is set to `true`, the ego vehicle geometry 
    is considered in calculations upon the emission of the ray's first 
    bounce.

    When this parameter is set to `false` (which is the default value), 
    the ego vehicle geometry is not considered in calculations upon the 
    emission of the ray's first bounce.

    Default value: false
    """

    @property
    def debug_view_parameters(self) -> global___RadarDebugViewParameters:
        """Parameters for the generation of debug view images. 

        Optional field. If not set, the debug view images are not generated.
        """
        pass
    @property
    def max_ray_path_length_by_mode(self) -> google.protobuf.internal.containers.ScalarMap[builtins.int, builtins.float]:
        """The maximal length for the ray path per radar mode.

        Key [int32]: The mode id.

        Value [double]: The maximal length for the ray path.

        Unit: meters (m)

        Range: ]0, 2 * `max_path_length`[

        Default value:  200

        Note: Features with total path length greater than twice the max ray path
        length, including the path back to the radar, will be excluded.

        Note: This parameter only applies to radars with arbitrary waveform.
        """
        pass
    @property
    def max_velocity_by_mode(self) -> google.protobuf.internal.containers.ScalarMap[builtins.int, builtins.float]:
        """The maximal velocity for each radar mode. 

        Key [int32]: The mode id.

        Value [double]: The maximal velocity.

        Unit: meters per second (m/s)

        Range: ]0, double max[

        Default value:  75

        Note: Features with (absolute value of) relative velocity greater than
        the maximal velocity will be excluded.

        Note: This parameter only applies to radars with arbitrary waveform.
        """
        pass
    use_curvature: builtins.bool = ...
    """Field indicating whether or not to consider the curvature of a surface
    for bouncing rays.

    Default value: false

    Note: Curvatures are always considered for the signal construction.

    Note: Curvature consideration is delivered as a beta feature in the
    current release.
    """

    def __init__(self,
        *,
        number_of_ray_reflections : builtins.int = ...,
        number_of_ray_transmissions : builtins.int = ...,
        grid_sampling : typing.Optional[global___RadarGridSampling] = ...,
        manual_batching : typing.Optional[global___ManualBatching] = ...,
        automatic_batching : typing.Optional[global___AutomaticBatching] = ...,
        tx_waveform_report : builtins.bool = ...,
        ego_vehicle_emission_blockage : builtins.bool = ...,
        debug_view_parameters : typing.Optional[global___RadarDebugViewParameters] = ...,
        max_ray_path_length_by_mode : typing.Optional[typing.Mapping[builtins.int, builtins.float]] = ...,
        max_velocity_by_mode : typing.Optional[typing.Mapping[builtins.int, builtins.float]] = ...,
        use_curvature : builtins.bool = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["automatic_batching",b"automatic_batching","batching",b"batching","debug_view_parameters",b"debug_view_parameters","grid_sampling",b"grid_sampling","manual_batching",b"manual_batching"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["automatic_batching",b"automatic_batching","batching",b"batching","debug_view_parameters",b"debug_view_parameters","ego_vehicle_emission_blockage",b"ego_vehicle_emission_blockage","grid_sampling",b"grid_sampling","manual_batching",b"manual_batching","max_ray_path_length_by_mode",b"max_ray_path_length_by_mode","max_velocity_by_mode",b"max_velocity_by_mode","number_of_ray_reflections",b"number_of_ray_reflections","number_of_ray_transmissions",b"number_of_ray_transmissions","tx_waveform_report",b"tx_waveform_report","use_curvature",b"use_curvature"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal["batching",b"batching"]) -> typing.Optional[typing_extensions.Literal["manual_batching","automatic_batching"]]: ...
global___RadarSimulation = RadarSimulation

class RadarDebugViewParameters(google.protobuf.message.Message):
    """Parameters for the radar's debug view images."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    COLOR_MODE_FIELD_NUMBER: builtins.int
    IMAGE_WIDTH_FIELD_NUMBER: builtins.int
    BACKGROUND_GRAY_LEVEL_FIELD_NUMBER: builtins.int
    ENABLE_MATERIAL_SHADING_FIELD_NUMBER: builtins.int
    OVERSAMPLE_FIELD_NUMBER: builtins.int
    color_mode: global___ColorMode.ValueType = ...
    """The color mode of the debug view images."""

    @property
    def image_width(self) -> google.protobuf.wrappers_pb2.Int32Value:
        """The width of the debug view images.

        Range: ]0, int32 max]

        Default value: 1024

        Note: The debug view image is square (width = height).
        """
        pass
    @property
    def background_gray_level(self) -> google.protobuf.wrappers_pb2.Int32Value:
        """The gray level of the debug view image's background.

        Range: [0, 255]

        Default value: 128
        """
        pass
    @property
    def enable_material_shading(self) -> google.protobuf.wrappers_pb2.BoolValue:
        """Activation of the shading on materials in the output images 
        of the debug view with the `COATING` color mode. 
        Shading materials eases image interpretation by humans.

        Note: This parameter only applies to debug view images with the `COATING` 
        color mode. Its value will not be considered if any other color mode is 
        used.

        Default value: false
        """
        pass
    @property
    def oversample(self) -> google.protobuf.wrappers_pb2.DoubleValue:
        """The rasterization density when rasterizing the triangles to fill 
        image pixels.

        Range: ]0, double max]

        Default value: 1.0

        Note: It is recommended to start with 1.0 and increase as needed to 
        achieve the desired image quality.
        """
        pass
    def __init__(self,
        *,
        color_mode : global___ColorMode.ValueType = ...,
        image_width : typing.Optional[google.protobuf.wrappers_pb2.Int32Value] = ...,
        background_gray_level : typing.Optional[google.protobuf.wrappers_pb2.Int32Value] = ...,
        enable_material_shading : typing.Optional[google.protobuf.wrappers_pb2.BoolValue] = ...,
        oversample : typing.Optional[google.protobuf.wrappers_pb2.DoubleValue] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["background_gray_level",b"background_gray_level","enable_material_shading",b"enable_material_shading","image_width",b"image_width","oversample",b"oversample"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["background_gray_level",b"background_gray_level","color_mode",b"color_mode","enable_material_shading",b"enable_material_shading","image_width",b"image_width","oversample",b"oversample"]) -> None: ...
global___RadarDebugViewParameters = RadarDebugViewParameters

class RadarGridSampling(google.protobuf.message.Message):
    """Radar grid sampling specifies the global sampling and the adaptive
    sampling to be applied to the scene.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class AdaptiveSamplingEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: typing.Text = ...
        @property
        def value(self) -> global___RadarGridSamplingParameters: ...
        def __init__(self,
            *,
            key : typing.Text = ...,
            value : typing.Optional[global___RadarGridSamplingParameters] = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["value",b"value"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["key",b"key","value",b"value"]) -> None: ...

    GLOBAL_SAMPLING_FIELD_NUMBER: builtins.int
    ADAPTIVE_SAMPLING_FIELD_NUMBER: builtins.int
    @property
    def global_sampling(self) -> global___RadarGridSamplingParameters:
        """Global sampling defining the default sampling to be applied to the scene."""
        pass
    @property
    def adaptive_sampling(self) -> google.protobuf.internal.containers.MessageMap[typing.Text, global___RadarGridSamplingParameters]:
        """The tag-sampling mapping table for adaptive sampling which assigns ray 
        spacing values to tagged objects.

        Note: If a tag is not associated with any object in the scene, the simulation
        will stop with an error.

        Key [string]: The name of the tag.

        Note: For pre-defined tags, use the CamelCase form of the tag name in 
        AVxcelerate Asset Preparation Editor. For example, 
        "RoadSign" for Road Sign, "StreetLight" for Street Light, 
        "SteeringWheel" for Steering Wheel. 
        Be aware of the following two exceptions: "SimulationObject" should be used 
        instead of Object, "Indicator" should be used instead of Turn Indicator. 
        For custom tags, the expected text string is the name of the tag as 
        it is written in AVxcelerate Asset Preparation Editor.

        Value [`RadarGridSamplingParameters`]: Refer to this message for details.

        Note: For tags belonging to the same hierarchy of objects, the ray 
        spacing value assigned to a child-node tag must be less than or equal to 
        that of the parent-node tag. If the ray spacing value of 
        the child-node tag is greater than that of the parent-node tag, 
        it will be be lowered to match the ray spacing value of the parent-node 
        tag.
        """
        pass
    def __init__(self,
        *,
        global_sampling : typing.Optional[global___RadarGridSamplingParameters] = ...,
        adaptive_sampling : typing.Optional[typing.Mapping[typing.Text, global___RadarGridSamplingParameters]] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["global_sampling",b"global_sampling"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["adaptive_sampling",b"adaptive_sampling","global_sampling",b"global_sampling"]) -> None: ...
global___RadarGridSampling = RadarGridSampling

class RadarGridSamplingParameters(google.protobuf.message.Message):
    """Radar grid sampling parameters, which consist of the ray spacing 
    parameter.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    RAY_SPACING_FIELD_NUMBER: builtins.int
    ray_spacing: builtins.float = ...
    """For global sampling, the ray spacing is expressed as the distance between 
    adjacent rays measured at 100m from the source.

    For adaptive sampling, the ray spacing is expressed as the distance 
    between adjacent rays regardless of the distance of the object from the 
    source (the number of rays hitting the object will be kept constant 
    all across the simulation).

    Unit: meter (m)

    Range: ]0, double max]
    """

    def __init__(self,
        *,
        ray_spacing : builtins.float = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["ray_spacing",b"ray_spacing"]) -> None: ...
global___RadarGridSamplingParameters = RadarGridSamplingParameters

class ManualBatching(google.protobuf.message.Message):
    """Manual batching configuration.

    Note: With the manual batching method, the number of batches for rays and 
    rx channels must be specified.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class GpuByModesEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: builtins.int = ...
        value: typing.Text = ...
        def __init__(self,
            *,
            key : builtins.int = ...,
            value : typing.Text = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["key",b"key","value",b"value"]) -> None: ...

    NUMBER_OF_RAY_BATCHES_FIELD_NUMBER: builtins.int
    RX_BATCHING_FIELD_NUMBER: builtins.int
    GPU_BY_MODES_FIELD_NUMBER: builtins.int
    number_of_ray_batches: builtins.int = ...
    """The number of batches on casted rays: applies to all the radar modes."""

    @property
    def rx_batching(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___RxBatching]:
        """The batching on rx channels."""
        pass
    @property
    def gpu_by_modes(self) -> google.protobuf.internal.containers.ScalarMap[builtins.int, typing.Text]:
        """Definition of the GPU to use for the simulation of 
        each mode of this radar sensor.

        Key [int32]: The mode id.

        Value [string]: The GPU name.

        Note: The GPU names must correspond to the GpuIdentifier names specified 
        in the deploy parameters.
        """
        pass
    def __init__(self,
        *,
        number_of_ray_batches : builtins.int = ...,
        rx_batching : typing.Optional[typing.Iterable[global___RxBatching]] = ...,
        gpu_by_modes : typing.Optional[typing.Mapping[builtins.int, typing.Text]] = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["gpu_by_modes",b"gpu_by_modes","number_of_ray_batches",b"number_of_ray_batches","rx_batching",b"rx_batching"]) -> None: ...
global___ManualBatching = ManualBatching

class AutomaticBatching(google.protobuf.message.Message):
    """Automatic batching configuration.

    Note: With the automatic batching method, the number of batches on rays and 
    on rx channels are computed by the system taking into account the 
    specified two constraints. 
    There are two possibilities for the second constraint according to your 
    needs: 
    To use the default GPU, set the `gpu_memory_quota`. 
    To use any other GPU or several GPUs, set the `gpu_quotas`.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class GpuQuotasEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: typing.Text = ...
        value: builtins.float = ...
        def __init__(self,
            *,
            key : typing.Text = ...,
            value : builtins.float = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["key",b"key","value",b"value"]) -> None: ...

    MAX_NUMBER_OF_RAY_BATCHES_FIELD_NUMBER: builtins.int
    GPU_MEMORY_QUOTA_FIELD_NUMBER: builtins.int
    GPU_QUOTAS_FIELD_NUMBER: builtins.int
    max_number_of_ray_batches: builtins.int = ...
    """First constraint: the upper bound on the automatically computed number 
    of ray batches.
    """

    gpu_memory_quota: builtins.float = ...
    """Second constraint, option 1: the max fraction (quota) of the total 
    GPU memory that can be used. The default GPU (whose index is 0) will be 
    used.
    """

    @property
    def gpu_quotas(self) -> google.protobuf.internal.containers.ScalarMap[typing.Text, builtins.float]:
        """Second constraint, option 2: the max fraction (quota) of the total memory 
        of the specified GPU that can be used.

        Key [string]: The GPU name.

        Note: The GPU names must correspond to the `GpuIdentifier` names specified 
        in the deploy parameters.

        Value [double]: The max fraction of the GPU memory that can be used.
        """
        pass
    def __init__(self,
        *,
        max_number_of_ray_batches : builtins.int = ...,
        gpu_memory_quota : builtins.float = ...,
        gpu_quotas : typing.Optional[typing.Mapping[typing.Text, builtins.float]] = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["gpu_memory_quota",b"gpu_memory_quota","gpu_quotas",b"gpu_quotas","max_number_of_ray_batches",b"max_number_of_ray_batches"]) -> None: ...
global___AutomaticBatching = AutomaticBatching

class RxBatching(google.protobuf.message.Message):
    """Settings for the batching on rx channels.

    Note: The number of batches is set, and therefore applies, independently 
    for each radar mode.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    MODE_ID_FIELD_NUMBER: builtins.int
    NUMBER_OF_RX_BATCHES_FIELD_NUMBER: builtins.int
    mode_id: builtins.int = ...
    """The id of the mode to which rx batching is applied."""

    number_of_rx_batches: builtins.int = ...
    """The number of batches on rx channels."""

    def __init__(self,
        *,
        mode_id : builtins.int = ...,
        number_of_rx_batches : builtins.int = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["mode_id",b"mode_id","number_of_rx_batches",b"number_of_rx_batches"]) -> None: ...
global___RxBatching = RxBatching

class LidarSimulation(google.protobuf.message.Message):
    """Simulation parameters for a Lidar."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    WAVEFORM_FIELD_NUMBER: builtins.int
    CONTRIBUTION_FIELD_NUMBER: builtins.int
    GRID_FIELD_NUMBER: builtins.int
    NUMBER_OF_BATCHES_FIELD_NUMBER: builtins.int
    GPU_NAME_FIELD_NUMBER: builtins.int
    USE_RGB_DIFFUSE_FIELD_NUMBER: builtins.int
    ENABLE_SURFACE_SMOOTHING_FIELD_NUMBER: builtins.int
    waveform: builtins.bool = ...
    """Activation of the waveform output production by the lidar.

    Default value: false
    """

    contribution: builtins.bool = ...
    """Activation of the contribution output production by the lidar.

    Default value: false
    """

    @property
    def grid(self) -> global___Grid:
        """The lidar ray-tracing grid."""
        pass
    @property
    def number_of_batches(self) -> google.protobuf.wrappers_pb2.Int32Value:
        """The number of batches.

        Default value: 1

        Note: The number of batches must be less than or equal to the lidar 
        resolution.
        """
        pass
    gpu_name: typing.Text = ...
    """The GPU name that must be used for the simulation of this 
    lidar sensor.

    Note: The GPU name must correspond to a `GpuIdentifier` name specified in 
    the deploy parameters.

    Note: Optional field. If not set, the default GPU (whose index is 0)
    will be used.
    """

    use_rgb_diffuse: builtins.bool = ...
    """Use RGB diffuse parameters in the simulation of this lidar sensor. 

    Default value: false
    """

    enable_surface_smoothing: builtins.bool = ...
    """Enable surface smoothing for time of flight calculation according to the
    surface curvature.

    Default value: false
    """

    def __init__(self,
        *,
        waveform : builtins.bool = ...,
        contribution : builtins.bool = ...,
        grid : typing.Optional[global___Grid] = ...,
        number_of_batches : typing.Optional[google.protobuf.wrappers_pb2.Int32Value] = ...,
        gpu_name : typing.Text = ...,
        use_rgb_diffuse : builtins.bool = ...,
        enable_surface_smoothing : builtins.bool = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["grid",b"grid","number_of_batches",b"number_of_batches"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["contribution",b"contribution","enable_surface_smoothing",b"enable_surface_smoothing","gpu_name",b"gpu_name","grid",b"grid","number_of_batches",b"number_of_batches","use_rgb_diffuse",b"use_rgb_diffuse","waveform",b"waveform"]) -> None: ...
global___LidarSimulation = LidarSimulation

class Grid(google.protobuf.message.Message):
    """Type of grid for the lidar sensor."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    CARTESIAN_GRID_FIELD_NUMBER: builtins.int
    POLAR_GRID_FIELD_NUMBER: builtins.int
    @property
    def cartesian_grid(self) -> global___CartesianGrid:
        """The Cartesian grid.

        Note: Cartesian grid applies to flashing lidar only.
        """
        pass
    @property
    def polar_grid(self) -> global___PolarGrid:
        """The polar grid.

        Note: Polar grid applies to rotating lidar only.
        """
        pass
    def __init__(self,
        *,
        cartesian_grid : typing.Optional[global___CartesianGrid] = ...,
        polar_grid : typing.Optional[global___PolarGrid] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["cartesian_grid",b"cartesian_grid","grid",b"grid","polar_grid",b"polar_grid"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["cartesian_grid",b"cartesian_grid","grid",b"grid","polar_grid",b"polar_grid"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal["grid",b"grid"]) -> typing.Optional[typing_extensions.Literal["cartesian_grid","polar_grid"]]: ...
global___Grid = Grid

class CartesianGrid(google.protobuf.message.Message):
    """Cartesian grid definition."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    HORIZONTAL_GRID_POINTS_FIELD_NUMBER: builtins.int
    VERTICAL_GRID_POINTS_FIELD_NUMBER: builtins.int
    horizontal_grid_points: builtins.int = ...
    """The number of horizontal squares in the grid."""

    vertical_grid_points: builtins.int = ...
    """The number of vertical squares in the grid."""

    def __init__(self,
        *,
        horizontal_grid_points : builtins.int = ...,
        vertical_grid_points : builtins.int = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["horizontal_grid_points",b"horizontal_grid_points","vertical_grid_points",b"vertical_grid_points"]) -> None: ...
global___CartesianGrid = CartesianGrid

class PolarGrid(google.protobuf.message.Message):
    """Polar grid definition."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    RADIAL_GRID_POINTS_FIELD_NUMBER: builtins.int
    ANGULAR_GRID_POINTS_FIELD_NUMBER: builtins.int
    HAS_CENTRAL_POINT_FIELD_NUMBER: builtins.int
    radial_grid_points: builtins.int = ...
    """The number of radial segments."""

    angular_grid_points: builtins.int = ...
    """The number of angular segments."""

    has_central_point: builtins.bool = ...
    """Field indicating whether or not an on-axis ray (point of emission) 
    must be added to the center of the grid.

    Default value: false
    """

    def __init__(self,
        *,
        radial_grid_points : builtins.int = ...,
        angular_grid_points : builtins.int = ...,
        has_central_point : builtins.bool = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["angular_grid_points",b"angular_grid_points","has_central_point",b"has_central_point","radial_grid_points",b"radial_grid_points"]) -> None: ...
global___PolarGrid = PolarGrid

class RecordingFormat(google.protobuf.message.Message):
    """Format for recording the sensor's outputs."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    CAMERA_RECORDING_FORMAT_FIELD_NUMBER: builtins.int
    RADAR_RECORDING_FORMAT_FIELD_NUMBER: builtins.int
    LIDAR_RECORDING_FORMAT_FIELD_NUMBER: builtins.int
    camera_recording_format: ansys.api.avxcelerate.sensors.v1.sensor_data_format_pb2.CameraDataFormat.ValueType = ...
    """Format for saving camera output on disk.

    Possible value:
      - for physics-based camera: RAW, BMP, GIF, JPEG, or PNG,
      - for thermal camera: TEMPERATURE_MAP.
    """

    radar_recording_format: ansys.api.avxcelerate.sensors.v1.sensor_data_format_pb2.OutputFormat.ValueType = ...
    """Format for recording radar output."""

    lidar_recording_format: ansys.api.avxcelerate.sensors.v1.sensor_data_format_pb2.OutputFormat.ValueType = ...
    """Format for recording lidar output."""

    def __init__(self,
        *,
        camera_recording_format : ansys.api.avxcelerate.sensors.v1.sensor_data_format_pb2.CameraDataFormat.ValueType = ...,
        radar_recording_format : ansys.api.avxcelerate.sensors.v1.sensor_data_format_pb2.OutputFormat.ValueType = ...,
        lidar_recording_format : ansys.api.avxcelerate.sensors.v1.sensor_data_format_pb2.OutputFormat.ValueType = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["camera_recording_format",b"camera_recording_format","lidar_recording_format",b"lidar_recording_format","radar_recording_format",b"radar_recording_format","sensor_data_format",b"sensor_data_format"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["camera_recording_format",b"camera_recording_format","lidar_recording_format",b"lidar_recording_format","radar_recording_format",b"radar_recording_format","sensor_data_format",b"sensor_data_format"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal["sensor_data_format",b"sensor_data_format"]) -> typing.Optional[typing_extensions.Literal["camera_recording_format","radar_recording_format","lidar_recording_format"]]: ...
global___RecordingFormat = RecordingFormat

class LightingSystemParameters(google.protobuf.message.Message):
    """Lighting system simulation parameters."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    SAMPLING_RATE_FIELD_NUMBER: builtins.int
    sampling_rate: builtins.float = ...
    """Angular sampling used when computing the rendering of the light sources 
    in the Lighting System.

    Unit: degrees

    Range: [0.05, 57]

    Default value: 0.05
    """

    def __init__(self,
        *,
        sampling_rate : builtins.float = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["sampling_rate",b"sampling_rate"]) -> None: ...
global___LightingSystemParameters = LightingSystemParameters

class OutputSplitting(google.protobuf.message.Message):
    """Output data splitting configuration."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    RADAR_OUTPUT_SPLITTING_FIELD_NUMBER: builtins.int
    @property
    def radar_output_splitting(self) -> global___RadarOutputSplitting:
        """The radar output splitting configuration."""
        pass
    def __init__(self,
        *,
        radar_output_splitting : typing.Optional[global___RadarOutputSplitting] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["radar_output_splitting",b"radar_output_splitting"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["radar_output_splitting",b"radar_output_splitting"]) -> None: ...
global___OutputSplitting = OutputSplitting

class RadarOutputSplitting(google.protobuf.message.Message):
    """Radar output data splitting configuration."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    RADAR_OUTPUT_SPLITTING_LEVEL_FIELD_NUMBER: builtins.int
    radar_output_splitting_level: global___RadarOutputSplittingLevel.ValueType = ...
    """The radar output splitting level."""

    def __init__(self,
        *,
        radar_output_splitting_level : global___RadarOutputSplittingLevel.ValueType = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["radar_output_splitting_level",b"radar_output_splitting_level"]) -> None: ...
global___RadarOutputSplitting = RadarOutputSplitting

class LightPropagationEngineSimulationParameters(google.protobuf.message.Message):
    """Simulation parameters for the Light Propagation Engine."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    CAMERA_NEAR_DISTANCE_FIELD_NUMBER: builtins.int
    CAMERA_CULLING_DISTANCE_FIELD_NUMBER: builtins.int
    SCREEN_SPACE_AMBIENT_OCCLUSION_FIELD_NUMBER: builtins.int
    RAYTRACED_AMBIENT_OCCLUSION_FIELD_NUMBER: builtins.int
    OCCLUSION_CULLING_FIELD_NUMBER: builtins.int
    RAYTRACED_SHADOWS_FIELD_NUMBER: builtins.int
    SHADOW_QUALITY_FIELD_NUMBER: builtins.int
    ANTIALIASING_FACTOR_FIELD_NUMBER: builtins.int
    CAMERA_GROUND_TRUTH_PARAMETERS_FIELD_NUMBER: builtins.int
    RAYTRACED_SCENE_RENDERER_FIELD_NUMBER: builtins.int
    RAYTRACED_REFLECTIONS_FIELD_NUMBER: builtins.int
    camera_near_distance: builtins.float = ...
    """Distance at which the camera starts seeing objects.

    Unit: meters (m) 

    Range: ]0.0, `camera_culling_distance`] or ]0.0, inf[ if `camera_culling_distance` == 0

    Default value: 0.3
    """

    camera_culling_distance: builtins.float = ...
    """Distance at which the camera stops seeing objects.

    Unit : meters (m)

    Range: [`camera_near_distance`, inf[ or 0

    Note: Setting the value to 0 means infinite.

    Default value: 1000
    """

    @property
    def screen_space_ambient_occlusion(self) -> global___ScreenSpaceAmbientOcclusion:
        """Screen-Space Ambient Occlusion."""
        pass
    @property
    def raytraced_ambient_occlusion(self) -> global___RaytracedAmbientOcclusion:
        """Raytraced Ambient Occlusion."""
        pass
    occlusion_culling: builtins.bool = ...
    """Activation of the Occlusion Culling experimental feature.

    Note: It improves performances, but can lead to unexpected behaviors.

    Default value: true
    """

    raytraced_shadows: builtins.bool = ...
    """Activation of the Raytraced Shadows experimental feature.

    Note: It improves the quality of the shadows, 
    but can lead to unexpected behaviors.

    Default value: true
    """

    shadow_quality: global___Qualities.ValueType = ...
    """The camera shadow quality.

    Default value: MEDIUM
    """

    antialiasing_factor: builtins.float = ...
    """The camera antialiasing factor.

    Range: [1.0, 4.0]

    Default value: 1.0
    """

    @property
    def camera_ground_truth_parameters(self) -> global___CameraGroundTruthParameters:
        """Activation of ground truth output production.

        Ground truth output data can be used to test or train a perception 
        algorithms.

        Note: Optional field. If not set, no ground truth output is generated.
        """
        pass
    raytraced_scene_renderer: builtins.bool = ...
    """Activation of raytraced scene renderer.

    Note: Raytraced scene renderer is delivered
    as an experimental feature in the current release.
    """

    raytraced_reflections: builtins.bool = ...
    """Activation of the Raytraced Reflections.

    Default value: false
    """

    def __init__(self,
        *,
        camera_near_distance : typing.Optional[builtins.float] = ...,
        camera_culling_distance : typing.Optional[builtins.float] = ...,
        screen_space_ambient_occlusion : typing.Optional[global___ScreenSpaceAmbientOcclusion] = ...,
        raytraced_ambient_occlusion : typing.Optional[global___RaytracedAmbientOcclusion] = ...,
        occlusion_culling : typing.Optional[builtins.bool] = ...,
        raytraced_shadows : typing.Optional[builtins.bool] = ...,
        shadow_quality : global___Qualities.ValueType = ...,
        antialiasing_factor : typing.Optional[builtins.float] = ...,
        camera_ground_truth_parameters : typing.Optional[global___CameraGroundTruthParameters] = ...,
        raytraced_scene_renderer : typing.Optional[builtins.bool] = ...,
        raytraced_reflections : typing.Optional[builtins.bool] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["_antialiasing_factor",b"_antialiasing_factor","_camera_culling_distance",b"_camera_culling_distance","_camera_near_distance",b"_camera_near_distance","_occlusion_culling",b"_occlusion_culling","_raytraced_reflections",b"_raytraced_reflections","_raytraced_scene_renderer",b"_raytraced_scene_renderer","_raytraced_shadows",b"_raytraced_shadows","ambient_occlusion",b"ambient_occlusion","antialiasing_factor",b"antialiasing_factor","camera_culling_distance",b"camera_culling_distance","camera_ground_truth_parameters",b"camera_ground_truth_parameters","camera_near_distance",b"camera_near_distance","occlusion_culling",b"occlusion_culling","raytraced_ambient_occlusion",b"raytraced_ambient_occlusion","raytraced_reflections",b"raytraced_reflections","raytraced_scene_renderer",b"raytraced_scene_renderer","raytraced_shadows",b"raytraced_shadows","screen_space_ambient_occlusion",b"screen_space_ambient_occlusion"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["_antialiasing_factor",b"_antialiasing_factor","_camera_culling_distance",b"_camera_culling_distance","_camera_near_distance",b"_camera_near_distance","_occlusion_culling",b"_occlusion_culling","_raytraced_reflections",b"_raytraced_reflections","_raytraced_scene_renderer",b"_raytraced_scene_renderer","_raytraced_shadows",b"_raytraced_shadows","ambient_occlusion",b"ambient_occlusion","antialiasing_factor",b"antialiasing_factor","camera_culling_distance",b"camera_culling_distance","camera_ground_truth_parameters",b"camera_ground_truth_parameters","camera_near_distance",b"camera_near_distance","occlusion_culling",b"occlusion_culling","raytraced_ambient_occlusion",b"raytraced_ambient_occlusion","raytraced_reflections",b"raytraced_reflections","raytraced_scene_renderer",b"raytraced_scene_renderer","raytraced_shadows",b"raytraced_shadows","screen_space_ambient_occlusion",b"screen_space_ambient_occlusion","shadow_quality",b"shadow_quality"]) -> None: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing_extensions.Literal["_antialiasing_factor",b"_antialiasing_factor"]) -> typing.Optional[typing_extensions.Literal["antialiasing_factor"]]: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing_extensions.Literal["_camera_culling_distance",b"_camera_culling_distance"]) -> typing.Optional[typing_extensions.Literal["camera_culling_distance"]]: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing_extensions.Literal["_camera_near_distance",b"_camera_near_distance"]) -> typing.Optional[typing_extensions.Literal["camera_near_distance"]]: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing_extensions.Literal["_occlusion_culling",b"_occlusion_culling"]) -> typing.Optional[typing_extensions.Literal["occlusion_culling"]]: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing_extensions.Literal["_raytraced_reflections",b"_raytraced_reflections"]) -> typing.Optional[typing_extensions.Literal["raytraced_reflections"]]: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing_extensions.Literal["_raytraced_scene_renderer",b"_raytraced_scene_renderer"]) -> typing.Optional[typing_extensions.Literal["raytraced_scene_renderer"]]: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing_extensions.Literal["_raytraced_shadows",b"_raytraced_shadows"]) -> typing.Optional[typing_extensions.Literal["raytraced_shadows"]]: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing_extensions.Literal["ambient_occlusion",b"ambient_occlusion"]) -> typing.Optional[typing_extensions.Literal["screen_space_ambient_occlusion","raytraced_ambient_occlusion"]]: ...
global___LightPropagationEngineSimulationParameters = LightPropagationEngineSimulationParameters

class ScreenSpaceAmbientOcclusion(google.protobuf.message.Message):
    """Parameters for Screen-Space Ambient Occlusion."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    ACTIVATION_FIELD_NUMBER: builtins.int
    AMOUNT_FIELD_NUMBER: builtins.int
    RADIUS_FIELD_NUMBER: builtins.int
    POWER_EXPONENT_FIELD_NUMBER: builtins.int
    SURFACE_BIAS_FIELD_NUMBER: builtins.int
    activation: builtins.bool = ...
    """Activation of the screen space ambient occlusion feature.

    Default value: false
    """

    amount: builtins.float = ...
    """Linear gain factor of neighbouring occluders.

    Range: [ 1.0, 8.0 ]
    Default value: 1.0
    """

    radius: builtins.float = ...
    """Maximal radius to detect occluders.

    Unit: meters (m)

    Range: [0.01, 2.0]

    Default: 0.8
    """

    power_exponent: builtins.float = ...
    """Amplification factor of the occlusion ambient lighting.

    Range: [0.0, 8.0]

    Default: 2
    """

    surface_bias: builtins.float = ...
    """Distance bias to avoid self shadowing.

    Unit: meters (m)

    Range: [0.0, 1.0]

    Default value: 0.01
    """

    def __init__(self,
        *,
        activation : builtins.bool = ...,
        amount : typing.Optional[builtins.float] = ...,
        radius : typing.Optional[builtins.float] = ...,
        power_exponent : typing.Optional[builtins.float] = ...,
        surface_bias : typing.Optional[builtins.float] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["_amount",b"_amount","_power_exponent",b"_power_exponent","_radius",b"_radius","_surface_bias",b"_surface_bias","amount",b"amount","power_exponent",b"power_exponent","radius",b"radius","surface_bias",b"surface_bias"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["_amount",b"_amount","_power_exponent",b"_power_exponent","_radius",b"_radius","_surface_bias",b"_surface_bias","activation",b"activation","amount",b"amount","power_exponent",b"power_exponent","radius",b"radius","surface_bias",b"surface_bias"]) -> None: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing_extensions.Literal["_amount",b"_amount"]) -> typing.Optional[typing_extensions.Literal["amount"]]: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing_extensions.Literal["_power_exponent",b"_power_exponent"]) -> typing.Optional[typing_extensions.Literal["power_exponent"]]: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing_extensions.Literal["_radius",b"_radius"]) -> typing.Optional[typing_extensions.Literal["radius"]]: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing_extensions.Literal["_surface_bias",b"_surface_bias"]) -> typing.Optional[typing_extensions.Literal["surface_bias"]]: ...
global___ScreenSpaceAmbientOcclusion = ScreenSpaceAmbientOcclusion

class RaytracedAmbientOcclusion(google.protobuf.message.Message):
    """Parameters for raytraced ambient occlusion.

    Note: Raytraced ambient occlusion is delivered as a beta feature in the
    current release.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    ACTIVATION_FIELD_NUMBER: builtins.int
    SAMPLING_ANGLE_FIELD_NUMBER: builtins.int
    OCCLUSION_DETECTION_RADIUS_FIELD_NUMBER: builtins.int
    SAMPLE_NUMBER_FIELD_NUMBER: builtins.int
    POWER_FACTOR_FIELD_NUMBER: builtins.int
    USE_DENOISER_FIELD_NUMBER: builtins.int
    RESOLUTION_SCALE_FIELD_NUMBER: builtins.int
    activation: builtins.bool = ...
    """Activation of the raytraced ambient occlusion feature.

    Default value: false
    """

    sampling_angle: builtins.float = ...
    """The angle of the cone sampling distribution:
      - 0 for sampling along the normal only.
      - Pi/2 to sample the whole hemisphere.

    Unit: radian

    Range: [0, Pi/2]

    Default: 1.0
    """

    occlusion_detection_radius: builtins.float = ...
    """The maximum distance up to which ray-intersections are computed. All
    occlusion events beyond this distance are ignored.

    Unit: meter (m)

    Range: [0.01, 1000]

    Default: 5
    """

    sample_number: builtins.int = ...
    """The number of samples used to compute the occlusion map.

    Note: Setting the `Sample_Number` greater than 128 and the 
    `Downscale Factor` to `FULL` has a huge impact on performances.

    Range: [1, 512]

    Default: 8
    """

    power_factor: builtins.float = ...
    """Exponent applied to the ambient occlusion map.

    Note: The raytraced ambient occlusion feature is no more physically correct when
    the `Power Factor` value is set to anything but 1.

    Range: Strictly positive

    Default: 1
    """

    use_denoiser: builtins.bool = ...
    """Activation of denoising on the raytraced ambient occlusion output.

    Default: true
    """

    resolution_scale: global___RtaoDownscaleFactor.ValueType = ...
    """Scale for the resolution at which the ambient occlusion is
    computed.
    """

    def __init__(self,
        *,
        activation : builtins.bool = ...,
        sampling_angle : typing.Optional[builtins.float] = ...,
        occlusion_detection_radius : typing.Optional[builtins.float] = ...,
        sample_number : typing.Optional[builtins.int] = ...,
        power_factor : typing.Optional[builtins.float] = ...,
        use_denoiser : typing.Optional[builtins.bool] = ...,
        resolution_scale : typing.Optional[global___RtaoDownscaleFactor.ValueType] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["_occlusion_detection_radius",b"_occlusion_detection_radius","_power_factor",b"_power_factor","_resolution_scale",b"_resolution_scale","_sample_number",b"_sample_number","_sampling_angle",b"_sampling_angle","_use_denoiser",b"_use_denoiser","occlusion_detection_radius",b"occlusion_detection_radius","power_factor",b"power_factor","resolution_scale",b"resolution_scale","sample_number",b"sample_number","sampling_angle",b"sampling_angle","use_denoiser",b"use_denoiser"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["_occlusion_detection_radius",b"_occlusion_detection_radius","_power_factor",b"_power_factor","_resolution_scale",b"_resolution_scale","_sample_number",b"_sample_number","_sampling_angle",b"_sampling_angle","_use_denoiser",b"_use_denoiser","activation",b"activation","occlusion_detection_radius",b"occlusion_detection_radius","power_factor",b"power_factor","resolution_scale",b"resolution_scale","sample_number",b"sample_number","sampling_angle",b"sampling_angle","use_denoiser",b"use_denoiser"]) -> None: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing_extensions.Literal["_occlusion_detection_radius",b"_occlusion_detection_radius"]) -> typing.Optional[typing_extensions.Literal["occlusion_detection_radius"]]: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing_extensions.Literal["_power_factor",b"_power_factor"]) -> typing.Optional[typing_extensions.Literal["power_factor"]]: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing_extensions.Literal["_resolution_scale",b"_resolution_scale"]) -> typing.Optional[typing_extensions.Literal["resolution_scale"]]: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing_extensions.Literal["_sample_number",b"_sample_number"]) -> typing.Optional[typing_extensions.Literal["sample_number"]]: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing_extensions.Literal["_sampling_angle",b"_sampling_angle"]) -> typing.Optional[typing_extensions.Literal["sampling_angle"]]: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing_extensions.Literal["_use_denoiser",b"_use_denoiser"]) -> typing.Optional[typing_extensions.Literal["use_denoiser"]]: ...
global___RaytracedAmbientOcclusion = RaytracedAmbientOcclusion
