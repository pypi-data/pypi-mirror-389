"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""
import builtins
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import typing
import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor = ...

class _Multiplexing:
    ValueType = typing.NewType('ValueType', builtins.int)
    V: typing_extensions.TypeAlias = ValueType
class _MultiplexingEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_Multiplexing.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
    INTERLEAVED: Multiplexing.ValueType = ...  # 0
    """Interleaved multiplexing."""

    SIMULTANEOUS: Multiplexing.ValueType = ...  # 1
    """Simultaneous multiplexing."""

class Multiplexing(_Multiplexing, metaclass=_MultiplexingEnumTypeWrapper):
    """The possible ways a radar can use its TX antennas."""
    pass

INTERLEAVED: Multiplexing.ValueType = ...  # 0
"""Interleaved multiplexing."""

SIMULTANEOUS: Multiplexing.ValueType = ...  # 1
"""Simultaneous multiplexing."""

global___Multiplexing = Multiplexing


class RadarOutputData(google.protobuf.message.Message):
    """Radar output data for all the modes."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    MODES_FIELD_NUMBER: builtins.int
    @property
    def modes(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___ModeOutputData]:
        """An array of ModeOutputData."""
        pass
    def __init__(self,
        *,
        modes : typing.Optional[typing.Iterable[global___ModeOutputData]] = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["modes",b"modes"]) -> None: ...
global___RadarOutputData = RadarOutputData

class ModeOutputData(google.protobuf.message.Message):
    """Radar output data for a given mode."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    RANGE_DOPPLER_RESPONSE_FIELD_NUMBER: builtins.int
    FREQUENCY_PULSE_RESPONSE_FIELD_NUMBER: builtins.int
    ANALOG_TO_DIGITAL_CONVERTER_SAMPLES_FIELD_NUMBER: builtins.int
    MODE_IDENTIFIER_FIELD_NUMBER: builtins.int
    TX_WAVEFORM_FIELD_NUMBER: builtins.int
    ARBITRARY_FREQUENCY_PULSE_RESPONSE_FIELD_NUMBER: builtins.int
    ARBITRARY_ANALOG_TO_DIGITAL_CONVERTER_SAMPLES_FIELD_NUMBER: builtins.int
    RESPONSE_TO_TX_WAVEFORM_MAP_FIELD_NUMBER: builtins.int
    @property
    def range_doppler_response(self) -> global___RangeDopplerResponseData:
        """Range Doppler Map data."""
        pass
    @property
    def frequency_pulse_response(self) -> global___FrequencyPulseResponseData:
        """Pulse Frequency Response data."""
        pass
    @property
    def analog_to_digital_converter_samples(self) -> global___AnalogToDigitalConverterSamplesData:
        """Analog-To-Digital Converter Samples data."""
        pass
    mode_identifier: builtins.int = ...
    """Identifier of the radar mode."""

    @property
    def tx_waveform(self) -> global___TxWaveformData:
        """Tx Waveform Data."""
        pass
    @property
    def arbitrary_frequency_pulse_response(self) -> global___ArbitraryFrequencyPulseResponseData:
        """Pulse Frequency Response data produced by a radar mode configured with 
        the "Arbitrary Pulse Doppler" waveform.
        """
        pass
    @property
    def arbitrary_analog_to_digital_converter_samples(self) -> global___ArbitraryAnalogToDigitalConverterSamplesData:
        """Analog-To-Digital Converter Samples data produced by a radar mode 
        configured with the "Arbitrary FMCW" waveform.
        """
        pass
    @property
    def response_to_tx_waveform_map(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]:
        """Response to Tx waveform map.

        List of indexes mapping the response data to the Tx waveform data. 
            - The position in the list represents the sample index in the 
            response data. 
            - The value in the list represents the sample index in the Tx  
            waveform data.
        """
        pass
    def __init__(self,
        *,
        range_doppler_response : typing.Optional[global___RangeDopplerResponseData] = ...,
        frequency_pulse_response : typing.Optional[global___FrequencyPulseResponseData] = ...,
        analog_to_digital_converter_samples : typing.Optional[global___AnalogToDigitalConverterSamplesData] = ...,
        mode_identifier : builtins.int = ...,
        tx_waveform : typing.Optional[global___TxWaveformData] = ...,
        arbitrary_frequency_pulse_response : typing.Optional[global___ArbitraryFrequencyPulseResponseData] = ...,
        arbitrary_analog_to_digital_converter_samples : typing.Optional[global___ArbitraryAnalogToDigitalConverterSamplesData] = ...,
        response_to_tx_waveform_map : typing.Optional[typing.Iterable[builtins.int]] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["analog_to_digital_converter_samples",b"analog_to_digital_converter_samples","arbitrary_analog_to_digital_converter_samples",b"arbitrary_analog_to_digital_converter_samples","arbitrary_frequency_pulse_response",b"arbitrary_frequency_pulse_response","frequency_pulse_response",b"frequency_pulse_response","range_doppler_response",b"range_doppler_response","tx_waveform",b"tx_waveform"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["analog_to_digital_converter_samples",b"analog_to_digital_converter_samples","arbitrary_analog_to_digital_converter_samples",b"arbitrary_analog_to_digital_converter_samples","arbitrary_frequency_pulse_response",b"arbitrary_frequency_pulse_response","frequency_pulse_response",b"frequency_pulse_response","mode_identifier",b"mode_identifier","range_doppler_response",b"range_doppler_response","response_to_tx_waveform_map",b"response_to_tx_waveform_map","tx_waveform",b"tx_waveform"]) -> None: ...
global___ModeOutputData = ModeOutputData

class RangeDopplerResponseData(google.protobuf.message.Message):
    """The radar range doppler output data.

    Data are stored as multi-dimensional array of complex values, with 
    interleaved real and imaginary parts: real1, imag1, real2, imag2 etc. 
    The physical dimensions are [TX, RX, velocity, range], therefore 
    the data contains:

        numTX x numRX x numVelocities x numRanges complex numbers

     or equivalently

        2 x numTX x numRX x numVelocities x numRanges real numbers

    If the complex data is read sequentially, the outermost loop corresponds to 
    the TX dimension, then RX, then velocity, and then range which is the 
    innermost.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    DATA_FIELD_NUMBER: builtins.int
    RANGE_DOMAIN_FIELD_NUMBER: builtins.int
    VELOCITY_DOMAIN_FIELD_NUMBER: builtins.int
    RX_IDENTIFIERS_FIELD_NUMBER: builtins.int
    TX_IDENTIFIERS_FIELD_NUMBER: builtins.int
    MULTIPLEXING_FIELD_NUMBER: builtins.int
    @property
    def data(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.float]:
        """The multi-dimensional array."""
        pass
    @property
    def range_domain(self) -> global___Domain:
        """The number of range samples and the min/max values in the samples."""
        pass
    @property
    def velocity_domain(self) -> global___Domain:
        """The number of velocity samples and the min/max values in the samples."""
        pass
    @property
    def rx_identifiers(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]:
        """The identifier of each receiver antenna."""
        pass
    @property
    def tx_identifiers(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]:
        """The identifier of each transmitter antenna."""
        pass
    multiplexing: global___Multiplexing.ValueType = ...
    """The type of multiplexing."""

    def __init__(self,
        *,
        data : typing.Optional[typing.Iterable[builtins.float]] = ...,
        range_domain : typing.Optional[global___Domain] = ...,
        velocity_domain : typing.Optional[global___Domain] = ...,
        rx_identifiers : typing.Optional[typing.Iterable[builtins.int]] = ...,
        tx_identifiers : typing.Optional[typing.Iterable[builtins.int]] = ...,
        multiplexing : global___Multiplexing.ValueType = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["range_domain",b"range_domain","velocity_domain",b"velocity_domain"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["data",b"data","multiplexing",b"multiplexing","range_domain",b"range_domain","rx_identifiers",b"rx_identifiers","tx_identifiers",b"tx_identifiers","velocity_domain",b"velocity_domain"]) -> None: ...
global___RangeDopplerResponseData = RangeDopplerResponseData

class FrequencyPulseResponseData(google.protobuf.message.Message):
    """The radar output data for pulse frequency response. 

    Data are stored as multi-dimensional array of complex values, with 
    interleaved real and imaginary parts: real1, imag1, real2, imag2 etc. 
    The physical dimensions are [TX, RX, pulse time, frequency], therefore  
    the data contains:

        numTX x numRX x numPulseTime x numFrequencies complex numbers

    or equivalently

        2 x numTX x numRX x numPulseTime x numFrequencies real numbers

    If the complex data is read sequentially, the outermost loop corresponds to 
    the TX dimension, then RX, then pulse time, and then frequencies which is 
    the innermost.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    DATA_FIELD_NUMBER: builtins.int
    FREQUENCY_DOMAIN_FIELD_NUMBER: builtins.int
    PULSE_TIME_DOMAIN_FIELD_NUMBER: builtins.int
    RX_IDENTIFIERS_FIELD_NUMBER: builtins.int
    TX_IDENTIFIERS_FIELD_NUMBER: builtins.int
    MULTIPLEXING_FIELD_NUMBER: builtins.int
    @property
    def data(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.float]:
        """The multi-dimensional array."""
        pass
    @property
    def frequency_domain(self) -> global___Domain:
        """The number of frequency samples and the min/max values in the samples."""
        pass
    @property
    def pulse_time_domain(self) -> global___Domain:
        """The number of pulse time samples and the min/max values in the samples."""
        pass
    @property
    def rx_identifiers(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]:
        """The identifier of each receiver antenna."""
        pass
    @property
    def tx_identifiers(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]:
        """The identifier of each transmitter antenna."""
        pass
    multiplexing: global___Multiplexing.ValueType = ...
    """The type of multiplexing."""

    def __init__(self,
        *,
        data : typing.Optional[typing.Iterable[builtins.float]] = ...,
        frequency_domain : typing.Optional[global___Domain] = ...,
        pulse_time_domain : typing.Optional[global___Domain] = ...,
        rx_identifiers : typing.Optional[typing.Iterable[builtins.int]] = ...,
        tx_identifiers : typing.Optional[typing.Iterable[builtins.int]] = ...,
        multiplexing : global___Multiplexing.ValueType = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["frequency_domain",b"frequency_domain","pulse_time_domain",b"pulse_time_domain"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["data",b"data","frequency_domain",b"frequency_domain","multiplexing",b"multiplexing","pulse_time_domain",b"pulse_time_domain","rx_identifiers",b"rx_identifiers","tx_identifiers",b"tx_identifiers"]) -> None: ...
global___FrequencyPulseResponseData = FrequencyPulseResponseData

class AnalogToDigitalConverterSamplesData(google.protobuf.message.Message):
    """The radar output data for analog-to-digital converter samples. 

    Data are stored as multi-dimensional array of complex values or real 
    values, depending on the `is_complex_valued` flag in the message. 
    The physical dimensions are [TX, RX, chirp time, sample time], therefore  
    the data contains:

        numTX x numRX x numChirpTime x numSampleTime complex numbers

    or equivalently

        2 x numTX x numRX x numChirpTime x numSampleTime real numbers

    If the complex data is read sequentially, the outermost loop corresponds 
    to the TX dimension, then RX, then chirp time, and then sample 
    time which is the innermost.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    DATA_FIELD_NUMBER: builtins.int
    SAMPLE_TIME_DOMAIN_FIELD_NUMBER: builtins.int
    CHIRP_TIME_DOMAIN_FIELD_NUMBER: builtins.int
    RX_IDENTIFIERS_FIELD_NUMBER: builtins.int
    TX_IDENTIFIERS_FIELD_NUMBER: builtins.int
    IS_COMPLEX_VALUED_FIELD_NUMBER: builtins.int
    MULTIPLEXING_FIELD_NUMBER: builtins.int
    @property
    def data(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.float]:
        """The multi-dimensional array."""
        pass
    @property
    def sample_time_domain(self) -> global___Domain:
        """The number of time samples and the min/max values in the samples."""
        pass
    @property
    def chirp_time_domain(self) -> global___Domain:
        """The number of chirp time samples and the min/max values in the samples."""
        pass
    @property
    def rx_identifiers(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]:
        """The identifier of each receiver antenna."""
        pass
    @property
    def tx_identifiers(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]:
        """The identifier of each transmitter antenna."""
        pass
    is_complex_valued: builtins.bool = ...
    """Flag indicating whether or not the values are defined as complex numbers."""

    multiplexing: global___Multiplexing.ValueType = ...
    """The type of multiplexing."""

    def __init__(self,
        *,
        data : typing.Optional[typing.Iterable[builtins.float]] = ...,
        sample_time_domain : typing.Optional[global___Domain] = ...,
        chirp_time_domain : typing.Optional[global___Domain] = ...,
        rx_identifiers : typing.Optional[typing.Iterable[builtins.int]] = ...,
        tx_identifiers : typing.Optional[typing.Iterable[builtins.int]] = ...,
        is_complex_valued : builtins.bool = ...,
        multiplexing : global___Multiplexing.ValueType = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["chirp_time_domain",b"chirp_time_domain","sample_time_domain",b"sample_time_domain"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["chirp_time_domain",b"chirp_time_domain","data",b"data","is_complex_valued",b"is_complex_valued","multiplexing",b"multiplexing","rx_identifiers",b"rx_identifiers","sample_time_domain",b"sample_time_domain","tx_identifiers",b"tx_identifiers"]) -> None: ...
global___AnalogToDigitalConverterSamplesData = AnalogToDigitalConverterSamplesData

class Domain(google.protobuf.message.Message):
    """A radar data domain. 

    Indicates how to retrieve information from the float array of 
    the containing data message.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    SIZE_FIELD_NUMBER: builtins.int
    MIN_VALUE_FIELD_NUMBER: builtins.int
    MAX_VALUE_FIELD_NUMBER: builtins.int
    size: builtins.int = ...
    """The number of samples for this domain."""

    min_value: builtins.float = ...
    """The minimal value in the samples."""

    max_value: builtins.float = ...
    """The maximal value in the samples."""

    def __init__(self,
        *,
        size : builtins.int = ...,
        min_value : builtins.float = ...,
        max_value : builtins.float = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["max_value",b"max_value","min_value",b"min_value","size",b"size"]) -> None: ...
global___Domain = Domain

class TxWaveformData(google.protobuf.message.Message):
    """The radar output data for the transmitted waveform.

    Data are stored as a multi-dimensional array of values. 
    The physical dimensions are [pulses or chirps, samples, values per sample], 
    therefore the data contains:

        numPulsesOrChirps x numSamples x  numValuesPerSample numbers
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    DATA_FIELD_NUMBER: builtins.int
    TX_IDENTIFIERS_FIELD_NUMBER: builtins.int
    NUMBER_OF_VALUES_PER_SAMPLE_FIELD_NUMBER: builtins.int
    NUMBER_OF_SAMPLES_FIELD_NUMBER: builtins.int
    NUMBER_OF_PULSES_OR_CHIRPS_FIELD_NUMBER: builtins.int
    @property
    def data(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.float]:
        """The multi-dimensional array."""
        pass
    @property
    def tx_identifiers(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]:
        """The identifier of each transmitter antenna."""
        pass
    number_of_values_per_sample: builtins.int = ...
    """The number of values for a single waveform sample.

    Current implementation will provide nine values for each sample, 
    organized as follows: 
        - Pulse or chirp index (0-based): the pulse/chirp position within  
          the pulse/chirp sequence. 
        - Sample index (0-based): the sample position within a pulse/chirp. 
        - Transmitter index (0-based position): the transmitter position in 
          the tx_identifiers list. 
        - Simulation sample time: the sample time relative to the simulation 
          update time. Expressed in seconds (s). 
        - CPI sample time: the sample time relative to the center of CPI. 
          Expressed in seconds (s). 
        - Chirp sample time: the sample time relative to the center of chirp. 
          Expressed in seconds (s). Always zero for a pulse-Doppler waveform. 
        - Sample frequency: the frequency of sample in hertz (Hz). 
        - Amplitude: the relative broadcast amplitude of the sample, 
          currently always unity (1). 
        - Phase: the phase of the broadcast sample relative to the signal fed 
          to rx mixer, currently always zero (0).

    All values are double-precision, including notionally integer values  
    (i.e. indices).

    Note: The number of values per sample might increase in future versions.
    """

    number_of_samples: builtins.int = ...
    """The number of samples for a single pulse or chirp."""

    number_of_pulses_or_chirps: builtins.int = ...
    """The number of pulses or chirps in the waveform."""

    def __init__(self,
        *,
        data : typing.Optional[typing.Iterable[builtins.float]] = ...,
        tx_identifiers : typing.Optional[typing.Iterable[builtins.int]] = ...,
        number_of_values_per_sample : builtins.int = ...,
        number_of_samples : builtins.int = ...,
        number_of_pulses_or_chirps : builtins.int = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["data",b"data","number_of_pulses_or_chirps",b"number_of_pulses_or_chirps","number_of_samples",b"number_of_samples","number_of_values_per_sample",b"number_of_values_per_sample","tx_identifiers",b"tx_identifiers"]) -> None: ...
global___TxWaveformData = TxWaveformData

class ArbitraryFrequencyPulseResponseData(google.protobuf.message.Message):
    """The radar output data for Arbitrary pulse frequency response.

    Data are stored as multi-dimensional array of complex values, with 
    interleaved real and imaginary parts: real1, imag1, real2, imag2 etc. 
    The physical dimensions are [TX, RX, Sample], therefore the data 
    contains:

        numberOfTX x numberOfRX x numberOfSamples complex numbers

     or equivalently

        2 x numberOfTX x numberOfRX x numberOfSamples real numbers

    If the complex data is read sequentially, the outermost loop corresponds to 
    the TX dimension, then RX dimension, then Sample dimension which is 
    the innermost.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    DATA_FIELD_NUMBER: builtins.int
    NUMBER_OF_SAMPLES_FIELD_NUMBER: builtins.int
    RX_IDENTIFIERS_FIELD_NUMBER: builtins.int
    TX_IDENTIFIERS_FIELD_NUMBER: builtins.int
    MULTIPLEXING_FIELD_NUMBER: builtins.int
    @property
    def data(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.float]:
        """The multi-dimensional array."""
        pass
    number_of_samples: builtins.int = ...
    """The number of samples."""

    @property
    def rx_identifiers(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]:
        """The identifier of each receiver antenna."""
        pass
    @property
    def tx_identifiers(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]:
        """The identifier of each transmitter antenna."""
        pass
    multiplexing: global___Multiplexing.ValueType = ...
    """The type of multiplexing."""

    def __init__(self,
        *,
        data : typing.Optional[typing.Iterable[builtins.float]] = ...,
        number_of_samples : builtins.int = ...,
        rx_identifiers : typing.Optional[typing.Iterable[builtins.int]] = ...,
        tx_identifiers : typing.Optional[typing.Iterable[builtins.int]] = ...,
        multiplexing : global___Multiplexing.ValueType = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["data",b"data","multiplexing",b"multiplexing","number_of_samples",b"number_of_samples","rx_identifiers",b"rx_identifiers","tx_identifiers",b"tx_identifiers"]) -> None: ...
global___ArbitraryFrequencyPulseResponseData = ArbitraryFrequencyPulseResponseData

class ArbitraryAnalogToDigitalConverterSamplesData(google.protobuf.message.Message):
    """The radar output data for Arbitrary analog-to-digital converter 
    samples.

    Data are stored as multi-dimensional array of complex values or real 
    values, depending of the is_complex_valued flag of the message.
    The physical dimensions are [TX, RX, Sample] and
    so the data contains:

        numberOfTX x numberOfRX x numberOfSamples complex numbers

     or equivalently

        2 x numberOfTX x numberOfRX x numberOfSamples real numbers

    If the complex data is read sequentially, the outermost loop corresponds
    to the TX dimension, then RX dimension, then Sample dimension which is the
    innermost.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    DATA_FIELD_NUMBER: builtins.int
    NUMBER_OF_SAMPLES_FIELD_NUMBER: builtins.int
    RX_IDENTIFIERS_FIELD_NUMBER: builtins.int
    TX_IDENTIFIERS_FIELD_NUMBER: builtins.int
    IS_COMPLEX_VALUED_FIELD_NUMBER: builtins.int
    MULTIPLEXING_FIELD_NUMBER: builtins.int
    @property
    def data(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.float]:
        """The multi-dimensional array."""
        pass
    number_of_samples: builtins.int = ...
    """The number of samples."""

    @property
    def rx_identifiers(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]:
        """The identifier of each receiver antenna."""
        pass
    @property
    def tx_identifiers(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]:
        """The identifier of each transmitter antenna."""
        pass
    is_complex_valued: builtins.bool = ...
    """Flag indicating whether or not the values are defined as complex numbers."""

    multiplexing: global___Multiplexing.ValueType = ...
    """Type of multiplexing."""

    def __init__(self,
        *,
        data : typing.Optional[typing.Iterable[builtins.float]] = ...,
        number_of_samples : builtins.int = ...,
        rx_identifiers : typing.Optional[typing.Iterable[builtins.int]] = ...,
        tx_identifiers : typing.Optional[typing.Iterable[builtins.int]] = ...,
        is_complex_valued : builtins.bool = ...,
        multiplexing : global___Multiplexing.ValueType = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["data",b"data","is_complex_valued",b"is_complex_valued","multiplexing",b"multiplexing","number_of_samples",b"number_of_samples","rx_identifiers",b"rx_identifiers","tx_identifiers",b"tx_identifiers"]) -> None: ...
global___ArbitraryAnalogToDigitalConverterSamplesData = ArbitraryAnalogToDigitalConverterSamplesData
