{
  "markdown": "# Building a Semantic Table\n\nDefine your data model with dimensions and measures using Ibis expressions.\n\n## Overview\n\nA Semantic Table is the core building block of BSL. It transforms a raw Ibis table into a reusable, self-documenting data model by defining:\n- **Dimensions**: Attributes to group by (e.g., origin, carrier, year)\n- **Measures**: Aggregations and calculations (e.g., flight count, total distance)\n\n## to_semantic_table()\n\n```setup_flights\nimport ibis\nfrom boring_semantic_layer import to_semantic_table\n\n# 1. Start with an Ibis table\ncon = ibis.duckdb.connect(\":memory:\")\nflights_data = ibis.memtable({\n    \"origin\": [\"JFK\", \"LAX\", \"SFO\"],\n    \"dest\": [\"LAX\", \"SFO\", \"JFK\"],\n    \"carrier\": [\"AA\", \"UA\", \"DL\"],\n    \"year\": [2023, 2023, 2024],\n    \"distance\": [2475, 337, 382],\n    \"dep_delay\": [10, 5, 0]\n})\nflights_tbl = con.create_table(\"flights\", flights_data)\n\n# 2. Convert to a Semantic Table\nflights_st = to_semantic_table(flights_tbl, name=\"flights\")\n```\n\n## with_dimensions()\n\nDimensions define the attributes you can group by in your queries. They represent the categorical or descriptive aspects of your data that you want to analyze.\n\nYou can define dimensions using lambda expressions, unbound syntax (`_.`), or the `Dimension` class with descriptions:\n\n```dimensions_demo\nfrom ibis import _\nfrom boring_semantic_layer import Dimension\n\nflights_st = flights_st.with_dimensions(\n    # Lambda expressions - simple and explicit\n    origin=lambda t: t.origin,\n\n    # Unbound syntax - cleaner and more concise\n    destination=_.dest,\n    year=_.year,\n\n    # Dimension - self-documenting and AI-friendly\n    carrier=Dimension(\n        expr=lambda t: t.carrier,\n        description=\"Airline carrier code\"\n    )\n)\n\nflights_st.dimensions\n```\n<regularoutput code-block=\"dimensions_demo\"></regularoutput>\n\n## with_measures()\n\nMeasures define the aggregations and calculations you can query. They represent the quantitative aspects of your data that you want to analyze (counts, sums, averages, etc.).\n\nYou can define measures using lambda expressions, reference other measures for composition, or use the `Measure` class with descriptions:\n\n```measures_demo\nfrom boring_semantic_layer import Measure\n\nflights_st = flights_st.with_measures(\n    # Lambda expressions - simple and concise\n    total_flights=lambda t: t.count(),\n    total_distance=lambda t: t.distance.sum(),\n    max_delay=lambda t: t.dep_delay.max(),\n\n    # Reference other measures for composition\n    avg_distance_per_flight=lambda t: t.total_distance / t.total_flights,\n\n    # Measure - self-documenting and AI-friendly\n    avg_distance=Measure(\n        expr=lambda t: t.distance.mean(),\n        description=\"Average flight distance in miles\"\n    )\n)\n\nflights_st.measures\n```\n\n<regularoutput code-block=\"measures_demo\"></regularoutput>\n\n### all()\n\nThe `all()` function references the entire dataset within measure definitions, enabling percent-of-total and comparison calculations.\n\n**Example:** Calculate market share as a percentage\n\n```measure_all_demo\nflights_with_pct = flights_st.with_measures(\n        flight_count=lambda t: t.count(),\n        market_share=lambda t: t.flight_count / t.all(t.flight_count) * 100  # Percent of total\n    )\n\n# Query by carrier\nresult = (\n    flights_with_pct\n    .group_by(\"carrier\")\n    .aggregate(\"flight_count\", \"market_share\")\n)\n```\n\n<bslquery code-block=\"measure_all_demo\"></bslquery>\n\n<note type=\"info\">\n`t.all()` is a method available on the table parameter `t` in measure definitions. It references the entire dataset regardless of grouping, making it perfect for calculating percentages, or comparing groups to the total.\n</note>\n\nFor more examples, see the [Percent of Total pattern](/advanced/percentage-total).\n\n## join_one() / join_many() / join_cross()\n\nJoin semantic tables together to query across relationships. Joins allow you to combine data from multiple semantic tables and access dimensions and measures across all joined tables.\n\n**What Makes Semantic Joins Different?**\n\nSemantic joins explicitly capture the **relationship type** between tables, rather than just specifying SQL join mechanics:\n\n**SQL Joins:**\n```python\n# Specifies HOW to join (LEFT/INNER), but not the relationship\nflights.join(carriers, condition, how=\"left\")\n```\n\n**Semantic Joins:**\n```python\n# Specifies the relationship: one carrier has many flights\nflights.join_many(carriers, left_on=\"carrier\", right_on=\"code\")\n```\n\n**What You Get:**\n- **Explicit relationships**: `join_many()` documents that this is a one-to-many relationship\n- **Table hierarchy information**: The method name describes how tables relate to each other\n- **Richer metadata**: Makes the data model structure explicit for documentation and tooling\n\n<note type=\"info\">\nAfter joining, dimensions and measures are prefixed with table names (e.g., `flights.origin`, `carriers.name`) to avoid naming conflicts.\n</note>\n\n\nLet's get some additional data:\n\n```setup_carriers\nimport ibis\nfrom boring_semantic_layer import to_semantic_table\n\ncon = ibis.duckdb.connect(\":memory:\")\n\n# Create carriers data\ncarriers_data = ibis.memtable({\n    \"code\": [\"AA\", \"UA\", \"DL\"],\n    \"name\": [\"American Airlines\", \"United Airlines\", \"Delta Air Lines\"]\n})\ncarriers_tbl = con.create_table(\"carriers\", carriers_data)\n```\n<collapsedcodeblock code-block=\"setup_carriers\" title=\"Create carriers Ibis table\"></collapsedcodeblock>\n\nAnd create a carriers semantic table:\n\n```carriers_st\ncarriers = (\n    to_semantic_table(carriers_tbl, name=\"carriers\")\n    .with_dimensions(\n        code=lambda t: t.code,\n        name=lambda t: t.name\n    )\n    .with_measures(\n        carrier_count=lambda t: t.count()\n    )\n)\n```\n\n### join_many() - One-to-Many Relationships\n\nUse `join_many()` when one row in the left table can match multiple rows in the right table (LEFT JOIN).\n\n```join_demo\n# Join carriers to flights - one carrier has many flights\nflights_with_carriers = flights_st.join_many(\n    carriers,\n    left_on=\"carrier\",\n    right_on=\"code\"\n)\n\n# Inspect available dimensions and measures\nflights_with_carriers.dimensions\n```\n<regularoutput code-block=\"join_demo\"></regularoutput>\n\nAfter joining, all dimensions and measures from both tables are available. Each is prefixed with its table name to avoid conflicts:\n\n\n### join_one() - One-to-One Relationships\n\nUse `join_one()` when rows have a unique matching relationship (INNER JOIN).\n\n```python\n# Many flights \u2192 one carrier (each flight has exactly one carrier)\nflights_with_carrier = flights_st.join_one(\n    carriers,\n    left_on=\"carrier\",\n    right_on=\"code\"\n)\n```\n\n### join_cross() - Cross Join\n\nUse `join_cross()` to create every possible combination of rows from both tables (CARTESIAN PRODUCT).\n\n```python\n# Every flight \u00d7 every carrier combination\nall_combinations = flights_st.join_cross(carriers)\n```\n\n### join() - Custom Join Conditions\n\nUse `join()` for complex join conditions or specific SQL join types.\n\n```python\n# LEFT JOIN with custom condition\nflights_with_carriers = flights_st.join(\n    carriers,\n    lambda f, c: f.carrier == c.code,\n    how=\"left\"\n)\n\n# INNER JOIN\nflights_matched = flights_st.join(\n    carriers,\n    lambda f, c: f.carrier == c.code,\n    how=\"inner\"\n)\n\n# Complex conditions\ndate_range_join = flights_st.join(\n    promotions,\n    lambda f, p: (f.date >= p.start_date) & (f.date <= p.end_date),\n    how=\"left\"\n)\n```\n\n**Supported join types:** `\"inner\"`, `\"left\"`, `\"right\"`, `\"outer\"`, `\"cross\"`\n\n## Next Steps\n\n- Learn about [Composing Models](/examples/compose)\n- Explore [YAML Configuration](/examples/yaml-config)\n- Start [Querying Semantic Tables](/examples/query-methods)\n",
  "queries": {
    "dimensions_demo": {
      "output": "('origin', 'destination', 'year', 'carrier')"
    },
    "measures_demo": {
      "output": "('total_flights', 'total_distance', 'max_delay', 'avg_distance', 'avg_distance_per_flight')"
    },
    "measure_all_demo": {
      "code": "flights_with_pct = flights_st.with_measures(\n        flight_count=lambda t: t.count(),\n        market_share=lambda t: t.flight_count / t.all(t.flight_count) * 100  # Percent of total\n    )\n\n# Query by carrier\nresult = (\n    flights_with_pct\n    .group_by(\"carrier\")\n    .aggregate(\"flight_count\", \"market_share\")\n)",
      "sql": "WITH \"t1\" AS (\n  SELECT\n    *\n  FROM \"memory\".\"main\".\"flights\" AS \"t0\"\n)\nSELECT\n  \"t7\".\"carrier\",\n  \"t7\".\"flight_count\",\n  (\n    CAST(\"t7\".\"flight_count\" AS DOUBLE) / CAST(\"t7\".\"flight_count_right\" AS DOUBLE)\n  ) * 100 AS \"market_share\"\nFROM (\n  SELECT\n    \"t5\".\"carrier\",\n    \"t5\".\"flight_count\",\n    \"t6\".\"flight_count\" AS \"flight_count_right\"\n  FROM (\n    SELECT\n      \"t2\".\"carrier\",\n      COUNT(*) AS \"flight_count\"\n    FROM \"t1\" AS \"t2\"\n    GROUP BY\n      1\n  ) AS \"t5\"\n  CROSS JOIN (\n    SELECT\n      COUNT(*) AS \"flight_count\"\n    FROM \"t1\" AS \"t2\"\n  ) AS \"t6\"\n) AS \"t7\"",
      "plan": "r0 := SemanticTableOp[flights]\n  4 dimensions: origin, destination, year, ...\n  7 measures: total_flights, total_distance, max_delay, ...\n\nr1 := SemanticGroupByOp\n  source: SemanticTableOp\n  keys: ['carrier']\n  inherited dimensions: 4\n  inherited measures: 7\n\nSemanticAggregateOp\n  source: SemanticGroupByOp\n  keys: ['carrier']\n  aggs: [flight_count, market_share]",
      "table": {
        "columns": [
          "carrier",
          "flight_count",
          "market_share"
        ],
        "data": [
          [
            "AA",
            1,
            33.33333333333333
          ],
          [
            "UA",
            1,
            33.33333333333333
          ],
          [
            "DL",
            1,
            33.33333333333333
          ]
        ]
      },
      "chart": {
        "type": "vega",
        "spec": {
          "config": {
            "view": {
              "continuousWidth": 300,
              "continuousHeight": 300
            }
          },
          "data": {
            "name": "data-5702d87060c2f48d90709e77ac71067e"
          },
          "mark": {
            "type": "bar"
          },
          "encoding": {
            "color": {
              "field": "measure",
              "type": "nominal"
            },
            "tooltip": [
              {
                "field": "carrier",
                "type": "nominal"
              },
              {
                "field": "measure",
                "type": "nominal"
              },
              {
                "field": "value",
                "type": "quantitative"
              }
            ],
            "x": {
              "field": "carrier",
              "sort": null,
              "type": "ordinal"
            },
            "xOffset": {
              "field": "measure"
            },
            "y": {
              "field": "value",
              "type": "quantitative"
            }
          },
          "height": 400,
          "transform": [
            {
              "fold": [
                "flight_count",
                "market_share"
              ],
              "as": [
                "measure",
                "value"
              ]
            }
          ],
          "width": 700,
          "$schema": "https://vega.github.io/schema/vega-lite/v5.20.1.json",
          "datasets": {
            "data-5702d87060c2f48d90709e77ac71067e": [
              {
                "carrier": "DL",
                "flight_count": 1,
                "market_share": 33.33333333333333
              },
              {
                "carrier": "UA",
                "flight_count": 1,
                "market_share": 33.33333333333333
              },
              {
                "carrier": "AA",
                "flight_count": 1,
                "market_share": 33.33333333333333
              }
            ]
          }
        }
      }
    },
    "setup_carriers": {
      "code": "import ibis\nfrom boring_semantic_layer import to_semantic_table\n\ncon = ibis.duckdb.connect(\":memory:\")\n\n# Create carriers data\ncarriers_data = ibis.memtable({\n    \"code\": [\"AA\", \"UA\", \"DL\"],\n    \"name\": [\"American Airlines\", \"United Airlines\", \"Delta Air Lines\"]\n})\ncarriers_tbl = con.create_table(\"carriers\", carriers_data)",
      "sql": "WITH \"t1\" AS (\n  SELECT\n    *\n  FROM \"memory\".\"main\".\"flights\" AS \"t0\"\n)\nSELECT\n  \"t7\".\"carrier\",\n  \"t7\".\"flight_count\",\n  (\n    CAST(\"t7\".\"flight_count\" AS DOUBLE) / CAST(\"t7\".\"flight_count_right\" AS DOUBLE)\n  ) * 100 AS \"market_share\"\nFROM (\n  SELECT\n    \"t5\".\"carrier\",\n    \"t5\".\"flight_count\",\n    \"t6\".\"flight_count\" AS \"flight_count_right\"\n  FROM (\n    SELECT\n      \"t2\".\"carrier\",\n      COUNT(*) AS \"flight_count\"\n    FROM \"t1\" AS \"t2\"\n    GROUP BY\n      1\n  ) AS \"t5\"\n  CROSS JOIN (\n    SELECT\n      COUNT(*) AS \"flight_count\"\n    FROM \"t1\" AS \"t2\"\n  ) AS \"t6\"\n) AS \"t7\"",
      "plan": "r0 := SemanticTableOp[flights]\n  4 dimensions: origin, destination, year, ...\n  7 measures: total_flights, total_distance, max_delay, ...\n\nr1 := SemanticGroupByOp\n  source: SemanticTableOp\n  keys: ['carrier']\n  inherited dimensions: 4\n  inherited measures: 7\n\nSemanticAggregateOp\n  source: SemanticGroupByOp\n  keys: ['carrier']\n  aggs: [flight_count, market_share]",
      "table": {
        "columns": [
          "carrier",
          "flight_count",
          "market_share"
        ],
        "data": [
          [
            "AA",
            1,
            33.33333333333333
          ],
          [
            "DL",
            1,
            33.33333333333333
          ],
          [
            "UA",
            1,
            33.33333333333333
          ]
        ]
      },
      "chart": {
        "type": "vega",
        "spec": {
          "config": {
            "view": {
              "continuousWidth": 300,
              "continuousHeight": 300
            }
          },
          "data": {
            "name": "data-02b3c9107cbad36a10c64f9097bccef8"
          },
          "mark": {
            "type": "bar"
          },
          "encoding": {
            "color": {
              "field": "measure",
              "type": "nominal"
            },
            "tooltip": [
              {
                "field": "carrier",
                "type": "nominal"
              },
              {
                "field": "measure",
                "type": "nominal"
              },
              {
                "field": "value",
                "type": "quantitative"
              }
            ],
            "x": {
              "field": "carrier",
              "sort": null,
              "type": "ordinal"
            },
            "xOffset": {
              "field": "measure"
            },
            "y": {
              "field": "value",
              "type": "quantitative"
            }
          },
          "height": 400,
          "transform": [
            {
              "fold": [
                "flight_count",
                "market_share"
              ],
              "as": [
                "measure",
                "value"
              ]
            }
          ],
          "width": 700,
          "$schema": "https://vega.github.io/schema/vega-lite/v5.20.1.json",
          "datasets": {
            "data-02b3c9107cbad36a10c64f9097bccef8": [
              {
                "carrier": "UA",
                "flight_count": 1,
                "market_share": 33.33333333333333
              },
              {
                "carrier": "DL",
                "flight_count": 1,
                "market_share": 33.33333333333333
              },
              {
                "carrier": "AA",
                "flight_count": 1,
                "market_share": 33.33333333333333
              }
            ]
          }
        }
      }
    },
    "join_demo": {
      "code": "# Join carriers to flights - one carrier has many flights\nflights_with_carriers = flights_st.join_many(\n    carriers,\n    left_on=\"carrier\",\n    right_on=\"code\"\n)\n\n# Inspect available dimensions and measures\nflights_with_carriers.dimensions",
      "sql": "WITH \"t1\" AS (\n  SELECT\n    *\n  FROM \"memory\".\"main\".\"flights\" AS \"t0\"\n)\nSELECT\n  \"t7\".\"carrier\",\n  \"t7\".\"flight_count\",\n  (\n    CAST(\"t7\".\"flight_count\" AS DOUBLE) / CAST(\"t7\".\"flight_count_right\" AS DOUBLE)\n  ) * 100 AS \"market_share\"\nFROM (\n  SELECT\n    \"t5\".\"carrier\",\n    \"t5\".\"flight_count\",\n    \"t6\".\"flight_count\" AS \"flight_count_right\"\n  FROM (\n    SELECT\n      \"t2\".\"carrier\",\n      COUNT(*) AS \"flight_count\"\n    FROM \"t1\" AS \"t2\"\n    GROUP BY\n      1\n  ) AS \"t5\"\n  CROSS JOIN (\n    SELECT\n      COUNT(*) AS \"flight_count\"\n    FROM \"t1\" AS \"t2\"\n  ) AS \"t6\"\n) AS \"t7\"",
      "plan": "r0 := SemanticTableOp[flights]\n  4 dimensions: origin, destination, year, ...\n  7 measures: total_flights, total_distance, max_delay, ...\n\nr1 := SemanticGroupByOp\n  source: SemanticTableOp\n  keys: ['carrier']\n  inherited dimensions: 4\n  inherited measures: 7\n\nSemanticAggregateOp\n  source: SemanticGroupByOp\n  keys: ['carrier']\n  aggs: [flight_count, market_share]",
      "table": {
        "columns": [
          "carrier",
          "flight_count",
          "market_share"
        ],
        "data": [
          [
            "UA",
            1,
            33.33333333333333
          ],
          [
            "DL",
            1,
            33.33333333333333
          ],
          [
            "AA",
            1,
            33.33333333333333
          ]
        ]
      },
      "chart": {
        "type": "vega",
        "spec": {
          "config": {
            "view": {
              "continuousWidth": 300,
              "continuousHeight": 300
            }
          },
          "data": {
            "name": "data-957c443b2b52e9d52db460acc818b08e"
          },
          "mark": {
            "type": "bar"
          },
          "encoding": {
            "color": {
              "field": "measure",
              "type": "nominal"
            },
            "tooltip": [
              {
                "field": "carrier",
                "type": "nominal"
              },
              {
                "field": "measure",
                "type": "nominal"
              },
              {
                "field": "value",
                "type": "quantitative"
              }
            ],
            "x": {
              "field": "carrier",
              "sort": null,
              "type": "ordinal"
            },
            "xOffset": {
              "field": "measure"
            },
            "y": {
              "field": "value",
              "type": "quantitative"
            }
          },
          "height": 400,
          "transform": [
            {
              "fold": [
                "flight_count",
                "market_share"
              ],
              "as": [
                "measure",
                "value"
              ]
            }
          ],
          "width": 700,
          "$schema": "https://vega.github.io/schema/vega-lite/v5.20.1.json",
          "datasets": {
            "data-957c443b2b52e9d52db460acc818b08e": [
              {
                "carrier": "AA",
                "flight_count": 1,
                "market_share": 33.33333333333333
              },
              {
                "carrier": "DL",
                "flight_count": 1,
                "market_share": 33.33333333333333
              },
              {
                "carrier": "UA",
                "flight_count": 1,
                "market_share": 33.33333333333333
              }
            ]
          }
        }
      }
    }
  },
  "files": {}
}